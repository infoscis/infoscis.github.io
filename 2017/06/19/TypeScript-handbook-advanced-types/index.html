<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    
    <title>TypeScript 핸드북 10 - 고급 타입 | Developer&#39;s Record</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
        <meta name="keywords" content="JavaScript,TypeScript" />
    
    <meta name="description" content="고급 타입(Advanced Type)Intersection TypesIntersection 타입은 여러 타입을 하나로 결합합니다. 이렇게하면 기존 타입을 모두 추가하여 필요한 모든 기능을 갖춘 단일 타입을 얻을 수 있습니다. 예를 들어, Person &amp;amp; Serializable &amp;amp; Loggable은 Person과 Serializable이며 Lo">
<meta property="og:type" content="article">
<meta property="og:title" content="TypeScript 핸드북 10 - 고급 타입">
<meta property="og:url" content="http://infoscis.github.io/2017/06/19/TypeScript-handbook-advanced-types/index.html">
<meta property="og:site_name" content="Developer's Record">
<meta property="og:description" content="고급 타입(Advanced Type)Intersection TypesIntersection 타입은 여러 타입을 하나로 결합합니다. 이렇게하면 기존 타입을 모두 추가하여 필요한 모든 기능을 갖춘 단일 타입을 얻을 수 있습니다. 예를 들어, Person &amp;amp; Serializable &amp;amp; Loggable은 Person과 Serializable이며 Lo">
<meta property="og:updated_time" content="2018-01-27T15:19:31.579Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="TypeScript 핸드북 10 - 고급 타입">
<meta name="twitter:description" content="고급 타입(Advanced Type)Intersection TypesIntersection 타입은 여러 타입을 하나로 결합합니다. 이렇게하면 기존 타입을 모두 추가하여 필요한 모든 기능을 갖춘 단일 타입을 얻을 수 있습니다. 예를 들어, Person &amp;amp; Serializable &amp;amp; Loggable은 Person과 Serializable이며 Lo">
    
    <link rel="canonical" href="http://infoscis.github.io/2017/06/19/TypeScript-handbook-advanced-types/"/>

    

    
        <link rel="icon" href="/favicon.png" />
    

    <link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="/libs/titillium-web/styles.css">
    <link rel="stylesheet" href="/libs/source-code-pro/styles.css">

    <link rel="stylesheet" href="/css/style.css">

    <script src="/libs/jquery/2.0.3/jquery.min.js"></script>
    
    
        <link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">
    
    
        <link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css">
    
    
        <script type="text/javascript">
(function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-100332906-1', 'auto');
ga('send', 'pageview');

</script>
    
    

</head>

<body>
    <div id="wrap">
        <header id="header">
    <div id="header-outer" class="outer">
        <div class="container">
            <div class="container-inner">
                <div id="header-title">
                    <h1 class="logo-wrap">
                        <a href="/" class="logo"></a>
                    </h1>
                    
                        <h2 class="subtitle-wrap">
                            <p class="subtitle">개발자의 기록 보관소</p>
                        </h2>
                    
                </div>
                <div id="header-inner" class="nav-container">
                    <a id="main-nav-toggle" class="nav-icon fa fa-bars"></a>
                    <div class="nav-container-inner">
                        <ul id="main-nav">
                            
                                <li class="main-nav-list-item" >
                                    <a class="main-nav-list-link" href="/">홈</a>
                                </li>
                            
                                        <ul class="main-nav-list"><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Angular/">Angular</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Hadoop/">Hadoop</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Java/">Java</a><ul class="main-nav-list-child"><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Java/Java9/">Java9</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Java/Spring/">Spring</a></li></ul></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/JavaScript/">JavaScript</a><ul class="main-nav-list-child"><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/JavaScript/ECMAScript-2015/">ECMAScript 2015</a></li></ul></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/TypeScript/">TypeScript</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Webpack/">Webpack</a></li></ul>
                                    
                                <li class="main-nav-list-item" >
                                    <a class="main-nav-list-link" href="https://about.me/jongcheol.kim">About</a>
                                </li>
                            
                        </ul>
                        <nav id="sub-nav">
                            <div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="검색" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="Type something..." />
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '포스트',
            PAGES: 'Pages',
            CATEGORIES: '카테고리',
            TAGS: '태그',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div>
                        </nav>
                    </div>
                </div>
            </div>
        </div>
    </div>
</header>
        <div class="container">
            <div class="main-body container-inner">
                <div class="main-body-inner">
                    <section id="main">
                        <div class="main-body-header">
    <h1 class="header">
    
    <a class="page-title-link" href="/categories/TypeScript/">TypeScript</a>
    </h1>
</div>
                        <div class="main-body-content">
                            <article id="post-TypeScript-handbook-advanced-types" class="article article-single article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
            <header class="article-header">
                
    
        <h1 class="article-title" itemprop="name">
        TypeScript 핸드북 10 - 고급 타입
        </h1>
    

            </header>
        
        
            <div class="article-meta">
                
    <div class="article-date">
        <a href="/2017/06/19/TypeScript-handbook-advanced-types/" class="article-date">
            <time datetime="2017-06-19T14:27:16.000Z" itemprop="datePublished">2017-06-19</time>
        </a>
    </div>

                
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/JavaScript/">JavaScript</a>, <a class="tag-link" href="/tags/TypeScript/">TypeScript</a>
    </div>

            </div>
        
        
        <div class="article-entry" itemprop="articleBody">
            <h1 id="고급-타입-Advanced-Type"><a href="#고급-타입-Advanced-Type" class="headerlink" title="고급 타입(Advanced Type)"></a>고급 타입(Advanced Type)</h1><h2 id="Intersection-Types"><a href="#Intersection-Types" class="headerlink" title="Intersection Types"></a>Intersection Types</h2><p><em>Intersection</em> 타입은 여러 타입을 하나로 결합합니다. 이렇게하면 기존 타입을 모두 추가하여 필요한 모든 기능을 갖춘 단일 타입을 얻을 수 있습니다. 예를 들어, <code>Person</code> &amp; <code>Serializable</code> &amp; <code>Loggable</code>은 <code>Person</code>과 <code>Serializable</code>이며 <code>Loggable</code>입니다. 즉, 이 타입의 객체는 세 가지 타입의 모든 멤버를 갖게됩니다.</p>
<p><em>Intersection</em> 타입의 대부분은 mixin과 고전적인 객체 지향 모습에 맞지 않는 형태에서 보게 됩니다.(JavaScript에는 이런 것들이 많이 있습니다!) 다음은 mixin을 만드는 방법을 보여주는 간단한 예제입니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt;(<span class="params">first: T, second: U</span>): <span class="title">T</span> &amp; <span class="title">U</span> </span>&#123;</div><div class="line">    <span class="keyword">let</span> result = &lt;T &amp; U&gt;&#123;&#125;;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> id <span class="keyword">in</span> first) &#123;</div><div class="line">        (&lt;<span class="built_in">any</span>&gt;result)[id] = (&lt;<span class="built_in">any</span>&gt;first)[id];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> id <span class="keyword">in</span> second) &#123;</div><div class="line">        <span class="keyword">if</span> (!result.hasOwnProperty(id)) &#123;</div><div class="line">            (&lt;<span class="built_in">any</span>&gt;result)[id] = (&lt;<span class="built_in">any</span>&gt;second)[id];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Person &#123;</div><div class="line">    <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span></span>) &#123; &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">interface</span> Loggable &#123;</div><div class="line">    log(): <span class="built_in">void</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">class</span> ConsoleLogger <span class="keyword">implements</span> Loggable &#123;</div><div class="line">    log() &#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> jim = extend(<span class="keyword">new</span> Person(<span class="string">"Jim"</span>), <span class="keyword">new</span> ConsoleLogger());</div><div class="line"><span class="keyword">var</span> n = jim.name;</div><div class="line">jim.log();</div></pre></td></tr></table></figure>
<h2 id="Union-Types"><a href="#Union-Types" class="headerlink" title="Union Types"></a>Union Types</h2><p><em>Union</em> 타입은 <em>Intersection</em> 타입과 밀접한 관련이 있지만 매우 다르게 사용됩니다. 때로는 파라미터가 <code>number</code> 또는 <code>string</code>이 될 것으로 기대하는 라이브러리를 실행하게 될때도 있습니다. 예를 들어, 다음과 같은 함수를 살펴보겠습니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 문자열을 가져 와서 왼쪽에 'padding'을 추가합니다.</div><div class="line"> * 'padding'이 문자열이면 'padding'이 왼쪽에 추가됩니다.</div><div class="line"> * 'padding'이 숫자 인 경우 해당 개수의 공백이 왼쪽에 추가됩니다.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">padLeft</span>(<span class="params">value: <span class="built_in">string</span>, padding: <span class="built_in">any</span></span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> padding === <span class="string">"number"</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">Array</span>(padding + <span class="number">1</span>).join(<span class="string">" "</span>) + value;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> padding === <span class="string">"string"</span>) &#123;</div><div class="line">        <span class="keyword">return</span> padding + value;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Expected string or number, got '<span class="subst">$&#123;padding&#125;</span>'.`</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">padLeft(<span class="string">"Hello world"</span>, <span class="number">4</span>); <span class="comment">// returns "    Hello world"</span></div></pre></td></tr></table></figure>
<p><code>padLeft</code>의 문제점은 <code>padding</code> 파라미터가 <code>any</code>로 입력된다는 것입니다. 즉, <code>number</code>나 <code>string</code>이 아닌 파라미터를 사용하여 호출할 수 있지만 TypeScript는 해당 파라미터를 수용합니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> indentedString = padLeft(<span class="string">"Hello world"</span>, <span class="literal">true</span>); <span class="comment">// 컴파일 타임에는 통과 하지만 runtime에 실패가 발생합니다.</span></div></pre></td></tr></table></figure>
<p>전통적인 객체 지향 코드에서는 타입의 계층 구조를 만들어 두가지 타입을 추상화할 수 있습니다. 이것이 훨씬 더 명확하지만, 그것은 또한 약간 과잉대응입니다. 이러한 접근법은 이미 다른 곳에있는 함수를 사용하려는 경우에도 도움이되지 않습니다. <code>padLeft</code>의 원래 버전에 대한 좋은 점 중 하나는 우리가 Primitive를 전달할 수 있다는 것이었습니다. 이는 사용법이 간단하고 간결하다는 것을 의미합니다. </p>
<p><code>any</code> 대신에 <code>padding</code> 파라미터에 <em>Union</em> 타입을 사용할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 문자열을 가져 와서 왼쪽에 "패딩"을 추가합니다.</div><div class="line"> * 'padding'이 문자열이면 'padding'이 왼쪽에 추가됩니다.</div><div class="line"> * 'padding'이 숫자 인 경우 해당 개수의 공백이 왼쪽에 추가됩니다.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">padLeft</span>(<span class="params">value: string, padding: string | number</span>) </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> indentedString = padLeft(<span class="string">"Hello world"</span>, <span class="literal">true</span>); <span class="comment">// errors during compilation</span></div></pre></td></tr></table></figure>
<p><em>Union</em> 타입은 여러 타입 중 하나 일 수 있는 값을 나타냅니다. 수직 막대 (<code>|</code>)를 사용하여 각 타입을 구분하므로 <code>number | string | boolean</code>은 <code>number</code>,<code>string</code> 또는<code>boolean</code> 일 수있는 값의 타입입니다.</p>
<p>만일 우리가 <em>Union</em> 타입을 가진 값을 가지고 있다면, <em>Union</em>의 모든 타입에 공통적인 멤버들만 접근할 수 있습니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> Bird &#123;</div><div class="line">    fly();</div><div class="line">    layEggs();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">interface</span> Fish &#123;</div><div class="line">    swim();</div><div class="line">    layEggs();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSmallPet</span>(<span class="params"></span>): <span class="title">Fish</span> | <span class="title">Bird</span> </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> pet = getSmallPet();</div><div class="line">pet.layEggs(); <span class="comment">// okay</span></div><div class="line">pet.swim();    <span class="comment">// errors</span></div></pre></td></tr></table></figure>
<p><em>Union</em> 타입은 약간 까다로울 수 있지만 익숙해지기 위해서는 약간의 직감이 필요합니다. 타입이 <code>A|B</code>인 값을 가지고 있다면, 우리는 <code>A</code>와 <code>B</code> 둘 다 특정 멤버가 있음을 확실히 알 수 있습니다. 이 예제에서 <code>Bird</code>에는 <code>fly</code>라는 멤버가 있습니다. 그리고 <code>Bird | Fish</code> 타입에는 <code>fly</code> 메서드가 있음을 확신할 수 없습니다. 그렇기 때문에 런타임에 변수가 실제로 <code>Fish</code> 인 경우 <code>pet.fly()</code>를 호출하면 실패할 수 있습니다.</p>
<h2 id="타입-가드와-차별-타입-Type-Guards-and-Differentiating-Types"><a href="#타입-가드와-차별-타입-Type-Guards-and-Differentiating-Types" class="headerlink" title="타입 가드와 차별 타입 (Type Guards and Differentiating Types)"></a>타입 가드와 차별 타입 (Type Guards and Differentiating Types)</h2><p><em>Union</em> 타입은 값들이 겹쳐 질 수있는 상황을 모델링하는데 유용합니다. 우리가 <code>Fish</code>를 가지고 있는지 여부를 구체적으로 알아야할 때 어떻게 해야 할까요? 두가지 값을 구별하는 JavaScript의 일반적인 방법은 멤버의 존재 여부를 확인하는 것입니다. 위에서 언급했듯이, <em>Union</em> 타입은 모든 구성 요소에 포함될 수 있는 멤버만 액세스할 수 있습니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> pet = getSmallPet();</div><div class="line"></div><div class="line"><span class="comment">// 이러한 각 프로퍼티의 액세스는 오류를 발생시킵니다.</span></div><div class="line"><span class="keyword">if</span> (pet.swim) &#123;</div><div class="line">    pet.swim();</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (pet.fly) &#123;</div><div class="line">    pet.fly();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>위 코드가 작동하도록 하려면 타입 어설션을 사용해야합니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> pet = getSmallPet();</div><div class="line"></div><div class="line"><span class="keyword">if</span> ((&lt;Fish&gt;pet).swim) &#123;</div><div class="line">    (&lt;Fish&gt;pet).swim();</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> &#123;</div><div class="line">    (&lt;Bird&gt;pet).fly();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="사용자-정의-타입-가드-User-Defined-Type-Guard"><a href="#사용자-정의-타입-가드-User-Defined-Type-Guard" class="headerlink" title="사용자 정의 타입 가드(User-Defined Type Guard)"></a>사용자 정의 타입 가드(User-Defined Type Guard)</h3><p>타입 어설션을 여러번 사용해야 한다는 점에 주목하십시오. 일단 우리가 체크를 수행할때 각 지점 내에서 <code>pet</code>의 타입을 알 수 있으면 훨씬 더 좋을 것입니다.</p>
<p>TypeScript에는 <em>타입 가드(Type guard)</em>가 있습니다. <em>타입 가드(Type guard)</em>는 어떤 Scope에서 타입을 보증하는 런타임 체크를 수행하는 몇 가지 표현식입니다. <em>타입 가드</em>를 정의하기 위해서, 리턴 타입이 <em>Type predicate</em>인 함수를 정의할 필요가 있습니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isFish</span>(<span class="params">pet: Fish | Bird</span>): <span class="title">pet</span> <span class="title">is</span> <span class="title">Fish</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> (&lt;Fish&gt;pet).swim !== <span class="literal">undefined</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>pet is Fish</code>는 위 예에서 <em>Type predicate</em>입니다. <em>Predicate</em>는 <code>parameterName is Type</code>의 형식을 취합니다. 여기서 <code>parameterName</code>은 현재 함수 Signature의 파라미터 이름이어야 합니다.</p>
<p><code>isFish</code>가 어떤 변수와 함께 호출될 때마다, 원래 타입이 호환 가능하다면 TypeScript은 그 변수를 그 특정 타입으로 추정할 것입니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 'swim'과 'fly'에 대한 호출은 이제 모두 괜찮습니다.</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> (isFish(pet)) &#123;</div><div class="line">    pet.swim();</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> &#123;</div><div class="line">    pet.fly();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>TypeScript는 <code>pet</code>이 <code>if</code>문에서 <code>Fish</code>라는 것을 알고 있을뿐만 아니라, <code>else</code>에서는 <code>Fish</code>가 아니기 때문에 <code>Bird</code>가 있어야합니다.</p>
<h3 id="타입-가드의-typeof"><a href="#타입-가드의-typeof" class="headerlink" title="타입 가드의 typeof"></a>타입 가드의 <code>typeof</code></h3><p>뒤로 돌아가서 <em>Union</em> 타입을 사용하는 <code>padLeft</code> 버전의 코드를 작성해 보겠습니다. 다음과 같이 <em>Type predicates</em>를 써서 쓸 수 있습니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isNumber</span>(<span class="params">x: <span class="built_in">any</span></span>): <span class="title">x</span> <span class="title">is</span> <span class="title">number</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> x === <span class="string">"number"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isString</span>(<span class="params">x: <span class="built_in">any</span></span>): <span class="title">x</span> <span class="title">is</span> <span class="title">string</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> x === <span class="string">"string"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">padLeft</span>(<span class="params">value: <span class="built_in">string</span>, padding: <span class="built_in">string</span> | <span class="built_in">number</span></span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (isNumber(padding)) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">Array</span>(padding + <span class="number">1</span>).join(<span class="string">" "</span>) + value;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (isString(padding)) &#123;</div><div class="line">        <span class="keyword">return</span> padding + value;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Expected string or number, got '<span class="subst">$&#123;padding&#125;</span>'.`</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>그러나 타입이 Primitive 인지 알아내는 함수를 정의하는 것은 고통입니다. 다행스럽게도, TypeScript가 인식하기 때문에, <code>typeof x === &quot;number&quot;</code>를 자신의 함수로 추상화할 필요가 없습니다. 즉, 이 체크를 인라인으로 작성할 수 있음을 의미합니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">padLeft</span>(<span class="params">value: <span class="built_in">string</span>, padding: <span class="built_in">string</span> | <span class="built_in">number</span></span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> padding === <span class="string">"number"</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">Array</span>(padding + <span class="number">1</span>).join(<span class="string">" "</span>) + value;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> padding === <span class="string">"string"</span>) &#123;</div><div class="line">        <span class="keyword">return</span> padding + value;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Expected string or number, got '<span class="subst">$&#123;padding&#125;</span>'.`</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>이 <code>typeof</code> <em>타입 가드</em>는 <code>typeof v === &quot;typename&quot;</code>과 <code>typeof v !== &quot;typename&quot;</code> 두 가지 형태로 인식됩니다. 여기서 <code>&quot;typename&quot;</code>은 <code>&quot;number&quot;</code>, <code>&quot;string&quot;</code>, <code>&quot;boolean&quot;</code>, 또는 <code>&quot;symbol&quot;</code>이어야 합니다. TypeScript는 여러분이 다른 문자열과 비교하는 것을 못하게 하지 않지만 TypeScript는 해당 표현을 <em>타입 가드</em>로 인식하지 않습니다.</p>
<h3 id="타입-가드의-instanceof"><a href="#타입-가드의-instanceof" class="headerlink" title="타입 가드의 instanceof"></a><em>타입 가드</em>의 <code>instanceof</code></h3><p><code>typeof</code> <em>타입 가드</em>를 읽었고 JavaScript에서 <code>instanceof</code> 연산자에 익숙하다면 아마 여기서 설명하는 내용이 익숙할 것입니다.</p>
<p><code>instanceof</code> <em>타입 가드</em>는 생성자 함수를 사용하여 타입을 좁히는 방법입니다. 예를 들어, 이전의 문자열 padding 예제를 살펴보겠습니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> Padder &#123;</div><div class="line">    getPaddingString(): <span class="built_in">string</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> SpaceRepeatingPadder <span class="keyword">implements</span> Padder &#123;</div><div class="line">    <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> numSpaces: <span class="built_in">number</span></span>) &#123; &#125;</div><div class="line">    getPaddingString() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">Array</span>(<span class="keyword">this</span>.numSpaces + <span class="number">1</span>).join(<span class="string">" "</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> StringPadder <span class="keyword">implements</span> Padder &#123;</div><div class="line">    <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> value: <span class="built_in">string</span></span>) &#123; &#125;</div><div class="line">    getPaddingString() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRandomPadder</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.random() &lt; <span class="number">0.5</span> ?</div><div class="line">        <span class="keyword">new</span> SpaceRepeatingPadder(<span class="number">4</span>) :</div><div class="line">        <span class="keyword">new</span> StringPadder(<span class="string">"  "</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 'SpaceRepeatingPadder | StringPadder' 타입입니다.</span></div><div class="line"><span class="keyword">let</span> padder: Padder = getRandomPadder();</div><div class="line"></div><div class="line"><span class="keyword">if</span> (padder <span class="keyword">instanceof</span> SpaceRepeatingPadder) &#123;</div><div class="line">    padder; <span class="comment">// 타입이 'SpaceRepeatingPadder'로 좁혀졌습니다.</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (padder <span class="keyword">instanceof</span> StringPadder) &#123;</div><div class="line">    padder; <span class="comment">// 타입이 'StringPadder'로 좁혀졌습니다.</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>instanceof</code>의 오른쪽은 생성자 함수여야하며, TypeScript는 다음으로 순서로 범위를 좁힙니다.</p>
<ol>
<li>타입이 <code>any</code>가 아닌 경우 함수의 <code>prototype</code> 프로퍼티 타입</li>
<li>그 타입의 생성자 Signatures 의해 리턴되는 타입의 <em>Union</em> 타입</li>
</ol>
<h2 id="Nullable-types"><a href="#Nullable-types" class="headerlink" title="Nullable types"></a>Nullable types</h2><p>TypeScript에는 <code>null</code>과 <code>undefined</code> 값을 가질수 있는 두 가지 특별한 타입인 <code>null</code>과 <code>undefined</code> 타입이 있습니다.<a href="https://infoscis.github.io/2017/05/14/TypeScript-handbook-basic-types/">Basic Types</a>에서 간단히 언급했습니다. 기본적으로 타입 checker는<br> <code>null</code>및 <code>undefined</code>를 어떤것이든 할당할수 있다고 간주합니다. 그리고,<code>null</code>과 <code>undefined</code>는 모든 타입의 유효한 값입니다. 즉, 이 값의 할당을 막고 싶을 때조차도 <code>any</code> 타입에 할당되는 것을 막을 수 없다는 것을 의미합니다. <code>null</code>의 고안자인 토니 호아레 (Tony Hoare)는 이것을 <a href="https://en.wikipedia.org/wiki/Null_pointer#History" target="_blank" rel="external">“billion dollar mistake”</a> 라고 부르기도 했습니다.</p>
<p><code>--strictNullChecks</code> 플래그는 이 문제를 해결할 수 있습니다. 변수를 선언하면 <code>null</code> 또는 <code>undefined</code>가 자동으로 포함되지 않습니다. 하지만<br> <em>Union</em> 타입을 사용하여 명시적으로 포함 시킬수 있습니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> s = <span class="string">"foo"</span>;</div><div class="line">s = <span class="literal">null</span>; <span class="comment">// error, 'null' is not assignable to 'string'</span></div><div class="line"><span class="keyword">let</span> sn: <span class="built_in">string</span> | <span class="literal">null</span> = <span class="string">"bar"</span>;</div><div class="line">sn = <span class="literal">null</span>; <span class="comment">// ok</span></div><div class="line"></div><div class="line">sn = <span class="literal">undefined</span>; <span class="comment">// error, 'undefined' is not assignable to 'string | null'</span></div></pre></td></tr></table></figure>
<p>TypeScript는 JavaScript 의미와 일치시키기 위해 <code>null</code>과 <code>undefined</code>를 다르게 취급합니다. <code>string | null</code>은 <code>string | undefined</code>와<code>string | undefined | null</code>과 다른 타입입니다.</p>
<h3 id="Optional-파라미터와-프로퍼티"><a href="#Optional-파라미터와-프로퍼티" class="headerlink" title="Optional 파라미터와 프로퍼티"></a>Optional 파라미터와 프로퍼티</h3><p><code>--strictNullChecks</code> 옵션은 자동으로 <code>| undefined</code>를 포함 시킵니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x: <span class="built_in">number</span>, y?: <span class="built_in">number</span></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> x + (y || <span class="number">0</span>);</div><div class="line">&#125;</div><div class="line">f(<span class="number">1</span>, <span class="number">2</span>);</div><div class="line">f(<span class="number">1</span>);</div><div class="line">f(<span class="number">1</span>, <span class="literal">undefined</span>);</div><div class="line">f(<span class="number">1</span>, <span class="literal">null</span>); <span class="comment">// error, 'null'은 'number | undefined' 타입에 할당할 수 없습니다.</span></div></pre></td></tr></table></figure>
<p><em>Optional</em> 프로퍼티에 대해서도 마찬가지입니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> C &#123;</div><div class="line">    a: <span class="built_in">number</span>;</div><div class="line">    b?: <span class="built_in">number</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> C();</div><div class="line">c.a = <span class="number">12</span>;</div><div class="line">c.a = <span class="literal">undefined</span>; <span class="comment">// error, 'undefined' is not assignable to 'number'</span></div><div class="line">c.b = <span class="number">13</span>;</div><div class="line">c.b = <span class="literal">undefined</span>; <span class="comment">// ok</span></div><div class="line">c.b = <span class="literal">null</span>; <span class="comment">// error, 'null' is not assignable to 'number | undefined'</span></div></pre></td></tr></table></figure>
<h3 id="타입-가드와-타입-어설션-Type-guards-and-type-assertions"><a href="#타입-가드와-타입-어설션-Type-guards-and-type-assertions" class="headerlink" title="타입 가드와 타입 어설션 (Type guards and type assertions)"></a><em>타입 가드</em>와 타입 어설션 (Type guards and type assertions)</h3><p>Nullable 타입은 <em>Union</em>으로 구현 되었기 때문에 <em>타입 가드</em>를 사용하여 <code>null</code>을 제거해야합니다. 다행히도 JavaScript에서 작성하는 코드와 똑같습니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">sn: <span class="built_in">string</span> | <span class="literal">null</span></span>): <span class="title">string</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (sn == <span class="literal">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"default"</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> sn;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>위 코드에서 <code>null</code> 제거 코드는 명확하지만 더 간단한 연산자를 사용할 수 있습니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">sn: <span class="built_in">string</span> | <span class="literal">null</span></span>): <span class="title">string</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> sn || <span class="string">"default"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>컴파일러가 <code>null</code> 또는 <code>undefined</code>를 제거할 수없는 경우, 타입 선언 연산자를 사용하여 수동으로 제거할 수 있습니다. 구문은 변수<br> 뒤에 <code>!</code>를 붙이는 것입니다. <code>identifier!</code>는 식별자의 타입에서 <code>null</code>과 <code>undefined</code>를 제거합니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">broken</span>(<span class="params">name: <span class="built_in">string</span> | <span class="literal">null</span></span>): <span class="title">string</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">postfix</span>(<span class="params">epithet: <span class="built_in">string</span></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> name.charAt(<span class="number">0</span>) + <span class="string">'.  the '</span> + epithet; <span class="comment">// error, 'name' is possibly null</span></div><div class="line">  &#125;</div><div class="line">  name = name || <span class="string">"Bob"</span>;</div><div class="line">  <span class="keyword">return</span> postfix(<span class="string">"great"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fixed</span>(<span class="params">name: <span class="built_in">string</span> | <span class="literal">null</span></span>): <span class="title">string</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">postfix</span>(<span class="params">epithet: <span class="built_in">string</span></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> name!.charAt(<span class="number">0</span>) + <span class="string">'.  the '</span> + epithet; <span class="comment">// ok</span></div><div class="line">  &#125;</div><div class="line">  name = name || <span class="string">"Bob"</span>;</div><div class="line">  <span class="keyword">return</span> postfix(<span class="string">"great"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>컴파일러가 중첩 함수 내에서 <code>null</code>을 제거할 수 없으므로 (즉시 함수 호출 표현식 제외) 이 예제에서는 중첩 함수를 사용합니다. 중첩된 함수에 대한 모든 호출을 추적할 수 없기 때문입니다. 특히 외부 함수에서 반환하는 경우가 그렇습니다. 함수가 호출되는 위치를 알지 못하면 본문이 실행될 때 <code>name</code>의 타입이 무엇인지 알 수 없습니다.</p>
<h2 id="Type-Aliases"><a href="#Type-Aliases" class="headerlink" title="Type Aliases"></a>Type Aliases</h2><p><em>타입 Alias</em>는 타입의 새이름을 작성합니다. <em>타입 Alias</em>는 때때로 인터페이스와 비슷하지만, <em>Primitive</em>, <em>Union</em>, <em>Tuple</em>, 그리고 여러분이 직접 작성한 타입에 이름을 붙일 수 있습니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Name = <span class="built_in">string</span>;</div><div class="line"><span class="keyword">type</span> NameResolver = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">string</span>;</div><div class="line"><span class="keyword">type</span> NameOrResolver = Name | NameResolver;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params">n: NameOrResolver</span>): <span class="title">Name</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> n === <span class="string">"string"</span>) &#123;</div><div class="line">        <span class="keyword">return</span> n;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> n();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><em>타입 Alias</em>는 실제로 새 타입을 작성하지 않으며 해당 타입을 참조하는 새 <code>이름</code>을 작성합니다. Primitive의 Alias는 사용될 수 있지만 딱히 유용성은 없습니다.</p>
<p>인터페이스와 마찬가지로 <em>타입 Alias</em>도 Generic을 사용할 수 있습니다. 타입 파라미터를 추가하고 Alias 선언의 오른쪽에 사용할 수 있습니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Container&lt;T&gt; = &#123; value: T &#125;;</div></pre></td></tr></table></figure>
<p>또한 프로퍼티에서 <em>타입 Alias</em>를 참조할 수 있습니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Tree&lt;T&gt; = &#123;</div><div class="line">    value: T;</div><div class="line">    left: Tree&lt;T&gt;;</div><div class="line">    right: Tree&lt;T&gt;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Intersection 타입과 함께 우리는 Mind-bending 타입도 만들 수 있습니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> LinkedList&lt;T&gt; = T &amp; &#123; next: LinkedList&lt;T&gt; &#125;;</div><div class="line"></div><div class="line"><span class="keyword">interface</span> Person &#123;</div><div class="line">    name: <span class="built_in">string</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> people: LinkedList&lt;Person&gt;;</div><div class="line"><span class="keyword">var</span> s = people.name;</div><div class="line"><span class="keyword">var</span> s = people.next.name;</div><div class="line"><span class="keyword">var</span> s = people.next.next.name;</div><div class="line"><span class="keyword">var</span> s = people.next.next.next.name;</div></pre></td></tr></table></figure>
<p>그러나 <em>타입 Alias</em>가 선언의 오른쪽에 있는 곳은 사용할 수 없습니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Yikes = <span class="built_in">Array</span>&lt;Yikes&gt;; <span class="comment">// error</span></div></pre></td></tr></table></figure>
<h3 id="Interfaces-vs-Type-Aliases"><a href="#Interfaces-vs-Type-Aliases" class="headerlink" title="Interfaces vs. Type Aliases"></a>Interfaces vs. Type Aliases</h3><p>앞서 언급했듯이 <em>타입 Alias</em>는 인터페이스와 비슷한 일을할 수 있습니다. 그러나 약간의 차이가 있습니다.</p>
<p>한가지 차이점은 인터페이스는 어디에서나 사용되는 새로운 이름을 생성한다는 것입니다. 하지만 <em>타입 Alias</em>는 새 이름을 만들지 않습니다. 예를 들어 오류 메시지는 Alias를 사용하지 않습니다. 아래의 코드는 편집기에서 <code>interfaced</code> 위로 마우스를 가져 가면 <code>Interface</code> 를 반환한다고 나오지만 <code>aliased</code>는 객체 리터럴 타입을 반환한다는 것을 보여줄 것입니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Alias = &#123; num: <span class="built_in">number</span> &#125;</div><div class="line"><span class="keyword">interface</span> Interface &#123;</div><div class="line">    num: <span class="built_in">number</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">aliased</span>(<span class="params">arg: Alias</span>): <span class="title">Alias</span></span>;</div><div class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">interfaced</span>(<span class="params">arg: Interface</span>): <span class="title">Interface</span></span>;</div></pre></td></tr></table></figure>
<p>두번째로 중요한 차이점은 <em>타입 Aliase</em>를 확장하거나 구현할 수 없습니다. (다른 타입을 확장/구현할 수도 없습니다).<br><a href="https://en.wikipedia.org/wiki/Open/closed_principle" target="_blank" rel="external">소프트웨어의 이상적인 특성은 확장에 열려 있기</a> 때문에 가능한 경우 항상 <em>타입 Alias</em> 대신 인터페이스를 사용해야합니다.</p>
<p>반면에, 인터페이스로 어떤 모양을 표현할 수 없고 <em>Union</em>이나 <em>Tuple</em> 타입을 사용해야 한다면, 일반적으로 <em>타입 Aliase</em>를 사용할 수 있습니다.</p>
<h2 id="문자열-리터럴-타입"><a href="#문자열-리터럴-타입" class="headerlink" title="문자열 리터럴 타입"></a>문자열 리터럴 타입</h2><p>문자열 리터럴 타입을 사용하면 문자열에 있어야하는 정확한 값을 지정할 수 있습니다. 실제로 문자열 리터럴 타입은 <em>Union 타입</em>, <em>타입 가드</em> 및 <em>타입 Alias</em>와 잘 결합됩니다. 이러한 기능을 함께 사용하여 문자열에서 Enum 타입과 같이 작동할 수 있습니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Easing = <span class="string">"ease-in"</span> | <span class="string">"ease-out"</span> | <span class="string">"ease-in-out"</span>;</div><div class="line"><span class="keyword">class</span> UIElement &#123;</div><div class="line">    animate(dx: <span class="built_in">number</span>, dy: <span class="built_in">number</span>, easing: Easing) &#123;</div><div class="line">        <span class="keyword">if</span> (easing === <span class="string">"ease-in"</span>) &#123;</div><div class="line">            <span class="comment">// ...</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (easing === <span class="string">"ease-out"</span>) &#123;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (easing === <span class="string">"ease-in-out"</span>) &#123;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// error! null 또는 undefined를 넘겨서는 안됩니다.</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> button = <span class="keyword">new</span> UIElement();</div><div class="line">button.animate(<span class="number">0</span>, <span class="number">0</span>, <span class="string">"ease-in"</span>);</div><div class="line">button.animate(<span class="number">0</span>, <span class="number">0</span>, <span class="string">"uneasy"</span>); <span class="comment">// error: "uneasy"는 여기에 사용할 수 없습니다.</span></div></pre></td></tr></table></figure>
<p>세가지 허용되는 문자열 중 하나는 전달할 수 있지만 다른 문자열은 오류가 발생합니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Argument of type &apos;&quot;uneasy&quot;&apos; is not assignable to parameter of type &apos;&quot;ease-in&quot; | &quot;ease-out&quot; | &quot;ease-in-out&quot;&apos;</div></pre></td></tr></table></figure>
<p>오버로드를 구별하기 위해 동일한 방법으로 문자열 리터럴 타입을 사용할 수 있습니다.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function createElement(tagName: "img"): HTMLImageElement;</div><div class="line">function createElement(tagName: "input"): HTMLInputElement;</div><div class="line">// ... more overloads ...</div><div class="line">function createElement(tagName: string): Element &#123;</div><div class="line">    // ... code goes here ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Discriminated-Union"><a href="#Discriminated-Union" class="headerlink" title="Discriminated Union"></a>Discriminated Union</h2><p>문자열 리터럴 타입, <em>Union 타입</em>, <em>타입 가드</em> 및 <em>타입 Alias</em>을 결합하여 <em>Tagged union</em> 또는 <em>Algebraic 데이터 타입</em>이라 불리는 <em>Discriminated union</em>이라는 고급 패턴을 빌드할 수 있습니다. <em>Discriminated union</em>은 함수형 프로그래밍에 유용합니다. 일부 언어는 자동으로 <em>Discriminated union</em>을 사용합니다. TypeScript는 현재 존재하는 JavaScript 패턴을 기반으로 합니다. 세가지 형식이 있습니다.</p>
<ol>
<li>일반적인 문자열 리터럴 프로퍼티가 있는 타입 - Discriminated</li>
<li>타입의 합집합을 취하는 타입 Alias - Union</li>
<li>공통 프로퍼티의 타입 가드.</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> Square &#123;</div><div class="line">    kind: <span class="string">"square"</span>;</div><div class="line">    size: <span class="built_in">number</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">interface</span> Rectangle &#123;</div><div class="line">    kind: <span class="string">"rectangle"</span>;</div><div class="line">    width: <span class="built_in">number</span>;</div><div class="line">    height: <span class="built_in">number</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">interface</span> Circle &#123;</div><div class="line">    kind: <span class="string">"circle"</span>;</div><div class="line">    radius: <span class="built_in">number</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>먼저 우리가 결합할 인터페이스를 선언합니다. 각 인터페이스는 다른 문자열 리터럴 타입을 가진 <code>kind</code> 프로퍼티을 가지고 있습니다. kind 프로퍼티는 Discriminant 또는 Tag라고 불립니다. 다른 프로퍼티는 각 인터페이스에 고유합니다. 인터페이스는 현재 서로 관련이 없습니다. 이제 그들을 결합 하겠습니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Shape = Square | Rectangle | Circle;</div></pre></td></tr></table></figure>
<p>이제 Discriminated union을 사용합니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">area</span>(<span class="params">s: Shape</span>) </span>&#123;</div><div class="line">    <span class="keyword">switch</span> (s.kind) &#123;</div><div class="line">        <span class="keyword">case</span> <span class="string">"square"</span>: <span class="keyword">return</span> s.size * s.size;</div><div class="line">        <span class="keyword">case</span> <span class="string">"rectangle"</span>: <span class="keyword">return</span> s.height * s.width;</div><div class="line">        <span class="keyword">case</span> <span class="string">"circle"</span>: <span class="keyword">return</span> <span class="built_in">Math</span>.PI * s.radius ** <span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="철저한-검사-Exhaustiveness-checking"><a href="#철저한-검사-Exhaustiveness-checking" class="headerlink" title="철저한 검사(Exhaustiveness checking)"></a>철저한 검사(Exhaustiveness checking)</h3><p>컴파일러가 <em>Discriminated union</em>의 모든 변종을 커버하지 않을 때 우리에게 알려주고 싶습니다. 예를 들어 <code>Shape</code>에 <code>Triangle</code>을 추가하면<code>area</code>도 업데이트 해야합니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Shape = Square | Rectangle | Circle | Triangle;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">area</span>(<span class="params">s: Shape</span>) </span>&#123;</div><div class="line">    <span class="keyword">switch</span> (s.kind) &#123;</div><div class="line">        <span class="keyword">case</span> <span class="string">"square"</span>: <span class="keyword">return</span> s.size * s.size;</div><div class="line">        <span class="keyword">case</span> <span class="string">"rectangle"</span>: <span class="keyword">return</span> s.height * s.width;</div><div class="line">        <span class="keyword">case</span> <span class="string">"circle"</span>: <span class="keyword">return</span> <span class="built_in">Math</span>.PI * s.radius ** <span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// should error here - we didn't handle case "triangle"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>두 가지 방법이 있습니다. 첫 번째는 <code>--strictNullChecks</code>를 켜고 리턴 타입을 지정하는 것입니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">area</span>(<span class="params">s: Shape</span>): <span class="title">number</span> </span>&#123; <span class="comment">// error: returns number | undefined</span></div><div class="line">    <span class="keyword">switch</span> (s.kind) &#123;</div><div class="line">        <span class="keyword">case</span> <span class="string">"square"</span>: <span class="keyword">return</span> s.size * s.size;</div><div class="line">        <span class="keyword">case</span> <span class="string">"rectangle"</span>: <span class="keyword">return</span> s.height * s.width;</div><div class="line">        <span class="keyword">case</span> <span class="string">"circle"</span>: <span class="keyword">return</span> <span class="built_in">Math</span>.PI * s.radius ** <span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>switch</code>가 더 이상 철저하지 않기 때문에, TypeScript는 함수가 때때로 <code>undefined</code>를 리턴할 수 있다는 것을 알고 있습니다. 명시적 리턴 타입<code>number</code>를 가지고 있다면 리턴 타입이 실제로 <code>number | undefined</code>입니다. 그러나 이 방법은 조금 미묘하며, 게다가 <code>--strictNullChecks</code>가 오래된 코드에서 항상 작동하는 것은 아닙니다.</p>
<p>두번째 방법은 컴파일러가 철저히 검사하기 위해 사용하는 <code>never</code> 타입을 사용합니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">assertNever</span>(<span class="params">x: never</span>): <span class="title">never</span> </span>&#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Unexpected object: "</span> + x);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">area</span>(<span class="params">s: Shape</span>) </span>&#123;</div><div class="line">    <span class="keyword">switch</span> (s.kind) &#123;</div><div class="line">        <span class="keyword">case</span> <span class="string">"square"</span>: <span class="keyword">return</span> s.size * s.size;</div><div class="line">        <span class="keyword">case</span> <span class="string">"rectangle"</span>: <span class="keyword">return</span> s.height * s.width;</div><div class="line">        <span class="keyword">case</span> <span class="string">"circle"</span>: <span class="keyword">return</span> <span class="built_in">Math</span>.PI * s.radius ** <span class="number">2</span>;</div><div class="line">        <span class="keyword">default</span>: <span class="keyword">return</span> assertNever(s); <span class="comment">// error here if there are missing cases</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>여기서 <code>assertNever</code>는 <code>s</code>가 <code>never</code> 타입인지 검사합니다 - 다른 모든 케이스가 제거된 후에 남아있는 타입입니다. 여러분이 <code>case</code>를 잊어 버리면 <code>s</code>는 실제 타입을 가지게되고 타입 에러가 발생합니다. 이 방법을 사용하려면 추가 기능을 정의해야하지만 잊어 버렸을 때 훨씬 더 확실히 알수 있습니다.</p>
<h2 id="this-타입의-다형성"><a href="#this-타입의-다형성" class="headerlink" title="this 타입의 다형성"></a>this 타입의 다형성</h2><p><code>this</code> 타입의 다형성은 포함하는 클래스 또는 인터페이스의 subtype을 나타냅니다. 이를 F-바운드 다형성 (F-bounded polymorphism)이라고합니다. 따라서 계층적 인터페이스를 훨씬 쉽게 표현할 수 있습니다. 각 연산 후에 <code>this</code>를 반환하는 간단한 계산기가 있습니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> BasicCalculator &#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">constructor</span>(<span class="params"><span class="keyword">protected</span> value: <span class="built_in">number</span> = 0</span>) &#123; &#125;</div><div class="line">    <span class="keyword">public</span> currentValue(): <span class="built_in">number</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> add(operand: <span class="built_in">number</span>): <span class="keyword">this</span> &#123;</div><div class="line">        <span class="keyword">this</span>.value += operand;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> multiply(operand: <span class="built_in">number</span>): <span class="keyword">this</span> &#123;</div><div class="line">        <span class="keyword">this</span>.value *= operand;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// ... other operations go here ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> v = <span class="keyword">new</span> BasicCalculator(<span class="number">2</span>)</div><div class="line">            .multiply(<span class="number">5</span>)</div><div class="line">            .add(<span class="number">1</span>)</div><div class="line">            .currentValue();</div></pre></td></tr></table></figure>
<p>클래스는 <code>this</code> 타입을 사용하기 때문에 클래스를 확장할 수 있고 새로운 클래스는 변경없이 이전 메서드를 사용할 수 있습니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> ScientificCalculator <span class="keyword">extends</span> BasicCalculator &#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">constructor</span>(<span class="params">value = 0</span>) &#123;</div><div class="line">        <span class="keyword">super</span>(value);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> sin() &#123;</div><div class="line">        <span class="keyword">this</span>.value = <span class="built_in">Math</span>.sin(<span class="keyword">this</span>.value);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// ... other operations go here ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> v = <span class="keyword">new</span> ScientificCalculator(<span class="number">2</span>)</div><div class="line">        .multiply(<span class="number">5</span>)</div><div class="line">        .sin()</div><div class="line">        .add(<span class="number">1</span>)</div><div class="line">        .currentValue();</div></pre></td></tr></table></figure>
<p><code>this</code> 타입이 없으면 <code>ScientificCalculator</code>는 <code>BasicCalculator</code>를 확장하고 인터페이스를 유지할 수 없었을 것입니다. <code>multiply</code>는 <code>sin</code> 메서드가 없는 <code>BasicCalculator</code>를 리턴했을 것입니다. 그러나, <code>this</code> 타입을 사용하면 <code>multiply</code>는 <code>this</code>를 반환하는데, 이것은 <code>ScientificCalculator</code>입니다.</p>
<h2 id="인덱스-타입"><a href="#인덱스-타입" class="headerlink" title="인덱스 타입"></a>인덱스 타입</h2><p>인덱스 타입을 사용하면 컴파일러에서 동적 프로퍼티 이름을 사용하는 코드를 확인하도록 할 수 있습니다. 예를 들어 아래의 코드는 일반적인 JavaScript 패턴에서 객체 프로퍼티의 하위 집합을 선택하는 것입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">pluck</span>(<span class="params">o, names</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> names.map(<span class="function"><span class="params">n</span> =&gt;</span> o[n]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>다음은 인덱스 타입 쿼리 및 인덱싱된 액세스 연산자를 사용하여 TypeScript에서 이 함수를 작성하고 사용하는 방법입니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">pluck</span>&lt;<span class="title">T</span>, <span class="title">K</span> <span class="title">extends</span> <span class="title">keyof</span> <span class="title">T</span>&gt;(<span class="params">o: T, names: K[]</span>): <span class="title">T</span>[<span class="title">K</span>][] </span>&#123;</div><div class="line">  <span class="keyword">return</span> names.map(<span class="function"><span class="params">n</span> =&gt;</span> o[n]);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">interface</span> Person &#123;</div><div class="line">    name: <span class="built_in">string</span>;</div><div class="line">    age: <span class="built_in">number</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> person: Person = &#123;</div><div class="line">    name: <span class="string">'Jarid'</span>,</div><div class="line">    age: <span class="number">35</span></div><div class="line">&#125;;</div><div class="line"><span class="keyword">let</span> strings: <span class="built_in">string</span>[] = pluck(person, [<span class="string">'name'</span>]); <span class="comment">// ok, string[]</span></div></pre></td></tr></table></figure>
<p>컴파일러는 실제로 그 이름이 <code>Person</code>의 프로퍼티인지 확인합니다. 이 예제는 몇 가지 새로운 타입 연산자를 도입합니다. 첫 번째는 인덱스 타입 쿼리 연산자인 <code>keyof T</code>입니다. 어떤 타입의 <code>T</code>에 대해서, <code>keyof T</code>는 <code>T</code>의 알려진 공개 프로퍼티 이름들의 합집합입니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> personProps: keyof Person; <span class="comment">// 'name' | 'age'</span></div></pre></td></tr></table></figure>
<p><code>keyof Person</code>은 <code>&#39;name&#39; | &#39;age&#39;</code>와 완벽하게 호환됩니다. 차이점은 <code>Person</code>에 또 다른 프로퍼티 <code>address : string</code>를 추가하면 <code>keyof Person</code>이 자동으로 <code>&#39;name&#39; | &#39;age&#39; | &#39;address&#39;</code>로 업데이트 된다는 것입니다. 그리고 <code>pluck</code>과 같은 generic 문장에서 <code>keyof</code>를 사용할 수 있습니다. 여기서 <code>pluck</code>는 그 이전에 프로퍼티 이름을 알 수 없습니다. 즉, 컴파일러는 올바른 프라퍼티 집합을 <code>pluck</code>에 전달했는지 확인합니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pluck(person, [<span class="string">'age'</span>, <span class="string">'unknown'</span>]); <span class="comment">// error, 'unknown' is not in 'name' | 'age'</span></div></pre></td></tr></table></figure>
<p>두 번째 연산자는 인덱싱된 액세스 연산자인 <code>T[K]</code>입니다. 여기에서 type syntax는 expression syntax를 반영합니다. 즉, <code>person[&#39;name&#39;]</code>은 <code>Person[&#39;name&#39;]</code> 타입을 가지고 있습니다. 이 예제에서는 단지 문자열입니다. 그리고 인덱스 타입의 질의와 마찬가지로 <code>T[K]</code>를 generic 문장에서 사용할 수 있습니다. 이 문장이 실제로 힘이 생기는 곳입니다. 타입 변수 <code>K extends keyof T</code>를 확실히 해야합니다. 다음은 <code>getProperty</code>라는 함수를 가진 또 다른 예제입니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getProperty</span>&lt;<span class="title">T</span>, <span class="title">K</span> <span class="title">extends</span> <span class="title">keyof</span> <span class="title">T</span>&gt;(<span class="params">o: T, name: K</span>): <span class="title">T</span>[<span class="title">K</span>] </span>&#123;</div><div class="line">    <span class="keyword">return</span> o[name]; <span class="comment">// o[name] is of type T[K]</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>getProperty</code>에서 <code>o:T</code> 그리고 <code>name:K</code>은 <code>o[name]:T[K]</code>를 의미합니다. <code>T[K]</code> 결과를 반환하면 컴파일러는 실제 키 타입을 인스턴스화 할 것이므로 <code>getProperty</code>의 리턴 타입은 요청한 프로퍼티에 따라 달라집니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> name: <span class="built_in">string</span> = getProperty(person, <span class="string">'name'</span>);</div><div class="line"><span class="keyword">let</span> age: <span class="built_in">number</span> = getProperty(person, <span class="string">'age'</span>);</div><div class="line"><span class="keyword">let</span> unknown = getProperty(person, <span class="string">'unknown'</span>); <span class="comment">// error, 'unknown' is not in 'name' | 'age'</span></div></pre></td></tr></table></figure>
<h3 id="인덱스-타입-및-문자열-인덱스-시그니처"><a href="#인덱스-타입-및-문자열-인덱스-시그니처" class="headerlink" title="인덱스 타입 및 문자열 인덱스 시그니처"></a>인덱스 타입 및 문자열 인덱스 시그니처</h3><p><code>keyof</code>와 <code>T[K]</code>는 문자열 인덱스 시그니처와 상호 작용합니다. 문자열 인덱스 시그니처를 가진 타입을 가지고 있다면, <code>keyof T</code>는 단지 문자열일 것입니다. 그리고 <code>T[string]</code>은 단지 인덱스 시그니처 타입입니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> Map&lt;T&gt; &#123;</div><div class="line">    [key: <span class="built_in">string</span>]: T;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> keys: keyof Map&lt;<span class="built_in">number</span>&gt;; <span class="comment">// string</span></div><div class="line"><span class="keyword">let</span> value: Map&lt;<span class="built_in">number</span>&gt;[<span class="string">'foo'</span>]; <span class="comment">// number</span></div></pre></td></tr></table></figure>
<h2 id="Mapped-type"><a href="#Mapped-type" class="headerlink" title="Mapped type"></a>Mapped type</h2><p>일반적인 작업은 기존 타입을 가져 와서 각 프로퍼티를 선택적으로 만드는 것입니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> PersonPartial &#123;</div><div class="line">    name?: <span class="built_in">string</span>;</div><div class="line">    age?: <span class="built_in">number</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>또는 읽기 전용 버전을 원할 수도 있습니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> PersonReadonly &#123;</div><div class="line">    readonly name: <span class="built_in">string</span>;</div><div class="line">    readonly age: <span class="built_in">number</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>이것은 JavaScript에서 종종 자주 발생합니다. TypeScript는 이전 타입의 <em>Mapped type</em>을 기반으로 새로운 타입을 생성할 수 있는 방법을 제공합니다. <em>Mapped type</em>에서 새 타입은 이전 타입의 각 특성을 동일한 방식으로 변환합니다. 예를 들어 <code>readonly</code> 또는 <code>optional</code>타입의 모든 프로퍼티를 만들 수 있습니다. 다음은 몇 가지 예입니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Readonly&lt;T&gt; = &#123;</div><div class="line">    readonly [P <span class="keyword">in</span> keyof T]: T[P];</div><div class="line">&#125;</div><div class="line"><span class="keyword">type</span> Partial&lt;T&gt; = &#123;</div><div class="line">    [P <span class="keyword">in</span> keyof T]?: T[P];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>그리고 사용하려면</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> PersonPartial = Partial&lt;Person&gt;;</div><div class="line"><span class="keyword">type</span> ReadonlyPerson = Readonly&lt;Person&gt;;</div></pre></td></tr></table></figure>
<p>가장 단순한 <em>Mapped type</em>과 그 부분을 살펴 보겠습니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Keys = <span class="string">'option1'</span> | <span class="string">'option2'</span>;</div><div class="line"><span class="keyword">type</span> Flags = &#123; [K <span class="keyword">in</span> Keys]: <span class="built_in">boolean</span> &#125;;</div></pre></td></tr></table></figure>
<p>구문은 내부에 <code>for..in</code>이 있는 인덱스 시그니처의 구문과 유사합니다. 세 부분으로 나뉩니다.</p>
<ol>
<li>타입 변수 <code>K</code>는 차례대로 각 프로퍼티에 바인딩됩니다.</li>
<li>반복 처리할 프로퍼티의 이름이 들어있는 문자열 리터럴 Union <code>Keys</code>입니다.</li>
<li>프로퍼티의 결과 타입</li>
</ol>
<p>이 간단한 예제에서 <code>Keys</code>는 하드코딩된 프로퍼티 이름 목록이고 프로퍼티 타입은 항상 <code>boolean</code>이므로 이 <em>Mapped type</em>은 다음과 같습니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Flags = &#123;</div><div class="line">    option1: <span class="built_in">boolean</span>;</div><div class="line">    option2: <span class="built_in">boolean</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>그러나 실제 응용 프로그램은 위의 <code>Readonly</code> 또는 <code>Partial</code> 처럼 보입니다. 그들은 기존의 타입을 기반으로하며, 어떤 방식으로든 필드를 변형합니다. 그것은 <code>keyof</code>와 indexed access type이 들어있는 곳입니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> NullablePerson = &#123; [P <span class="keyword">in</span> keyof Person]: Person[P] | <span class="literal">null</span> &#125;</div><div class="line"><span class="keyword">type</span> PartialPerson = &#123; [P <span class="keyword">in</span> keyof Person]?: Person[P] &#125;</div></pre></td></tr></table></figure>
<p>그러나 일반적인 버전을 사용하는 것이 더 유용할 수도 있습니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Nullable&lt;T&gt; = &#123; [P <span class="keyword">in</span> keyof T]: T[P] | <span class="literal">null</span> &#125;</div><div class="line"><span class="keyword">type</span> Partial&lt;T&gt; = &#123; [P <span class="keyword">in</span> keyof T]?: T[P] &#125;</div></pre></td></tr></table></figure>
<p>이 예제들에서, 프로퍼티 리스트는 <code>keyof T</code>이고 결과 타입은 <code>T[P]</code>의 변형입니다. 이것은 <em>Mapped type</em>의 일반적인 사용을 위한 좋은 템플릿입니다. 왜냐하면 이러한 종류의 변환은 <a href="https://en.wikipedia.org/wiki/Homomorphism" target="_blank" rel="external">Homomorphic</a>이기 때문에 매핑은 <code>T</code>의 프로퍼티에만 적용되고 다른 프로퍼티는 적용되지 않습니다. 컴파일러는 새로운 프로퍼티를 추가하기 전에 모든 기존 프로퍼티 modifier를 복사할 수 있음을 알고 있습니다. 예를 들어, <code>Person.name</code>이 읽기 전용이면, <code>Partial&lt;Person&gt;.name</code>은 읽기 전용이고 선택적입니다.</p>
<p>다음은 <code>T [P]</code>가 <code>Proxy &lt;T&gt;</code>클래스에 싸여있는 또 하나의 예입니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Proxy&lt;T&gt; = &#123;</div><div class="line">    <span class="keyword">get</span>(): T;</div><div class="line">    <span class="keyword">set</span>(value: T): <span class="built_in">void</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">type</span> Proxify&lt;T&gt; = &#123;</div><div class="line">    [P <span class="keyword">in</span> keyof T]: Proxy&lt;T[P]&gt;;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">proxify</span>&lt;<span class="title">T</span>&gt;(<span class="params">o: T</span>): <span class="title">Proxify</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">   <span class="comment">// ... wrap proxies ...</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> proxyProps = proxify(props);</div></pre></td></tr></table></figure>
<p><code>Readonly &lt;T&gt;</code>와 <code>Partial &lt;T&gt;</code>는 매우 유용하며, <code>Pick</code>와 <code>Record</code>와 함께 TypeScript의 표준 라이브러리에 포함되어 있습니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Pick&lt;T, K <span class="keyword">extends</span> keyof T&gt; = &#123;</div><div class="line">    [P <span class="keyword">in</span> K]: T[P];</div><div class="line">&#125;</div><div class="line"><span class="keyword">type</span> Record&lt;K <span class="keyword">extends</span> <span class="built_in">string</span> | <span class="built_in">number</span>, T&gt; = &#123;</div><div class="line">    [P <span class="keyword">in</span> K]: T;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Readonly</code>, <code>Partial</code>과 <code>Pick</code>은 Homomorphic이고 <code>Record</code>는 그렇지 않습니다. <code>Record</code>가 Homomorphic이 아닌 이유는 프로퍼티를 복사하는 입력 타입을 취하지 않는다는 것입니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> ThreeStringProps = Record&lt;<span class="string">'prop1'</span> | <span class="string">'prop2'</span> | <span class="string">'prop3'</span>, <span class="built_in">string</span>&gt;</div></pre></td></tr></table></figure>
<p>Non-homomorphic 타입은 본질적으로 새로운 속성을 생성하므로 아무 곳에서나 프로퍼티 modifier를 복사할 수 없습니다.</p>
<h3 id="Mapped-type의-추론"><a href="#Mapped-type의-추론" class="headerlink" title="Mapped type의 추론"></a><em>Mapped type</em>의 추론</h3><p>이제 타입의 프로퍼티를 Wrapping하는 방법을 알았으므로 다음으로해야 할 일은 Unwrapping하는 것입니다. 다행히도, 그것은 꽤 쉽습니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">unproxify</span>&lt;<span class="title">T</span>&gt;(<span class="params">t: Proxify&lt;T&gt;</span>): <span class="title">T</span> </span>&#123;</div><div class="line">    <span class="keyword">let</span> result = &#123;&#125; <span class="keyword">as</span> T;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> k <span class="keyword">in</span> t) &#123;</div><div class="line">        result[k] = t[k].get();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> originalProps = unproxify(proxyProps);</div></pre></td></tr></table></figure>
<p>이 Unwrapping 추론은 Homomorphic <em>Mapped type</em>에서만 작동합니다. Wrapping된 타입이 Homomorphic이 아닌 경우에는 Unwrapping 함수에 명시적 타입 파라미터를 지정해야합니다.</p>
<hr>
<blockquote>
<p>이 내용은 나중에 참고하기 위해 제가 공부하며 정리한 내용입니다.<br>의역, 오역, 직역이 있을 수 있음을 알려드립니다.<br>This post is a translation of this original article [<a href="https://www.typescriptlang.org/docs/handbook/advanced-types.html" target="_blank" rel="external">https://www.typescriptlang.org/docs/handbook/advanced-types.html</a>]</p>
</blockquote>
<h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul>
<li><a href="https://infoscis.github.io/2017/05/14/TypeScript-handbook-basic-types/">TypeScript 핸드북 1 - 기본 타입</a></li>
<li><a href="https://infoscis.github.io/2017/05/14/TypeScript-handbook-variable-declarations/">TypeScript 핸드북 2 - 변수 선언</a></li>
<li><a href="https://infoscis.github.io/2017/05/20/TypeScript-handbook-interfaces/">TypeScript 핸드북 3 - 인터페이스</a></li>
<li><a href="https://infoscis.github.io/2017/05/20/TypeScript-handbook-classes/">TypeScript 핸드북 4 - 클래스</a></li>
<li><a href="https://infoscis.github.io/2017/05/20/TypeScript-handbook-functions/">TypeScript 핸드북 5 - 함수</a></li>
<li><a href="https://infoscis.github.io/2017/05/25/TypeScript-handbook-generic/">TypeScript 핸드북 6 - Generic</a></li>
<li><a href="https://infoscis.github.io/2017/05/25/TypeScript-handbook-enum/">TypeScript 핸드북 7 - Enum</a></li>
<li><a href="https://infoscis.github.io/2017/06/01/TypeScript-handbook-type-inference/">TypeScript 핸드북 8 - 타입 유추</a></li>
<li><a href="https://infoscis.github.io/2017/06/01/TypeScript-handbook-type-compatibility/">TypeScript 핸드북 9 - 타입 호환성</a></li>
<li><a href="https://infoscis.github.io/2017/06/19/TypeScript-handbook-advanced-types/">TypeScript 핸드북 10 - 고급 타입</a></li>
<li><a href="https://infoscis.github.io/2017/06/19/TypeScript-handbook-symbols/">TypeScript 핸드북 11 - Symbol</a></li>
<li><a href="https://infoscis.github.io/2017/06/19/TypeScript-handbook-iterators-and-generators/">TypeScript 핸드북 12 - Iterator와 Generator</a></li>
</ul>

        </div>
        <footer class="article-footer">
            



    <a data-url="http://infoscis.github.io/2017/06/19/TypeScript-handbook-advanced-types/" data-id="cjkl9rpu5001c2guzo14qxfxp" class="article-share-link"><i class="fa fa-share"></i>공유하기</a>
<script>
    (function ($) {
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

        </footer>
    </div>
</article>

    <section id="comments">
    
        
    <div id="disqus_thread">
        <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>

    
    </section>


                        </div>
                    </section>
                    <aside id="sidebar">
    <a class="sidebar-toggle" title="Expand Sidebar"><i class="toggle icon"></i></a>
    <div class="sidebar-top">
        <p>팔로우:</p>
        <ul class="social-links">
            
                
                <li>
                    <a class="social-tooltip" title="github" href="https://github.com/infoscis" target="_blank">
                        <i class="icon fa fa-github"></i>
                    </a>
                </li>
                
            
        </ul>
    </div>
    
        
<nav id="article-nav">
    
        <a href="/2017/06/19/TypeScript-handbook-symbols/" id="article-nav-newer" class="article-nav-link-wrap">
        <strong class="article-nav-caption">새로운</strong>
        <p class="article-nav-title">
        
            TypeScript 핸드북 11 - Symbol
        
        </p>
        <i class="icon fa fa-chevron-right" id="icon-chevron-right"></i>
    </a>
    
    
        <a href="/2017/06/15/angular-webpack-configuration/" id="article-nav-older" class="article-nav-link-wrap">
        <strong class="article-nav-caption">오래된</strong>
        <p class="article-nav-title">Angular Webpack 설정</p>
        <i class="icon fa fa-chevron-left" id="icon-chevron-left"></i>
        </a>
    
</nav>

    
    <div class="widgets-container">
        
            
                
    <div class="widget-wrap">
        <h3 class="widget-title">최근 글</h3>
        <div class="widget">
            <ul id="recent-post" class="no-thumbnail">
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Angular/">Angular</a></p>
                            <p class="item-title"><a href="/2018/08/08/angular-observables-and-rxjs/" class="title">Angular Observable &amp; RxJS</a></p>
                            <p class="item-date"><time datetime="2018-08-08T14:38:02.000Z" itemprop="datePublished">2018-08-08</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/JavaScript/">JavaScript</a><i class="icon fa fa-angle-right"></i><a class="article-category-link" href="/categories/JavaScript/ECMAScript-2015/">ECMAScript 2015</a></p>
                            <p class="item-title"><a href="/2018/02/27/ecmascript-6-appendix-b-understanding-ecmascript-7/" class="title">ECMAScript 6 부록 B. ECMAScript 7 (2016) 이해하기</a></p>
                            <p class="item-date"><time datetime="2018-02-27T13:32:48.000Z" itemprop="datePublished">2018-02-27</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/JavaScript/">JavaScript</a><i class="icon fa fa-angle-right"></i><a class="article-category-link" href="/categories/JavaScript/ECMAScript-2015/">ECMAScript 2015</a></p>
                            <p class="item-title"><a href="/2018/02/27/ecmascript-6-appendix-a-smaller-changes/" class="title">ECMAScript 6 부록 A. 작은 변경 사항</a></p>
                            <p class="item-date"><time datetime="2018-02-27T13:32:12.000Z" itemprop="datePublished">2018-02-27</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/JavaScript/">JavaScript</a><i class="icon fa fa-angle-right"></i><a class="article-category-link" href="/categories/JavaScript/ECMAScript-2015/">ECMAScript 2015</a></p>
                            <p class="item-title"><a href="/2018/02/27/ecmascript-6-encapsulating-code-with-modules/" class="title">ECMAScript 6 Module로 코드 캡슐화하기</a></p>
                            <p class="item-date"><time datetime="2018-02-27T13:31:45.000Z" itemprop="datePublished">2018-02-27</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/JavaScript/">JavaScript</a><i class="icon fa fa-angle-right"></i><a class="article-category-link" href="/categories/JavaScript/ECMAScript-2015/">ECMAScript 2015</a></p>
                            <p class="item-title"><a href="/2018/02/27/ecmascript-6-proxies-and-the-reflection-api/" class="title">ECMAScript 6 프록시와 리플렉션 API</a></p>
                            <p class="item-date"><time datetime="2018-02-27T13:31:03.000Z" itemprop="datePublished">2018-02-27</time></p>
                        </div>
                    </li>
                
            </ul>
        </div>
    </div>

            
                
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">카테고리</h3>
        <div class="widget">
            <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Angular/">Angular</a><span class="category-list-count">15</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hadoop/">Hadoop</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">5</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/Java9/">Java9</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/Spring/">Spring</a><span class="category-list-count">2</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/">JavaScript</a><span class="category-list-count">16</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/ECMAScript-2015/">ECMAScript 2015</a><span class="category-list-count">15</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/TypeScript/">TypeScript</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Webpack/">Webpack</a><span class="category-list-count">1</span></li></ul>
        </div>
    </div>


            
                
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">아카이브</h3>
        <div class="widget">
            <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">8월 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">2월 2018</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">1월 2018</a><span class="archive-list-count">11</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">7월 2017</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">6월 2017</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">5월 2017</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">3월 2017</a><span class="archive-list-count">5</span></li></ul>
        </div>
    </div>


            
                
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">태그</h3>
        <div class="widget">
            <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Angular/">Angular</a><span class="tag-list-count">15</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ECMAScript-2015/">ECMAScript 2015</a><span class="tag-list-count">15</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Event/">Event</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hadoop/">Hadoop</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JDK9/">JDK9</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java9/">Java9</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript</a><span class="tag-list-count">29</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Jigsaw/">Jigsaw</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nashorn/">Nashorn</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/">Spring</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringBoot/">SpringBoot</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TypeScript/">TypeScript</a><span class="tag-list-count">12</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Webpack/">Webpack</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/YARN/">YARN</a><span class="tag-list-count">1</span></li></ul>
        </div>
    </div>


            
                
    <div class="widget-wrap widget-float">
        <h3 class="widget-title">태그 클라우드</h3>
        <div class="widget tagcloud">
            <a href="/tags/Angular/" style="font-size: 18px;">Angular</a> <a href="/tags/ECMAScript-2015/" style="font-size: 18px;">ECMAScript 2015</a> <a href="/tags/Event/" style="font-size: 10px;">Event</a> <a href="/tags/Hadoop/" style="font-size: 10px;">Hadoop</a> <a href="/tags/JDK9/" style="font-size: 12px;">JDK9</a> <a href="/tags/Java/" style="font-size: 14px;">Java</a> <a href="/tags/Java9/" style="font-size: 12px;">Java9</a> <a href="/tags/JavaScript/" style="font-size: 20px;">JavaScript</a> <a href="/tags/Jigsaw/" style="font-size: 12px;">Jigsaw</a> <a href="/tags/Nashorn/" style="font-size: 10px;">Nashorn</a> <a href="/tags/Spring/" style="font-size: 12px;">Spring</a> <a href="/tags/SpringBoot/" style="font-size: 10px;">SpringBoot</a> <a href="/tags/TypeScript/" style="font-size: 16px;">TypeScript</a> <a href="/tags/Webpack/" style="font-size: 10px;">Webpack</a> <a href="/tags/YARN/" style="font-size: 10px;">YARN</a>
        </div>
    </div>


            
        
    </div>
</aside>
                </div>
            </div>
        </div>
        <footer id="footer">
    <div class="container">
        <div class="container-inner">
            <a id="back-to-top" href="javascript:;"><i class="icon fa fa-angle-up"></i></a>
            <div class="credit">
                <h1 class="logo-wrap">
                    <a href="/" class="logo"></a>
                </h1>
                <p>&copy; 2018 Jongcheol-Kim</p>
                <p>Powered by <a href="//hexo.io/" target="_blank">Hexo</a>. Theme by <a href="//github.com/ppoffice" target="_blank">PPOffice</a></p>
            </div>
        </div>
    </div>
</footer>
        
    
    <script>
    var disqus_shortname = 'infoscis';
    
    
    var disqus_url = 'http://infoscis.github.io/2017/06/19/TypeScript-handbook-advanced-types/';
    
    (function() {
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    </script>




    
        <script src="/libs/lightgallery/js/lightgallery.min.js"></script>
        <script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>
        <script src="/libs/lightgallery/js/lg-pager.min.js"></script>
        <script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>
        <script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>
        <script src="/libs/lightgallery/js/lg-zoom.min.js"></script>
        <script src="/libs/lightgallery/js/lg-hash.min.js"></script>
        <script src="/libs/lightgallery/js/lg-share.min.js"></script>
        <script src="/libs/lightgallery/js/lg-video.min.js"></script>
    
    
        <script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script>
    
    


<!-- Custom Scripts -->
<script src="/js/main.js"></script>

    </div>
</body>
</html>
