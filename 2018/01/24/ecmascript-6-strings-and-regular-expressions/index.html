<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    
    <title>ECMAScript 6 문자열과 정규 표현식 | Developer&#39;s Record</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
        <meta name="keywords" content="JavaScript,ECMAScript 2015" />
    
    <meta name="description" content="문자열과 정규 표현식논쟁의 여지는 있지만 String은 프로그래밍에서 가장 중요한 데이터 타입중 하나입니다. 문자열은 거의 모든 고급 프로그래밍 언어에 포함되어 있고, 개발자가 유용한 프로그램을 만드는데 중요한 요소입니다. 정규 표현식은 개발자가 문자열을 다양하게 다룰수 있도록 하기 때문에 매우 중요합니다. 이러한 내용을 고려한 ECMAScript 6의 제">
<meta property="og:type" content="article">
<meta property="og:title" content="ECMAScript 6 문자열과 정규 표현식">
<meta property="og:url" content="http://infoscis.github.io/2018/01/24/ecmascript-6-strings-and-regular-expressions/index.html">
<meta property="og:site_name" content="Developer's Record">
<meta property="og:description" content="문자열과 정규 표현식논쟁의 여지는 있지만 String은 프로그래밍에서 가장 중요한 데이터 타입중 하나입니다. 문자열은 거의 모든 고급 프로그래밍 언어에 포함되어 있고, 개발자가 유용한 프로그램을 만드는데 중요한 요소입니다. 정규 표현식은 개발자가 문자열을 다양하게 다룰수 있도록 하기 때문에 매우 중요합니다. 이러한 내용을 고려한 ECMAScript 6의 제">
<meta property="og:updated_time" content="2018-02-27T14:12:07.677Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ECMAScript 6 문자열과 정규 표현식">
<meta name="twitter:description" content="문자열과 정규 표현식논쟁의 여지는 있지만 String은 프로그래밍에서 가장 중요한 데이터 타입중 하나입니다. 문자열은 거의 모든 고급 프로그래밍 언어에 포함되어 있고, 개발자가 유용한 프로그램을 만드는데 중요한 요소입니다. 정규 표현식은 개발자가 문자열을 다양하게 다룰수 있도록 하기 때문에 매우 중요합니다. 이러한 내용을 고려한 ECMAScript 6의 제">
    
    <link rel="canonical" href="http://infoscis.github.io/2018/01/24/ecmascript-6-strings-and-regular-expressions/"/>

    

    
        <link rel="icon" href="/favicon.png" />
    

    <link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="/libs/titillium-web/styles.css">
    <link rel="stylesheet" href="/libs/source-code-pro/styles.css">

    <link rel="stylesheet" href="/css/style.css">

    <script src="/libs/jquery/2.0.3/jquery.min.js"></script>
    
    
        <link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">
    
    
        <link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css">
    
    
        <script type="text/javascript">
(function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-100332906-1', 'auto');
ga('send', 'pageview');

</script>
    
    

</head>

<body>
    <div id="wrap">
        <header id="header">
    <div id="header-outer" class="outer">
        <div class="container">
            <div class="container-inner">
                <div id="header-title">
                    <h1 class="logo-wrap">
                        <a href="/" class="logo"></a>
                    </h1>
                    
                        <h2 class="subtitle-wrap">
                            <p class="subtitle">개발자의 기록 보관소</p>
                        </h2>
                    
                </div>
                <div id="header-inner" class="nav-container">
                    <a id="main-nav-toggle" class="nav-icon fa fa-bars"></a>
                    <div class="nav-container-inner">
                        <ul id="main-nav">
                            
                                <li class="main-nav-list-item" >
                                    <a class="main-nav-list-link" href="/">홈</a>
                                </li>
                            
                                        <ul class="main-nav-list"><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Angular/">Angular</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Hadoop/">Hadoop</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Java/">Java</a><ul class="main-nav-list-child"><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Java/Java9/">Java9</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Java/Spring/">Spring</a></li></ul></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/JavaScript/">JavaScript</a><ul class="main-nav-list-child"><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/JavaScript/ECMAScript-2015/">ECMAScript 2015</a></li></ul></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/TypeScript/">TypeScript</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Webpack/">Webpack</a></li></ul>
                                    
                                <li class="main-nav-list-item" >
                                    <a class="main-nav-list-link" href="https://about.me/jongcheol.kim">About</a>
                                </li>
                            
                        </ul>
                        <nav id="sub-nav">
                            <div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="검색" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="Type something..." />
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '포스트',
            PAGES: 'Pages',
            CATEGORIES: '카테고리',
            TAGS: '태그',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div>
                        </nav>
                    </div>
                </div>
            </div>
        </div>
    </div>
</header>
        <div class="container">
            <div class="main-body container-inner">
                <div class="main-body-inner">
                    <section id="main">
                        <div class="main-body-header">
    <h1 class="header">
    
    <a class="page-title-link" href="/categories/JavaScript/">JavaScript</a><i class="icon fa fa-angle-right"></i><a class="page-title-link" href="/categories/JavaScript/ECMAScript-2015/">ECMAScript 2015</a>
    </h1>
</div>
                        <div class="main-body-content">
                            <article id="post-ecmascript-6-strings-and-regular-expressions" class="article article-single article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
            <header class="article-header">
                
    
        <h1 class="article-title" itemprop="name">
        ECMAScript 6 문자열과 정규 표현식
        </h1>
    

            </header>
        
        
            <div class="article-meta">
                
    <div class="article-date">
        <a href="/2018/01/24/ecmascript-6-strings-and-regular-expressions/" class="article-date">
            <time datetime="2018-01-24T14:08:10.000Z" itemprop="datePublished">2018-01-24</time>
        </a>
    </div>

                
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/ECMAScript-2015/">ECMAScript 2015</a>, <a class="tag-link" href="/tags/JavaScript/">JavaScript</a>
    </div>

            </div>
        
        
        <div class="article-entry" itemprop="articleBody">
            <h1 id="문자열과-정규-표현식"><a href="#문자열과-정규-표현식" class="headerlink" title="문자열과 정규 표현식"></a>문자열과 정규 표현식</h1><p>논쟁의 여지는 있지만 <em>String</em>은 프로그래밍에서 가장 중요한 데이터 타입중 하나입니다. 문자열은 거의 모든 고급 프로그래밍 언어에 포함되어 있고, 개발자가 유용한 프로그램을 만드는데 중요한 요소입니다. 정규 표현식은 개발자가 문자열을 다양하게 다룰수 있도록 하기 때문에 매우 중요합니다. 이러한 내용을 고려한 ECMAScript 6의 제작자는 새로운 기능과 오랫동안 누락된 기능들을 추가하여 문자열과 정규 표현식을 향상 시켰습니다. 이 장에서는 이러한 두가지 타입의 변경 사항에 대해 설명합니다.</p>
<h2 id="더-나은-Unicode-지원"><a href="#더-나은-Unicode-지원" class="headerlink" title="더 나은 Unicode 지원"></a>더 나은 Unicode 지원</h2><p>ECMAScript 6 이전에는 JavaScript 문자열이 16-bit 문자 인코딩(UTF-16)이 중심이었습니다. 각 16-bit 시퀀스는 문자를 나타내는 코드 단위입니다. <code>length</code> 속성과 <code>charAt()</code> 메서드와 같은 모든 문자열 속성과 메서드는 이 16-bit 코드 단위를 기반으로 했습니다. 물론 16-bit는 모든 문자를 포함하기에 충분했습니다. 하지만 Unicode가 도입 한 확장 문자 세트 덕분에 더 이상 충분하지 않습니다.</p>
<h3 id="UTF-16-Code-Point"><a href="#UTF-16-Code-Point" class="headerlink" title="UTF-16 Code Point"></a>UTF-16 Code Point</h3><p>문자 길이를 16-bit로 제한하는 것은 세계의 모든 문자를 전 세계적으로 고유 한 식별자로 제공하겠다는 Unicode의 목표를 이룰수 없습니다. <em>Code Point</em>라고 하는 이러한 전역적으로 고유 한 식별자는 단순히 0부터 시작하는 숫자일 뿐입니다. <em>Code Point</em>는 문자 코드로 생각할 수 있습니다. 숫자는 문자를 나타냅니다. 문자 인코딩은 <em>Code Point</em>를 내부적으로 일관된 <em>Code Unit</em>으로 인코딩해야 합니다. UTF-16의 경우 <em>Code Point</em>를 많은 <em>Code Unit</em>으로 구성할 수 있습니다.</p>
<p>UTF-16의 첫 2^16 개 <em>Code Point</em>는 하나의 16-bit <em>Code Unit</em>으로 표현됩니다. 이 범위를 <em>BMP (Basic Multilingual Plane)</em>이라고 합니다. 그 이상에 있는 것은 <em>Supplementary plane</em> 중 하나에있는 것으로 생각되어 더 이상 16-bit만으로 <em>Code Point</em>를 표현할 수 없습니다. UTF-16은 단일 <em>Code Point</em>가 두 개의 16-bit <em>Code Unit</em>으로 표현되는 <em>Surrogate pair</em>을 도입하여 이 문제를 해결했습니다. 즉, 문자열의 모든 단일 문자는, BMP 문자의 경우 하나의 <em>Code Unit</em>이 되어 총 16-bit를 제공하거나 <em>Supplementary plane</em> 문자의 경우 총 32-bit를 제공 합니다.</p>
<p>ECMAScript5에서 모든 문자열 연산은 16-bit <em>Code Unit</em>에서 작동합니다. 즉, 아래 코드에서와 같이 <em>Surrogate pair</em>가 포함된 UTF-16 인코딩된 문자열에서 예기치 않은 결과가 발생할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> text = <span class="string">"𠮷"</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(text.length);           <span class="comment">// 2</span></div><div class="line"><span class="built_in">console</span>.log(<span class="regexp">/^.$/</span>.test(text));      <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log(text.charAt(<span class="number">0</span>));        <span class="comment">// ""</span></div><div class="line"><span class="built_in">console</span>.log(text.charAt(<span class="number">1</span>));        <span class="comment">// ""</span></div><div class="line"><span class="built_in">console</span>.log(text.charCodeAt(<span class="number">0</span>));    <span class="comment">// 55362</span></div><div class="line"><span class="built_in">console</span>.log(text.charCodeAt(<span class="number">1</span>));    <span class="comment">// 57271</span></div></pre></td></tr></table></figure>
<p>Unicode 문자<code>&quot;𠮷&quot;</code>는 <em>Surrogate pair</em>를 사용하여 표현되며 위의 JavaScript 문자열 연산은 문자열을 두 개의 16-bit 문자로 취급합니다. 이러한 의미는 다음을 나타냅니다.</p>
<ul>
<li><code>text</code>의<code>length</code>는 1이어야 할 때 2입니다.</li>
<li>한 문자와 일치하는 정규식은 두 문자가 있다고 생각하기 때문에 실패합니다.</li>
<li><code>charAt()</code> 메서드는 유효한 문자열을 반환 할 수 없습니다. 왜냐하면 16-bit의 문자는 출력 가능한 문자가 아니기 때문입니다.</li>
</ul>
<p>또한 <code>charCodeAt()</code> 메서드는 문자를 제대로 식별 할 수 없습니다. 각 <em>Code Unit</em>에 대해 적절한 16-bit 숫자를 반환하지만 ECMAScript5에서 <code>text</code>의 실제 값에 유사한 값이기 때문입니다.</p>
<p>반면 ECMAScript 6은 이러한 Address Problem을 해결하기 위해 UTF-16 문자열 인코딩을 시행합니다. 이 문자 인코딩을 기반으로 문자열 연산을 표준화하면 JavaScript가 <em>Surrogate pair</em>와 함께 작동하도록 설계된 기능을 사용할 수 있습니다. 이 절의 나머지 부분에서는 해당 기능의 몇 가지 주요한 예제를 설명합니다.</p>
<h3 id="codePointAt-메서드"><a href="#codePointAt-메서드" class="headerlink" title="codePointAt() 메서드"></a><code>codePointAt()</code> 메서드</h3><p>완벽하게 UTF-16을 지원하기 위해 추가된 ECMAScript 6 메서드 중 하나는 <code>codePointAt()</code> 메서드입니다.이 메서드는 문자열의 주어진 위치에 매핑되는 유니 코드 <em>Code Point</em>를 검색합니다. 이 메서드는 문자 위치가 아닌 <em>Code Unit</em> 위치를 받아 들여 정수 값을 반환합니다. 아래 예제를 살펴 보겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> text = <span class="string">"𠮷a"</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(text.charCodeAt(<span class="number">0</span>));    <span class="comment">// 55362</span></div><div class="line"><span class="built_in">console</span>.log(text.charCodeAt(<span class="number">1</span>));    <span class="comment">// 57271</span></div><div class="line"><span class="built_in">console</span>.log(text.charCodeAt(<span class="number">2</span>));    <span class="comment">// 97</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(text.codePointAt(<span class="number">0</span>));   <span class="comment">// 134071</span></div><div class="line"><span class="built_in">console</span>.log(text.codePointAt(<span class="number">1</span>));   <span class="comment">// 57271</span></div><div class="line"><span class="built_in">console</span>.log(text.codePointAt(<span class="number">2</span>));   <span class="comment">// 97</span></div></pre></td></tr></table></figure>
<p><code>codePointAt()</code> 메서드는 문자가 BMP이면 <code>charCodeAt()</code>메서드와 같은 값을 반환합니다. 변수 <code>text</code>의 첫 번째 문자는 BMP가 아니기 때문에 두 개의 <em>Code Unit</em>으로 구성됩니다. 즉, <code>length</code> 값은 2가 아니라 3입니다. <code>charCodeAt()</code> 메서드는 0 번 위치의 첫 번째 <em>Code Unit</em>만 반환하지만 <code>codePointAt()</code>는 <em>Code Point</em>가 여러 개의 <em>Code Unit</em>에 걸쳐 있더라도 전체 <em>Code Point</em>를 반환합니다. 두 메서드는 모두 위치 1 (첫 번째 문자의 두 번째 <em>Code Unit</em>)과 2 ( <code>&quot;a&quot;</code>문자)에 대해 동일한 값을 반환합니다.</p>
<p>문자에 대해 <code>codePointAt()</code> 메서드를 호출하는 것은 그 문자가 하나 또는 두 개의 코드 포인트로 표현되는지를 결정하는 가장 쉬운 방법이다. 이러한 확인을 위해 다음 코드를 사용할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">is32Bit</span>(<span class="params">c</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> c.codePointAt(<span class="number">0</span>) &gt; <span class="number">0xFFFF</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(is32Bit(<span class="string">"𠮷"</span>));         <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(is32Bit(<span class="string">"a"</span>));          <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p>16-bit로 표시가능한 최대 숫자는 16 진수로 <code>FFFF</code>로 표현되므로, 그 숫자 위의 모든 <em>Code Point</em>는 총 32-bit의 두 <em>Code Unit</em>으로 표현되어야 합니다.</p>
<h3 id="String-fromCodePoint-메서드"><a href="#String-fromCodePoint-메서드" class="headerlink" title="String.fromCodePoint() 메서드"></a><code>String.fromCodePoint()</code> 메서드</h3><p>ECMAScript는 어떤 일을 할 수있는 방법을 제공 할 때, 또한 반대로도 할 수있는 방법을 제공하는 경향이 있습니다. <code>codePointAt()</code> 메서드를 사용하여 문자열의 문자에 대한 <em>Code Point</em>를 찾을 수 있고, `String.fromCodePoint()’ 메서드는 주어진 <em>Code Point</em>에서 단일 문자열을 생성합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.fromCodePoint(<span class="number">134071</span>));  <span class="comment">// "𠮷"</span></div></pre></td></tr></table></figure>
<p><code>String.fromCharCode()</code> 메서드의 보다 완벽한 버전 인 <code>String.fromCodePoint()</code>를 생각해 보십시오. 둘 다 BMP의 모든 문자에 대해 동일한 결과를 제공합니다. 하지만 BMP 외부의 문자에 대한 <em>Code Point</em>를 전달할 때 차이가 있습니다.</p>
<h3 id="normalize-메서드"><a href="#normalize-메서드" class="headerlink" title="normalize() 메서드"></a><code>normalize()</code> 메서드</h3><p>Unicode의 또 다른 흥미로운 점은 정렬이나 다른 비교 기반 작업을 위해 서로 다른 문자를 비교할수 있다는 것입니다. 비교를 위한 이러한 연관 관계를 정의하는 두 가지 방법이 있습니다. 첫째 <em>Canonical equivalence</em>는 모든 점에서 <em>Code Point</em>의 두 시퀀스가 상호 교환 가능하다고 간주됨을 의미합니다. 예를 들어, 두 문자의 조합은 기본적으로 한 문자와 같을 수 있습니다. 두 번째는 <em>Compatibility(호환성)</em>입니다. <em>Code point</em>의 시퀀스는 서로 다르게 보이지만 특정 상황에서는 서로 바꿔서 사용할 수 있습니다.</p>
<p>이러한 관계로 인해 근본적으로 동일한 텍스트를 나타내는 두 개의 문자열은 서로 다른 <em>Code point</em> 시퀀스를 포함 할 수 있습니다. 예를 들어, 문자 <code>&quot;æ&quot;</code>와 두 자의 문자열 <code>&quot;ae&quot;</code>는 어떤 방식으로든 표준화를 하지 않으면 엄격하게 동등하지 않기 때문에 서로 바꿔서 사용할 수 없습니다.</p>
<p>ECMAScript 6는 문자열에 <code>normalize()</code>가 있어서 Unicode 정규화 형식을 지원합니다. 이 메서드에 사용할 정규화 타입중 하나를 나타내는 하나의 문자열을 파라미터로 사용할 수 있습니다.</p>
<ul>
<li>Normalization Form Canonical Composition (<code>&quot;NFC&quot;</code>) - 기본값</li>
<li>Normalization Form Canonical Decomposition (<code>&quot;NFD&quot;</code>)</li>
<li>Normalization Form Compatibility Composition (<code>&quot;NFKC&quot;</code>)</li>
<li>Normalization Form Compatibility Decomposition (<code>&quot;NFKD&quot;</code>)</li>
</ul>
<p>이 네 가지 형식의 차이점을 설명하는 것은이 책의 범위를 벗어납니다. 문자열을 비교할 때 두 문자열을 같은 형식으로 정규화해야한다는 점을 명심하십시오.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> normalized = values.map(<span class="function"><span class="keyword">function</span>(<span class="params">text</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> text.normalize();</div><div class="line">&#125;);</div><div class="line"></div><div class="line">normalized.sort(<span class="function"><span class="keyword">function</span>(<span class="params">first, second</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (first &lt; second) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (first === second) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>위 코드는 변수 <code>values</code> <em>Array</em>의 문자열을 정규화된 형식으로 변환하여 <em>Array</em>을 적절히 정렬 할 수 있도록 합니다. 아래 코드와 같이 Comparator의 일부로서<code>normalize()</code> 를 호출하여 원래의 <em>Array</em>을 정렬 할 수도 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">values.sort(<span class="function"><span class="keyword">function</span>(<span class="params">first, second</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> firstNormalized = first.normalize(),</div><div class="line">        secondNormalized = second.normalize();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (firstNormalized &lt; secondNormalized) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstNormalized === secondNormalized) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>위 코드의 중요한 점은 <code>first</code>와 <code>second</code>가 같은 방식으로 표준화 되어야 한다는 것입니다. 이 예제는 기본 <code>NFC</code>를 사용했지만 다음과 같이 나머지 중 하나를 쉽게 지정할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">values.sort(<span class="function"><span class="keyword">function</span>(<span class="params">first, second</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> firstNormalized = first.normalize(<span class="string">"NFD"</span>),</div><div class="line">        secondNormalized = second.normalize(<span class="string">"NFD"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (firstNormalized &lt; secondNormalized) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstNormalized === secondNormalized) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>이전에 Unicode 표준화에 대해 걱정 해 본 적이 없다면 아마 이 방법을 사용하지 않을 것입니다. 하지만 국제화된 응용 프로그램에서 작업한다면 <code>normalize()</code> 메서드가 도움이 될 것입니다.</p>
<p><code>normalize()</code> 메서드가 ECMAScript 6에서 Unicode 문자열 작업에 제공하는 유일한 메서드가 아닙니다. ECMAScript 6은 또한 두가지의 유용한 구문을 추가 했습니다.</p>
<h3 id="Regular-Expression의-u-플래그"><a href="#Regular-Expression의-u-플래그" class="headerlink" title="Regular Expression의 u 플래그"></a>Regular Expression의 <code>u</code> 플래그</h3><p>정규 표현식을 통해 일반적인 많은 문자열 연산을 수행 할 수 있습니다. 그러나 정규 표현식은 16-bit <em>Code unit</em>를 가정하고 각 <em>Code unit</em>은 하나의 문자를 나타냅니다. 이 문제를 해결하기 위해 ECMAScript 6에서 Unicode를 나타내는 정규 표현식에 대해 <code>u</code> 플래그를 정의합니다.</p>
<h4 id="실행중일-때의-u-플래그"><a href="#실행중일-때의-u-플래그" class="headerlink" title="실행중일 때의 u 플래그"></a>실행중일 때의 <code>u</code> 플래그</h4><p>정규 표현식에 <code>u</code> 플래그가 설정되면, <em>Code unit</em>이 아닌 문자에 대한 작업 모드로 전환됩니다. 즉 정규 표현식이 문자열의 <em>Surrogate pair</em>에 대해 더 이상 혼동하지 않아야 하며 예상대로 작동해야합니다. 예를 들어 다음 코드를 생각해 보겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> text = <span class="string">"𠮷"</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(text.length);           <span class="comment">// 2</span></div><div class="line"><span class="built_in">console</span>.log(<span class="regexp">/^.$/</span>.test(text));      <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log(<span class="regexp">/^.$/u</span>.test(text));     <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>정규 표현식 <code>/^.$/</code>은 입력 문자열을 단일 문자와 일치시킵니다. <code>u</code> 플래그없이 사용하면 이 정규 표현식이 <em>Code unit</em>으로 일치를 판단 하기 때문에 한자(두개의 <em>Code unit</em>으로 표현됨)가 정규 표현식과 일치하지 않습니다. <code>u</code> 플래그와 함께 사용하면 정규식은 <em>Code unit</em> 대신 문자들을 비교하므로 한자 문자가 일치합니다.</p>
<h4 id="Code-Point-카운트"><a href="#Code-Point-카운트" class="headerlink" title="Code Point 카운트"></a><em>Code Point</em> 카운트</h4><p>유감스럽게도 ECMAScript 6은 문자열의 <em>Code point</em> 수를 알려주는 메서드를 추가하지 않았습니다. 하지만 <code>u</code> 플래그를 사용하면 정규 표현식을 사용하여 다음과 같이 계산할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">codePointLength</span>(<span class="params">text</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> result = text.match(<span class="regexp">/[\s\S]/gu</span>);</div><div class="line">    <span class="keyword">return</span> result ? result.length : <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(codePointLength(<span class="string">"abc"</span>));    <span class="comment">// 3</span></div><div class="line"><span class="built_in">console</span>.log(codePointLength(<span class="string">"𠮷bc"</span>));   <span class="comment">// 3</span></div></pre></td></tr></table></figure>
<p>위 코드는 <code>match()</code>를 호출할 때 <code>u</code> 옵션을 이용하여 전체 문자열에서 공백 문자와 공백 문자가 아닌 문자(<code>[\s\S]</code>는 개행문자도 포함합니다.)를 <code>text</code>에서 둘다 확인합니다. <code>result</code>는 일치가 발생한 문자의 <em>Array</em>이기 때문에 <em>Array</em>의 길이는 문자열의 <em>Code point</em> 수가 됩니다. Unicode에서 문자열 <code>&quot;abc&quot;</code>와 <code>&quot;𠮷bc&quot;</code>는 둘 다 3 개의 문자를 가지므로 <em>Array</em> 길이는 3입니다.</p>
<blockquote>
<p>위의 예제는 효과적 일지는 몰라도, 특히 긴 문자열에 적용 할 때 빠르지는 않습니다. 문자열 Iterator(나중에 설명)를 사용할 수 있습니다. <em>Code point</em> 카운트를 최소화하는게 좋습니다.</p>
</blockquote>
<h4 id="u-플래그-지원-여부-확인하기"><a href="#u-플래그-지원-여부-확인하기" class="headerlink" title="u 플래그 지원 여부 확인하기"></a><code>u</code> 플래그 지원 여부 확인하기</h4><p><code>u</code> 플래그는 구문 변경이므로 ECMAScript 6과 호환되지 않는 JavaScript 엔진에서 사용하려고 시도하면 구문 오류가 발생합니다. <code>u</code> 플래그가 지원되는지를 결정하는 가장 안전한 방법은 다음과 같은 함수를 사용하는 것입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasRegExpU</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">var</span> pattern = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"."</span>, <span class="string">"u"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125; <span class="keyword">catch</span> (ex) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>이 함수는 <code>RegExp</code> 생성자를 사용하여 <code>u</code> 플래그를 인수로 전달합니다. 이 구문은 구형 JavaScript 엔진에서도 유효하지만, ‘u’가 지원되지 않으면 생성자는 오류를 발생시킵니다.</p>
<blockquote>
<p>코드가 오래된 JavaScript 엔진에서 작동해야하는 경우, <code>u</code> 플래그를 사용할 때 항상 <code>RegExp</code> 생성자를 사용하십시오. 이렇게하면 구문 오류가 방지되고, 실행을 중단하지 않고 선택적으로 <code>u</code>플래그를 감지하여 사용할 수 있습니다.</p>
</blockquote>
<h2 id="String의-다른-변경사항"><a href="#String의-다른-변경사항" class="headerlink" title="String의 다른 변경사항"></a>String의 다른 변경사항</h2><p>JavaScript 문자열 관련 기능들은 다른 언어보다 항상 뒤떨어져 있습니다. 예를 들어 ECMAScript 5에서 문자열의 <code>trim()</code> 메서드가 추가 되었으며 ECMAScript 6는 JavaScript의 기능을 확장하여 새로운 기능으로 문자열을 파싱합니다.</p>
<h3 id="Substring-문자열-식별-메서드"><a href="#Substring-문자열-식별-메서드" class="headerlink" title="Substring 문자열 식별 메서드"></a>Substring 문자열 식별 메서드</h3><p>개발자들은 JavaScript가 처음 소개된 이래로 <code>indexOf()</code> 메서드를 사용하여 문자열 내부에서 어떤 텍스트가 있는지 판단 했습니다. ECMAScript 6에는 다음과 같은 세 가지 방법이 추가 되었습니다.</p>
<ul>
<li><code>includes()</code> 메서드는 주어진 텍스트가 문자열 내의 어느 위치에서든 발견되면 true를 반환합니다. 그렇지 않으면 false를 반환합니다.</li>
<li><code>startsWith()</code> 메서드는 지정된 텍스트가 문자열의 시작 부분에서 발견되면 true를 반환합니다. 그렇지 않으면 false를 반환합니다.</li>
<li><code>endsWith()</code> 메서드는 주어진 텍스트가 문자열의 끝에서 발견되면 true를 반환합니다. 그렇지 않으면 false를 반환합니다.</li>
</ul>
<p>각 메서드는 검색 할 텍스트와 검색을 시작할 인덱스(Optional)라는 두 개의 파라미터를 사용할 수 있습니다. 두 번째 파라미터가 입력 되면 <code>includes()</code>는 입력된 파라미터 이후에 일치하는 텍스트가 있는지 확인하고, <code>startsWith()</code>는 입력받은 파라미터의 인덱스에 첫 번째 입력 받은 텍스트가 일치 하는지 검사합니다. 그리고 <code>endsWith ()</code>는 두 번째 파라미터를 문자열의 마지막으로 설정해서 문자열에서 마지막 텍스트가 일치하는지 확인합니다. 두 번째 인수가 생략되면 <code>endsWith()</code>가 맨 끝에서 시작하고, <code>includes ()</code> 및 <code>startsWith ()</code>는 문자열의 처음부터 검색합니다.결과적으로 두 번째 인수는 검색되는 문자열의 양을 최소화합니다. 다음은이 세 가지 방법을 보여주는 몇 가지 예입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> msg = <span class="string">"Hello world!"</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(msg.startsWith(<span class="string">"Hello"</span>));       <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(msg.endsWith(<span class="string">"!"</span>));             <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(msg.includes(<span class="string">"o"</span>));             <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(msg.startsWith(<span class="string">"o"</span>));           <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log(msg.endsWith(<span class="string">"world!"</span>));        <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(msg.includes(<span class="string">"x"</span>));             <span class="comment">// false</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(msg.startsWith(<span class="string">"o"</span>, <span class="number">4</span>));        <span class="comment">// msg: "o world!" =&gt; true</span></div><div class="line"><span class="built_in">console</span>.log(msg.endsWith(<span class="string">"o"</span>, <span class="number">8</span>));          <span class="comment">// msg: "Hello wo" =&gt; true</span></div><div class="line"><span class="built_in">console</span>.log(msg.includes(<span class="string">"o"</span>, <span class="number">8</span>));          <span class="comment">// msg: "rld!" =&gt; false</span></div></pre></td></tr></table></figure>
<p>처음 6 개 호출에는 두 번째 파라미터가 없으므로 전체 문자열을 검색에 사용합니다. 마지막 세 건의 호출은 문자열의 일부만 검사합니다. <code>msg.startsWith( &quot;o&quot;, 4)</code>를 호출하면 “Hello”에서 “o”인 <code>msg</code> 문자열의 4개의 문자를 건너뛰고 일치를 시작합니다. <code>msg.endsWith(&quot;o&quot;, 8)</code> 호출은 전체 문자열 길이(12)중에서 처음부터 입력받은 <code>8</code>개까지 문자열의 마지막에서 텍스트 일치를 시작합니다. <code>msg.includes(&quot;o&quot;, 8)</code>호출은 “world”의 “r”인 8개의 문자를 건너뛰고 일치를 시작합니다.</p>
<p>이 세 가지 방법을 사용하면 하위 문자열의 존재를 다 쉽게 식별 할 수 있지만 각각 true/false 값만 반환합니다. 한 문자열의 실제 위치를 다른 문자열 내에서 찾으려면 <code>indexOf()</code> 또는 <code>lastIndexOf ()</code> 메서드를 사용하십시오.</p>
<blockquote>
<p><code>startsWith()</code>, <code>endsWith()</code> 및 <code>includes()</code> 메서드는 문자열 대신 정규 표현식을 파라미터로 전달하면 오류가 발생합니다. 정규 표현식이 포함된 파라미터를 문자열로 변환 한 다음 해당 문자열을 검색하는 <code>indexOf()</code>, <code>lastIndexOf()</code>와는 대조적입니다.</p>
</blockquote>
<h3 id="repeat-메서드"><a href="#repeat-메서드" class="headerlink" title="repeat() 메서드"></a><code>repeat()</code> 메서드</h3><p>ECMAScript 6은 String에 <code>repeat ()</code> 메서드를 추가했습니다. 이 메서드는 파라미터로 입력한 회수 만큼 문자열을 반복합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="string">"x"</span>.repeat(<span class="number">3</span>));         <span class="comment">// "xxx"</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"hello"</span>.repeat(<span class="number">2</span>));     <span class="comment">// "hellohello"</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"abc"</span>.repeat(<span class="number">4</span>));       <span class="comment">// "abcabcabcabc"</span></div></pre></td></tr></table></figure>
<p>이 메서드는 텍스트를 조작 할 때 특히 유용하고 편리한 함수입니다. 다음과 같이 들여 쓰기 수준을 만들어야 하는 코드 서식 유틸리티에서 특히 유용합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// indent using a specified number of spaces</span></div><div class="line"><span class="keyword">var</span> indent = <span class="string">" "</span>.repeat(<span class="number">4</span>),</div><div class="line">    indentLevel = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="comment">// whenever you increase the indent</span></div><div class="line"><span class="keyword">var</span> newIndent = indent.repeat(++indentLevel);</div></pre></td></tr></table></figure>
<p>첫 번째 <code>repeat()</code> 호출은 4개의 공백이 포함된 문자열을 생성하고, <code>indentLevel</code> 변수는 들여 쓰기 레벨을 추적합니다. 그런 다음, <code>repeat()</code>를 증가된 <code>indentLevel</code>과 함께 호출하여 공백(“ “)의 수를 변경할 수 있습니다.</p>
<p>또한 ECMAScript 6은 특정 범주에 맞지 않는 정규 표현식 기능을 일부 변경했습니다. 다음 섹션에서는 몇 가지 사항을 집중적으로 설명합니다.</p>
<h2 id="정규-표현식-Regular-Expression-의-다른-변경-사항"><a href="#정규-표현식-Regular-Expression-의-다른-변경-사항" class="headerlink" title="정규 표현식(Regular Expression)의 다른 변경 사항"></a>정규 표현식(Regular Expression)의 다른 변경 사항</h2><p>정규 표현식은 JavaScript로 문자열을 다루는 중요한 부분이며, JavaScript의 다른 많은 부분과 마찬가지로 최근 버전까지 많이 변경되지 않았습니다. 하지만 ECMAScript 6에서 문자열에 대한 몇몇 업데이트와 함께 정규 표현식이 몇 가지 개선되었습니다.</p>
<h3 id="정규-표현식-Regular-Expression-y-플래그"><a href="#정규-표현식-Regular-Expression-y-플래그" class="headerlink" title="정규 표현식(Regular Expression) y 플래그"></a>정규 표현식(Regular Expression) <code>y</code> 플래그</h3><p>ECMAScript 6은 파이어 폭스에서 정규 표현식을 독점적으로 확장 구현 후 <code>y</code> 플래그를 표준화 했습니다. <code>y</code> 플래그는 정규 표현식 검색의 <code>sticky</code> 속성에 영향을 미치며 정규 표현식의 <code>lastIndex</code> 속성에 의해 지정된 위치의 문자열에서 일치하는 문자를 검색하도록 검색을 지시합니다. 해당 위치에서 일치하는 항목이 없으면 정규식은 매칭을 중지합니다. 이것이 어떻게 작동하는지 다음 코드를 보도록 하겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> text = <span class="string">"hello1 hello2 hello3"</span>,</div><div class="line">    pattern = <span class="regexp">/hello\d\s?/</span>,</div><div class="line">    result = pattern.exec(text),</div><div class="line">    globalPattern = <span class="regexp">/hello\d\s?/g</span>,</div><div class="line">    globalResult = globalPattern.exec(text),</div><div class="line">    stickyPattern = <span class="regexp">/hello\d\s?/y</span>,</div><div class="line">    stickyResult = stickyPattern.exec(text);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(result[<span class="number">0</span>]);         <span class="comment">// "hello1 "</span></div><div class="line"><span class="built_in">console</span>.log(globalResult[<span class="number">0</span>]);   <span class="comment">// "hello1 "</span></div><div class="line"><span class="built_in">console</span>.log(stickyResult[<span class="number">0</span>]);   <span class="comment">// "hello1 "</span></div><div class="line"></div><div class="line">pattern.lastIndex = <span class="number">1</span>;</div><div class="line">globalPattern.lastIndex = <span class="number">1</span>;</div><div class="line">stickyPattern.lastIndex = <span class="number">1</span>;</div><div class="line"></div><div class="line">result = pattern.exec(text);</div><div class="line">globalResult = globalPattern.exec(text);</div><div class="line">stickyResult = stickyPattern.exec(text);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(result[<span class="number">0</span>]);         <span class="comment">// "hello1 "</span></div><div class="line"><span class="built_in">console</span>.log(globalResult[<span class="number">0</span>]);   <span class="comment">// "hello2 "</span></div><div class="line"><span class="built_in">console</span>.log(stickyResult[<span class="number">0</span>]);   <span class="comment">// Error! stickyResult is null</span></div></pre></td></tr></table></figure>
<p>이 예제에는 3 개의 정규 표현식이 있습니다. <code>pattern</code>의 표현식에는 플래그가 없으며 <code>globalPattern</code>의 표현식은 <code>g</code> 플래그를 사용하고<code>stickyPattern</code>의 표현식은 <code>y</code> 플래그를 사용합니다. 첫 번째의 3개 <code>console.log()</code>에서 세 정규식은 모두 끝에 스페이스가 포함된 <code>&quot;hello1 &quot;</code>를 반환 합니다.</p>
<p>그런 다음 <code>lastIndex</code> 속성은 세 패턴 모두에서 1로 변경됩니다. 즉 정규 표현식이 두 번째에서 일치를 시작합니다. 플래그가 없는 정규 표현식은<code>lastIndex</code>에 대한 변경 사항을 완전히 무시하고 <code>&quot;hello1 &quot;</code>과 아무런 문제없이 일치합니다. <code>g</code> 플래그를 사용하는 정규 표현식은 문자열의 두 번째 문자(<code>&quot;e&quot;</code>)에서 검색을 시작하기 때문에 <code>&quot;hello2 &quot;</code>와 일치합니다. <code>sticky</code> 정규 표현은 두 번째 문자에서 시작하는 것과 일치하지 않으므로<code>stickyResult</code>는 <code>null</code>입니다.</p>
<p><code>sticky</code> 플래그는 작업이 수행될 때마다 <code>lastIndex</code>에서 마지막으로 일치 한 다음 문자 다음의 인덱스를 저장합니다. 연산 결과가 일치하지 않으면 <code>lastIndex</code>가 0으로 다시 설정됩니다. 전역 <code>stickyPattern.lastIndex</code>는 다음과 같이 동일한 방식으로 동작합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> text = <span class="string">"hello1 hello2 hello3"</span>,</div><div class="line">    pattern = <span class="regexp">/hello\d\s?/</span>,</div><div class="line">    result = pattern.exec(text),</div><div class="line">    globalPattern = <span class="regexp">/hello\d\s?/g</span>,</div><div class="line">    globalResult = globalPattern.exec(text),</div><div class="line">    stickyPattern = <span class="regexp">/hello\d\s?/y</span>,</div><div class="line">    stickyResult = stickyPattern.exec(text);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(result[<span class="number">0</span>]);         <span class="comment">// "hello1 "</span></div><div class="line"><span class="built_in">console</span>.log(globalResult[<span class="number">0</span>]);   <span class="comment">// "hello1 "</span></div><div class="line"><span class="built_in">console</span>.log(stickyResult[<span class="number">0</span>]);   <span class="comment">// "hello1 "</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(pattern.lastIndex);         <span class="comment">// 0</span></div><div class="line"><span class="built_in">console</span>.log(globalPattern.lastIndex);   <span class="comment">// 7</span></div><div class="line"><span class="built_in">console</span>.log(stickyPattern.lastIndex);   <span class="comment">// 7</span></div><div class="line"></div><div class="line">result = pattern.exec(text);</div><div class="line">globalResult = globalPattern.exec(text);</div><div class="line">stickyResult = stickyPattern.exec(text);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(result[<span class="number">0</span>]);         <span class="comment">// "hello1 "</span></div><div class="line"><span class="built_in">console</span>.log(globalResult[<span class="number">0</span>]);   <span class="comment">// "hello2 "</span></div><div class="line"><span class="built_in">console</span>.log(stickyResult[<span class="number">0</span>]);   <span class="comment">// "hello2 "</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(pattern.lastIndex);         <span class="comment">// 0</span></div><div class="line"><span class="built_in">console</span>.log(globalPattern.lastIndex);   <span class="comment">// 14</span></div><div class="line"><span class="built_in">console</span>.log(stickyPattern.lastIndex);   <span class="comment">// 14</span></div></pre></td></tr></table></figure>
<p><code>lastIndex</code>의 값은 <code>stickyPattern</code> 변수와 <code>globalPattern</code> 변수 모두에 대해 <code>exec()</code>의 첫 번째 호출 후에 7로 변경되고 두 번째 호출 후에 14로 변경됩니다.</p>
<p>염두에 두어야 할 sticky 플래그에 대한 두 가지 미묘한 세부 사항이 있습니다.</p>
<ol>
<li><code>lastIndex</code> 속성은 <code>exec()</code>및 <code>test()</code> 메서드와 같이 정규 표현식 객체에 존재하는 메서드를 호출 할 때만 적용됩니다. 정규 표현식을 <code>match ()</code>와 같은 문자열 메서드에 전달하면 sticky를 실행하지 않습니다.</li>
<li>문자열의 시작과 일치시키기 위해<code>^</code>문자를 사용할 때, sticky 정규 표현식은 문자열의 시작 부분 또는 여러 줄 모드의 줄 시작 부분에서만 일치합니다. <code>lastIndex</code>가 0 일때  <code>^</code>는 non-sticky 정규 표현식과 sticky 정규 표현식의 결과가 같습니다. <code>lastIndex</code>가 단일 행 모드에서 문자열의 시작이나 다중 행 모드에서 행의 시작과 일치하지 않으면 sticky 정규 표현식은 절대로 매칭하지 않습니다.</li>
</ol>
<p>일반 다른 정규식 플래그와 마찬가지로 프로퍼티를 사용하여 <code>sticky</code> 플래그의 존재를 확인 할 수 있습니다. 다음 코드는 <code>sticky</code> 속성을 검사 하는 예제입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> pattern = <span class="regexp">/hello\d/y</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(pattern.sticky);    <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p><code>sticky</code> 속성은 sticky 플래그가 있으면 true로 설정되고, 그렇지 않으면 false로 설정됩니다. <code>sticky</code> 속성은 플래그의 존재에 기초한 읽기 전용이며 코드라서 변경할 수 없습니다.</p>
<p><code>u</code> 플래그와 비슷하게, <code>y</code> 플래그는 구문 변경이므로 오래된 JavaScript 엔진에서는 구문 오류가 발생할 수 있습니다. 다음 방법을 사용하여 <code>sticky</code> 지원을 검사 할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasRegExpY</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">var</span> pattern = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"."</span>, <span class="string">"y"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125; <span class="keyword">catch</span> (ex) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>u</code> 검사와 마찬가지로, <code>y</code> 플래그를 가진 정규 표현식을 만들 수 없다면 false를 반환합니다. <code>u</code> 플래그와 유사하게 오래된 JavaScript 엔진에서 실행되는 코드 내부에 <code>y</code>를 사용해야 할 경우, 정규 표현식을 정의 할 때 <code>RegExp</code> 생성자를 사용하여 구문 오류를 피하십시오.</p>
<h3 id="정규-표현식-복제-Duplicating-Regular-Expressions"><a href="#정규-표현식-복제-Duplicating-Regular-Expressions" class="headerlink" title="정규 표현식 복제(Duplicating Regular Expressions)"></a>정규 표현식 복제(Duplicating Regular Expressions)</h3><p>ECMAScript 5에서는 다음과 같이 <code>RegExp</code> 생성자에 정규 표현식을 전달하여 복제할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> re1 = <span class="regexp">/ab/i</span>,</div><div class="line">    re2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(re1);</div></pre></td></tr></table></figure>
<p><code>re2</code> 변수는 <code>re1</code> 변수의 복사본입니다. 그러나 정규식에 대한 플래그를 지정하는 <code>RegExp</code> 생성자에 두 번째 파라미터를 제공하면 다음 코드와 같이 정상 작동하지 않습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> re1 = <span class="regexp">/ab/i</span>,</div><div class="line"></div><div class="line">    <span class="comment">// ES5에서는 error 발생, ES6에서는 OK</span></div><div class="line">    re2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(re1, <span class="string">"g"</span>);</div></pre></td></tr></table></figure>
<p>ECMAScript 5 환경에서 이 코드를 실행하면 첫 번째 파라미터가 정규 표현식 일 때 두 번째 파라미터를 사용할 수 없다는 오류가 발생합니다. ECMAScript 6은 두 번째 파라미터가 허용되고 첫 번째 파라미터에있는 플래그를 무시하도록이 동작이 변경 되었습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> re1 = <span class="regexp">/ab/i</span>,</div><div class="line"></div><div class="line">    <span class="comment">// ES5에서는 error 발생, ES6에서는 OK</span></div><div class="line">    re2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(re1, <span class="string">"g"</span>);</div><div class="line"></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(re1.toString());            <span class="comment">// "/ab/i"</span></div><div class="line"><span class="built_in">console</span>.log(re2.toString());            <span class="comment">// "/ab/g"</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(re1.test(<span class="string">"ab"</span>));            <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(re2.test(<span class="string">"ab"</span>));            <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(re1.test(<span class="string">"AB"</span>));            <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(re2.test(<span class="string">"AB"</span>));            <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p>이 코드에서,<code>re1</code>은 대소 문자를 구분하지 않는 <code>i</code> 플래그를, <code>re2</code>는 전역 <code>g</code> 플래그만을 가지고 있습니다. <code>RegExp</code> 생성자는 <code>re1</code>에서 패턴을 복사하고 <code>i</code> 플래그를 <code>g</code> 플래그로 대체했습니다. 두 번째 인수가 없으면 <code>re2</code>는 <code>re1</code>과 같은 플래그를가집니다.</p>
<h3 id="플래그-프로퍼티"><a href="#플래그-프로퍼티" class="headerlink" title="플래그 프로퍼티"></a>플래그 프로퍼티</h3><p>새 플래그를 추가하고 플래그를 사용하여 작업하는 방법을 변경하는 것과 함께 ECMAScript 6은 이와 관련된 프로퍼티를 추가했습니다. ECMAScript 5에서는 <code>source</code> 프로퍼티를 사용하여 정규 표현식의 텍스트를 얻을 수 있지만 플래그 문자열을 얻으려면 아래와 같이<code>toString ()</code>메서드의 출력을 파싱해야합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFlags</span>(<span class="params">re</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> text = re.toString();</div><div class="line">    <span class="keyword">return</span> text.substring(text.lastIndexOf(<span class="string">"/"</span>) + <span class="number">1</span>, text.length);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// toString() is "/ab/g"</span></div><div class="line"><span class="keyword">var</span> re = <span class="regexp">/ab/g</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(getFlags(re));          <span class="comment">// "g"</span></div></pre></td></tr></table></figure>
<p>정규식을 문자열로 변환 한 다음 마지막 <code>/</code> 다음에 나오는 문자를 반환합니다. <code>/</code> 이후의 문자가 플래그입니다.</p>
<p>ECMAScript 6는 <code>flags</code> 프로퍼티를 <code>source</code> 프로퍼티와 함께 추가하여 플래그를 쉽게 가져옵니다. 두 프로퍼티는 모두 getter 만 할당된 프로토 타입 접근자이므로 읽기 전용입니다. <code>flags</code> 프로퍼티는 디버깅과 상속 목적을 위해 정규 표현식을 더 쉽게 검사하게 합니다.</p>
<p>ECMAScript 6에 추가된 <code>flags</code> 프로퍼티는 정규 표현식에 적용된 플래그의 문자열 표현을 반환합니다. 예 :</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> re = <span class="regexp">/ab/g</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(re.source);     <span class="comment">// "ab"</span></div><div class="line"><span class="built_in">console</span>.log(re.flags);      <span class="comment">// "g"</span></div></pre></td></tr></table></figure>
<p>위 코드는 <code>re</code>에 있는 모든 플래그를 가져 와서 <code>toString ()</code> 기법보다 훨씬 적은 코드로 결과를 콘솔에 출력합니다. <code>source</code>와 <code>flags</code>를 함께 사용하면 정규식 문자열을 직접 파싱하지 않고도 필요한 정규 표현식을 추출할 수 있습니다.</p>
<p>이 장에서 지금까지 다루었던 일반 문자열과 정규 표현식에 대한 변경 사항은 분명 강력하지만 ECMAScript 6는 훨씬 더 강력한 방식의 문자열을 지원합니다.</p>
<h2 id="Template-literal-템플릿-리터럴"><a href="#Template-literal-템플릿-리터럴" class="headerlink" title="Template literal(템플릿 리터럴)"></a>Template literal(템플릿 리터럴)</h2><p>항상 JavaScript의 문자열 처리 기능은 다른 언어와 비교하면 기능이 제한적이었습니다. 예를 들어, ECMAScript 6까지 문자열은 지금까지 위에서 다루었던 메서드가 없었으며 문자열 연결은 가능한 간단했습니다. 개발자가 보다 복잡한 문제를 해결할 수 있도록 ECMAScript 6의 <em>Template literal</em>은 ECMAScript 5 이하에서 사용할 수있는 솔루션보다 안전한 방법으로 콘텐츠 작업을 위한 도메인 별 언어 (DSL) 생성 구문을 제공합니다. (DSL은 JavaScript와 같은 범용 언어와 달리 특정 목적을 위해 설계된 프로그래밍 언어입니다.) ECMAScript wiki는 <a href="http://wiki.ecmascript.org/doku.php?id=harmony:quasis" target="_blank" rel="external">template literal strawman</a>에 대해 다음과 같이 설명합니다.</p>
<blockquote>
<p>이 스키마는 Syntactic sugar를 활용한 ECMAScript 구문을 확장하여 라이브러리가 다른 언어의 내용을 쉽게 생성, 쿼리 및 조작할 수있는 DSL을 제공 하여 XSS, SQL Injection 등과 같이 Injection attack에 대항하거나 면역 기능을 부여 합니다.</p>
</blockquote>
<p>실제로 <em>Template literal</em>은 JavaScript가 ECMAScript 5를 통해 부족했던 다음 기능에 대한 ECMAScript 6의 대답입니다.</p>
<ul>
<li><strong>Multiline strings</strong> 여러 줄 문자열의 공식 개념.</li>
<li><strong>Basic string formatting</strong> 변수값으로 문자열의 일부를 대체할 수있는 기능.</li>
<li><strong>HTML escaping</strong> HTML에 삽입하는 것이 안전하도록 문자열을 변환하는 기능.</li>
</ul>
<p><em>Template literal</em>은 JavaScript의 기존 문자열에 더 많은 기능을 추가하기 보다는 이러한 문제를 해결하기 위한 완전히 새로운 접근 방식입니다.</p>
<h3 id="기본-문법-Basic-Syntax"><a href="#기본-문법-Basic-Syntax" class="headerlink" title="기본 문법 (Basic Syntax)"></a>기본 문법 (Basic Syntax)</h3><p>가장 단순한 <em>Template literal</em>은 이중 따옴표(<code>&quot;</code>) 나 작은 따옴표(<code>&#39;</code>) 대신 백팅(<code>` </code>)으로 문자열을 감싸면 됩니다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> message = <span class="string">`Hello world!`</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(message);               <span class="comment">// "Hello world!"</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> message);        <span class="comment">// "string"</span></div><div class="line"><span class="built_in">console</span>.log(message.length);        <span class="comment">// 12</span></div></pre></td></tr></table></figure>
<p>위 코드는 <code>message</code> 변수가 일반적인 JavaScript 문자열을 포함하고 있음을 보여줍니다. <em>Template literal</em> 구문은 문자열의 <em>Code point</em>을 생성하는 데 사용되며, 이 <em>Code point</em>는 <code>message</code> 변수에 할당됩니다.</p>
<p>문자열에서 백틱을 사용하려면 아래의 코드의 <code>message</code> 변수 처럼 백 슬래시 (<code>\</code>)를 사용하여 이스케이프합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> message = <span class="string">`\`Hello\` world!`</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(message);               <span class="comment">// "`Hello` world!"</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> message);        <span class="comment">// "string"</span></div><div class="line"><span class="built_in">console</span>.log(message.length);        <span class="comment">// 14</span></div></pre></td></tr></table></figure>
<p><em>Template literal</em> 안의 이중 따옴표 나 작은 따옴표는 이스케이프할 필요가 없습니다.</p>
<h3 id="여러-줄의-문자열-Multiline-String"><a href="#여러-줄의-문자열-Multiline-String" class="headerlink" title="여러 줄의 문자열 (Multiline String)"></a>여러 줄의 문자열 (Multiline String)</h3><p>JavaScript 개발자는 첫 번째 버전 이후로 항상 여러 줄을 만드는 방법을 원했습니다. 그러나 이중 따옴표 나 작은 따옴표를 사용하는 경우 문자열은 한줄로 완전히 포함되어야합니다.</p>
<h4 id="ECMAScript-6-이전-방법"><a href="#ECMAScript-6-이전-방법" class="headerlink" title="ECMAScript 6 이전 방법"></a>ECMAScript 6 이전 방법</h4><p>하지만 오래 지속되는 문법 버그 덕분에 JavaScript는 해결 방법이 있습니다. 개행 전에 백 슬래시 (<code>\</code>)가 있으면 여러 줄을 만들 수 있습니다. 다음은 그 예입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> message = <span class="string">"Multiline \</span></div><div class="line">string";</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(message);       <span class="comment">// "Multiline string"</span></div></pre></td></tr></table></figure>
<p>하지만 백 슬래시가 개행이 아닌 연속으로 처리되기 때문에 <code>message</code> 문자열에는 콘솔에 출력할 때 개행 문자가 없습니다. 출력에 개행 문자를 표시하려면 수동으로 포함시켜야합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> message = <span class="string">"Multiline \n\</span></div><div class="line">string";</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(message);       <span class="comment">// "Multiline</span></div><div class="line">                            <span class="comment">//  string"</span></div></pre></td></tr></table></figure>
<p>이것은 모든 주요한 JavaScript 엔진에서 두줄로된 <code>Multiline String</code>을 출력 하는 방법입니다. 그러나 이 동작은 버그로 정의되어 있으므로 많은 개발자들은 이를 피하는 것을 권장합니다.</p>
<p>일반적으로 ECMAScript 6 이전 버전으로 다중 문자열을 만들기 위한 방법은 다음과 같이 <em>Array</em>이나 문자열 연결에 의존합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> message = [</div><div class="line">    <span class="string">"Multiline "</span>,</div><div class="line">    <span class="string">"string"</span></div><div class="line">].join(<span class="string">"\n"</span>);</div><div class="line"></div><div class="line"><span class="keyword">let</span> message = <span class="string">"Multiline \n"</span> +</div><div class="line">    <span class="string">"string"</span>;</div></pre></td></tr></table></figure>
<p>JavaScript에서 여러 줄을 사용하지 못하게하는 하는 문제는 개발자의 오랜 숙원이었습니다.</p>
<h4 id="쉽게-여러줄의-문자열-만드는-방법"><a href="#쉽게-여러줄의-문자열-만드는-방법" class="headerlink" title="쉽게 여러줄의 문자열 만드는 방법"></a>쉽게 여러줄의 문자열 만드는 방법</h4><p>ECMAScript 6의 <em>Template literal</em>은 특수 구문이 없기 때문에 여러 줄 문자열을 쉽게 만듭니다. 원하는 위치에 개행을 포함하면 결과에 나타납니다. 예 :</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> message = <span class="string">`Multiline</span></div><div class="line">string`;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(message);           <span class="comment">// "Multiline</span></div><div class="line">                                <span class="comment">//  string"</span></div><div class="line"><span class="built_in">console</span>.log(message.length);    <span class="comment">// 16</span></div></pre></td></tr></table></figure>
<p>백틱의 모든 공백은 문자열의 일부이므로 들여 쓰기에 주의하십시오.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> message = <span class="string">`Multiline</span></div><div class="line">               string`;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(message);           <span class="comment">// "Multiline</span></div><div class="line">                                <span class="comment">//                 string"</span></div><div class="line"><span class="built_in">console</span>.log(message.length);    <span class="comment">// 31</span></div></pre></td></tr></table></figure>
<p>이 코드에서 <em>Template literal</em>의 두 번째 줄 앞에있는 공백은 모두 문자열 자체의 일부로 간주됩니다. 적절한 들여 쓰기로 텍스트 줄을 만드는 것이 중요하다면 다음과 같이 여러 줄 <em>Template literal</em>의 첫 줄에 아무 것도 남기지 말고 그 다음에 들여 쓰기하는 것을 생각해 볼수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> html = <span class="string">`</span></div><div class="line">&lt;div&gt;</div><div class="line">    &lt;h1&gt;Title&lt;/h1&gt;</div><div class="line">&lt;/div&gt;`.trim();</div></pre></td></tr></table></figure>
<p>이 코드는 첫 번째 줄에서 <em>Template literal</em>을 시작하지만 두 번째 줄까지는 텍스트가 없습니다. HTML 태그는 올바른 모양으로 들여 쓰여지고 <code>trim()</code> 메서드가 호출되어 초기 빈 줄이 제거됩니다.</p>
<p>원하는 경우, <em>Template literal</em>에서 <code>\n</code>을 사용하여 개행을 삽입할 위치를 지정할 수도 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> message = <span class="string">`Multiline\nstring`</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(message);           <span class="comment">// "Multiline</span></div><div class="line">                                <span class="comment">//  string"</span></div><div class="line"><span class="built_in">console</span>.log(message.length);    <span class="comment">// 16</span></div></pre></td></tr></table></figure>
<h3 id="문자열-치환-하기"><a href="#문자열-치환-하기" class="headerlink" title="문자열 치환 하기"></a>문자열 치환 하기</h3><p>이 시점에서 <em>Template literal</em>은 일반적인 JavaScript 문자열보다 더 멋진 버전처럼 보일 수 있습니다. 하지만 일반 JavaScript의 문자열과 <em>Template literal</em>의 실제 차이는 <em>Substitution(치환)</em>에 있습니다. 치환 기능을 사용하면 유효한 JavaScript 표현식을 <em>Template literal</em>에 포함시키고 결과를 문자열의 일부로 출력할 수 있습니다.</p>
<p>문자열 치환은 문자열 내부에 임의의 JavaScript 표현식이 포함된 여는 <code>${</code> 및 닫는<code>}</code>로 처리 됩니다. 가장 간단한 치환은 다음과 같이 결과 문자열에 지역 변수를 직접 포함시킬 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> name = <span class="string">"Nicholas"</span>,</div><div class="line">    message = <span class="string">`Hello, <span class="subst">$&#123;name&#125;</span>.`</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(message);       <span class="comment">// "Hello, Nicholas."</span></div></pre></td></tr></table></figure>
<p>치환 <code>${name}</code>은 로컬 변수 <code>name</code>에 접근하여 <code>name</code>을 <code>message</code> 문자열에 삽입합니다. <code>message</code> 변수는 즉시 치환 결과를 저장합니다.</p>
<blockquote>
<p><em>Template literal</em>은 정의된 Scope에서 액세스할 수있는 모든 변수를 액세스할 수 있습니다. <em>Template literal</em>에서 선언되지 않은 변수를 사용하려고 시도하면 엄격 모드와 비 엄격 모드 모두에서 오류가 발생합니다.</p>
</blockquote>
<p>모든 치환은 JavaScript 표현식이므로 간단한 변수 값의 치환 그 이상을 할 수 있습니다. 계산, 함수 호출 등도 쉽게 포함할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> count = <span class="number">10</span>,</div><div class="line">    price = <span class="number">0.25</span>,</div><div class="line">    message = <span class="string">`<span class="subst">$&#123;count&#125;</span> items cost $<span class="subst">$&#123;(count * price).toFixed(<span class="number">2</span>)&#125;</span>.`</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(message);       <span class="comment">// "10 items cost $2.50."</span></div></pre></td></tr></table></figure>
<p>이 코드는 <em>Template literal</em>의 일부로 계산 기능을 수행합니다. <code>count</code>와 <code>price</code> 변수를 곱해서 결과를 얻은 다음<code>.toFixed()</code>를 사용하여 소수점 두 자리까지 포맷합니다. 두 번째 치환 이전의 달러 기호는 여는 중괄호가 없기 때문에 그대로 출력됩니다.</p>
<p><em>Template literal</em>은 JavaScript 표현식이기도합니다. 즉,이 예제에서와 같이 다른 <em>Template literal</em>의 치환 내부에 <em>Template literal</em>을 배치할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> name = <span class="string">"Nicholas"</span>,</div><div class="line">    message = <span class="string">`Hello, <span class="subst">$&#123;</span></span></div><div class="line">        <span class="string">`my name is <span class="subst">$&#123; name &#125;</span>`</span></div><div class="line">    &#125;.`;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(message);        <span class="comment">// "Hello, my name is Nicholas."</span></div></pre></td></tr></table></figure>
<p>이 예제는 첫 번째 템플릿 안에 두 번째 <em>Template literal</em>을 중첩합니다. 첫 번째 <code>${</code> 다음에 다른 <em>Template literal</em>이 시작됩니다. 두 번째 <code>${</code>는 내부 <em>Template literal</em> 안에 삽입된 표현식의 시작을 나타냅니다. 그 표현식은 결과에 삽입되는 변수 <code>name</code>입니다.</p>
<h3 id="템플릿-Tag-Tagged-Template"><a href="#템플릿-Tag-Tagged-Template" class="headerlink" title="템플릿 Tag(Tagged Template)"></a>템플릿 Tag(Tagged Template)</h3><p>지금까지 <em>Template literal</em>이 여러 줄을 만들고 따로 연결없이(<code>+</code>) 문자열에 값을 삽입하는 방법을 살펴 보았습니다. 그러나 <em>Template literal</em>의 진정한 힘은 태그가있는 템플릿에서 비롯됩니다. <em>Template tag</em>는 <em>Template literal</em>에 대한 치환을 수행하고 최종 문자열 값을 반환합니다. 이 태그는 첫 번째<code>` </code>문자 바로 앞에있는 템플릿의 시작 부분에 다음과 같이 지정합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> message = tag<span class="string">`Hello world`</span>;</div></pre></td></tr></table></figure>
<p>이 예제에서 <code>tag</code>는 <code>`Hello world` </code><em>Template literal</em>에 적용할 템플릿 태그입니다.</p>
<h4 id="Tag-정의하기"><a href="#Tag-정의하기" class="headerlink" title="Tag 정의하기"></a>Tag 정의하기</h4><p><em>Tag</em>는 단순히 처리된 <em>Template literal</em> 데이터가 호출되는 함수입니다. <em>Tag</em>는 <em>Template literal</em>에 대한 데이터를 개별 조각으로 수신하고 조각을 결합하여 결과를 만들어야 합니다. 첫 번째 파라미터는 JavaScript에 의해 해석되는 리터럴 문자열을 포함하는 <em>Array</em>입니다. 후속 파라미터는 각 치환에 사용될 값입니다.</p>
<p><em>Tag</em> 함수는 일반적으로 다음과 같은 파라미터를 사용하여 정의되어 데이터를 보다 쉽게 처리할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">literals, ...substitutions</span>) </span>&#123;</div><div class="line">    <span class="comment">// return a string</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>무엇이 <em>Tag</em>로 전달되는지 더 잘 이해하기 위해 다음 코드를 살펴 보겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> count = <span class="number">10</span>,</div><div class="line">    price = <span class="number">0.25</span>,</div><div class="line">    message = passthru<span class="string">`<span class="subst">$&#123;count&#125;</span> items cost $<span class="subst">$&#123;(count * price).toFixed(<span class="number">2</span>)&#125;</span>.`</span>;</div></pre></td></tr></table></figure>
<p>위 코드를 보면, <code>passthru()</code> 함수는 3 개의 파라미터를 받습니다. 첫 번째 파라미터는 아래의 요소를 포함하는 <code>literals</code> <em>Array</em>입니다.</p>
<ul>
<li>첫 번째 치환 전의 빈 문자열 (<code>&quot;&quot;</code>)</li>
<li>첫 번째 치환 후 두 번째 문자열 앞에있는 문자열 <code>( &quot;items cost $&quot;)</code></li>
<li>두 번째 치환 후의 문자열 <code>(&quot;.&quot;)</code></li>
</ul>
<p>두 번째 파라미터는 <code>count</code> 변수에 대한 해석된 값인 <code>10</code>입니다. 이것은 <code>substitutions</code> <em>Array</em>의 첫 번째 요소가됩니다. 마지막 인수는<code>(count * price).toFixed(2)</code>의 해석된 값이고 <code>substitutions</code> <em>Array</em>의 두 번째 요소인 <code>&quot;2.50&quot;</code>이 될 것입니다.</p>
<p><code>literals</code>의 첫 번째 항목은 빈 문자열입니다. 이것은 <code>literals[literals.length - 1]</code>이 항상 문자열의 끝인 것처럼 <code>literals[0]</code>이 항상 문자열의 시작임을 보장합니다. 항상 <code>substitutions.length === literals.length - 1</code>이라는 표현이 true라는 것은 <code>substitutions</code>이 <code>literals</code>보다 항상 하나 더 적다는 것을 의미합니다.</p>
<p>이 패턴을 사용하면 <code>literals</code>과 <code>substitutions</code> <em>Array</em>을 결합하여 결과 문자열을 만들 수 있습니다. <code>literals</code>의 첫 번째 항목이 먼저오고, <code>substitutions</code>의 첫 번째 항목은 다음 항목이며, 이런 순서는 문자열이 완료될 때까지 계속됩니다. 예를 들어, 다음 두 <em>Array</em>의 값을 교대로 사용하여 <em>Template literal</em>의 기본 동작을 모방할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">passthru</span>(<span class="params">literals, ...substitutions</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> result = <span class="string">""</span>;</div><div class="line"></div><div class="line">    <span class="comment">// loop는 substitutions 카운트 만큼 실행합니다.</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; substitutions.length; i++) &#123;</div><div class="line">        result += literals[i];</div><div class="line">        result += substitutions[i];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 마지막 literal</span></div><div class="line">    result += literals[literals.length - <span class="number">1</span>];</div><div class="line"></div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> count = <span class="number">10</span>,</div><div class="line">    price = <span class="number">0.25</span>,</div><div class="line">    message = passthru<span class="string">`<span class="subst">$&#123;count&#125;</span> items cost $<span class="subst">$&#123;(count * price).toFixed(<span class="number">2</span>)&#125;</span>.`</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(message);       <span class="comment">// "10 items cost $2.50."</span></div></pre></td></tr></table></figure>
<p>위 예제는 <em>Template literal</em>의 기본 액션과 동일한 치환을 수행하는 <code>passthru</code> <em>Tag</em>를 정의합니다. 유일한 트릭은 <code>substitutions</code> <em>Array</em>의 끝을 지나치는 것을 피하기 위해 <code>literalals.length</code>가 아닌 <code>substitutions.length</code>를 loop에서 사용하는 것입니다. 이것은 <code>literalals</code>와 <code>substitutions</code> 사이의 관계가 ECMAScript 6에서 잘 정의되어 있기 때문에 가능합니다.</p>
<blockquote>
<p>‘substitutions’에 포함된 값은 반드시 문자열 일 필요는 없습니다. 앞의 예에서와 같이 표현식이 숫자로 평가되면 숫자 값이 전달됩니다. 이러한 값이 결과에 어떻게 출력되어야 하는지를 결정하는 것은 <em>Tag</em> 작업의 일부입니다.</p>
</blockquote>
<h4 id="Template-literal의-Raw-Value-사용하기"><a href="#Template-literal의-Raw-Value-사용하기" class="headerlink" title="Template literal의 Raw Value 사용하기"></a><em>Template literal</em>의 Raw Value 사용하기</h4><p>템플릿 <em>Tag</em>는 <em>Raw string</em> 정보에도 접근할 수 있습니다. 이 정보는 주로 문자 이스케이프에 대한 액세스를 의미합니다. <em>Raw string</em> 값으로 작업하는 가장 간단한 방법은 내장된 <code>String.raw()</code> <em>Tag</em>를 사용하는 것입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> message1 = <span class="string">`Multiline\nstring`</span>,</div><div class="line">    message2 = <span class="built_in">String</span>.raw<span class="string">`Multiline\nstring`</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(message1);          <span class="comment">// "Multiline</span></div><div class="line">                                <span class="comment">//  string"</span></div><div class="line"><span class="built_in">console</span>.log(message2);          <span class="comment">// "Multiline\\nstring"</span></div></pre></td></tr></table></figure>
<p>이 코드에서 <code>message1</code>의 <code>\n</code>은 개행 문자로 해석되고 <code>message2</code>의 <code>\n</code>은 <code>&quot;\\n&quot;</code>(역슬래시 및 문자 n)의 <code>Raw string</code>으로 해석됩니다. 이와 같이 <code>Raw string</code> 정보를 찾을려면 생각보다 복잡한 처리가 필요합니다.</p>
<p><em>Raw string</em> 정보는 또한 템플릿 <em>Tag</em>로 전달됩니다. <em>Tag</em> 함수의 첫 번째 파라미터는 <code>raw</code>라는 추가 프로퍼티가 있는 <em>Array</em>입니다. <code>raw</code> 프로퍼티는 각 리터럴 값과 정확히 일치하는 <em>Raw</em>을 포함하는 <em>Array</em>입니다. 예를 들어, <code>literals[0]</code>의 값은 항상 <code>Raw string</code> 정보를 포함하는 <code>literals.raw[0]</code>과 일치합니다. 다음 코드를 사용하여 <code>String.raw()</code>을 모방할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">raw</span>(<span class="params">literals, ...substitutions</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> result = <span class="string">""</span>;</div><div class="line"></div><div class="line">    <span class="comment">// loop는 substitutions 카운트 만큼 실행합니다.</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; substitutions.length; i++) &#123;</div><div class="line">        result += literals.raw[i];      <span class="comment">// 대신 raw 값을 사용하세요.</span></div><div class="line">        result += substitutions[i];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 마지막 리터럴을 더합니다.</span></div><div class="line">    result += literals.raw[literals.length - <span class="number">1</span>];</div><div class="line"></div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> message = raw<span class="string">`Multiline\nstring`</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(message);           <span class="comment">// "Multiline\\nstring"</span></div><div class="line"><span class="built_in">console</span>.log(message.length);    <span class="comment">// 17</span></div></pre></td></tr></table></figure>
<p><code>result</code>를 만들기 위해 위해 <code>literalals</code>대신에 <code>literals.raw</code>를 사용합니다. 즉, Unicode <em>Code point</em> 이스케이프를 비롯한 모든 문자 이스케이프는 <em>Raw 형식</em>으로 반환되어야합니다. <code>Raw string</code>은 이스케이프 문자를 포함해야 하는 코드가 포함된 문자열을 출력하려는 경우 유용합니다. (예를 들어, 일부 코드에 대한 설명서를 생성하려면 실제 코드가 나타나는대로 출력하고 싶을 수 있습니다.)</p>
<h2 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h2><p>완전한 Unicode 지원을 통해 JavaScript는 논리적 인 방식으로 UTF-16 문자를 처리할 수 있습니다. <code>codePointAt()</code>와 <code>String.fromCodePoint()</code>를 통해 <em>Code point</em>와 캐릭터 사이를 옮기는 능력은 문자열 조작을 위한 중요한 단계입니다. 정규 표현식 <code>u</code> 플래그를 추가하면 16-bit 문자 대신 <em>Code point</em>에서 연산을 수행할 수 있으며, <code>normalize()</code> 메서드는 보다 적절한 문자열 비교에 유용합니다.</p>
<p>ECMAScript 6는 문자열 작업을위한 새로운 방법을 추가하여 부모 문자열의 위치에 관계없이 하위 문자열을 보다 쉽게 식별할 수 있도록합니다. 정규 표현식에 더 많은 기능이 추가되었습니다.</p>
<p><em>Template literal</em>은 ECMAScript 6에 중요한 추가 기능으로 문자열 작성을 쉽게하기 위해 도메인 별 언어 (DSL)를 만들 수 있습니다. 변수를 <em>Template literal</em>에 직접 포함시킬 수 있다는 것은 개발자가 변수가 있는 긴 문자열을 작성하기 위해 문자열 연결보다 안전한 도구라는 것을 의미합니다.</p>
<p>여러 줄 문자열에 대한 지원 기능이 내장되어 있어 <em>Template literal</em>은 일반적인 JavaScript 문자열보다 유용합니다. <em>Template literal</em> 내부에 개행을 직접 허용하더라도 여전히 <code>\n</code>과 다른 문자 이스케이프 시퀀스를 사용할 수 있습니다.</p>
<p>템플릿 <em>Tag</em>는 DSL을 생성할 때 가장 중요한 부분입니다. <em>Tag</em>는 <em>Template literal</em> 조각을 인수로받는 함수입니다. 그런 다음 해당 데이터를 사용하여 적절한 문자열 값을 반환할 수 있습니다. 제공된 데이터에는 리터럴, raw 값 및 치환 값이 포함됩니다. 그런 다음 이러한 정보를 사용하여 태그의 정확한 리턴을 결정할 수 있습니다.</p>
<hr>
<blockquote>
<p>이 내용은 나중에 참고하기 위해 제가 공부하며 정리한 내용입니다.<br>의역, 오역, 직역이 있을 수 있음을 알려드립니다.<br>This post is a translation of this original article [<a href="https://leanpub.com/understandinges6/read#leanpub-auto-strings-and-regular-expressions" target="_blank" rel="external">https://leanpub.com/understandinges6/read#leanpub-auto-strings-and-regular-expressions</a>]</p>
</blockquote>
<h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul>
<li><a href="https://infoscis.github.io/2018/01/24/ecmascript-6-block-binding/">ECMAScript 6 Block Binding</a></li>
<li><a href="https://infoscis.github.io/2018/01/24/ecmascript-6-strings-and-regular-expressions/">ECMAScript 6 문자열과 정규 표현식</a></li>
<li><a href="https://infoscis.github.io/2018/01/24/ecmascript-6-functions/">ECMAScript 6 함수</a></li>
<li><a href="https://infoscis.github.io/2018/01/25/ecmascript-6-expanded-object-functionality/">ECMAScript 6 객체의 확장된 기능</a></li>
<li><a href="https://infoscis.github.io/2018/01/26/ecmascript-6-destructuring-for-easier-data-access/">ECMAScript 6 쉬운 데이터 액세스를 위한 Destructuring</a></li>
<li><a href="https://infoscis.github.io/2018/01/27/ecmascript-6-symbols-and-symbol-properties/">ECMAScript 6 Symbol과 Symbol 프로퍼티</a></li>
<li><a href="https://infoscis.github.io/2018/01/27/ecmascript-6-sets-and-maps/">ECMAScript 6 Set과 Map</a></li>
<li><a href="https://infoscis.github.io/2018/01/31/ecmascript-6-iterators-and-generators/">ECMAScript 6 Iterator와 Generator</a></li>
<li><a href="https://infoscis.github.io/2018/02/13/ecmascript-6-introducing-javascript-classes/">ECMAScript 6 JavaScript 클래스 소개</a></li>
<li><a href="https://infoscis.github.io/2018/02/13/ecmascript-6-improved-array-capabilities/">ECMAScript 6 Array 기능 향상</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-promises-and-asynchronous-programming/">ECMAScript 6 Promise와 비동기 프로그램밍</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-proxies-and-the-reflection-api/">ECMAScript 6 프록시와 리플렉션 API</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-encapsulating-code-with-modules/">ECMAScript 6 Module로 코드 캡슐화하기</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-appendix-a-smaller-changes/">ECMAScript 6 부록 A. 작은 변경 사항</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-appendix-b-understanding-ecmascript-7/">ECMAScript 6 부록 B. ECMAScript 7(2016) 이해하기</a></li>
</ul>

        </div>
        <footer class="article-footer">
            



    <a data-url="http://infoscis.github.io/2018/01/24/ecmascript-6-strings-and-regular-expressions/" data-id="cjkl9102k002ojguzq28dcd6f" class="article-share-link"><i class="fa fa-share"></i>공유하기</a>
<script>
    (function ($) {
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

        </footer>
    </div>
</article>

    <section id="comments">
    
        
    <div id="disqus_thread">
        <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>

    
    </section>


                        </div>
                    </section>
                    <aside id="sidebar">
    <a class="sidebar-toggle" title="Expand Sidebar"><i class="toggle icon"></i></a>
    <div class="sidebar-top">
        <p>팔로우:</p>
        <ul class="social-links">
            
                
                <li>
                    <a class="social-tooltip" title="github" href="https://github.com/infoscis" target="_blank">
                        <i class="icon fa fa-github"></i>
                    </a>
                </li>
                
            
        </ul>
    </div>
    
        
<nav id="article-nav">
    
        <a href="/2018/01/24/ecmascript-6-functions/" id="article-nav-newer" class="article-nav-link-wrap">
        <strong class="article-nav-caption">새로운</strong>
        <p class="article-nav-title">
        
            ECMAScript 6 함수
        
        </p>
        <i class="icon fa fa-chevron-right" id="icon-chevron-right"></i>
    </a>
    
    
        <a href="/2018/01/24/ecmascript-6-block-binding/" id="article-nav-older" class="article-nav-link-wrap">
        <strong class="article-nav-caption">오래된</strong>
        <p class="article-nav-title">ECMAScript 6 Block binding</p>
        <i class="icon fa fa-chevron-left" id="icon-chevron-left"></i>
        </a>
    
</nav>

    
    <div class="widgets-container">
        
            
                
    <div class="widget-wrap">
        <h3 class="widget-title">최근 글</h3>
        <div class="widget">
            <ul id="recent-post" class="no-thumbnail">
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Angular/">Angular</a></p>
                            <p class="item-title"><a href="/2018/08/08/angular-observables-and-rxjs/" class="title">Angular Observable &amp; RxJS</a></p>
                            <p class="item-date"><time datetime="2018-08-08T14:38:02.000Z" itemprop="datePublished">2018-08-08</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/JavaScript/">JavaScript</a><i class="icon fa fa-angle-right"></i><a class="article-category-link" href="/categories/JavaScript/ECMAScript-2015/">ECMAScript 2015</a></p>
                            <p class="item-title"><a href="/2018/02/27/ecmascript-6-appendix-b-understanding-ecmascript-7/" class="title">ECMAScript 6 부록 B. ECMAScript 7 (2016) 이해하기</a></p>
                            <p class="item-date"><time datetime="2018-02-27T13:32:48.000Z" itemprop="datePublished">2018-02-27</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/JavaScript/">JavaScript</a><i class="icon fa fa-angle-right"></i><a class="article-category-link" href="/categories/JavaScript/ECMAScript-2015/">ECMAScript 2015</a></p>
                            <p class="item-title"><a href="/2018/02/27/ecmascript-6-appendix-a-smaller-changes/" class="title">ECMAScript 6 부록 A. 작은 변경 사항</a></p>
                            <p class="item-date"><time datetime="2018-02-27T13:32:12.000Z" itemprop="datePublished">2018-02-27</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/JavaScript/">JavaScript</a><i class="icon fa fa-angle-right"></i><a class="article-category-link" href="/categories/JavaScript/ECMAScript-2015/">ECMAScript 2015</a></p>
                            <p class="item-title"><a href="/2018/02/27/ecmascript-6-encapsulating-code-with-modules/" class="title">ECMAScript 6 Module로 코드 캡슐화하기</a></p>
                            <p class="item-date"><time datetime="2018-02-27T13:31:45.000Z" itemprop="datePublished">2018-02-27</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/JavaScript/">JavaScript</a><i class="icon fa fa-angle-right"></i><a class="article-category-link" href="/categories/JavaScript/ECMAScript-2015/">ECMAScript 2015</a></p>
                            <p class="item-title"><a href="/2018/02/27/ecmascript-6-proxies-and-the-reflection-api/" class="title">ECMAScript 6 프록시와 리플렉션 API</a></p>
                            <p class="item-date"><time datetime="2018-02-27T13:31:03.000Z" itemprop="datePublished">2018-02-27</time></p>
                        </div>
                    </li>
                
            </ul>
        </div>
    </div>

            
                
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">카테고리</h3>
        <div class="widget">
            <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Angular/">Angular</a><span class="category-list-count">15</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hadoop/">Hadoop</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">5</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/Java9/">Java9</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/Spring/">Spring</a><span class="category-list-count">2</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/">JavaScript</a><span class="category-list-count">16</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/ECMAScript-2015/">ECMAScript 2015</a><span class="category-list-count">15</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/TypeScript/">TypeScript</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Webpack/">Webpack</a><span class="category-list-count">1</span></li></ul>
        </div>
    </div>


            
                
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">아카이브</h3>
        <div class="widget">
            <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">8월 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">2월 2018</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">1월 2018</a><span class="archive-list-count">11</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">7월 2017</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">6월 2017</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">5월 2017</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">3월 2017</a><span class="archive-list-count">5</span></li></ul>
        </div>
    </div>


            
                
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">태그</h3>
        <div class="widget">
            <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Angular/">Angular</a><span class="tag-list-count">15</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ECMAScript-2015/">ECMAScript 2015</a><span class="tag-list-count">15</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Event/">Event</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hadoop/">Hadoop</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JDK9/">JDK9</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java9/">Java9</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript</a><span class="tag-list-count">29</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Jigsaw/">Jigsaw</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nashorn/">Nashorn</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/">Spring</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringBoot/">SpringBoot</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TypeScript/">TypeScript</a><span class="tag-list-count">12</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Webpack/">Webpack</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/YARN/">YARN</a><span class="tag-list-count">1</span></li></ul>
        </div>
    </div>


            
                
    <div class="widget-wrap widget-float">
        <h3 class="widget-title">태그 클라우드</h3>
        <div class="widget tagcloud">
            <a href="/tags/Angular/" style="font-size: 18px;">Angular</a> <a href="/tags/ECMAScript-2015/" style="font-size: 18px;">ECMAScript 2015</a> <a href="/tags/Event/" style="font-size: 10px;">Event</a> <a href="/tags/Hadoop/" style="font-size: 10px;">Hadoop</a> <a href="/tags/JDK9/" style="font-size: 12px;">JDK9</a> <a href="/tags/Java/" style="font-size: 14px;">Java</a> <a href="/tags/Java9/" style="font-size: 12px;">Java9</a> <a href="/tags/JavaScript/" style="font-size: 20px;">JavaScript</a> <a href="/tags/Jigsaw/" style="font-size: 12px;">Jigsaw</a> <a href="/tags/Nashorn/" style="font-size: 10px;">Nashorn</a> <a href="/tags/Spring/" style="font-size: 12px;">Spring</a> <a href="/tags/SpringBoot/" style="font-size: 10px;">SpringBoot</a> <a href="/tags/TypeScript/" style="font-size: 16px;">TypeScript</a> <a href="/tags/Webpack/" style="font-size: 10px;">Webpack</a> <a href="/tags/YARN/" style="font-size: 10px;">YARN</a>
        </div>
    </div>


            
        
    </div>
</aside>
                </div>
            </div>
        </div>
        <footer id="footer">
    <div class="container">
        <div class="container-inner">
            <a id="back-to-top" href="javascript:;"><i class="icon fa fa-angle-up"></i></a>
            <div class="credit">
                <h1 class="logo-wrap">
                    <a href="/" class="logo"></a>
                </h1>
                <p>&copy; 2018 Jongcheol-Kim</p>
                <p>Powered by <a href="//hexo.io/" target="_blank">Hexo</a>. Theme by <a href="//github.com/ppoffice" target="_blank">PPOffice</a></p>
            </div>
        </div>
    </div>
</footer>
        
    
    <script>
    var disqus_shortname = 'infoscis';
    
    
    var disqus_url = 'http://infoscis.github.io/2018/01/24/ecmascript-6-strings-and-regular-expressions/';
    
    (function() {
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    </script>




    
        <script src="/libs/lightgallery/js/lightgallery.min.js"></script>
        <script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>
        <script src="/libs/lightgallery/js/lg-pager.min.js"></script>
        <script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>
        <script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>
        <script src="/libs/lightgallery/js/lg-zoom.min.js"></script>
        <script src="/libs/lightgallery/js/lg-hash.min.js"></script>
        <script src="/libs/lightgallery/js/lg-share.min.js"></script>
        <script src="/libs/lightgallery/js/lg-video.min.js"></script>
    
    
        <script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script>
    
    


<!-- Custom Scripts -->
<script src="/js/main.js"></script>

    </div>
</body>
</html>
