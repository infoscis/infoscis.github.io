<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    
    <title>ECMAScript 6 Iterator와 Generator | Developer&#39;s Record</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
        <meta name="keywords" content="JavaScript,ECMAScript 2015" />
    
    <meta name="description" content="Iterator와 Generator많은 프로그래밍 언어는 컬렉션에서 위치를 추적하기 위해 변수가 필요한 for 루프를 사용하여 데이터를 반복하는 것에서 컬렉션의 다음 항목을 반환하는 Interator 객체를 사용하는 방식으로 전환했습니다. Iterator를 사용하면 데이터 컬렉션을 쉽게 처리할 수 있어 ECMAScript 6에서는 Iterator를 Java">
<meta property="og:type" content="article">
<meta property="og:title" content="ECMAScript 6 Iterator와 Generator">
<meta property="og:url" content="http://infoscis.github.io/2018/01/31/ecmascript-6-iterators-and-generators/index.html">
<meta property="og:site_name" content="Developer's Record">
<meta property="og:description" content="Iterator와 Generator많은 프로그래밍 언어는 컬렉션에서 위치를 추적하기 위해 변수가 필요한 for 루프를 사용하여 데이터를 반복하는 것에서 컬렉션의 다음 항목을 반환하는 Interator 객체를 사용하는 방식으로 전환했습니다. Iterator를 사용하면 데이터 컬렉션을 쉽게 처리할 수 있어 ECMAScript 6에서는 Iterator를 Java">
<meta property="og:image" content="https://leanpub.com/site_images/understandinges6/fg0601.png">
<meta property="og:updated_time" content="2018-02-27T14:12:31.782Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ECMAScript 6 Iterator와 Generator">
<meta name="twitter:description" content="Iterator와 Generator많은 프로그래밍 언어는 컬렉션에서 위치를 추적하기 위해 변수가 필요한 for 루프를 사용하여 데이터를 반복하는 것에서 컬렉션의 다음 항목을 반환하는 Interator 객체를 사용하는 방식으로 전환했습니다. Iterator를 사용하면 데이터 컬렉션을 쉽게 처리할 수 있어 ECMAScript 6에서는 Iterator를 Java">
<meta name="twitter:image" content="https://leanpub.com/site_images/understandinges6/fg0601.png">
    
    <link rel="canonical" href="http://infoscis.github.io/2018/01/31/ecmascript-6-iterators-and-generators/"/>

    

    
        <link rel="icon" href="/favicon.png" />
    

    <link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="/libs/titillium-web/styles.css">
    <link rel="stylesheet" href="/libs/source-code-pro/styles.css">

    <link rel="stylesheet" href="/css/style.css">

    <script src="/libs/jquery/2.0.3/jquery.min.js"></script>
    
    
        <link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">
    
    
        <link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css">
    
    
        <script type="text/javascript">
(function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-100332906-1', 'auto');
ga('send', 'pageview');

</script>
    
    

</head>

<body>
    <div id="wrap">
        <header id="header">
    <div id="header-outer" class="outer">
        <div class="container">
            <div class="container-inner">
                <div id="header-title">
                    <h1 class="logo-wrap">
                        <a href="/" class="logo"></a>
                    </h1>
                    
                        <h2 class="subtitle-wrap">
                            <p class="subtitle">개발자의 기록 보관소</p>
                        </h2>
                    
                </div>
                <div id="header-inner" class="nav-container">
                    <a id="main-nav-toggle" class="nav-icon fa fa-bars"></a>
                    <div class="nav-container-inner">
                        <ul id="main-nav">
                            
                                <li class="main-nav-list-item" >
                                    <a class="main-nav-list-link" href="/">홈</a>
                                </li>
                            
                                        <ul class="main-nav-list"><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Angular/">Angular</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Hadoop/">Hadoop</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Java/">Java</a><ul class="main-nav-list-child"><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Java/Java9/">Java9</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Java/Spring/">Spring</a></li></ul></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/JavaScript/">JavaScript</a><ul class="main-nav-list-child"><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/JavaScript/ECMAScript-2015/">ECMAScript 2015</a></li></ul></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/TypeScript/">TypeScript</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Webpack/">Webpack</a></li></ul>
                                    
                                <li class="main-nav-list-item" >
                                    <a class="main-nav-list-link" href="https://about.me/jongcheol.kim">About</a>
                                </li>
                            
                        </ul>
                        <nav id="sub-nav">
                            <div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="검색" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="Type something..." />
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '포스트',
            PAGES: 'Pages',
            CATEGORIES: '카테고리',
            TAGS: '태그',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div>
                        </nav>
                    </div>
                </div>
            </div>
        </div>
    </div>
</header>
        <div class="container">
            <div class="main-body container-inner">
                <div class="main-body-inner">
                    <section id="main">
                        <div class="main-body-header">
    <h1 class="header">
    
    <a class="page-title-link" href="/categories/JavaScript/">JavaScript</a><i class="icon fa fa-angle-right"></i><a class="page-title-link" href="/categories/JavaScript/ECMAScript-2015/">ECMAScript 2015</a>
    </h1>
</div>
                        <div class="main-body-content">
                            <article id="post-ecmascript-6-iterators-and-generators" class="article article-single article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
            <header class="article-header">
                
    
        <h1 class="article-title" itemprop="name">
        ECMAScript 6 Iterator와 Generator
        </h1>
    

            </header>
        
        
            <div class="article-meta">
                
    <div class="article-date">
        <a href="/2018/01/31/ecmascript-6-iterators-and-generators/" class="article-date">
            <time datetime="2018-01-31T14:24:43.000Z" itemprop="datePublished">2018-01-31</time>
        </a>
    </div>

                
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/ECMAScript-2015/">ECMAScript 2015</a>, <a class="tag-link" href="/tags/JavaScript/">JavaScript</a>
    </div>

            </div>
        
        
        <div class="article-entry" itemprop="articleBody">
            <h1 id="Iterator와-Generator"><a href="#Iterator와-Generator" class="headerlink" title="Iterator와 Generator"></a>Iterator와 Generator</h1><p>많은 프로그래밍 언어는 컬렉션에서 위치를 추적하기 위해 변수가 필요한 <code>for</code> 루프를 사용하여 데이터를 반복하는 것에서 컬렉션의 다음 항목을 반환하는 <em>Interator</em> 객체를 사용하는 방식으로 전환했습니다. <em>Iterator</em>를 사용하면 데이터 컬렉션을 쉽게 처리할 수 있어 ECMAScript 6에서는 <em>Iterator</em>를 JavaScript에 추가했습니다. <em>Iterator</em>는 새로운 <em>Array</em> 메서드 및 새로운 타입의 컬렉션 (<em>Set</em> 및 <em>Map</em>)과 결합하여 데이터를 효율적으로 처리할수 있는 핵심 요소이며, 이러한 부분은 JavaScript의 여러곳에서 찾아볼 수 있습니다. 또한 <em>Iterator</em>와 함께 작동하는 새로운 <code>for-of</code> 루프가 있으며, <em>Spread</em> (<code>...</code>) 연산자에서도 <em>Iterator</em>를 사용할 수 있습니다. 그리고<br> <em>Iterator</em>는 비동기 프로그래밍을 더 쉽게 만들수 있게 합니다.</p>
<p>이 장에서는 <em>Iterator</em>의 많은 용도에 대해 다루지만, 먼저 <em>Iterator</em>가 JavaScript에 추가된 이유에 대한 역사를 이해하는 것이 중요합니다.</p>
<h2 id="루프-Loop-문제점"><a href="#루프-Loop-문제점" class="headerlink" title="루프(Loop) 문제점"></a>루프(Loop) 문제점</h2><p>JavaScript로 프로그래밍한 적이 있다면 아마도 다음 코드가 익숙할 것입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>];</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = colors.length; i &lt; len; i++) &#123;</div><div class="line">    <span class="built_in">console</span>.log(colors[i]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>이 표준 <code>for</code> 루프는 인덱스를 <code>colors</code> <em>Array</em>에 대해 <code>i</code> 변수로 추적합니다. <code>i</code>의 값은 <code>i</code>가 (<code>len</code>에 저장된) <em>Array</em>의 길이보다 크지 않다면 루프가 실행될 때마다 증가합니다.</p>
<p>이 예제의 루프는 매우 간단하지만 루프를 중첩하여 여러 변수를 추적해야 할 때 매우 복잡해집니다. 추가적인 복잡성으로 인해 오류가 발생할 수 있으며, <code>for</code> 루프의 상용구는 유사한 코드가 여러 위치에 작성되어 더 많은 오류를 발생시킬 수 있습니다. <em>Iterator</em>는 이 문제를 해결하기 위한 것입니다.</p>
<h2 id="Iterator는-무엇일까요"><a href="#Iterator는-무엇일까요" class="headerlink" title="Iterator는 무엇일까요?"></a><em>Iterator</em>는 무엇일까요?</h2><p><em>Iterator</em>는 반복을 위해 설계된 특정 인터페이스가 있는 객체입니다. 모든 <em>Iterator</em> 객체는 결과 객체를 반환하는 <code>next()</code> 메서드를 가지고 있습니다. 결과 객체에는 두 가지 프로퍼티, 즉 다음 값인 <code>value</code>와 반환할 값이 더 이상 없을 때 <code>true</code> 인 부울 값인 <code>done</code> 프로퍼티입니다. <em>Iterator</em>는 값 컬렉션 내의 위치에 대한 내부 포인터를 유지하고 <code>next()</code> 메서드를 호출할 때마다 다음 적절한 값을 반환합니다.</p>
<p>마지막 값이 반환된 후에 <code>next()</code>를 호출하면 메서드는 <code>done</code>을 <code>true</code>로 리턴하고 <code>value</code>는 <em>Iterator</em>의 <em>리턴 값</em>을 포함합니다. 이 리턴 값은 데이터의 일부가 아니며 관련 데이터의 마지막 부분이거나 그러한 데이터가 없으면 <code>undefined</code>입니다. <em>Iterator</em>의 리턴 값은 정보를 호출자에게 전달하는 마지막 방법이라는 점에서 함수의 리턴 값과 유사합니다.</p>
<p>이를 염두에 두고 ECMAScript 5에서 <em>Iterator</em>를 만드는 것은 아래와 같이 간단합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createIterator</span>(<span class="params">items</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> i = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">next</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">            <span class="keyword">var</span> done = (i &gt;= items.length);</div><div class="line">            <span class="keyword">var</span> value = !done ? items[i++] : <span class="literal">undefined</span>;</div><div class="line"></div><div class="line">            <span class="keyword">return</span> &#123;</div><div class="line">                <span class="attr">done</span>: done,</div><div class="line">                <span class="attr">value</span>: value</div><div class="line">            &#125;;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> iterator = createIterator([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(iterator.next());         <span class="comment">// "&#123; value: 1, done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());         <span class="comment">// "&#123; value: 2, done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());         <span class="comment">// "&#123; value: 3, done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());         <span class="comment">// "&#123; value: undefined, done: true &#125;"</span></div><div class="line"></div><div class="line"><span class="comment">// for all further calls</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());         <span class="comment">// "&#123; value: undefined, done: true &#125;"</span></div></pre></td></tr></table></figure>
<p><code>createIterator()</code> 함수는 <code>next()</code> 메서드를 가진 객체를 반환합니다. 메서드가 호출될 때마다 <code>items</code> <em>Array</em>의 다음 값은 <code>value</code>로 리턴됩니다. <code>i</code>가 3 일 때 <code>done</code>은 <code>true</code>가 되고 <code>value</code>를 설정하는 삼항 조건 연산자는 <code>undefined</code>로 평가됩니다. 이 결과는  ECMAScript 6에서는 마지막 데이터가 사용된 후 <code>next()</code>가 호출될 때와 같은 특수한 역할을 합니다.</p>
<p>이 예제에서 보듯이, ECMAScript 6에 규정된 규칙에 따라 동작하는 <em>Iterator</em> 작성은 약간 복잡합니다.</p>
<p>다행히도 ECMAScript 6은 <em>Iterator</em> 생성자를 제공하여 <em>Iterator</em> 객체를 훨씬 쉽게 만들 수 있습니다.</p>
<h2 id="Generator는-무엇일까요"><a href="#Generator는-무엇일까요" class="headerlink" title="Generator는 무엇일까요?"></a><em>Generator</em>는 무엇일까요?</h2><p><em>Generator</em>는 <em>Iterator</em>를 반환하는 함수입니다. <em>Generator</em> 함수는 <code>function</code> 키워드 다음에 별표 (<code>*</code>)가 추가되고 새로운 <code>yield</code> 키워드를 사용합니다. 별표가 <code>function</code> 바로 앞에 있는지 또는 <code>*</code>와 <code>function</code> 사이에 공백이 있는지는 중요하지 않습니다. 아래 예제를 보겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// generator</span></div><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createIterator</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</div><div class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// generator는 일반 함수처럼 호출되지만 iterator를 반환합니다.</span></div><div class="line"><span class="keyword">let</span> iterator = createIterator();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(iterator.next().value);     <span class="comment">// 1</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next().value);     <span class="comment">// 2</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next().value);     <span class="comment">// 3</span></div></pre></td></tr></table></figure>
<p><code>createIterator()</code> 이전의 <code>*</code>는 함수를 <em>Generator</em>로 만듭니다. ECMAScript 6에 새로 도입된 <code>yield</code> 키워드는 <code>next()</code>가 호출될 때 결과 <em>Iterator</em>가 리턴 해야하는 값을 리턴될 순서대로 지정합니다. 이 예제에서 생성된 <em>Iterator</em>는 <code>next()</code> 메서드를 연속적으로 호출할 때 세가지 다른 값을 리턴합니다. : <code>1</code>, <code>2</code> 그리고 마지막으로 <code>3</code>. <em>Generator</em>는 <code>iterator</code>를 생성할 때 본 것처럼 다른 함수와 똑같이 호출할 수 있습니다.</p>
<p>아마도 <em>Generator</em> 함수 중 가장 흥미로운 부분은 각 <code>yield</code> 문 다음에 실행을 멈추는 것입니다. 예를 들어, 이 코드에서 <code>yield 1</code>을 실행 한 후에, 함수는 <em>Iterator</em>의 <code>next()</code> 메서드가 호출될 때까지 다른 것을 실행하지 않고, <code>next()</code>가 호출 되는 시점에 <code>yield 2</code>가 실행됩니다. 함수 중간에 실행을 중지하는 이 기능은 매우 강력하며 <em>Generator</em> 함수의 사용을 흥미롭게 합니다. (“Iterator의 고급기능”섹션에서 논의 함).</p>
<p><code>yield</code> 키워드는 모든 값이나 표현식과 함께 사용할 수 있으므로 항목을 하나씩 나열하지 않고 <em>Iterator</em>에 항목을 추가하는 <em>Generator</em> 함수를 작성할 수 있습니다. 예를 들어, <code>for</code> 루프에서 <code>yield</code>를 사용할 수있는 방법은 다음과 같습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createIterator</span>(<span class="params">items</span>) </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; items.length; i++) &#123;</div><div class="line">        <span class="keyword">yield</span> items[i];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> iterator = createIterator([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: 1, done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: 2, done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: 3, done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: undefined, done: true &#125;"</span></div><div class="line"></div><div class="line"><span class="comment">// for all further calls</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: undefined, done: true &#125;"</span></div></pre></td></tr></table></figure>
<p>이 예제는 <code>items</code>라는 <em>Array</em>를 <code>createIterator()</code> <em>Generator</em> 함수에 전달합니다. 함수 내에서 <code>for</code> 루프가 진행됨에 따라 <em>Array</em>에서 <em>Iterator</em> 요소를 생성합니다. <code>yield</code>가 발생할 때마다 루프가 멈추고 <code>iterator</code>의 <code>next()</code>가 호출될 때마다 루프의 다음 <code>yield</code> 문이 실행 됩니다.</p>
<p><em>Generator</em>는 ECMAScript 6의 중요한 기능이며, 함수이기 때문에 모든 곳에서 사용할 수 있습니다. 이 섹션의 나머지 부분에서는 <em>Generator</em>를 작성하는 다른 유용한 방법에 중점을 둡니다.</p>
<blockquote>
<p><code>yield</code> 키워드는 <em>Generator</em> 내부에서만 사용할 수 있습니다. 예를 들면 다음과 같이 <em>Generator</em> 내부 함수에서 사용하는 것을 포함하여 다른 곳에서 <code>yield</code>를 사용하는 것은 구문 오류입니다.</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createIterator</span>(<span class="params">items</span>) </span>&#123;</div><div class="line"></div><div class="line">    items.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">// syntax error</span></div><div class="line">        <span class="keyword">yield</span> item + <span class="number">1</span>;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><code>yield</code>는 기술적으로 <code>createIterator()</code> 내부에 있지만, <code>yield</code>는 함수의 경계를 넘을 수 없으므로 이 코드는 구문 오류입니다. <code>yield</code>가 <code>return</code>과 비슷한 방식으로 사용되었지만 중첩된 함수는 그 함수를 포함하는 값을 리턴할 수 없습니다.</p>
</blockquote>
<h3 id="Generator-함수-표현식"><a href="#Generator-함수-표현식" class="headerlink" title="Generator 함수 표현식"></a><em>Generator</em> 함수 표현식</h3><p>함수 표현식을 사용하여 <code>function</code> 키워드와 여는 괄호 사이에 별표 (<code>*</code>) 문자를 포함시킴으로써 <em>Generator</em>를 생성할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> createIterator = <span class="function"><span class="keyword">function</span> *(<span class="params">items</span>) </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; items.length; i++) &#123;</div><div class="line">        <span class="keyword">yield</span> items[i];</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> iterator = createIterator([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(iterator.next());         <span class="comment">// "&#123; value: 1, done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());         <span class="comment">// "&#123; value: 2, done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());         <span class="comment">// "&#123; value: 3, done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());         <span class="comment">// "&#123; value: undefined, done: true &#125;"</span></div><div class="line"></div><div class="line"><span class="comment">// for all further calls</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());         <span class="comment">// "&#123; value: undefined, done: true &#125;"</span></div></pre></td></tr></table></figure>
<p>이 코드에서, <code>createIterator()</code>는 함수 선언 대신에 <em>Generator</em> 함수 표현식입니다. 함수 표현식이 익명이므로 별표는 <code>function</code> 키워드와 여는 괄호 사이에 옵니다. 그 외에 이 예제는 <code>for</code> 루프를 사용했던 <code>createIterator()</code> 함수의 이전 버전과 동일합니다.</p>
<blockquote>
<p><em>Arrow</em> 함수를 이용해 <em>Generator</em>를 만들수 없습니다.</p>
</blockquote>
<h3 id="Generator-객체-메서드"><a href="#Generator-객체-메서드" class="headerlink" title="Generator 객체 메서드"></a><em>Generator</em> 객체 메서드</h3><p><em>Generator</em>는 함수이기 때문에 객체에도 추가할 수 있습니다. 예를 들어, 함수 표현식을 사용하여 ECMAScript 5 스타일 객체 리터럴에서 <em>Generator</em>를 만들 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = &#123;</div><div class="line"></div><div class="line">    <span class="attr">createIterator</span>: <span class="function"><span class="keyword">function</span> *(<span class="params">items</span>) </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; items.length; i++) &#123;</div><div class="line">            <span class="keyword">yield</span> items[i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> iterator = o.createIterator([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</div></pre></td></tr></table></figure>
<p>메서드 이름 앞에 별표(<code>*</code>)를 붙임으로써 ECMAScript 6 단축 메서드를 바로 사용할 수도 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = &#123;</div><div class="line"></div><div class="line">    *createIterator(items) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; items.length; i++) &#123;</div><div class="line">            <span class="keyword">yield</span> items[i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> iterator = o.createIterator([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</div></pre></td></tr></table></figure>
<p>이 예제는 “<em>Generator</em> 함수 표현식” 섹션의 예제와 기능적으로 동일합니다. 단지 다른 구문을 사용했을 뿐입니다. 단축 버전에서는<br> <code>createIterator()</code> 메서드가 <code>function</code> 키워드 없이 정의되었고 별표와 메서드 이름 사이에 공백을 둘 수 있지만 별표는 메서드 이름 바로 앞에 위치해야 합니다.</p>
<h2 id="Iterables-과-for-of"><a href="#Iterables-과-for-of" class="headerlink" title="Iterables 과 for-of"></a>Iterables 과 for-of</h2><p><em>Iterator</em>와 밀접하게 관련된 <em>Iterable</em> 은 <code>Symbol.iterator</code> 프로퍼티를 가진 객체입니다. 잘 알려진 <code>Symbol.iterator</code> <em>Symbol</em>은 주어진 객체에 대한 <em>Iterator</em>를 반환하는 함수를 지정합니다. ECMAScript 6에서는 모든 컬렉션 객체 (<em>Array</em>, <em>Set</em> 및 <em>Map</em>) 및 문자열이 <em>Iterable</em>이므로 기본 <em>Iterator</em>가 지정되어 있습니다. <em>Iterable</em>은 ECMAScript에 새로 추가된 <code>for-of</code> 루프와 함께 사용하도록 설계되었습니다.</p>
<blockquote>
<p><em>Generator</em>가 기본적으로 <code>Symbol.iterator</code> 프로퍼티를 할당하므로 <em>Generator</em>가 만든 모든 <em>Iterator</em>도 <em>Iterable</em>입니다.</p>
</blockquote>
<p>이 장의 시작 부분에서, <code>for</code> 루프 내에서 인덱스를 추적하는 문제에 대해 언급했습니다. 이 문제를 해결하는 첫 번째는 <em>Iterator</em>입니다. 그리고 두 번째는 <code>for-of</code> 루프입니다. 컬렉션에 대한 인덱스를 추적할 필요가 없기 때문에 컬렉션의 내용에 대한 작업에 집중할 수 있습니다.</p>
<p><code>for-of</code> 루프는 루프가 실행될 때마다 <em>Iterable</em>에서 <code>next()</code>를 호출하고 결과 객체의 <code>value</code>를 변수에 저장합니다. 루프는 반환된 객체의 <code>done</code> 프로퍼티 값이 <code>true</code>가 될 때까지 이 과정을 계속합니다. 다음은 그 예제를 살펴 보겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> values) &#123;</div><div class="line">    <span class="built_in">console</span>.log(num);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>이 코드는 다음을 출력합니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td></tr></table></figure>
<p>이 <code>for-of</code> 루프는 <code>values</code> <em>Array</em>에 <code>Symbol.iterator</code> 메서드를 먼저 호출하여 <em>Iterator</em>를 검색합니다. (<code>Symbol.iterator</code>에 대한 호출은 JavaScript 엔진 자체에서 발생합니다.) 그러면 <code>iterator.next()</code>가 호출되고 <em>Iterator</em>의 결과 객체에있는 <code>value</code> 프로퍼티가<br> <code>num</code>으로 읽혀집니다. <code>num</code> 변수는 <code>1</code>, <code>2</code>, 그리고 마지막으로 <code>3</code>입니다. 결과 객체에서 <code>done</code>이 <code>true</code> 일 때, 루프는 끝나기 때문에 <code>num</code>은 결코 <code>undefined</code>의 값으로 지정되지 않습니다.</p>
<p>단순히 <em>Array</em>이나 컬렉션의 값을 반복한다면 <code>for</code> 루프 대신에 <code>for-of</code> 루프를 사용하는 것이 좋습니다. <code>for-of</code> 루프는 일반적으로 추적하기 위한 조건이 적기 때문에 에러 발생이 전통적인 <code>for</code> 루프보다 적습니다. 보다 복잡한 제어 조건이 필요한 경우 전통적인<code>for</code> 루프를 사용 하십시오.</p>
<blockquote>
<p><code>for-of</code> 문은 <em>Non-iterable</em> 객체, <code>null</code> 또는 <code>undefined</code>에서 사용될 때 에러를 던집니다.</p>
</blockquote>
<h3 id="Default-Iterator-액세스-하기"><a href="#Default-Iterator-액세스-하기" class="headerlink" title="Default Iterator 액세스 하기"></a>Default Iterator 액세스 하기</h3><p>Symbol.iterator를 사용하여 다음과 같이 객체의 <em>Default Iterator</em>를 액세스할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line"><span class="keyword">let</span> iterator = values[<span class="built_in">Symbol</span>.iterator]();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(iterator.next());         <span class="comment">// "&#123; value: 1, done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());         <span class="comment">// "&#123; value: 2, done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());         <span class="comment">// "&#123; value: 3, done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());         <span class="comment">// "&#123; value: undefined, done: true &#125;"</span></div></pre></td></tr></table></figure>
<p>이 코드는 <code>values</code>에 대한 <em>Default Iterator</em>를 가져오고 이를 사용하여 <em>Array</em>의 각항목을 반복합니다. 이것은 <code>for-of</code> 루프를 사용할 때 배후에서 일어나는 것과 같은 방식입니다.</p>
<p>Symbol.iterator는 <em>Default Iterator</em>를 지정하므로 이를 사용하여 객체가 다음과 같이 반복 가능한지 여부를 확인할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isIterable</span>(<span class="params">object</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> object[<span class="built_in">Symbol</span>.iterator] === <span class="string">"function"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(isIterable([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]));     <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(isIterable(<span class="string">"Hello"</span>));       <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(isIterable(<span class="keyword">new</span> <span class="built_in">Map</span>()));     <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(isIterable(<span class="keyword">new</span> <span class="built_in">Set</span>()));     <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(isIterable(<span class="keyword">new</span> <span class="built_in">WeakMap</span>())); <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log(isIterable(<span class="keyword">new</span> <span class="built_in">WeakSet</span>())); <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p><code>isIterable()</code> 함수는 객체에 <em>Default Iterator</em>가 존재 하는지를 확인하는 함수입니다. <code>for-of</code> 루프는 실행 전에 비슷한 검사를 수행합니다.</p>
<p>지금까지 이 섹션의 예제에서는 내장 <em>Iterable</em>이 있는 <code>Symbol.iterator</code>를 사용하는 방법을 알아 봤지만 <code>Symbol.iterator</code> 프로퍼티를 사용하여 고유한 <em>Iterable</em>을 만들수도 있습니다.</p>
<h3 id="Iterable-만들기"><a href="#Iterable-만들기" class="headerlink" title="Iterable 만들기"></a><em>Iterable</em> 만들기</h3><p>개발자가 정의한 객체는 기본적으로 반복 가능하지 않지만 <em>Generator</em>가 포함된 <code>Symbol.iterator</code> 프로퍼티를 만들어 반복 가능하게 만들 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> collection = &#123;</div><div class="line">    <span class="attr">items</span>: [],</div><div class="line">    *[<span class="built_in">Symbol</span>.iterator]() &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> <span class="keyword">this</span>.items) &#123;</div><div class="line">            <span class="keyword">yield</span> item;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div><div class="line">collection.items.push(<span class="number">1</span>);</div><div class="line">collection.items.push(<span class="number">2</span>);</div><div class="line">collection.items.push(<span class="number">3</span>);</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> collection) &#123;</div><div class="line">    <span class="built_in">console</span>.log(x);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>위 코드는 다음을 출력합니다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td></tr></table></figure></p>
<p>먼저, 이 예제는 <code>collection</code>이라는 객체의 <em>Default Iterator</em>를 정의합니다. <em>Default Iterator</em>는 <em>Generator</em>인 <code>Symbol.iterator</code> 메서드에 의해 생성됩니다 (별표시는 여전히 이름 앞에 옵니다). <em>Generator</em>는 <code>for-of</code> 루프를 사용하여 <code>this.items</code>의 값을 반복하고 <code>yield</code>를 사용하여 각각을 리턴합니다. <code>collection</code> 객체는 수동으로 반복하여 <code>collection</code>의 <em>Default Iterator</em>에 대한 값을 정의하는 대신, <code>this.items</code>의 <em>Default Iterator</em>를 사용하여 작업을 수행합니다.</p>
<blockquote>
<p>이 장의 뒷부분에 나오는 “Generator 위임”에서는 다른 객체의 <em>Iterator</em>를 사용하는 방법에 대해 설명합니다.</p>
</blockquote>
<p>이제까지  <em>Array</em>의 <em>Default Iterator</em>에 대한 사용법을 살펴 보았지만 ECMAScript 6에는 더 많은 <em>Iterator</em>가 내장되어 있어 데이터 수집 작업을 쉽게 수행할 수 있습니다.</p>
<h2 id="내장-Iterator들"><a href="#내장-Iterator들" class="headerlink" title="내장 Iterator들"></a>내장 <em>Iterator</em>들</h2><p><em>Iterator</em>는 ECMAScript 6의 중요한 부분이므로 많은 빌트인 타입에 대해 자체적으로 <em>Iterator</em>를 만들 필요가 없습니다. 언어 레벨에서 기본적으로 포함하고 있습니다. 기본 제공되는 <em>Iterator</em>가 목적에 부합하지 않을 때만 <em>Iterator</em>를 만들어야 하며, 이는 자신만의 객체 나 클래스를 정의할 때 자주 발생합니다. 그 외에는 내장된 <em>Iterator</em>를 사용하여 작업을 수행할 수 있습니다. 아마도 가장 일반적인 <em>Iterator</em>는 컬렉션에서 작동하는 <em>Iterator</em>일 것입니다.</p>
<h3 id="컬렉션-Iterator들"><a href="#컬렉션-Iterator들" class="headerlink" title="컬렉션 Iterator들"></a>컬렉션 <em>Iterator</em>들</h3><p>ECMAScript 6에는 <em>Array</em>, <em>Map</em> 및 <em>Set</em> 세가지 타입의 컬렉션 객체가 있습니다. 세가지 모두에는 내용을 탐색하는데 도움이되는 다음과 같은 기본 제공 <em>Iterator</em>가 있습니다.</p>
<ul>
<li>entries() - 값이 키 - 값 쌍인 <em>Iterator</em>를 반환합니다.</li>
<li>values() - 값이 컬렉션의 value인 <em>Iterator</em>를 반환합니다.</li>
<li>keys() - 값이 컬렉션에 포함된 key인 <em>Iterator</em>를 반환합니다.</li>
</ul>
<p>이 메서드 중 하나를 호출하여 컬렉션을 검색할 수 있습니다.</p>
<h4 id="entries-Iterator"><a href="#entries-Iterator" class="headerlink" title="entries() Iterator"></a>entries() <em>Iterator</em></h4><p><code>entries()</code> <em>Iterator</em>는 <code>next()</code>가 호출될 때마다 두개의 아이템 <em>Array</em>을 반환합니다. 두개의 아이템 <em>Array</em>는 컬렉션의 각 항목에 대한 키와 값을 나타냅니다. <em>Array</em>의 경우 첫 번째 항목은 숫자 인덱스입니다. <em>Set</em>의 경우 첫 번째 항목은 값이기도합니다 (값은 <em>Set</em>의 키와 동일하므로). <em>Map</em>의 경우 첫 번째 항목은 키입니다.</p>
<p>다음은이 <em>Iterator</em>를 사용하는 몇 가지 예제입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> colors = [ <span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span> ];</div><div class="line"><span class="keyword">let</span> tracking = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1234</span>, <span class="number">5678</span>, <span class="number">9012</span>]);</div><div class="line"><span class="keyword">let</span> data = <span class="keyword">new</span> <span class="built_in">Map</span>();</div><div class="line"></div><div class="line">data.set(<span class="string">"title"</span>, <span class="string">"Understanding ECMAScript 6"</span>);</div><div class="line">data.set(<span class="string">"format"</span>, <span class="string">"ebook"</span>);</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> entry <span class="keyword">of</span> colors.entries()) &#123;</div><div class="line">    <span class="built_in">console</span>.log(entry);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> entry <span class="keyword">of</span> tracking.entries()) &#123;</div><div class="line">    <span class="built_in">console</span>.log(entry);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> entry <span class="keyword">of</span> data.entries()) &#123;</div><div class="line">    <span class="built_in">console</span>.log(entry);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>console.log()</code> 호출은 다음과 같은 결과를냅니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[0, &quot;red&quot;]</div><div class="line">[1, &quot;green&quot;]</div><div class="line">[2, &quot;blue&quot;]</div><div class="line">[1234, 1234]</div><div class="line">[5678, 5678]</div><div class="line">[9012, 9012]</div><div class="line">[&quot;title&quot;, &quot;Understanding ECMAScript 6&quot;]</div><div class="line">[&quot;format&quot;, &quot;ebook&quot;]</div></pre></td></tr></table></figure>
<p>위 예제는 각 컬렉션 타입에 대해 <code>entries()</code> 메서드를 사용하여 <em>Iterator</em>를 검색하고 <code>for-of</code> 루프를 사용하여 반복합니다. console 출력은 각 객체에 대해 어떻게 키와 값이 쌍으로 리턴되는지 보여줍니다.</p>
<h4 id="values-Iterator"><a href="#values-Iterator" class="headerlink" title="values() Iterator"></a>values() <em>Iterator</em></h4><p><code>values()</code> <em>Iterator</em>는 컬렉션에 저장된 값을 반환합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> colors = [ <span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span> ];</div><div class="line"><span class="keyword">let</span> tracking = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1234</span>, <span class="number">5678</span>, <span class="number">9012</span>]);</div><div class="line"><span class="keyword">let</span> data = <span class="keyword">new</span> <span class="built_in">Map</span>();</div><div class="line"></div><div class="line">data.set(<span class="string">"title"</span>, <span class="string">"Understanding ECMAScript 6"</span>);</div><div class="line">data.set(<span class="string">"format"</span>, <span class="string">"ebook"</span>);</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> colors.values()) &#123;</div><div class="line">    <span class="built_in">console</span>.log(value);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> tracking.values()) &#123;</div><div class="line">    <span class="built_in">console</span>.log(value);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> data.values()) &#123;</div><div class="line">    <span class="built_in">console</span>.log(value);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>이 코드는 다음을 출력합니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&quot;red&quot;</div><div class="line">&quot;green&quot;</div><div class="line">&quot;blue&quot;</div><div class="line">1234</div><div class="line">5678</div><div class="line">9012</div><div class="line">&quot;Understanding ECMAScript 6&quot;</div><div class="line">&quot;ebook&quot;</div></pre></td></tr></table></figure>
<p>이 예제에서와 같이 <code>values()</code> <em>Iterator</em>를 호출하면 컬렉션의 해당 데이터 위치에 대한 정보없이 각 컬렉션에 포함된 정확한 데이터가 반환됩니다.</p>
<h4 id="keys-Iterator"><a href="#keys-Iterator" class="headerlink" title="keys() Iterator"></a>keys() <em>Iterator</em></h4><p><code>keys()</code> <em>Iterator</em>는 컬렉션에 있는 각 키를 반환합니다. <em>Array</em>의 경우 숫자 키만 반환하며 <em>Array</em>의 다른 프로퍼티는 반환하지 않습니다. <em>Set</em>의 경우 키는 값과 동일하므로 <code>keys()</code> 및 <code>values()</code>는 동일한 <em>Iterator</em>를 반환합니다. <em>Map</em>의 경우, <code>keys()</code> <em>Iterator</em>는 각 고유 키를 리턴합니다. 다음은 이 세가지를 모두 보여주는 예제입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> colors = [ <span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span> ];</div><div class="line"><span class="keyword">let</span> tracking = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1234</span>, <span class="number">5678</span>, <span class="number">9012</span>]);</div><div class="line"><span class="keyword">let</span> data = <span class="keyword">new</span> <span class="built_in">Map</span>();</div><div class="line"></div><div class="line">data.set(<span class="string">"title"</span>, <span class="string">"Understanding ECMAScript 6"</span>);</div><div class="line">data.set(<span class="string">"format"</span>, <span class="string">"ebook"</span>);</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> colors.keys()) &#123;</div><div class="line">    <span class="built_in">console</span>.log(key);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> tracking.keys()) &#123;</div><div class="line">    <span class="built_in">console</span>.log(key);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> data.keys()) &#123;</div><div class="line">    <span class="built_in">console</span>.log(key);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>이 예제는 다음을 출력합니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">0</div><div class="line">1</div><div class="line">2</div><div class="line">1234</div><div class="line">5678</div><div class="line">9012</div><div class="line">&quot;title&quot;</div><div class="line">&quot;format&quot;</div></pre></td></tr></table></figure>
<p><code>keys()</code> <em>Iterator</em>는 <code>colors</code>, <code>tracking</code> 및 <code>data</code>에서 각 키를 가져 오며, 이 키들은 세개의 <code>for-of</code> 루프 내부에서 출력됩니다. <em>Array</em>의 경우 숫자 색인만 출력되며 <em>Array</em>에 명명된(named) 프로퍼티를 추가 한 경우에도 숫자 색인만 출력합니다. 이것은 <code>for-in</code> 루프는 숫자 인덱스가 아닌 프로퍼티를 반복하기 때문에 <code>for-in</code>에서 <em>Array</em>를 이용하는 방식과 다릅니다.</p>
<h4 id="컬렉션-타입에-대한-Default-Iterator"><a href="#컬렉션-타입에-대한-Default-Iterator" class="headerlink" title="컬렉션 타입에 대한 Default Iterator"></a>컬렉션 타입에 대한 <em>Default Iterator</em></h4><p>각 컬렉션 타입에는 <em>Iterator</em>가 명시적으로 지정되지 않은 경우 <code>for-of</code>에 의해 사용되는 <em>Default Iterator</em>가 있습니다. <code>values()</code> 메서드는 <em>Array</em>와 <em>Set</em>의 <em>Default Iterator</em>이며, <code>entries()</code> 메서드는 <em>Map</em>의 <em>Default Iterator</em>입니다. 이러한 기본값은 <code>for-of</code> 루프에서 컬렉션 객체를 사용하는 것을 좀더 쉽게 만듭니다. 다음 예제를 살펴보겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> colors = [ <span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span> ];</div><div class="line"><span class="keyword">let</span> tracking = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1234</span>, <span class="number">5678</span>, <span class="number">9012</span>]);</div><div class="line"><span class="keyword">let</span> data = <span class="keyword">new</span> <span class="built_in">Map</span>();</div><div class="line"></div><div class="line">data.set(<span class="string">"title"</span>, <span class="string">"Understanding ECMAScript 6"</span>);</div><div class="line">data.set(<span class="string">"format"</span>, <span class="string">"print"</span>);</div><div class="line"></div><div class="line"><span class="comment">// colors.values()를 사용하는 것과 같습니다.</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> colors) &#123;</div><div class="line">    <span class="built_in">console</span>.log(value);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// tracking.values()를 사용하는 것과 같습니다.</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> tracking) &#123;</div><div class="line">    <span class="built_in">console</span>.log(num);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// data.entries()를 사용하는 것과 같습니다.</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> entry <span class="keyword">of</span> data) &#123;</div><div class="line">    <span class="built_in">console</span>.log(entry);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><em>Iterator</em>가 지정되지 않았기 때문에 <em>Default Iterator</em>가 사용됩니다. <em>Array</em>, <em>Set</em> 및 <em>Map</em>의 <em>Default Iterator</em>는 이러한 객체가 초기화되는 방식을 반영하도록 설계되었으므로 이 코드는 다음을 출력합니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&quot;red&quot;</div><div class="line">&quot;green&quot;</div><div class="line">&quot;blue&quot;</div><div class="line">1234</div><div class="line">5678</div><div class="line">9012</div><div class="line">[&quot;title&quot;, &quot;Understanding ECMAScript 6&quot;]</div><div class="line">[&quot;format&quot;, &quot;print&quot;]</div></pre></td></tr></table></figure>
<p><em>Array</em>와 <em>Set</em>은 기본적으로 값을 반환하고, <em>Map</em>은 <code>Map</code> 생성자에 전달할 수 있는 것과 동일한 <em>Array</em> 형태를 반환합니다. 반대로 <em>Weak Set</em>과 <em>Weak Map</em>에는 Built-in <em>Iterator</em>가 없습니다. 약한 참조를 관리한다는 것은 이러한 컬렉션에 정확히 얼마나 많은 값이 있는지를 알 수있는 방법이 없다는 것을 의미합니다. 또한 이들을 반복할 방법이 없다는 것을 의미합니다.</p>
<h3 id="Destructuring과-for-of-루프"><a href="#Destructuring과-for-of-루프" class="headerlink" title="Destructuring과 for-of 루프"></a>Destructuring과 for-of 루프</h3><p><em>Map</em>에 대한 <em>Default Iterator</em>의 동작은 다음 예와 같이 <em>Destructuring</em>이 있는 <code>for-of</code> 루프에서 사용될 때도 유용합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> data = <span class="keyword">new</span> <span class="built_in">Map</span>();</div><div class="line"></div><div class="line">data.set(<span class="string">"title"</span>, <span class="string">"Understanding ECMAScript 6"</span>);</div><div class="line">data.set(<span class="string">"format"</span>, <span class="string">"ebook"</span>);</div><div class="line"></div><div class="line"><span class="comment">// data.entries()을 사용하는 것과 같습니다.</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> data) &#123;</div><div class="line">    <span class="built_in">console</span>.log(key + <span class="string">"="</span> + value);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>이 코드의 <code>for-of</code> 루프는 <em>Destructured</em> <em>Array</em>을 사용하여 <em>Map</em>의 각 항목에 대해 <code>key</code>와 <code>value</code>를 지정합니다. 이 방법으로 두 항목 <em>Array</em>에 액세스하거나 <em>Map</em>에서 키 또는 값을 가져 오지 않고도 키와 값을 사용하여 쉽게 작업할 수 있습니다. <em>Map</em>에 대해 <em>Destructured</em> <em>Array</em>를 사용하여 <code>for-of</code> 루프가 <em>Set</em>과 <em>Array</em>의 경우와 마찬가지로 <em>Map</em>에 똑같이 유용할 수 있습니다.</p>
<h3 id="문자열-Iterator"><a href="#문자열-Iterator" class="headerlink" title="문자열 Iterator"></a>문자열 Iterator</h3><p>JavaScript 문자열은 ECMAScript 5가 출시된 이후 천천히 배열과 비슷해졌습니다. 예를 들어, ECMAScript 5는 문자열의 문자에 액세스하기위한 대괄호 표기법을 사용합니다 (즉, 첫 번째 문자를 가져 오기 위해 <code>text[0]</code> 사용). 그러나 대괄호 표기법은 문자가 아닌 <em>Code Unit</em>에서 작동하므로 아래 예제에서 보여주는 것처럼 2 바이트 문자를 올바르게 액세스하는데 사용할 수 없습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> message = <span class="string">"A ð ®· B"</span>;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i &lt; message.length; i++) &#123;</div><div class="line">    <span class="built_in">console</span>.log(message[i]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>이 코드는 괄호 표기법과 <code>length</code> 프로퍼티를 사용하여 반복하고 유니 코드 문자가 포함된 문자열을 출력합니다. 결과는 예상과 다릅니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">A</div><div class="line">(blank)</div><div class="line">(blank)</div><div class="line">(blank)</div><div class="line">(blank)</div><div class="line">B</div></pre></td></tr></table></figure>
<p>두개의 바이는 두 개의 개별 <em>Code Unit</em>으로 취급되기 때문에 A와 B 사이에 4 개의 비어있는 행이 출력됩니다.</p>
<p>다행스럽게도 ECMAScript 6은 유니 코드를 완벽하게 지원하고 (2 장 참조) 기본 문자열 <em>Iterator</em>는 문자열 반복 문제를 해결하기 위한 시도입니다. 따라서 문자열의 기본 <em>Iterator</em>는 <em>Code Unit</em>이 아닌 문자단위로 작동합니다. 이 예제를 <code>for-of</code> 루프와 함께 기본 문자열 <em>Iterator</em>를 사용하도록 변경하면 보다 적절한 결과가 출력됩니다. 다음은 수정된 코드입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> message = <span class="string">"A ð ®· B"</span>;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> c <span class="keyword">of</span> message) &#123;</div><div class="line">    <span class="built_in">console</span>.log(c);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>출력 결과는 다음과 같습니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">A</div><div class="line">(blank)</div><div class="line">ð ®·</div><div class="line">(blank)</div><div class="line">B</div></pre></td></tr></table></figure>
<p>이 결과는 문자로 작업할 때 기대했던 것과 더 비슷합니다. 루프는 유니 코드 문자뿐 아니라 나머지 문자도 모두 성공적으로 출력합니다.</p>
<h3 id="NodeList-Iterator"><a href="#NodeList-Iterator" class="headerlink" title="NodeList Iterator"></a>NodeList Iterator</h3><p>DOM (Document Object Model)에는 문서의 요소 컬렉션을 나타내는 <code>NodeList</code> 타입이 있습니다. JavaScript를 웹 브라우저에서 실행하는 사람들에게는 <code>NodeList</code> 객체와 <em>Array</em>의 차이점을 이해하는 것이 항상 약간 어려웠습니다. <code>NodeList</code> 객체와 <em>Array</em>는 항목의 수를 나타 내기 위해 <code>length</code> 프로퍼티를 사용하며, 둘 다 괄호 표기법을 사용하여 개별 항목에 액세스합니다. 그러나 내부적으로 <code>NodeList</code>와 <em>Array</em>는 완전히 다르게 작동하므로 많은 혼란을 겪습니다.</p>
<p>ECMAScript 6에 <em>Default Iterator</em>가 추가된 <code>NodeList</code> (ECMAScript 6 자체가 아닌 HTML 사양에 포함됨)의 DOM 정의에는 <em>Array</em> <em>Default Iterator</em>와 같은 방식으로 작동하는 <em>Default Iterator</em>가 포함되어 있습니다. 즉, <code>for-of</code> 루프 또는 객체의 <em>Default Iterator</em>를 사용하는 다른 부분에서 아래와같이 <code>NodeList</code>를 사용할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> divs = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"div"</span>);</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> div <span class="keyword">of</span> divs) &#123;</div><div class="line">    <span class="built_in">console</span>.log(div.id);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>이 코드는 <code>getElementsByTagName()</code>을 호출하여 <code>document</code> 객체의 모든 <code>&lt;div&gt;</code> 요소를 나타내는 <code>NodeList</code>를 검색합니다. <code>for-of</code> 루프는 각 요소를 반복하고 엘리먼트 ID를 출력하므로 표준 <em>Array</em>의 코드와 동일합니다.</p>
<h2 id="Spread-연산자와-Non-Array-Iterables"><a href="#Spread-연산자와-Non-Array-Iterables" class="headerlink" title="Spread 연산자와 Non-Array Iterables"></a>Spread 연산자와 Non-Array Iterables</h2><p>7 장에서 아래와 같이 <em>Set</em>을 <em>Array</em>로 변환하는 데 <em>Spread</em> 연산자 (<code>...</code>)를 사용할 수 있다는 점을 설명했습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]),</div><div class="line">    array = [...set];</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(array);             <span class="comment">// [1,2,3,4,5]</span></div></pre></td></tr></table></figure>
<p>이 코드는 <em>Array</em> 리터럴의 <em>Spread</em> 연산자를 사용하여 해당 <em>Array</em>을 <code>set</code>의 값으로 채웁니다. <em>Spread</em> 연산자는 모든 <em>Iterable</em>에서 작동하고 <em>Default Iterator</em>를 사용하여 포함할 값을 결정합니다. 모든 값은 <em>Iterator</em>에서 읽혀지고 <em>Iterator</em>에서 값이 리턴된 순서대로 <em>Array</em>에 삽입됩니다. 이 예제는 <em>Set</em>이 <em>Iterable</em>이기 때문에 작동했습니다. 그리고 모든 <em>Iterable</em>에서 똑같이 작동 합니다. 다른 예를 살펴 보겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([ [<span class="string">"name"</span>, <span class="string">"Nicholas"</span>], [<span class="string">"age"</span>, <span class="number">25</span>]]),</div><div class="line">    array = [...map];</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(array);         <span class="comment">// [ ["name", "Nicholas"], ["age", 25]]</span></div></pre></td></tr></table></figure>
<p>여기에서 <em>Spread</em> 연산자는 <code>map</code>을 <em>Array</em>의 <em>Array</em>로 변환합니다. <em>Map</em>에 대한 <em>Default Iterator</em>는 키-값 쌍을 반환하기 때문에 결과 <em>Array</em>는 <code>new Map()</code>호출 중에 전달된 <em>Array</em>처럼 보입니다.</p>
<p><em>Array</em> 리터럴에서 원하는 만큼 여러번 <em>Spread</em> 연산자를 사용할 수 있으며 <em>Iterable</em>에서 여러 항목을 삽입하려는 곳이면 어디에서나 사용할 수 있습니다. 이러한 항목은 <em>Spread</em> 연산자의 위치에 있는 새로운 <em>Array</em>에 순서대로 나타납니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> smallNumbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</div><div class="line">    bigNumbers = [<span class="number">100</span>, <span class="number">101</span>, <span class="number">102</span>],</div><div class="line">    allNumbers = [<span class="number">0</span>, ...smallNumbers, ...bigNumbers];</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(allNumbers.length);     <span class="comment">// 7</span></div><div class="line"><span class="built_in">console</span>.log(allNumbers);    <span class="comment">// [0, 1, 2, 3, 100, 101, 102]</span></div></pre></td></tr></table></figure>
<p><em>Spread</em> 연산자는 <code>smallNumbers</code> 및 <code>bigNumbers</code>의 값에서 <code>allNumbers</code>를 만드는 데 사용됩니다. 값은 <code>allNumbers</code>가 만들어질 때 <em>Array</em>가 추가되는 순서와 동일한 순서로 <code>allNumbers</code>에 배치됩니다. 먼저 <code>0</code>이오고 <code>smallNumbers</code>의 값이 뒤 따르고 <code>bigNumbers</code>의 값이옵니다. 그러나 원래 배열은 값이 <code>allNumbers</code>로 복사되었으므로 변경되지 않습니다.</p>
<p><em>Spread</em> 연산자는 어떤 <em>Iterable</em>에서도 사용할 수 있기 때문에, <em>Iterable</em>을 <em>Array</em>로 변환하는 가장 쉬운 방법입니다. 문자열을 문자 <em>Array</em>(<em>Code Unit</em> 아님) 및 브라우저의 <code>NodeList</code> 객체를 Node <em>Array</em>로 변환할 수 있습니다.</p>
<p><code>for-of</code> 연산자와 <em>Spread</em> 연산자를 포함하여 <em>Iterator</em>가 작동하는 기본 사항을 이해 했으므로 이제는 <em>Iterator</em>를 좀 더 복잡한 용도로 살펴볼 차례입니다.</p>
<h2 id="Iterator-고급-기능"><a href="#Iterator-고급-기능" class="headerlink" title="Iterator 고급 기능"></a><em>Iterator</em> 고급 기능</h2><p><em>Iterator</em>는 <em>Genertor</em>를 이용하여 쉽게 만들고 기본 기능을 이용하여 <em>Iterator</em>를 쉽게 사용할수 있습니다. 그러나 <em>Iterator</em>는 단순히 값의 모음을 반복하는것 이외의 작업에 사용될 때 훨씬 강력합니다. ECMAScript 6을 개발하는 동안 제작자가 더 많은 기능을 추가하도록 독창적인 아이디어와 패턴이 많이 나타났습니다. 이러한 추가 기능중 일부는 함께 사용하면 흥미로운 상호 작용을 수행할 수 있습니다.</p>
<h3 id="Iterator에-파라미터-넘기기"><a href="#Iterator에-파라미터-넘기기" class="headerlink" title="Iterator에 파라미터 넘기기"></a><em>Iterator</em>에 파라미터 넘기기</h3><p>이 장 전반의 예제에서는 <em>Iterator</em>의 <code>next()</code> 메서드를 통해 값을 전달받거나 <em>Generator</em>의 <code>yield</code>를 사용하는 모습을 보여줬습습니다. 그러나 <code>next()</code> 메서드를 통해 <em>Iterator</em>에 파라미터를 전달할 수도 있습니다. 파라미터가 <code>next()</code> 메서드에 전달되면, 그 파라미터는 <em>Generator</em> 내부의 <code>yield</code> 문의 값이 됩니다. 이 기능은 비동기 프로그래밍과 같은 고급 기능에 중요합니다. 다음은 기본적인 예입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createIterator</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> first = <span class="keyword">yield</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">let</span> second = <span class="keyword">yield</span> first + <span class="number">2</span>;       <span class="comment">// 4 + 2</span></div><div class="line">    <span class="keyword">yield</span> second + <span class="number">3</span>;                   <span class="comment">// 5 + 3</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> iterator = createIterator();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: 1, done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next(<span class="number">4</span>));          <span class="comment">// "&#123; value: 6, done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next(<span class="number">5</span>));          <span class="comment">// "&#123; value: 8, done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: undefined, done: true &#125;"</span></div></pre></td></tr></table></figure>
<p><code>next()</code>의 첫 번째 호출은 전달된 파라미터가 사라지는 특별한 경우입니다. <code>yield</code> 문 앞에 접근할 수 있다면 <code>next()</code>에 전달된 파라미터가 <code>yield</code>에 의해 리턴된 값이되기 때문에, <code>next()</code>에 대한 첫 번째 호출의 파라미터는 <em>Generator</em> 함수의 첫 번째 <code>yield</code> 문장을 대체할 수 있습니다. 하지만 그건 불가능합니다. 그래서 <code>next()</code>가 처음 호출되었을 때 파라미터를 넘길 이유가 없습니다.</p>
<p><code>next()</code>의 두 번째 호출에서 <code>4</code>값이 파라미터로 전달됩니다. <code>4</code>는 <em>Generator</em> 함수 내에서 <code>first</code> 변수에 할당됩니다. 할당을 포함하는 <code>yield</code> 문에서 표현식의 오른쪽은 <code>next()</code>의 첫 번째 호출에서 평가되고 왼쪽은 함수가 계속 실행되기 전에 <code>next()</code>의 두 번째 호출에서 평가됩니다. <code>next()</code>의 두 번째 호출이 <code>4</code>로 전달되기 때문에, 그 값은 <code>first</code>에 할당되고 실행이 계속됩니다.</p>
<p>두 번째 <code>yield</code>는 첫 번째 <code>yield</code>의 결과를 사용하고 두개를 더합니다. 즉, <code>6</code>의 값을 반환합니다. <code>next()</code>가 세번째로 호출될 때, 값 <code>5</code>가 파라미터로 전달됩니다. 이 값은 변수 <code>second</code>에 할당된 다음 <code>yield</code> 문에서 <code>8</code>을 반환하는데 사용됩니다.</p>
<p>실행이 <em>Generator</em> 함수 내에서 계속될 때마다 어떤 코드가 실행되고 있는지 고려하여 어떤 일이 일어나고 있는지 생각하는 것이 쉽습니다. 그림 8-1은 색상을 사용하여 실행중인 코드를 보여줍니다.</p>
<p><img src="https://leanpub.com/site_images/understandinges6/fg0601.png" alt=""><br><strong>[그림 8-1]Generator 내부에서 코드 실행</strong></p>
<p>노란색은 <code>next()</code>에 대한 첫 번째 호출과 <em>Generator</em> 내부에서 실행된 코드를 나타냅니다. 아쿠아색은 <code>next(4)</code>의 호출과 그 호출로 실행된 코드를 나타냅니다. 그리고 자주색은 <code>next(5)</code> 호출과 그 결과로 실행되는 코드를 나타냅니다. 까다로운 부분은 왼쪽면이 실행되기 전에 각 표현식의 오른쪽에있는 코드가 어떻게 실행되고 중지되는지 입니다. 이것은 일반 함수를 디버깅하는 것보다 <em>Generator</em>를 디버깅하는 것을 더 복잡하게 만드는 원인입니다.</p>
<p>지금까지 <code>next()</code> 메서드에 값이 전달될 때 <code>yield</code>가 <code>return</code>처럼 작동할 수 있다는 것을 보았습니다. 그러나 이것만이 <em>Generator</em> 내부에서 수행할 수있는 유일한 실행이 아닙니다. <em>Iterator</em>로 인해 오류가 발생할 수도 있습니다.</p>
<h3 id="Iterator에서-에러-던지기"><a href="#Iterator에서-에러-던지기" class="headerlink" title="Iterator에서 에러 던지기"></a>Iterator에서 에러 던지기</h3><p><em>Iterator</em>에 데이터뿐만 아니라 오류 조건도 전달할 수 있습니다. <em>Iterator</em>는 <em>Iterator</em>가 다시 시작할 때 오류를 발생 시키도록 지시하는 <code>throw()</code> 메서드를 구현하도록 선택할 수 있습니다. 이것은 비동기 프로그래밍을 위한 중요한 기능이고, 함수를 종료하는 두가지 방법인 리턴과 오류를 던지는 기능을 모방할 수 있어 <em>Generator</em> 내부의 유연성에도 중요합니다. <em>Iterator</em>가 처리를 계속할 때 던져 져야하는 <code>throw()</code>에 에러 객체를 전달할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createIterator</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> first = <span class="keyword">yield</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">let</span> second = <span class="keyword">yield</span> first + <span class="number">2</span>;       <span class="comment">// yield 4 + 2, then throw</span></div><div class="line">    <span class="keyword">yield</span> second + <span class="number">3</span>;                   <span class="comment">// never is executed</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> iterator = createIterator();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(iterator.next());                   <span class="comment">// "&#123; value: 1, done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next(<span class="number">4</span>));                  <span class="comment">// "&#123; value: 6, done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.throw(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Boom"</span>))); <span class="comment">// generator에서 에러를 던집니다.</span></div></pre></td></tr></table></figure>
<p>이 예제에서 처음 두개의 <code>yield</code> 표현식은 평범한 것으로 평가되지만 <code>throw()</code>가 호출되면 <code>let second</code>가 평가되기 전에 에러가 발생합니다. 이로 인해 코드 실행이 오류를 직접 throw 하는 것과 비슷한 효과로 중지됩니다. 유일한 차이점은 오류가 발생하는 위치입니다. [그림 8-2]는 각 단계에서 어떤 코드가 실행되는지 보여줍니다.</p>
<p><img src="https://leanpub.com/site_images/understandinges6/fg0602.png" alt=""><br><strong>[그림 8-2] Generator 내부에서 에러를 던집니다</strong></p>
<p>이 그림에서 붉은색은 <code>throw()</code>가 호출될 때 실행되는 코드를 나타내며 빨간색 별은 오류가 <em>Generator</em> 내부로 던져지는 부분을 대략 나타냅니다. 처음 두개의 <code>yield</code> 문이 실행되고 <code>throw()</code>가 호출되면 다른 코드가 실행되기 전에 오류가 발생합니다.</p>
<p>이것을 알고있다면, <code>try-catch</code> 블록을 사용하여 <em>Generator</em> 내에서 에러를 잡을 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createIterator</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> first = <span class="keyword">yield</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">let</span> second;</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        second = <span class="keyword">yield</span> first + <span class="number">2</span>;       <span class="comment">// yield 4 + 2, then throw</span></div><div class="line">    &#125; <span class="keyword">catch</span> (ex) &#123;</div><div class="line">        second = <span class="number">6</span>;                     <span class="comment">// 에러시 다른 값을 할당함.</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">yield</span> second + <span class="number">3</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> iterator = createIterator();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(iterator.next());                   <span class="comment">// "&#123; value: 1, done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next(<span class="number">4</span>));                  <span class="comment">// "&#123; value: 6, done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.throw(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Boom"</span>))); <span class="comment">// "&#123; value: 9, done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());                   <span class="comment">// "&#123; value: undefined, done: true &#125;"</span></div></pre></td></tr></table></figure>
<p>이 예제에서, 두 번째 <code>yield</code> 문은 <code>try-catch</code> 블록이 감싸고 있습니다. 이 <code>yield</code>는 에러 없이 실행되고, 다음 실행에서 어떤한 값이 <code>second</code>에 할당되기 전에 에러가 던져 지므로 <code>catch</code> 블록은 6의 값을 할당합니다. 그리고 실행은 다음 <code>yield</code>로 이동하여 9를 반환합니다.</p>
<p>흥미로운 일이 발생합니다. <code>throw()</code> 메서드는 <code>next()</code> 메서드와 마찬가지로 결과 객체를 리턴합니다. 오류가 <em>Generator</em> 내부에서 발견 되었기 때문에 코드 실행은 다음 <code>yield</code>로 이어지고 다음 값인 <code>9</code>가 반환됩니다.</p>
<p><em>Iterator</em>에 대한 지시사항인 <code>next()</code>와 <code>throw()</code>를 생각하는 것이 도움이됩니다. <code>next()</code> 메서드는 <em>Iterator</em>에게 (주어진 값으로) 실행을 계속하도록 지시하고 <code>throw()</code>는 <em>Iterator</em>에게 오류를 던져 실행을 계속하도록 지시합니다. 그 시점 이후에 일어나는 일은 <em>Generator</em> 내부의 코드에 달려 있습니다.</p>
<p><code>next()</code>와 <code>throw()</code> 메서드는 <code>yield</code>를 사용할 때 <em>Iterator</em> 안에서 실행을 제어하지만 <code>return</code> 문도 사용할 수 있습니다. 그러나<code>return</code>은 다음 절에서 보듯이 정규 함수와 약간 다르게 작동합니다.</p>
<h3 id="Generator의-Return-문"><a href="#Generator의-Return-문" class="headerlink" title="Generator의 Return 문"></a>Generator의 Return 문</h3><p><em>Generator</em>는 함수이기 때문에 <code>return</code> 문을 사용하여 일찍 종료하고 <code>next()</code> 메서드에 대한 마지막 호출의 반환 값을 지정할 수 있습니다. 이 장의 대부분의 예제에서, <em>Iterator</em>에서 <code>next()</code>를 마지막으로 호출하면 <code>undefined</code>가 반환되지만 다른 함수에서와 같이 <code>return</code>을 사용하여 값을 지정할 수 있습니다. <em>Generator</em>에서 <code>return</code>은 모든 처리가 완료되었음을 나타내므로 <code>done</code> 프로퍼티는<code>true</code>로 설정되고 값이 제공되면 <code>value</code>가 됩니다. 다음은 <code>return</code>을 사용하여 일찍 종료하는 예제입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createIterator</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</div><div class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> iterator = createIterator();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: 1, done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: undefined, done: true &#125;"</span></div></pre></td></tr></table></figure>
<p>이 코드의 <em>Generator</em>에는 <code>yield</code>문 다음에 <code>return</code> 문장이 옵니다. <code>return</code>은 더 이상의 값이 없다는 것을 나타내므로 나머지 <code>yield</code> 문은 실행되지 않습니다 (도달할 수 없습니다).</p>
<p>리턴된 오브젝트의 <code>value</code> 필드에 값을 지정할 수도 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createIterator</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">42</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> iterator = createIterator();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: 1, done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: 42, done: true &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: undefined, done: true &#125;"</span></div></pre></td></tr></table></figure>
<p>두 번째 <code>next()</code> 메서드 호출에서 <code>value</code> 프로퍼티에 값 <code>42</code>가 리턴됩니다.(<code>done</code>이 처음으로 <code>true</code>인 지점입니다.)<br><code>next()</code>의 세번째 호출에 <code>value</code> 프로퍼티가 다시 <code>undefined</code>인 객체를 반환합니다. <code>return</code>으로 지정한 값은 <code>value</code> 프로퍼티가<code>undefined</code>로 재설정되기 전에 반환된 객체에서만 한번 사용할 수 있습니다.</p>
<blockquote>
<p><em>Spread</em> 연산자와 <code>for-of</code>는 <code>return</code> 문에 의해 지정된 값을 무시합니다. <code>done</code>이 <code>true</code>이면  바로<code>value</code>를 읽지 않고 멈춥니다. 그러나 <em>Generator</em>를 위임할 때는 <em>Iterator</em> 리턴 값이 유용합니다.</p>
</blockquote>
<h3 id="Generator-위임"><a href="#Generator-위임" class="headerlink" title="Generator 위임"></a>Generator 위임</h3><p>경우에 따라 두 개의 <em>Iterator</em> 값을 하나로 결합하는 것이 유용할 수 있습니다. <em>Generator</em>는 별표 (<code>*</code>) 문자로 <code>yield</code>라는 특수 형식을 사용하여 다른 <em>Iterator</em>에 위임할 수 있습니다. <em>Generator</em> 정의에서와 같이 <code>*</code>가 나타나는 위치는 <code>*</code>이 <code>yield</code> 키워드와 <em>Generator</em> 함수 이름 사이에있는 한 중요하지 않습니다. 다음은 그 예입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createNumberIterator</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createColorIterator</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">yield</span> <span class="string">"red"</span>;</div><div class="line">    <span class="keyword">yield</span> <span class="string">"green"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createCombinedIterator</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">yield</span> *createNumberIterator();</div><div class="line">    <span class="keyword">yield</span> *createColorIterator();</div><div class="line">    <span class="keyword">yield</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> iterator = createCombinedIterator();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: 1, done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: 2, done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: "red", done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: "green", done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: true, done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: undefined, done: true &#125;"</span></div></pre></td></tr></table></figure>
<p>위 예제에서, <code>createCombinedIterator()</code> <em>Generator</em>는 <code>createNumberIterator()</code>에서 리턴된 <em>Iterator</em>에 먼저 위임한 다음<code>createColorIterator()</code>에서 리턴된 <em>Iterator</em>에 위임합니다. <code>createCombinedIterator()</code>에서 반환된 <em>Iterator</em>는 바깥쪽에서 보기에 일관된 <em>Iterator</em>로 보여집니다. <code>next()</code>에 대한 각각의 호출은 <code>createNumberIterator()</code>와 <code>createColorIterator()</code>에 의해 생성된 <em>Iterator</em>가 비게 될 때까지 적절한 <em>Iterator</em>에 위임됩니다. 그런 다음 최종 <code>yield</code>가 실행되어 <code>true</code>를 반환합니다.</p>
<p><em>Generator</em> 위임을 통해 <em>Generator</em> 리턴값을 더 많이 사용할 수도 있습니다. 이것은 반환된 값을 액세스하는 가장 쉬운 방법이며 복잡한 작업을 수행하는데 매우 유용할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createNumberIterator</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">3</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createRepeatingIterator</span>(<span class="params">count</span>) </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">        <span class="keyword">yield</span> <span class="string">"repeat"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createCombinedIterator</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> result = <span class="keyword">yield</span> *createNumberIterator();</div><div class="line">    <span class="keyword">yield</span> *createRepeatingIterator(result);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> iterator = createCombinedIterator();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: 1, done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: 2, done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: "repeat", done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: "repeat", done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: "repeat", done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: undefined, done: true &#125;"</span></div></pre></td></tr></table></figure>
<p>여기서 <code>createCombinedIterator()</code> <em>Generator</em> <code>createNumberIterator()</code>에 위임하고 <code>result</code>에 리턴값을 할당합니다. <code>createNumberIterator()</code>는 <code>return 3</code>을 포함하기 때문에 리턴값은 <code>3</code>입니다. <code>result</code> 변수는 <code>createRepeatingIterator()</code>에 같은 문자열을 <code>yield</code> 하는 횟수(이 경우에는 3 번)를 나타내는 인자로 전달됩니다.</p>
<p><code>next()</code> 메서드에 대한 호출에서 <code>3</code> 값은 절대로 출력되지 않았습니다. 지금은 <code>createCombinedIterator()</code> <em>Generator</em> 안에만 존재합니다. 그러나 다음과 같이 또 다른 <code>yield</code> 문을 추가하여 그 값을 출력할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createNumberIterator</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">3</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createRepeatingIterator</span>(<span class="params">count</span>) </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">        <span class="keyword">yield</span> <span class="string">"repeat"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createCombinedIterator</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> result = <span class="keyword">yield</span> *createNumberIterator();</div><div class="line">    <span class="keyword">yield</span> result;</div><div class="line">    <span class="keyword">yield</span> *createRepeatingIterator(result);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> iterator = createCombinedIterator();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: 1, done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: 2, done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: 3, done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: "repeat", done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: "repeat", done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: "repeat", done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: undefined, done: true &#125;"</span></div></pre></td></tr></table></figure>
<p>이 코드에서 여분의 <code>yield</code> 문은 리턴된 값을 <code>createNumberIterator()</code> <em>Generator</em>에서 명시적으로 출력합니다.</p>
<p>리턴값을 사용하는 <em>Generator</em> 위임은 특히 비동기 작업과 함께 사용할 때 매우 흥미로운 가능성을 가지는 매우 강력한 패러다임입니다.</p>
<blockquote>
<p>문자열에 <code>yield *</code>를 직접 사용할 수 있습니다 (예 :<code>yield * &quot;hello&quot;</code>). 이 경우 문자열의 기본 <em>Iterator</em>가 사용됩니다.</p>
</blockquote>
<h2 id="비동기-Asynchronous-작업-실행"><a href="#비동기-Asynchronous-작업-실행" class="headerlink" title="비동기(Asynchronous) 작업 실행"></a>비동기(Asynchronous) 작업 실행</h2><p><em>Generator</em>의 흥미로운 점은 비동기 프로그래밍과 직접 관련이 있습니다. JavaScript의 비동기 프로그래밍은 양날의 칼입니다. 간단한 작업은 비동기식으로 수행하기 쉽고 복잡한 작업은 코드에서 내용 역할을 하게됩니다. <em>Generator</em>는 실행 중간에 코드를 효과적으로 일시 중지할 수 있으므로 비동기 처리와 관련된 많은 가능성을 가지고 있습니다.</p>
<p>비동기 작업을 수행하는 전통적인 방법은 콜백이 있는 함수를 호출하는 것입니다. 예를 들어, Node.js의 디스크에서 파일을 읽는 것을 생각해<br> 보겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</div><div class="line"></div><div class="line">fs.readFile(<span class="string">"config.json"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, contents</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (err) &#123;</div><div class="line">        <span class="keyword">throw</span> err;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    doSomethingWith(contents);</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Done"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><code>fs.readFile()</code> 메서드는 읽을 파일 이름과 콜백 함수를 가지고 호출됩니다. 작업이 끝나면 콜백 함수가 호출됩니다. 콜백은 오류가 있는지 검사하고 그렇지 않은 경우 반환된 <code>contents</code>을 처리합니다. 이 작업은 작거나, 유한한 수의 비동기 작업을 완료하는데는 괜찮지만 콜백을 중첩하거나 일련의 비동기 작업을 순서대로 수행해야하는 경우에는 복잡해집니다. 이부분이 <em>Generator</em>와 <code>yield</code>가 도움이되는 곳입니다.</p>
<h3 id="간단한-작업-실행"><a href="#간단한-작업-실행" class="headerlink" title="간단한 작업 실행"></a>간단한 작업 실행</h3><p><code>yield</code>는 실행을 멈추고 다시 시작하기 전에 <code>next()</code> 메서드가 호출되기를 기다리기 때문에 콜백을 관리하지 않고 비동기 호출을 구현할 수 있습니다. 시작하려면 <em>Generator</em>를 호출하고 다음과 같이 <em>Iterator</em>를 시작할 수있는 함수가 필요합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">taskDef</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// iterator를 만들고 다른곳에서 사용할 수 있게 합니다.</span></div><div class="line">    <span class="keyword">let</span> task = taskDef();</div><div class="line"></div><div class="line">    <span class="comment">// 태스크 시작</span></div><div class="line">    <span class="keyword">let</span> result = task.next();</div><div class="line"></div><div class="line">    <span class="comment">// next() 호출을 계속하는 재귀 함수</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">// 더해야 할 일이 있다면</span></div><div class="line">        <span class="keyword">if</span> (!result.done) &#123;</div><div class="line">            result = task.next();</div><div class="line">            step();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// process를 시작</span></div><div class="line">    step();</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>run()</code> 함수는 태스크의 정의 (<em>Generator</em> 함수)를 파라미터로 받아들입니다. <em>Generator</em>를 호출하여 <em>Iterator</em>를 만들고 <em>Iterator</em>를<code>task</code>에 저장합니다. <code>task</code> 변수는 함수 외부에 있으므로 다른 함수가 접근할 수 있습니다(뒷부분에서 설명 합니다.). <code>next()</code>에 대한 첫 번째 호출은 <em>Iterator</em>를 시작하고 결과는 나중에 사용하기 위해 저장됩니다. <code>step()</code> 함수는 <code>result.done</code>이 false인지 검사하고, 만약 그렇다면 재귀적으로 자신을 호출하기 전에 <code>next()</code>를 호출합니다. <code>next()</code>를 호출할 때마다 결과 값이 <code>result</code>에 저장됩니다.이 값은 항상 최신 정보를 포함하도록 덮어 쓰여집니다. 처음 <code>step()</code>의 호출은 더 수행할 태스크가 있는지를 알기 위해 <code>result.done</code> 변수를 확인 합니다.</p>
<p>위에 구현한 <code>run()</code>을 다음과 같이 여러 <code>yield</code> 문이 포함된 <em>Generator</em>로 실행할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">run(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</div><div class="line">    <span class="keyword">yield</span>;</div><div class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</div><div class="line">    <span class="keyword">yield</span>;</div><div class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>이 예제는 단순히 콘솔에 세 개의 숫자를 출력하는데, 간단히 <code>next()</code>에 대한 모든 호출이 이루어지는 것을 보여줍니다. 그러나 단지 두 번 <code>yield</code>하는 것은 별로 유용하지 않습니다. 다음 단계는 <em>Iterator</em> 안팎으로 값을 전달하는 것입니다.</p>
<h3 id="데이터를-가진-태스크-실행하기"><a href="#데이터를-가진-태스크-실행하기" class="headerlink" title="데이터를 가진 태스크 실행하기"></a>데이터를 가진 태스크 실행하기</h3><p>태스크 실행에 데이터를 전달하는 가장 쉬운 방법은 <code>yield</code>에 의해 지정된 값을 <code>next()</code> 메서드에 대한 호출에 전달하는 것입니다. 이렇게하려면 이 코드에서와 같이 <code>result.value</code> 만 전달하면됩니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">taskDef</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// iterator를 만들고 다른곳에서 사용할 수 있게 합니다.</span></div><div class="line">    <span class="keyword">let</span> task = taskDef();</div><div class="line"></div><div class="line">    <span class="comment">// 태스크 시작</span></div><div class="line">    <span class="keyword">let</span> result = task.next();</div><div class="line"></div><div class="line">    <span class="comment">// next() 호출을 계속하는 재귀 함수</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">// 더해야 할 일이 있다면</span></div><div class="line">        <span class="keyword">if</span> (!result.done) &#123;</div><div class="line">            result = task.next(result.value);</div><div class="line">            step();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// process 시작</span></div><div class="line">    step();</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>이제 <code>result.value</code>가 파라미터로 <code>next()</code>에 전달되었으므로 다음과 같이 <code>yield</code> 호출간에 데이터를 전달할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">run(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> value = <span class="keyword">yield</span> <span class="number">1</span>;</div><div class="line">    <span class="built_in">console</span>.log(value);         <span class="comment">// 1</span></div><div class="line"></div><div class="line">    value = <span class="keyword">yield</span> value + <span class="number">3</span>;</div><div class="line">    <span class="built_in">console</span>.log(value);         <span class="comment">// 4</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>이 예제는 콘솔에 두 개의 값을 출력합니다(1과 4). 값 1은 <code>yield 1</code>에서 나오는데, 1은 <code>value</code> 변수로 바로 전달됩니다. 4는 <code>value</code>에 3을 더하고 그 결과를 <code>value</code>에 전달함으로써 계산됩니다. 데이터가 <code>yield</code>호출 사이에서 흐르고 있으므로 비동기 호출을 허용하려면 작은 변경만 하면됩니다.</p>
<h3 id="비동기-태스크-실행"><a href="#비동기-태스크-실행" class="headerlink" title="비동기 태스크 실행"></a>비동기 태스크 실행</h3><p>앞의 예제는 정적 데이터가 <code>yield</code> 호출 사이에서 왔다 갔다했지만 비동기 프로세스를 기다리는 것은 약간 다릅니다. 태스크 러너는 콜백 및 그 사용 방법을 알아야합니다. 그리고 <code>yield</code> 표현식은 값을 태스크 러너로 전달하기 때문에 어떤 함수 호출이라도 호출이 태스크 러너가 기다려야하는 비동기 연산임을 나타내는 값을 리턴해야 함을 의미합니다.</p>
<p>다음은 값이 비동기 작업임을 알리는 한 가지 방법입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchData</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</div><div class="line">        callback(<span class="literal">null</span>, <span class="string">"Hi!"</span>);</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>이 예제의 목적을 위해, 태스크 러너에 의해 호출되는 모든 함수는 callback을 실행하는 함수를 리턴할 것이다. <code>fetchData()</code> 함수는 콜백 함수를 파라미터로 받아들이는 함수를 리턴한다. 반환된 함수가 호출되면, 단일 데이터 ( <code>&quot;Hi!&quot;</code>문자열)로 콜백 함수를 실행합니다. <code>callback</code> 파라미터는 콜백을 실행하는 것이 기본 <em>Iterator</em>와 정확하게 상호 작용 하는지를 확인하기 위해 태스크 러너로부터 올 필요가있습니다. <code>fetchData()</code> 함수는 동기식이지만, 다음과 같이 약간의 지연만으로 콜백을 호출하여 쉽게 비동기식으로 확장할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchData</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</div><div class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            callback(<span class="literal">null</span>, <span class="string">"Hi!"</span>);</div><div class="line">        &#125;, <span class="number">50</span>);</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>이 버전의 <code>fetchData()</code>는 콜백을 호출하기 전에 50ms의 지연을 가져와 이 패턴이 동기 및 비동기 코드에서 똑같이 잘 작동 함을 보여줍니다. <code>yield</code>를 사용하여 호출하려는 각 함수가 동일한 패턴을 따르는지 확인해야 합니다.</p>
<p>함수가 비동기 프로세스라는 신호를 보내는 방법을 잘 이해하면 태스크 러너를 수정하여 해당 사실을 고려할 수 있습니다. <code>result.value</code>가 함수 일 때마다, 태스크 러너는 그 값을 <code>next()</code> 메서드로 전달하는 대신에 실행할 것입니다. 다음은 업데이트된 코드입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">taskDef</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// iterator를 만들고 다른곳에서 사용할 수 있게 합니다.</span></div><div class="line">    <span class="keyword">let</span> task = taskDef();</div><div class="line"></div><div class="line">    <span class="comment">// 태스크 시작</span></div><div class="line">    <span class="keyword">let</span> result = task.next();</div><div class="line"></div><div class="line">    <span class="comment">// next() 호출을 계속하는 재귀 함수</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">// 더해야 할 일이 있다면</span></div><div class="line">        <span class="keyword">if</span> (!result.done) &#123;</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> result.value === <span class="string">"function"</span>) &#123;</div><div class="line">                result.value(<span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</div><div class="line">                    <span class="keyword">if</span> (err) &#123;</div><div class="line">                        result = task.throw(err);</div><div class="line">                        <span class="keyword">return</span>;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    result = task.next(data);</div><div class="line">                    step();</div><div class="line">                &#125;);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                result = task.next(result.value);</div><div class="line">                step();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 프로세스 시작</span></div><div class="line">    step();</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>result.value</code>가 (<code>===</code>연산자로 검사된) 함수이면 콜백 함수가 호출됩니다. 이 콜백 함수는 가능한 오류를 첫 번째 인수 (<code>err</code>)로 전달하고 결과를 두 번째 인수로 전달하는 Node.js 규칙을 따릅니다. <code>err</code>가 있어 오류가 발생하면 <code>task.throw()</code>가 <code>task.next()</code>대신에 오류 객체와 함께 호출되므로 정확한 위치에 오류가 발생합니다. 오류가 없으면 <code>data</code>가 <code>task.next()</code>에 전달되고 그 결과가 저장됩니다. 그런 다음 <code>step()</code>이 호출되어 프로세스가 계속 진행됩니다. <code>result.value</code>가 함수가 아니라면 <code>next()</code> 메서드에 직접 전달됩니다.</p>
<p>이 새로운 버전의 태스크 러너는 모든 비동기 태스크에 대한 준비가 되어 있습니다. Node.js에서 파일로부터 데이터를 읽으려면, 이 섹션의 시작 부분에서 <code>fetchData()</code> 함수와 유사한 함수를 반환하는 <code>fs.readFile()</code>을 감싸는 래퍼를 생성해야합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">filename</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</div><div class="line">        fs.readFile(filename, callback);</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>readFile()</code> 메서드는 파라미터인 파일명을 받아들이고 콜백을 호출하는 함수를 반환합니다. 콜백은 <code>fs.readFile()</code> 메서드에 직접 전달되며, 메서드는 완료시 콜백을 실행합니다. 다음과 같이 <code>yield</code>를 사용하여 이 작업을 실행할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">run(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> contents = <span class="keyword">yield</span> readFile(<span class="string">"config.json"</span>);</div><div class="line">    doSomethingWith(contents);</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Done"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>이 예제는 주 코드에 콜백을 표시하지 않고 비동기 <code>readFile()</code> 연산을 수행합니다. <code>yield</code>와는 별도로, 코드는 동기 코드와 동일하게 보입니다. 비동기 작업을 수행하는 함수가 모두 동일한 인터페이스를 준수하는 한 동기 코드와 같은 로직을 작성할 수 있습니다.</p>
<p>물론,이 예제에서 사용된 패턴에는 단점이 있습니다. 즉, 함수를 반환하는 함수가 비동기인지 항상 확신할 수는 없습니다. 지금 당장은 실행중인 태스크 뒤에있는 이론을 이해하는 것이 중요합니다. <em>Promise</em>를 사용하면 비동기 작업을 예약하는 보다 강력한 방법이 제공되며 11 장에서는 이 주제에 대해 자세히 설명합니다.</p>
<h2 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h2><p><em>Iterator</em>는 ECMAScript 6의 중요한 부분이며 언어의 몇 가지 핵심 요소에 존재합니다. 표면적으로 <em>Iterator</em>는 간단한 API를 사용하여 일련의 값을 반환하는 방법을 제공합니다. 그러나 ECMAScript 6에서 <em>Iterator</em>를 사용하는 훨씬 더 복잡한 방법이 있습니다.</p>
<p><code>Symbol.iterator</code> <em>Symbol</em>은 객체의 기본 <em>Iterator</em>를 정의하는데 사용됩니다. <em>Built-in</em> 객체와 개발자 정의 객체는 모두 이 <em>Symbol</em>을 사용하여 <em>Iterator</em>를 반환하는 메서드를 제공할 수 있습니다. <code>Symbol.iterator</code>가 객체에 제공되면 객체는 <em>Iterable</em>한 것으로 간주됩니다.</p>
<p><code>for-of</code> 루프는 <em>Iterable</em>를 사용하여 루프에서 일련의 값을 반환합니다. <code>for-of</code>를 사용하면 더 이상 값을 추적할 필요가 없고 루프가 끝나는 시점을 제어할 필요가 없으므로 전통적인 <code>for</code> 루프를 반복하는 것보다 쉽습니다. <code>for-of</code> 루프는 <em>Iterator</em>에서 더 이상 값이 없을 때까지 모든 값을 자동으로 읽은 다음 종료합니다.</p>
<p><code>for-of</code>를 더 쉽게 사용하기 위해 ECMAScript 6의 많은 타입에는 기본 <em>Iterator</em>가 있습니다. 컬렉션, 즉 <em>Array</em>, <em>Map</em> 및 <em>Set</em>과 같은 모든 컬렉션 유형에는 내용에 쉽게 액세스할 수 있도록 설계된 <em>Iterator</em>가 있습니다. 문자열에는 기본 <em>Iterator</em>가 있어 <em>Code unit</em>이 아닌 문자열의 문자를 쉽게 반복할 수 있습니다.</p>
<p><em>Spread</em> 연산자는 모든 <em>Iterable</em> 함수에서 작동하며 <em>Iterable</em>를 <em>Array</em>로 쉽게 변환합니다. 변환은 <em>Iterator</em>에서 값을 읽어 <em>Array</em>에 개별적으로 삽입하여 작동합니다.</p>
<p><em>Generator</em>는 호출될 때 <em>Iterator</em>를 자동으로 생성하는 특수 함수입니다. <em>Generator</em> 정의는 별표(<code>*</code>) 문자로 표시되고 <code>yield</code> 키워드를 사용하여 <code>next()</code> 메서드를 연속적으로 호출할 때 반환할 값을 나타냅니다.</p>
<p><em>Generator</em> 위임은 새로운 <em>Generator</em>에서 기존 <em>Generator</em>를 재사용 하도록 함으로써 <em>Iterator</em> 동작을 잘 캡슐화하도록 합니다. <code>yield</code> 대신 <code>yield *</code>를 호출하여 다른 <em>Generator</em>의 기존 <em>Generator</em>를 사용할 수 있습니다. 이 프로세스를 통해 여러 <em>Iterator</em>의 값을 반환하는 <em>Iterator</em>를 만들 수 있습니다.</p>
<p>아마도 <em>Generator</em>와 <em>Iterator</em> 중 가장 흥미로운 부분은 보다 깨끗한 비동기 코드를 생성할 수 있다는 것입니다. 콜백을 사용하는 대신 동기식으로 보이는 코드가 실제로 <code>yield</code>를 사용하면 비동기 작업으로 완료될 때까지 대기합니다.</p>
<hr>
<blockquote>
<p>이 내용은 나중에 참고하기 위해 제가 공부하며 정리한 내용입니다.<br>의역, 오역, 직역이 있을 수 있음을 알려드립니다.<br>This post is a translation of this original article [<a href="https://leanpub.com/understandinges6/read#leanpub-auto-iterators-and-generators" target="_blank" rel="external">https://leanpub.com/understandinges6/read#leanpub-auto-iterators-and-generators</a>]</p>
</blockquote>
<h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul>
<li><a href="https://infoscis.github.io/2018/01/24/ecmascript-6-block-binding/">ECMAScript 6 Block Binding</a></li>
<li><a href="https://infoscis.github.io/2018/01/24/ecmascript-6-strings-and-regular-expressions/">ECMAScript 6 문자열과 정규 표현식</a></li>
<li><a href="https://infoscis.github.io/2018/01/24/ecmascript-6-functions/">ECMAScript 6 함수</a></li>
<li><a href="https://infoscis.github.io/2018/01/25/ecmascript-6-expanded-object-functionality/">ECMAScript 6 객체의 확장된 기능</a></li>
<li><a href="https://infoscis.github.io/2018/01/26/ecmascript-6-destructuring-for-easier-data-access/">ECMAScript 6 쉬운 데이터 액세스를 위한 Destructuring</a></li>
<li><a href="https://infoscis.github.io/2018/01/27/ecmascript-6-symbols-and-symbol-properties/">ECMAScript 6 Symbol과 Symbol 프로퍼티</a></li>
<li><a href="https://infoscis.github.io/2018/01/27/ecmascript-6-sets-and-maps/">ECMAScript 6 Set과 Map</a></li>
<li><a href="https://infoscis.github.io/2018/01/31/ecmascript-6-iterators-and-generators/">ECMAScript 6 Iterator와 Generator</a></li>
<li><a href="https://infoscis.github.io/2018/02/13/ecmascript-6-introducing-javascript-classes/">ECMAScript 6 JavaScript 클래스 소개</a></li>
<li><a href="https://infoscis.github.io/2018/02/13/ecmascript-6-improved-array-capabilities/">ECMAScript 6 Array 기능 향상</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-promises-and-asynchronous-programming/">ECMAScript 6 Promise와 비동기 프로그램밍</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-proxies-and-the-reflection-api/">ECMAScript 6 프록시와 리플렉션 API</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-encapsulating-code-with-modules/">ECMAScript 6 Module로 코드 캡슐화하기</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-appendix-a-smaller-changes/">ECMAScript 6 부록 A. 작은 변경 사항</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-appendix-b-understanding-ecmascript-7/">ECMAScript 6 부록 B. ECMAScript 7(2016) 이해하기</a></li>
</ul>

        </div>
        <footer class="article-footer">
            



    <a data-url="http://infoscis.github.io/2018/01/31/ecmascript-6-iterators-and-generators/" data-id="cjkl9rpwi00372guz42iienyu" class="article-share-link"><i class="fa fa-share"></i>공유하기</a>
<script>
    (function ($) {
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

        </footer>
    </div>
</article>

    <section id="comments">
    
        
    <div id="disqus_thread">
        <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>

    
    </section>


                        </div>
                    </section>
                    <aside id="sidebar">
    <a class="sidebar-toggle" title="Expand Sidebar"><i class="toggle icon"></i></a>
    <div class="sidebar-top">
        <p>팔로우:</p>
        <ul class="social-links">
            
                
                <li>
                    <a class="social-tooltip" title="github" href="https://github.com/infoscis" target="_blank">
                        <i class="icon fa fa-github"></i>
                    </a>
                </li>
                
            
        </ul>
    </div>
    
        
<nav id="article-nav">
    
        <a href="/2018/02/13/dynamic-content-in-angular/" id="article-nav-newer" class="article-nav-link-wrap">
        <strong class="article-nav-caption">새로운</strong>
        <p class="article-nav-title">
        
            Angular에서 동적 컨텐츠 생성
        
        </p>
        <i class="icon fa fa-chevron-right" id="icon-chevron-right"></i>
    </a>
    
    
        <a href="/2018/01/27/ecmascript-6-sets-and-maps/" id="article-nav-older" class="article-nav-link-wrap">
        <strong class="article-nav-caption">오래된</strong>
        <p class="article-nav-title">ECMAScript 6 Set과 Map</p>
        <i class="icon fa fa-chevron-left" id="icon-chevron-left"></i>
        </a>
    
</nav>

    
    <div class="widgets-container">
        
            
                
    <div class="widget-wrap">
        <h3 class="widget-title">최근 글</h3>
        <div class="widget">
            <ul id="recent-post" class="no-thumbnail">
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Angular/">Angular</a></p>
                            <p class="item-title"><a href="/2018/08/08/angular-observables-and-rxjs/" class="title">Angular Observable &amp; RxJS</a></p>
                            <p class="item-date"><time datetime="2018-08-08T14:38:02.000Z" itemprop="datePublished">2018-08-08</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/JavaScript/">JavaScript</a><i class="icon fa fa-angle-right"></i><a class="article-category-link" href="/categories/JavaScript/ECMAScript-2015/">ECMAScript 2015</a></p>
                            <p class="item-title"><a href="/2018/02/27/ecmascript-6-appendix-b-understanding-ecmascript-7/" class="title">ECMAScript 6 부록 B. ECMAScript 7 (2016) 이해하기</a></p>
                            <p class="item-date"><time datetime="2018-02-27T13:32:48.000Z" itemprop="datePublished">2018-02-27</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/JavaScript/">JavaScript</a><i class="icon fa fa-angle-right"></i><a class="article-category-link" href="/categories/JavaScript/ECMAScript-2015/">ECMAScript 2015</a></p>
                            <p class="item-title"><a href="/2018/02/27/ecmascript-6-appendix-a-smaller-changes/" class="title">ECMAScript 6 부록 A. 작은 변경 사항</a></p>
                            <p class="item-date"><time datetime="2018-02-27T13:32:12.000Z" itemprop="datePublished">2018-02-27</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/JavaScript/">JavaScript</a><i class="icon fa fa-angle-right"></i><a class="article-category-link" href="/categories/JavaScript/ECMAScript-2015/">ECMAScript 2015</a></p>
                            <p class="item-title"><a href="/2018/02/27/ecmascript-6-encapsulating-code-with-modules/" class="title">ECMAScript 6 Module로 코드 캡슐화하기</a></p>
                            <p class="item-date"><time datetime="2018-02-27T13:31:45.000Z" itemprop="datePublished">2018-02-27</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/JavaScript/">JavaScript</a><i class="icon fa fa-angle-right"></i><a class="article-category-link" href="/categories/JavaScript/ECMAScript-2015/">ECMAScript 2015</a></p>
                            <p class="item-title"><a href="/2018/02/27/ecmascript-6-proxies-and-the-reflection-api/" class="title">ECMAScript 6 프록시와 리플렉션 API</a></p>
                            <p class="item-date"><time datetime="2018-02-27T13:31:03.000Z" itemprop="datePublished">2018-02-27</time></p>
                        </div>
                    </li>
                
            </ul>
        </div>
    </div>

            
                
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">카테고리</h3>
        <div class="widget">
            <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Angular/">Angular</a><span class="category-list-count">15</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hadoop/">Hadoop</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">5</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/Java9/">Java9</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/Spring/">Spring</a><span class="category-list-count">2</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/">JavaScript</a><span class="category-list-count">16</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/ECMAScript-2015/">ECMAScript 2015</a><span class="category-list-count">15</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/TypeScript/">TypeScript</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Webpack/">Webpack</a><span class="category-list-count">1</span></li></ul>
        </div>
    </div>


            
                
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">아카이브</h3>
        <div class="widget">
            <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">8월 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">2월 2018</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">1월 2018</a><span class="archive-list-count">11</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">7월 2017</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">6월 2017</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">5월 2017</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">3월 2017</a><span class="archive-list-count">5</span></li></ul>
        </div>
    </div>


            
                
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">태그</h3>
        <div class="widget">
            <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Angular/">Angular</a><span class="tag-list-count">15</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ECMAScript-2015/">ECMAScript 2015</a><span class="tag-list-count">15</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Event/">Event</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hadoop/">Hadoop</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JDK9/">JDK9</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java9/">Java9</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript</a><span class="tag-list-count">29</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Jigsaw/">Jigsaw</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nashorn/">Nashorn</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/">Spring</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringBoot/">SpringBoot</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TypeScript/">TypeScript</a><span class="tag-list-count">12</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Webpack/">Webpack</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/YARN/">YARN</a><span class="tag-list-count">1</span></li></ul>
        </div>
    </div>


            
                
    <div class="widget-wrap widget-float">
        <h3 class="widget-title">태그 클라우드</h3>
        <div class="widget tagcloud">
            <a href="/tags/Angular/" style="font-size: 18px;">Angular</a> <a href="/tags/ECMAScript-2015/" style="font-size: 18px;">ECMAScript 2015</a> <a href="/tags/Event/" style="font-size: 10px;">Event</a> <a href="/tags/Hadoop/" style="font-size: 10px;">Hadoop</a> <a href="/tags/JDK9/" style="font-size: 12px;">JDK9</a> <a href="/tags/Java/" style="font-size: 14px;">Java</a> <a href="/tags/Java9/" style="font-size: 12px;">Java9</a> <a href="/tags/JavaScript/" style="font-size: 20px;">JavaScript</a> <a href="/tags/Jigsaw/" style="font-size: 12px;">Jigsaw</a> <a href="/tags/Nashorn/" style="font-size: 10px;">Nashorn</a> <a href="/tags/Spring/" style="font-size: 12px;">Spring</a> <a href="/tags/SpringBoot/" style="font-size: 10px;">SpringBoot</a> <a href="/tags/TypeScript/" style="font-size: 16px;">TypeScript</a> <a href="/tags/Webpack/" style="font-size: 10px;">Webpack</a> <a href="/tags/YARN/" style="font-size: 10px;">YARN</a>
        </div>
    </div>


            
        
    </div>
</aside>
                </div>
            </div>
        </div>
        <footer id="footer">
    <div class="container">
        <div class="container-inner">
            <a id="back-to-top" href="javascript:;"><i class="icon fa fa-angle-up"></i></a>
            <div class="credit">
                <h1 class="logo-wrap">
                    <a href="/" class="logo"></a>
                </h1>
                <p>&copy; 2018 Jongcheol-Kim</p>
                <p>Powered by <a href="//hexo.io/" target="_blank">Hexo</a>. Theme by <a href="//github.com/ppoffice" target="_blank">PPOffice</a></p>
            </div>
        </div>
    </div>
</footer>
        
    
    <script>
    var disqus_shortname = 'infoscis';
    
    
    var disqus_url = 'http://infoscis.github.io/2018/01/31/ecmascript-6-iterators-and-generators/';
    
    (function() {
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    </script>




    
        <script src="/libs/lightgallery/js/lightgallery.min.js"></script>
        <script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>
        <script src="/libs/lightgallery/js/lg-pager.min.js"></script>
        <script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>
        <script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>
        <script src="/libs/lightgallery/js/lg-zoom.min.js"></script>
        <script src="/libs/lightgallery/js/lg-hash.min.js"></script>
        <script src="/libs/lightgallery/js/lg-share.min.js"></script>
        <script src="/libs/lightgallery/js/lg-video.min.js"></script>
    
    
        <script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script>
    
    


<!-- Custom Scripts -->
<script src="/js/main.js"></script>

    </div>
</body>
</html>
