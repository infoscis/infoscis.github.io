<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    
    <title>Array 기능 향상 | Developer&#39;s Record</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
        <meta name="keywords" content="JavaScript,ECMAScript 2015" />
    
    <meta name="description" content="Array 기능 향상Array는 JavaScript의 기본 객체입니다. 그러나 JavaScript의 다른 부분은 시간이 지남에 따라 진화해 왔지만 Array는 ECMAScript 5가 사용하기 쉽도록 여러 가지 메서드를 도입할 때까지 동일하게 유지되었습니다. ECMAScript 6은 새로운 생성 메서드, 몇 가지 유용하고 편리한 메서드, Typed Arra">
<meta property="og:type" content="article">
<meta property="og:title" content="Array 기능 향상">
<meta property="og:url" content="http://infoscis.github.io/2018/02/13/ecmascript-6-improved-array-capabilities/index.html">
<meta property="og:site_name" content="Developer's Record">
<meta property="og:description" content="Array 기능 향상Array는 JavaScript의 기본 객체입니다. 그러나 JavaScript의 다른 부분은 시간이 지남에 따라 진화해 왔지만 Array는 ECMAScript 5가 사용하기 쉽도록 여러 가지 메서드를 도입할 때까지 동일하게 유지되었습니다. ECMAScript 6은 새로운 생성 메서드, 몇 가지 유용하고 편리한 메서드, Typed Arra">
<meta property="og:updated_time" content="2018-02-27T14:12:39.181Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Array 기능 향상">
<meta name="twitter:description" content="Array 기능 향상Array는 JavaScript의 기본 객체입니다. 그러나 JavaScript의 다른 부분은 시간이 지남에 따라 진화해 왔지만 Array는 ECMAScript 5가 사용하기 쉽도록 여러 가지 메서드를 도입할 때까지 동일하게 유지되었습니다. ECMAScript 6은 새로운 생성 메서드, 몇 가지 유용하고 편리한 메서드, Typed Arra">
    
    <link rel="canonical" href="http://infoscis.github.io/2018/02/13/ecmascript-6-improved-array-capabilities/"/>

    

    
        <link rel="icon" href="/favicon.png" />
    

    <link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="/libs/titillium-web/styles.css">
    <link rel="stylesheet" href="/libs/source-code-pro/styles.css">

    <link rel="stylesheet" href="/css/style.css">

    <script src="/libs/jquery/2.0.3/jquery.min.js"></script>
    
    
        <link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">
    
    
        <link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css">
    
    
        <script type="text/javascript">
(function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-100332906-1', 'auto');
ga('send', 'pageview');

</script>
    
    

</head>

<body>
    <div id="wrap">
        <header id="header">
    <div id="header-outer" class="outer">
        <div class="container">
            <div class="container-inner">
                <div id="header-title">
                    <h1 class="logo-wrap">
                        <a href="/" class="logo"></a>
                    </h1>
                    
                        <h2 class="subtitle-wrap">
                            <p class="subtitle">개발자의 기록 보관소</p>
                        </h2>
                    
                </div>
                <div id="header-inner" class="nav-container">
                    <a id="main-nav-toggle" class="nav-icon fa fa-bars"></a>
                    <div class="nav-container-inner">
                        <ul id="main-nav">
                            
                                <li class="main-nav-list-item" >
                                    <a class="main-nav-list-link" href="/">홈</a>
                                </li>
                            
                                        <ul class="main-nav-list"><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Angular/">Angular</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Hadoop/">Hadoop</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Java/">Java</a><ul class="main-nav-list-child"><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Java/Java9/">Java9</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Java/Spring/">Spring</a></li></ul></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/JavaScript/">JavaScript</a><ul class="main-nav-list-child"><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/JavaScript/ECMAScript-2015/">ECMAScript 2015</a></li></ul></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Kotlin/">Kotlin</a><ul class="main-nav-list-child"><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Kotlin/SpringBoot/">SpringBoot</a></li></ul></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/TypeScript/">TypeScript</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Webpack/">Webpack</a></li></ul>
                                    
                                <li class="main-nav-list-item" >
                                    <a class="main-nav-list-link" href="https://about.me/jongcheol.kim">About</a>
                                </li>
                            
                        </ul>
                        <nav id="sub-nav">
                            <div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="검색" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="Type something..." />
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '포스트',
            PAGES: 'Pages',
            CATEGORIES: '카테고리',
            TAGS: '태그',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div>
                        </nav>
                    </div>
                </div>
            </div>
        </div>
    </div>
</header>
        <div class="container">
            <div class="main-body container-inner">
                <div class="main-body-inner">
                    <section id="main">
                        <div class="main-body-header">
    <h1 class="header">
    
    <a class="page-title-link" href="/categories/JavaScript/">JavaScript</a><i class="icon fa fa-angle-right"></i><a class="page-title-link" href="/categories/JavaScript/ECMAScript-2015/">ECMAScript 2015</a>
    </h1>
</div>
                        <div class="main-body-content">
                            <article id="post-ecmascript-6-improved-array-capabilities" class="article article-single article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
            <header class="article-header">
                
    
        <h1 class="article-title" itemprop="name">
        Array 기능 향상
        </h1>
    

            </header>
        
        
            <div class="article-meta">
                
    <div class="article-date">
        <a href="/2018/02/13/ecmascript-6-improved-array-capabilities/" class="article-date">
            <time datetime="2018-02-13T14:50:12.000Z" itemprop="datePublished">2018-02-13</time>
        </a>
    </div>

                
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/ECMAScript-2015/">ECMAScript 2015</a>, <a class="tag-link" href="/tags/JavaScript/">JavaScript</a>
    </div>

            </div>
        
        
        <div class="article-entry" itemprop="articleBody">
            <h1 id="Array-기능-향상"><a href="#Array-기능-향상" class="headerlink" title="Array 기능 향상"></a>Array 기능 향상</h1><p><em>Array</em>는 JavaScript의 기본 객체입니다. 그러나 JavaScript의 다른 부분은 시간이 지남에 따라 진화해 왔지만 <em>Array</em>는 ECMAScript 5가 사용하기 쉽도록 여러 가지 메서드를 도입할 때까지 동일하게 유지되었습니다. ECMAScript 6은 새로운 생성 메서드, 몇 가지 유용하고 편리한 메서드, <em>Typed Array</em> 작성 기능과 같이 많은 기능을 추가하여 <em>Array</em>를 개선합니다.</p>
<h2 id="Array-생성하기"><a href="#Array-생성하기" class="headerlink" title="Array 생성하기"></a>Array 생성하기</h2><p>ECMAScript 6 이전에 <em>Array</em>를 생성하는 두 가지 기본 방법인 <code>Array</code> 생성자와 리터럴 구문이있었습니다. 두 방법 모두 <em>Array</em> 항목을 개별적으로 나열 해야하며 그렇지 않으면 상당히 제한적입니다. <em>Array</em>와 같은 객체 (즉, 숫자 인덱스와 <code>length</code> 프로퍼티를 가진 객체)를 <em>Array</em>로 변환하는 옵션도 제한되어 있으며 종종 추가 코드가 필요했습니다. JavaScript <em>Array</em>를 보다 쉽게 만들기 위해 ECMAScript 6은 <code>Array.of()</code>와 <code>Array.from ()</code> 메서드를 추가했습니다.</p>
<h3 id="Array-of-메서드"><a href="#Array-of-메서드" class="headerlink" title="Array.of() 메서드"></a>Array.of() 메서드</h3><p>ECMAScript 6이 JavaScript에 새로운 생성 메서드를 추가한 이유중 하나는 개발자가 <code>Array</code> 생성자를 사용하여 <em>Array</em>를 생성하는 것을 방지할 수 있다는 것입니다. <code>new Array()</code> 생성자는 실제로 전달된 인자의 타입과 개수에 따라 다르게 동작합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> items = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">2</span>);</div><div class="line"><span class="built_in">console</span>.log(items.length);          <span class="comment">// 2</span></div><div class="line"><span class="built_in">console</span>.log(items[<span class="number">0</span>]);              <span class="comment">// undefined</span></div><div class="line"><span class="built_in">console</span>.log(items[<span class="number">1</span>]);              <span class="comment">// undefined</span></div><div class="line"></div><div class="line">items = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"2"</span>);</div><div class="line"><span class="built_in">console</span>.log(items.length);          <span class="comment">// 1</span></div><div class="line"><span class="built_in">console</span>.log(items[<span class="number">0</span>]);              <span class="comment">// "2"</span></div><div class="line"></div><div class="line">items = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>, <span class="number">2</span>);</div><div class="line"><span class="built_in">console</span>.log(items.length);          <span class="comment">// 2</span></div><div class="line"><span class="built_in">console</span>.log(items[<span class="number">0</span>]);              <span class="comment">// 1</span></div><div class="line"><span class="built_in">console</span>.log(items[<span class="number">1</span>]);              <span class="comment">// 2</span></div><div class="line"></div><div class="line">items = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>, <span class="string">"2"</span>);</div><div class="line"><span class="built_in">console</span>.log(items.length);          <span class="comment">// 2</span></div><div class="line"><span class="built_in">console</span>.log(items[<span class="number">0</span>]);              <span class="comment">// 3</span></div><div class="line"><span class="built_in">console</span>.log(items[<span class="number">1</span>]);              <span class="comment">// "2"</span></div></pre></td></tr></table></figure>
<p><code>Array</code> 생성자가 하나의 숫자 값을 전달 받으면 <em>Array</em>의 <code>length</code> 프로퍼티는 그 값으로 설정됩니다. 숫자가 아닌 단일 값이 전달되면 해당 값은 <em>Array</em>의 유일한 항목이됩니다. 여러 값이 전달되면 (숫자 든 아니든) 해당 값은 <em>Array</em>의 항목이 됩니다. 전달되는 데이터의 유형을 항상 알지 못하기 때문에 이 동작은 혼란스럽고 위험합니다.</p>
<p>ECMAScript 6은 이 문제를 해결하기 위해 <code>Array.of()</code>를 도입했습니다. <code>Array.of ()</code> 메서드는 <code>Array</code> 생성자와 비슷하게 작동하지만 하나의 숫자 값에 대해서 특별한 경우가 없습니다. <code>Array.of()</code> 메서드는 파라미터의 개수나 타입에 상관없이 항상 파라미터를 포함하는 <em>Array</em>를 생성합니다. 다음은 <code>Array.of()</code> 메서드를 사용하는 예제들입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> items = <span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>);</div><div class="line"><span class="built_in">console</span>.log(items.length);          <span class="comment">// 2</span></div><div class="line"><span class="built_in">console</span>.log(items[<span class="number">0</span>]);              <span class="comment">// 1</span></div><div class="line"><span class="built_in">console</span>.log(items[<span class="number">1</span>]);              <span class="comment">// 2</span></div><div class="line"></div><div class="line">items = <span class="built_in">Array</span>.of(<span class="number">2</span>);</div><div class="line"><span class="built_in">console</span>.log(items.length);          <span class="comment">// 1</span></div><div class="line"><span class="built_in">console</span>.log(items[<span class="number">0</span>]);              <span class="comment">// 2</span></div><div class="line"></div><div class="line">items = <span class="built_in">Array</span>.of(<span class="string">"2"</span>);</div><div class="line"><span class="built_in">console</span>.log(items.length);          <span class="comment">// 1</span></div><div class="line"><span class="built_in">console</span>.log(items[<span class="number">0</span>]);              <span class="comment">// "2"</span></div></pre></td></tr></table></figure>
<p><code>Array.of()</code> 메서드로 <em>Array</em>를 생성하려면 <em>Array</em>에 원하는 값을 전달하면 됩니다. 여기서 첫 번째 예제는 두 개의 숫자를 포함하는 <em>Array</em>를 만들고 두 번째 <em>Array</em>는 한 개의 숫자를 포함하고 마지막 <em>Array</em>는 한 개의 문자열을 포함합니다. 이것은 <em>Array</em> 리터럴을 사용하는 것과 비슷하며, 대부분 네이티브 <em>Array</em> <code>Array.of()</code> 대신 <em>Array</em> 리터럴을 사용할 수 있습니다. 그러나 <code>Array</code> 생성자를 함수에 전달해야 한다면 일관된 동작을 보장하기 위해<code>Array.of()</code>를 대신 전달할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createArray</span>(<span class="params">arrayCreator, value</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> arrayCreator(value);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> items = createArray(<span class="built_in">Array</span>.of, value);</div></pre></td></tr></table></figure>
<p>이 코드에서 <code>createArray()</code> 함수는 <code>Array</code> 생성자 함수와 <em>Array</em>에 삽입할 값을 받아 들입니다. <code>Array.of()</code>를 <code>createArray()</code>의 첫번째 파라미터로 전달하여 새로운 <em>Array</em>를 만들 수 있습니다. <code>value</code>가 숫자가 아닐 것이라는 것을 보장할 수 없다면 <code>Array</code>를 직접 전달하는 것은 위험합니다.</p>
<blockquote>
<p><code>Array.of()</code> 메서드는 반환 값의 타입을 결정하기 위해 <code>Symbol.species</code> 프로퍼티 (9 장에서 설명됨)를 사용하지 않습니다. 대신 현재의 생성자 (<code>of()</code>메서드 내에 있는 <code>this</code>)를 사용하여 반환할 올바른 데이터 타입을 결정합니다.</p>
</blockquote>
<h3 id="Array-from-메서드"><a href="#Array-from-메서드" class="headerlink" title="Array.from() 메서드"></a>Array.from() 메서드</h3><p><em>Array</em>가 아닌 객체를 실제 <em>Array</em>로 변환하는 것은 JavaScript에서 항상 번거로운 작업이었습니다. 예를 들어, <em>Array</em>와 유사한<br> <code>arguments</code> 객체를 가지고 있고 <em>Array</em>처럼 사용하고 싶다면 먼저 변환해야합니다. <em>Array</em>와 유사한 객체를 ECMAScript 5의 <em>Array</em>로 변환하려고 다음 예제와 같은 함수를 작성합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeArray</span>(<span class="params">arrayLike</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> result = [];</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = arrayLike.length; i &lt; len; i++) &#123;</div><div class="line">        result.push(arrayLike[i]);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> args = makeArray(<span class="built_in">arguments</span>);</div><div class="line"></div><div class="line">    <span class="comment">// use args</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>이 방법은 수동으로 <code>result</code> <em>Array</em>를 만들고 <code>arguments</code>의 각 항목을 새로운 <em>Array</em>에 복사합니다. 이 방법이 효과가 있지만 비교적 간단한 작업을 수행하기 위해서 상당한 양의 코드가 필요합니다. 결국, 개발자들은 다음과 같이 <em>Array</em>와 유사한 객체에 <em>Array</em>의 Native <code>slice()</code> 메서드를 호출함으로써 코드의 양을 줄일 수 있다는 것을 발견했습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeArray</span>(<span class="params">arrayLike</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.slice.call(arrayLike);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> args = makeArray(<span class="built_in">arguments</span>);</div><div class="line"></div><div class="line">    <span class="comment">// use args</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>이 코드는 이전 예제와 기능적으로 동일하며, <code>slice()</code>에 대한 <code>this</code> 값을 <em>Array</em>와 유사한 객체로 설정하기 때문에 작동합니다. <code>slice()</code>는 숫자 인덱스와 <code>length</code> 프로퍼티만 있으면 올바르게 작동하기 때문에 <em>Array</em>와 유사한 객체가 잘 작동합니다.</p>
<p>이 기술은 타이핑이 덜 필요하지만 <code>Array.prototype.slice.call(arrayLike)</code> 호출은 분명히 <code>arrayLike</code>를 <em>Array</em>로 변환하지 않습니다. “다행히 ECMAScript 6은 <code>Array.from()</code> 메서드를 이용하여 객체를 <em>Array</em>로 변환하는 명백하고도 깨끗한 방법을 제공합니다.</p>
<p><em>Iterable</em> 또는 <em>Array</em>와 유사한 객체가 첫 번째 파라미터로 주어지면 <code>Array.from()</code> 메서드는 <em>Array</em>를 반환합니다. 다음은 간단한 예제입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>);</div><div class="line"></div><div class="line">    <span class="comment">// use args</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Array.from()</code> 호출은 <code>arguments</code>에 있는 항목을 기반으로 새로운 <em>Array</em>를 만듭니다. 그래서 <code>args</code>는 <code>arguments</code>와 같은 위치에 같은 값을 갖는 <code>Array</code>의 인스턴스입니다.</p>
<blockquote>
<p><code>Array.from()</code> 메서드는 <code>this</code>를 사용하여 반환할 <em>Array</em> 타입을 결정합니다.</p>
</blockquote>
<h4 id="매핑-변환-Mapping-Conversion"><a href="#매핑-변환-Mapping-Conversion" class="headerlink" title="매핑 변환 (Mapping Conversion)"></a>매핑 변환 (Mapping Conversion)</h4><p>한단계 더 나아가서 <em>Array</em> 변환을 원한다면 <code>Array.from()</code>에 매핑 함수를 두 번째 파라미터로 제공할 수 있습니다. 이 함수는 <em>Array</em>와 유사한 객체의 각 값에 대해 연산을 수행하고 결과를 최종 <em>Array</em>의 적절한 색인에 저장하기 전에 변환합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">translate</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>, (value) =&gt; value + <span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> numbers = translate(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(numbers);               <span class="comment">// 2,3,4</span></div></pre></td></tr></table></figure>
<p>여기서 <code>Array.from()</code>는 매핑 함수로 <code>(value) =&gt; value + 1</code>을 넘겨 주므로 항목을 저장하기 전에 <em>Array</em>의 각 항목에 1을 더합니다. 매핑 함수가 객체 상에 있다면, 매핑 함수를 위한 <code>this</code> 값을 <code>Array.from()</code>의 세 번째 파라미터에 선택적으로 전달할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> helper = &#123;</div><div class="line">    <span class="attr">diff</span>: <span class="number">1</span>,</div><div class="line"></div><div class="line">    add(value) &#123;</div><div class="line">        <span class="keyword">return</span> value + <span class="keyword">this</span>.diff;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">translate</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>, helper.add, helper);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> numbers = translate(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(numbers);               <span class="comment">// 2,3,4</span></div></pre></td></tr></table></figure>
<p>이 예제는 변환을 위한 매핑 함수로 <code>helper.add()</code>를 전달합니다. <code>helper.add()</code>는 <code>this.diff</code> 프로퍼티를 사용하기 때문에, <code>this</code>의 값을 지정하는 <code>Array.from()</code>에 세 번째 파라미터를 제공해야합니다. 세번째 파라미터 덕분에, <code>Array.from()</code>은 <code>bind()</code>를 호출하지 않거나 다른 방식으로 <code>this</code> 값을 지정하지 않고 쉽게 데이터를 변환할 수 있습니다.</p>
<h4 id="Iterables에서-사용하기"><a href="#Iterables에서-사용하기" class="headerlink" title="Iterables에서 사용하기"></a>Iterables에서 사용하기</h4><p><code>Array.from()</code> 메서드는 <em>Array</em>와 유사한 객체와 <em>Iterable</em>에서 실행가능합니다. 즉, 메서드는 <code>Symbol.iterator</code> 프로퍼티를 가진 객체를 <em>Array</em>로 변환할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> numbers = &#123;</div><div class="line">    *[<span class="built_in">Symbol</span>.iterator]() &#123;</div><div class="line">        <span class="keyword">yield</span> <span class="number">1</span>;</div><div class="line">        <span class="keyword">yield</span> <span class="number">2</span>;</div><div class="line">        <span class="keyword">yield</span> <span class="number">3</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> numbers2 = <span class="built_in">Array</span>.from(numbers, (value) =&gt; value + <span class="number">1</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(numbers2);              <span class="comment">// 2,3,4</span></div></pre></td></tr></table></figure>
<p><code>numbers</code> 객체는 <em>Iterable</em>이기 때문에 <code>numbers</code>를 직접 <code>Array.from()</code>에 전달하여 그 값을 <em>Array</em>로 변환할 수 있습니다. 매핑 함수는 각 숫자에 1을 더하여 결과 <em>Array</em>에 1, 2, 3 대신 2, 3, 4가 포함됩니다.</p>
<blockquote>
<p>객체가 <em>Array</em>와 유사하거나 <em>Iterable</em>한 경우 <code>Array.from()</code>에서 <em>Iterator</em>를 사용하여 변환할 값을 결정할 수 있습니다.</p>
</blockquote>
<h2 id="모든-Array에-대한-새로운-메서드"><a href="#모든-Array에-대한-새로운-메서드" class="headerlink" title="모든 Array에 대한 새로운 메서드"></a>모든 <em>Array</em>에 대한 새로운 메서드</h2><p>ECMAScript 5의 추세를 이어 가면서 ECMAScript 6는 <em>Array</em>에 몇가지 새로운 메서드를 추가했습니다. <code>find()</code> 및 <code>findIndex()</code> 메서드는 개발자가 <em>Array</em> 값을 사용하는 것을 돕기위한 것이지만, <code>fill()</code> 및 <code>copyWithin()</code>은 <em>Typed array</em>에 대한 유스 케이스에서 영감을 얻어 ECMAScript 6에 도입된 숫자만 사용하는 <em>Array</em> 형식입니다.</p>
<h3 id="find-및-findIndex-메서드"><a href="#find-및-findIndex-메서드" class="headerlink" title="find() 및 findIndex() 메서드"></a>find() 및 findIndex() 메서드</h3><p>ECMAScript 5 이전에는 <em>Array</em>를 검색하는 Built-in 메서드가 없었기 때문에 번거로운 작업이었습니다. ECMAScript 5에는 <code>indexOf()</code> 및 <code>lastIndexOf()</code> 메서드가 추가되었고, 개발자가 <em>Array</em> 내부의 특정 값을 검색할 수 있게되었습니다. 하지만 이 두가지 메서드는 크게 개선되었지만 한번에 하나의 값만 검색할 수 있어 상당히 제한적이었습니다. 예를 들어 일련의 숫자에서 첫번째 짝수를 찾으려면 코드를 직접 작성해야합니다. ECMAScript 6에서는 <code>find()</code> 및 <code>findIndex()</code> 메서드를 도입하여 이 문제를 해결했습니다.</p>
<p><code>find()</code>와 <code>findIndex()</code>는 두개의 파라미터를 받습니다(콜백함수와 콜백 함수 내에서 <code>this</code>에 사용할 선택적 값). 콜백 함수는 <em>Array</em>요소, <em>Array</em>에있는 해당 요소의 인덱스, <code>map()</code>과 <code>forEach()</code>와 같이 <em>Array</em> 자신을 전달하는 동일한 파라미터를 가집니다. 주어진 값이 당신이 정의한 어떤 기준과 일치하면 콜백은 <code>true</code>를 리턴해야합니다. <code>find()</code>와 <code>findIndex()</code>는 콜백 함수가 처음으로 <code>true</code>를 반환할 때 <em>Array</em> 검색을 중지합니다.</p>
<p>두 메서드의 유일한 차이점은 <code>find()</code>는 값을 반환하고 <code>findIndex()</code>는 값이 발견된 인덱스를 반환한다는 것입니다. 다음은 그 예를 보여줍니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> numbers = [<span class="number">25</span>, <span class="number">30</span>, <span class="number">35</span>, <span class="number">40</span>, <span class="number">45</span>];</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(numbers.find(<span class="function"><span class="params">n</span> =&gt;</span> n &gt; <span class="number">33</span>));         <span class="comment">// 35</span></div><div class="line"><span class="built_in">console</span>.log(numbers.findIndex(<span class="function"><span class="params">n</span> =&gt;</span> n &gt; <span class="number">33</span>));    <span class="comment">// 2</span></div></pre></td></tr></table></figure>
<p>이 <code>numbers</code> <em>Array</em>에서 33보다 큰 첫 번째 값을 찾기 위해 <code>find()</code>와 <code>findIndex()</code>를 호출합니다. <code>find()</code> 호출은 35를 반환하고<code>findIndex()</code>는 <code>numbers</code> <em>Array</em>에서 35의 위치인 2를 반환합니다.</p>
<p><code>find()</code>와 <code>findIndex()</code>는 값이 아닌 조건과 일치하는 <em>Array</em> 요소를 찾는 데 유용합니다. 하지만 값만을 찾고 싶다면 <code>indexOf()</code>와 <code>lastIndexOf()</code>가 더좋은 선택입니다.</p>
<h3 id="fill-메서드"><a href="#fill-메서드" class="headerlink" title="fill() 메서드"></a>fill() 메서드</h3><p><code>fill()</code> 메서드는 하나 이상의 <em>Array</em> 요소를 특정 값으로 채웁니다. 값이 전달되면, <code>fill()</code>은 <em>Array</em>의 모든 값을 그 값으로 덮어 씁니다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</div><div class="line"></div><div class="line">numbers.fill(<span class="number">1</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(numbers.toString());    <span class="comment">// 1,1,1,1</span></div></pre></td></tr></table></figure>
<p><code>numbers.fill(1)</code>을 호출하면 <code>numbers</code>의 모든 값이 1로 변경됩니다. 모든 요소가 아닌 일부 요소만 변경하려는 경우 시작 인덱스와 배타적 종료 인덱스(종료 인덱스는 포함되지 않음.)를 추가할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</div><div class="line"></div><div class="line">numbers.fill(<span class="number">1</span>, <span class="number">2</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(numbers.toString());    <span class="comment">// 1,2,1,1</span></div><div class="line"></div><div class="line">numbers.fill(<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(numbers.toString());    <span class="comment">// 1,0,0,1</span></div></pre></td></tr></table></figure>
<p><code>numbers.fill(1,2)</code>호출에서 2는 인덱스 2의 요소부터 채우는 것을 시작한다는 것을 나타냅니다. 배타적 종료 인덱스가 세 번째 파라미터로 지정되지 않으므로 <code>numbers.length</code>가 종료 인덱스로 사용됩니다 <code>numbers.fill(0, 1, 3)</code> 연산은 인덱스 1과 2의 <em>Array</em>요소를 0으로 채웁니다. 두 번째와 세 번째 인자로 <code>fill()</code>을 호출하면 전체 <em>Array</em>를 덮어 쓰지 않고 한 번에 여러 <em>Array</em> 요소를 채울 수 있습니다.</p>
<blockquote>
<p>시작 또는 끝 인덱스가 음수이면 <em>Array</em>의 길이에 해당 값이 추가되어 최종 위치가 결정됩니다. 예를 들어, <code>array</code>가 <code>fill()</code>이 호출되는 <em>Array</em>이고, 시작 인덱스가 <code>-1</code>이면 인덱스는 <code>array.length - 1</code>입니다.</p>
</blockquote>
<h3 id="copyWithin-메서드"><a href="#copyWithin-메서드" class="headerlink" title="copyWithin() 메서드"></a>copyWithin() 메서드</h3><p><code>copyWithin()</code> 메서드는 <em>Array</em>의 여러 요소를 동시에 변경한다는 점에서 <code>fill()</code>과 유사합니다. 그러나 <em>Array</em> 요소에 할당할 단일 값을 지정하는 대신 <code>copyWithin()</code>을 사용하면 <em>Array</em> 자체에서 <em>Array</em> 요소 값을 복사할 수 있습니다. 이를 수행하려면 <code>copyWithin()</code> 메서드에 두개의 파라미터, 즉 메서드가 값을 채우기 시작할 인덱스와 복사할 값이 시작되는 인덱스를 전달해야합니다.</p>
<p>예를 들어 <em>Array</em>의 처음 두 요소의 값을 <em>Array</em>의 마지막 두 항목에 복사하려면 다음 코드를 실행합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</div><div class="line"></div><div class="line"><span class="comment">// 인덱스 2부터 인덱스 0에 있는 값을 붙여 넣습니다.</span></div><div class="line">numbers.copyWithin(<span class="number">2</span>, <span class="number">0</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(numbers.toString());    <span class="comment">// 1,2,1,2</span></div></pre></td></tr></table></figure>
<p>이 코드는 인덱스 2에서 시작하는 값을 <code>numbers</code>에 붙여 넣기 때문에 인덱스 2와 3이 모두 덮어 쓰여집니다. <code>copyWithin()</code>의 두번째 파라미터로 <code>0</code>을 전달하면 인덱스 0에서 값을 복사하기 시작하고 복사할 요소가 없어질 때까지 계속 진행됩니다.</p>
<p>기본적으로, <code>copyWithin()</code>은 항상 <em>Array</em>의 끝까지 값을 복사하지만 선택적인 세번째 파라미터를 제공하면 덮어쓸 요소의 개수를 제한할 수 있습니다. 세번째 파라미터는 값 복사가 중지되는 배타적 종료 인덱스(종료 인덱스는 포함되지 않음.)입니다. 다음은 그 예제입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</div><div class="line"></div><div class="line"><span class="comment">// 인덱스 2번부터, 인덱스 0에 있는 값부터 인덱스 1번 이전 지점(0번 인덱스까지)까지의 값으로 채워 넣습니다.</span></div><div class="line">numbers.copyWithin(<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(numbers.toString());    <span class="comment">// 1,2,1,4</span></div></pre></td></tr></table></figure>
<p>이 예제에서는 선택적 종료 인덱스가 <code>1</code>로 설정되어 있기 때문에 인덱스 0의 값만 복사됩니다. <em>Array</em>의 마지막 요소는 변경되지 않습니다.</p>
<blockquote>
<p><code>fill()</code> 메서드와 마찬가지로 <code>copyWithin()</code> 메서드의 파라미터에 음수를 전달하면 <em>Array</em>의 길이가 자동으로 해당 값에 추가되어 인덱스를 결정합니다.</p>
</blockquote>
<p>이 시점에서 <code>fill()</code>과 <code>copyWithin()</code> 메서드의 이용 사례는 여러분에게 명확하지 않을 수도 있습니다. 이 메서드들은 <em>Typed array</em>에서 유래되었고 일관성을 위해 일반 <em>Array</em>에 추가 되었기 때문입니다. 그러나 다음 절에서 배우 겠지만, 숫자의 비트를 조작하기 위해 <em>Typed array</em>를 사용하면, 이 메서드들은 훨씬 더 유용합니다.</p>
<h2 id="Typed-Array"><a href="#Typed-Array" class="headerlink" title="Typed Array"></a>Typed Array</h2><p><em>Typed array</em>는 숫자 타입 (이름에서 암시하듯이 모든 타입이 아닌)을 처리하도록 설계된 특수 용도의 <em>Array</em>입니다. <em>Typed array</em>의 기원은 OpenGL ES 2.0의 port인 WebGL이며, <code>&lt;canvas&gt;</code> 엘리먼트가 있는 웹 페이지에서 사용하도록 설계되었습니다. <em>Typed array</em>는 JavaScript에서 빠른 비트 연산을 제공하기 위해 만들어졌습니다.</p>
<p>Native JavaScript의 대한 숫자 계산 연산은 WebGL에서 너무 느렸습니다. 왜냐하면 숫자가 64 비트 부동 소수점 포맷으로 저장되고 필요에 따라 32 비트 정수로 변환 되었기 때문입니다. 이 제한 사항을 우회하고 계산 연산에 더 나은 성능을 제공하기 위해 <em>Typed array</em>가 도입되었습니다. 개념은 모든 단일 숫자를 비트 <em>Array</em>처럼 취급할 수 있으므로 JavaScript <em>Array</em>에서 사용할 수있는 익숙한 메서드를 사용할 수 있다는 것입니다.</p>
<p>ECMAScript 6는 JavaScript 엔진 전반에 걸친 더 나은 호환성과 JavaScript <em>Array</em>와의 상호 운용성을 보장하기 위해 <em>Typed array</em>를 언어의 공식적인 부분으로 채택했습니다. ECMAScript 6 버전의 <em>Typed array</em>는  WebGL 버전과 완전히 똑같지는 않고, ECMAScript 6 버전을 WebGL 버전의 확장 버전으로 생각할 수 있습니다.</p>
<h3 id="숫자-데이터-타입-Numeric-Data-Types"><a href="#숫자-데이터-타입-Numeric-Data-Types" class="headerlink" title="숫자 데이터 타입(Numeric Data Types)"></a>숫자 데이터 타입(Numeric Data Types)</h3><p>JavaScript 숫자는 64 비트를 사용하여 숫자의 부동 소수점 표현을 저장하는 IEEE 754 형식으로 저장됩니다. 이 형식은 JavaScript에서 정수 및 부동 소수점을 모두 나타내며 두 형식 간의 변환은 숫자가 바뀌면서 자주 발생합니다. <em>Typed array</em>를 사용하면 아래의 8 가지 숫자 타입을 저장하고 조작할 수 있습니다.</p>
<ol>
<li>Signed 8-bit integer (int8)</li>
<li>Unsigned 8-bit integer (uint8)</li>
<li>Signed 16-bit integer (int16)</li>
<li>Unsigned 16-bit integer (uint16)</li>
<li>Signed 32-bit integer (int32)</li>
<li>Unsigned 32-bit integer (uint32)</li>
<li>32-bit float (float32)</li>
<li>64-bit float (float64)</li>
</ol>
<p>int8에 맞는 숫자를 일반적인 JavaScript Number 타입으로 나타내면 56 비트가 낭비됩니다. 이러한 비트는 추가 int8 값 또는 56 비트 미만을 필요로하는 다른 숫자를 저장하는 데 사용하는 것이 좋습니다. 비트를 보다 효율적으로 사용하는 것은 <em>Typed array</em>의 사용 예중 하나입니다.</p>
<p><em>Typed array</em>와 관련된 모든 연산 및 객체는 이 8 가지 데이터 타입을 중심으로 배치됩니다. 그러나 이들을 사용하려면 <em>Array Buffer</em>를 만들어 데이터를 저장해야합니다.</p>
<blockquote>
<p>이 책에서는 괄호 안에 보여준 약어들로 이 타입들을 언급할 것입니다. 이러한 약어는 실제 JavaScript 코드에는 나타나지 않습니다. 단지<br> 더 긴 설명들에 대한 약어 일뿐입니다.</p>
</blockquote>
<h3 id="Array-Buffer"><a href="#Array-Buffer" class="headerlink" title="Array Buffer"></a>Array Buffer</h3><p>모든 <em>Typed array</em>의 기초는 <em>Array Buffer</em>입니다. <em>Array Buffer</em>는 지정된 바이트 수를 포함할 수있는 메모리입니다. <em>Array Buffer</em>를 만드는 것은 C 언어에서 <code>malloc()</code>을 호출하여 메모리를 할당하는 것과 비슷합니다. 다음과 같이 <code>ArrayBuffer</code> 생성자를 사용하여 <em>Array Buffer</em>를 생성할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">10</span>);   <span class="comment">// 10 bytes 할당</span></div></pre></td></tr></table></figure>
<p><em>Array Buffer</em>가 생성자를 호출할 때 포함해야하는 바이트 수를 전달합니다. <code>let</code> 문장은 10 바이트 길이의 <em>Array Buffer</em>를 생성합니다. <em>Array Buffer</em>가 생성되면, <code>byteLength</code> 프로퍼티를 체크함으로써 바이트 수를 확인할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">10</span>);   <span class="comment">// 10 bytes 할당</span></div><div class="line"><span class="built_in">console</span>.log(buffer.byteLength);     <span class="comment">// 10</span></div></pre></td></tr></table></figure>
<p>또한 <code>slice()</code> 메서드를 사용하여 기존 <em>Array Buffer</em>의 일부를 포함하는 새로운 <em>Array Buffer</em>를 생성할 수 있습니다. <code>slice()</code> 메서드는 <em>Array</em>의 <code>slice()</code> 메서드와 같이 작동합니다. 여러분은 시작 인덱스와 끝 인덱스를 파라미터로 넘기고, 원래의 요소로 구성된 새로운 <code>ArrayBuffer</code> 인스턴스를 얻을수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">10</span>);   <span class="comment">// allocate 10 bytes</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">let</span> buffer2 = buffer.slice(<span class="number">4</span>, <span class="number">6</span>);</div><div class="line"><span class="built_in">console</span>.log(buffer2.byteLength);    <span class="comment">// 2</span></div></pre></td></tr></table></figure>
<p>위 코드에서, <code>buffer2</code>는 인덱스 4와 5에서 바이트를 추출하여 생성됩니다. 이 메소드의 <em>Array</em> 버전을 호출할 때와 마찬가지로 <code>slice()</code>의 두 번째 파라미터는 배타적(포함되지 않습니다.)입니다.</p>
<p>이렇게 저장 위치를 만들었지만 데이터를 쓸 수 없으면 별로 도움이되지 않습니다. 데이터를 쓰려면 <em>View</em>를 만들어야합니다.</p>
<blockquote>
<p><em>Array Buffer</em>는 항상 생성될 때 지정된 정확한 바이트 수를 나타냅니다. <em>Array Buffer</em> 내에 포함된 데이터는 변경할 수 있지만 <em>Array Buffer</em> 자체의 크기는 변경할 수 없습니다.</p>
</blockquote>
<h3 id="View를-사용하여-Array-Buffer-조작하기"><a href="#View를-사용하여-Array-Buffer-조작하기" class="headerlink" title="View를 사용하여 Array Buffer 조작하기"></a><em>View</em>를 사용하여 <em>Array Buffer</em> 조작하기</h3><p><em>Array Buffer</em>는 메모리 위치를 나타내며, <em>View</em>는 해당 메모리를 조작하는 데 사용할 인터페이스입니다. <em>View</em>는 <em>Array Buffer</em> 또는 <em>Array Buffer</em>의 하위 집합에서 작동하며 숫자 데이터 타입중 하나에 데이터를 읽고 씁니다. <code>DataView</code> 타입은 8개의 모든 숫자 데이터 타입에 대해 조작할 수있는 <em>Array Buffer</em>의 일반 <em>View</em>입니다.</p>
<p><code>DataView</code>를 사용하려면 먼저 <code>ArrayBuffer</code>의 인스턴스를 생성하고 그것을 사용하여 새로운 <code>DataView</code>를 만듭니다. 다음 예제를 살펴보겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">10</span>),</div><div class="line">    view = <span class="keyword">new</span> <span class="built_in">DataView</span>(buffer);</div></pre></td></tr></table></figure>
<p>이 예제의 <code>view</code> 객체는 <code>buffer</code>의 10 바이트 모두에 접근할 수 있습니다. 그리고 <em>Buffer</em>의 일부분에만 <em>View</em>를 생성할 수도 있습니다. 바이트의 시작 오프셋과 포함할 바이트 수를 선택적으로 입력가능합니다. 포함할 바이트 수를 입력하지 않으면, <code>DataView</code>는 기본적으로 시작 오프셋에서 버퍼 끝까지 선택됩니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">10</span>),</div><div class="line">    view = <span class="keyword">new</span> <span class="built_in">DataView</span>(buffer, <span class="number">5</span>, <span class="number">2</span>);      <span class="comment">// 5, 6번째 바이트를 포함합니다.</span></div></pre></td></tr></table></figure>
<p>여기서 <code>view</code>는 인덱스 5와 6의 바이트에서만 작동합니다. 이 방법을 사용하면 동일한 <em>Array Buffer</em>를 통해 여러 <em>View</em>를 만들 수 있습니다. 이는 전체 응용프로그램에서 필요에 따라 동적이 아닌 단일 메모리 위치를 사용하려는 경우 유용할 수 있습니다.</p>
<h4 id="View-정보-가져-오기"><a href="#View-정보-가져-오기" class="headerlink" title="View 정보 가져 오기"></a><em>View</em> 정보 가져 오기</h4><p>다음과 같은 읽기 전용 속성을 가져 와서 뷰에 대한 정보를 검색할 수 있습니다.</p>
<ul>
<li><code>buffer</code> - <em>View</em>가 연결된 <em>Array Buffer</em>입니다.</li>
<li><code>byteOffset</code> - 제공된 경우 <code>DataView</code> 생성자에 대한 두 번째 파라미터(기본값 : 0).</li>
<li><code>byteLength</code> - 제공된 경우 <code>DataView</code> 생성자에 대한 세 번째 파라미터(기본적으로 버퍼의 <code>byteLength</code>).</li>
</ul>
<p>이러한 프로퍼티를 사용하면 다음과 같이 <em>View</em>가 작동중인 위치를 정확하게 검사할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">10</span>),</div><div class="line">    view1 = <span class="keyword">new</span> <span class="built_in">DataView</span>(buffer),           <span class="comment">// cover all bytes</span></div><div class="line">    view2 = <span class="keyword">new</span> <span class="built_in">DataView</span>(buffer, <span class="number">5</span>, <span class="number">2</span>);     <span class="comment">// cover bytes 5 and 6</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(view1.buffer === buffer);       <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(view2.buffer === buffer);       <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(view1.byteOffset);              <span class="comment">// 0</span></div><div class="line"><span class="built_in">console</span>.log(view2.byteOffset);              <span class="comment">// 5</span></div><div class="line"><span class="built_in">console</span>.log(view1.byteLength);              <span class="comment">// 10</span></div><div class="line"><span class="built_in">console</span>.log(view2.byteLength);              <span class="comment">// 2</span></div></pre></td></tr></table></figure>
<p>이 코드는 전체 <em>Array Buffer</em>에 대한 <em>View</em>인 <code>view1</code>과 <em>Array Buffer</em>의 작은 섹션에 대해 작동하는 <code>view2</code>를 생성합니다. 이 <em>View</em>는 모두 동일한 <em>Array Buffer</em>에서 작동하기 때문에 동일한 <code>buffer</code> 프로퍼티를 갖습니다. 그러나 <code>byteOffset</code>과 <code>byteLength</code>는 각 <em>View</em>마다 다릅니다. 각 <em>View</em>가 작동하는 <em>Array Buffer</em> 부분을 반영합니다.</p>
<p>물론 메모리에 대한 정보만 읽는 것은 그다지 유용하지 않습니다. 이점을 얻으려면 해당 메모리에 데이터를 쓰고 해당 메모리에서 데이터를 읽을 수 있어야합니다.</p>
<h4 id="데이터-읽고-쓰기"><a href="#데이터-읽고-쓰기" class="headerlink" title="데이터 읽고 쓰기"></a>데이터 읽고 쓰기</h4><p>JavaScript의 8가지 숫자 데이터 타입 각각에 대해 <code>DataView</code> 프로토 타입에는 <em>Array Buffer</em>에서 데이터를 쓰는 메서드와 읽는 메서드가 있습니다. 메서드 이름은 모두 “set”또는 “get”로 시작하고 그 뒤에 데이터 타입 약어가 옵니다. 예를 들어 다음은 int8 및 uint8 값에서 작동할 수있는 읽기 및 쓰기 메서드 목록입니다.</p>
<ul>
<li><code>getInt8(byteOffset, littleEndian)</code> - <code>byteOffset</code>에서 시작하는 int8 읽기</li>
<li><code>setInt8(byteOffset, value, littleEndian)</code> - <code>byteOffset</code>에서 시작하는 int8 쓰기</li>
<li><code>getUint8(byteOffset, littleEndian)</code> - <code>byteOffset</code>에서 시작하는 uint8 읽기</li>
<li><code>setUint8(byteOffset, value, littleEndian)</code> - <code>byteOffset</code>에서 시작하는 uint8 쓰기</li>
</ul>
<p>“get” 메서드는 두개의 파라미터, 즉 읽을 바이트 오프셋과 값을 리틀 엔디안으로 읽어야하는지 여부를 나타내는 선택적 값을 사용합니다. (리틀 엔디안은 최하위 바이트가 마지막 바이트 대신에 바이트 0에 있음을 의미합니다.) “set” 메서드는 3 개의 파라미터, 즉 쓸 바이트 오프셋, 쓸 값, 그리고 값이 리틀 엔디안 형식으로 저장되어야 하는지를 나타냅니다.</p>
<p>8 비트 값과 함께 사용할 수있는 메서드만 보여 주었지만 16 비트 값과 32 비트 값에서 동일한 메서드를 사용할 수 있습니다. 각 이름의 <code>8</code>을 <code>16</code>또는 <code>32</code>로 바꾸면 됩니다. 모든 정수 메서드와 함께, <code>DataView</code>는 또한 부동 소수점 수에 대해 다음과 같은 읽기 및 쓰기 메서드를 가지고 있습니다.</p>
<ul>
<li><code>getFloat32(byteOffset, littleEndian)</code> - <code>byteOffset</code>에서 시작하는 float32 읽기</li>
<li><code>setFloat32(byteOffset, value, littleEndian)</code> - <code>byteOffset</code>에서 시작하는 float32 쓰기</li>
<li><code>getFloat64(byteOffset, littleEndian)</code> - <code>byteOffset</code>에서 시작하는 float64 읽기</li>
<li><code>setFloat64(byteOffset, value, littleEndian)</code> - <code>byteOffset</code>에서 시작하는 float64 쓰기</li>
</ul>
<p>“set”및 “get” 메서드는 다음 예제를 참고하십시오.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">2</span>),</div><div class="line">    view = <span class="keyword">new</span> <span class="built_in">DataView</span>(buffer);</div><div class="line"></div><div class="line">view.setInt8(<span class="number">0</span>, <span class="number">5</span>);</div><div class="line">view.setInt8(<span class="number">1</span>, <span class="number">-1</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(view.getInt8(<span class="number">0</span>));       <span class="comment">// 5</span></div><div class="line"><span class="built_in">console</span>.log(view.getInt8(<span class="number">1</span>));       <span class="comment">// -1</span></div></pre></td></tr></table></figure>
<p>이 코드는 2바이트 <em>Array Buffer</em>를 사용하여 두개의 int8 값을 저장합니다. 첫번째 값은 오프셋 0에서 설정되고 두번째 값은 오프셋 1에서 각 값이 전체 바이트 (8 비트)에 걸쳐 반영됩니다. 이러한 값은 나중에 <code>getInt8()</code> 메서드로 위치에서 읽을 수 있습니다. 이 예제에서는 int8 값을 사용하지만 8가지 숫자 타입중 하나를 해당 메서드와 함께 사용할 수 있습니다.</p>
<p><em>View</em>는 데이터가 이전에 저장된 방식에 관계없이 언제든지 어떤 형식으로든 읽고 쓸수 있기 때문에 흥미롭습니다. 예를 들어 두개의 int8 값을 쓰고 int16 메서드로 <em>Buffer</em>를 읽는 다음 예제를 살펴보겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">2</span>),</div><div class="line">    view = <span class="keyword">new</span> <span class="built_in">DataView</span>(buffer);</div><div class="line"></div><div class="line">view.setInt8(<span class="number">0</span>, <span class="number">5</span>);</div><div class="line">view.setInt8(<span class="number">1</span>, <span class="number">-1</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(view.getInt16(<span class="number">0</span>));      <span class="comment">// 1535</span></div><div class="line"><span class="built_in">console</span>.log(view.getInt8(<span class="number">0</span>));       <span class="comment">// 5</span></div><div class="line"><span class="built_in">console</span>.log(view.getInt8(<span class="number">1</span>));       <span class="comment">// -1</span></div></pre></td></tr></table></figure>
<p><code>view.getInt16(0)</code>에 대한 호출은 <em>View</em>의 모든 바이트를 읽고 그 바이트를 숫자 1535로 해석합니다. 왜 이런 일이 발생하는지 이해하려면 예제에서 각 <code>setInt8()</code>이 <em>Array Buffer</em>에 어떤 작업을 하는지 살펴 보면 됩니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">2</span>)      <span class="comment">// 0000000000000000</span></div><div class="line">view.setInt8(<span class="number">0</span>, <span class="number">5</span>);     <span class="comment">// 0000010100000000</span></div><div class="line">view.setInt8(<span class="number">1</span>, <span class="number">-1</span>);    <span class="comment">// 0000010111111111</span></div></pre></td></tr></table></figure>
<p><em>Array Buffer</em>는 모두 0 인 16비트로 시작합니다. <code>setInt8()</code>으로 첫번째 바이트에 <code>5</code>를 쓰면 8 비트 표현으로 00000101 입력됩니다. 두번째 바이트에 -1을 쓰면 해당 바이트의 모든 비트가 1로 설정되며, 이는 -1의 2의 보수 표현입니다. 두번째 <code>setInt8()</code>호출 후에, <em>Array Buffer</em>는 16비트를 포함하고, <code>getInt16()</code>은 그 비트들을 십진수로 1535인 하나의 16비트 정수로 읽습니다.</p>
<p><code>DataView</code> 객체는 이런식으로 다른 데이터 타입을 혼합하여 사용하는 경우에 유용합니다. 그러나 하나의 특정 데이터 타입만 사용하는 경우 타입 특화 <em>View</em>가 더 나은 선택일 수 있습니다.</p>
<h4 id="Typed-Array는-View입니다"><a href="#Typed-Array는-View입니다" class="headerlink" title="Typed Array는 View입니다."></a><em>Typed Array</em>는 <em>View</em>입니다.</h4><p>ECMAScript 6 <em>Typed Array</em>는 실제로 <em>Array Buffer</em>의 타입별 <em>View</em>입니다. 일반 <code>DataView</code> 객체를 사용하여 <em>Array Buffer</em>를 조작하는 대신 특정 데이터 타입을 적용하는 객체를 사용할 수 있습니다. 8 개의 숫자 데이터 타입에 해당하는 8 개의 타입별 <em>View</em>와 <code>uint8</code> 값에 대한 추가 옵션이 있습니다.</p>
<p>아래 표에서는 ECMAScript 6 사양의 타입별 <em>View</em>의 전체 목록을 간략하게 보여줍니다.</p>
<table>
<thead>
<tr>
<th>생성자 이름</th>
<th>크기 (byte)</th>
<th>설명</th>
<th>C언어의 동일 타입</th>
</tr>
</thead>
<tbody>
<tr>
<td>Int8Array</td>
<td>1</td>
<td>8-bit 부호있는 정수</td>
<td>signed char</td>
</tr>
<tr>
<td>Uint8Array</td>
<td>1</td>
<td>8-bit 부호없는 정수</td>
<td>unsigned char</td>
</tr>
<tr>
<td>Uint8ClampedArray</td>
<td>1</td>
<td>8-bit 부호없는 정수 (값 범위가 0~255로 제한됨)</td>
<td>unsigned char</td>
</tr>
<tr>
<td>Int16Array</td>
<td>2</td>
<td>16-bit 부호있는 정수</td>
<td>short</td>
</tr>
<tr>
<td>Uint16Array</td>
<td>2</td>
<td>16-bit 부호없는 정수</td>
<td>unsigned short</td>
</tr>
<tr>
<td>Int32Array</td>
<td>4</td>
<td>32-bit 부호있는 정수</td>
<td>int</td>
</tr>
<tr>
<td>Uint32Array</td>
<td>4</td>
<td>32-bit 부호없는 정수</td>
<td>int</td>
</tr>
<tr>
<td>Float32Array</td>
<td>4</td>
<td>32-bit IEEE 부동 소수점</td>
<td>float</td>
</tr>
<tr>
<td>Float64Array</td>
<td>8</td>
<td>64-bit IEEE 부동 소수점</td>
<td>double</td>
</tr>
</tbody>
</table>
<p>왼쪽 열은 <em>Typed Array</em> 생성자를 나열하고 다른 열은 <em>Typed Array</em>에 포함할 수있는 데이터를 설명합니다. <code>Uint8ClampedArray</code>는 <em>Array Buffer</em>의 값이 0보다 작거나 255보다 크지 않으면 <code>Uint8Array</code>와 같습니다. <code>Uint8ClampedArray</code>는 0보다 작은 값을 0으로 변환하고(-1은 0이되고) 255보다 큰 값은 255로 변환합니다(300은 255가됩니다).</p>
<p><em>Typed Array</em> 연산은 특정 타입의 데이터에서만 작동합니다. 예를 들어 <code>Int8Array</code>의 모든 연산은 <code>int8</code> 값을 사용합니다. <em>Typed Array</em>의 요소 크기는 <em>Array</em>의 타입에 따라 다릅니다. <code>Int8Array</code>의 요소는 한 바이트 길이이고, <code>Float64Array</code> 요소는 8바이트를 사용합니다. 다행스럽게도 요소는 일반 <em>Array</em>처럼 숫자 인덱스를 사용하여 액세스하므로 <code>DataView</code>의 “set”및 “get” 메서드에 대한 다소 어색한 호출을 피할 수 있습니다.</p>
<h4 id="요소-크기"><a href="#요소-크기" class="headerlink" title="요소 크기"></a>요소 크기</h4><p><em>Typed Array</em>는 여러 요소로 구성되며 요소 크기는 각 요소가 나타내는 바이트 수입니다. 이 값은 각 생성자 및 각 인스턴스의 <code>BYTES_PER_ELEMENT</code> 프로퍼티에 저장되므로 요소 크기를 쉽게 확인할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(UInt8Array.BYTES_PER_ELEMENT);      <span class="comment">// 1</span></div><div class="line"><span class="built_in">console</span>.log(UInt16Array.BYTES_PER_ELEMENT);     <span class="comment">// 2</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> ints = <span class="keyword">new</span> <span class="built_in">Int8Array</span>(<span class="number">5</span>);</div><div class="line"><span class="built_in">console</span>.log(ints.BYTES_PER_ELEMENT);            <span class="comment">// 1</span></div></pre></td></tr></table></figure>
<h4 id="타입-특화-View-만들기"><a href="#타입-특화-View-만들기" class="headerlink" title="타입 특화 View 만들기"></a>타입 특화 <em>View</em> 만들기</h4><p><em>Typed Array</em> 생성자는 여러개의 파라미터를 허용하므로 <em>Typed Array</em>를 만드는 데는 몇 가지 방법이 있습니다. 먼저, <code>DataView</code>에서 사용하는 것과 동일한 파라미터 (<em>Array Buffer</em>, 선택적 바이트 오프셋 및 선택적 바이트 길이)를 전달하여 새로운 <em>Typed Array</em>를 만들 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">10</span>),</div><div class="line">    view1 = <span class="keyword">new</span> <span class="built_in">Int8Array</span>(buffer),</div><div class="line">    view2 = <span class="keyword">new</span> <span class="built_in">Int8Array</span>(buffer, <span class="number">5</span>, <span class="number">2</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(view1.buffer === buffer);       <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(view2.buffer === buffer);       <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(view1.byteOffset);              <span class="comment">// 0</span></div><div class="line"><span class="built_in">console</span>.log(view2.byteOffset);              <span class="comment">// 5</span></div><div class="line"><span class="built_in">console</span>.log(view1.byteLength);              <span class="comment">// 10</span></div><div class="line"><span class="built_in">console</span>.log(view2.byteLength);              <span class="comment">// 2</span></div></pre></td></tr></table></figure>
<p>이 코드에서 두 개의 <em>View</em>는 모두 <code>buffer</code>를 사용하는 두 개의 <code>Int8Array</code> 인스턴스입니다. <code>view1</code>과 <code>view2</code>는 <code>DataView</code> 인스턴스 상에 존재하는<code>buffer</code>, <code>byteOffset</code>, <code>byteLength</code> 프로퍼티와 같습니다. 하나의 숫자 타입으로만 작업하면 <code>DataView</code>를 사용할 때 <em>Typed Array</em>를 사용하는 것으로 쉽게 전환할 수 있습니다.</p>
<p><em>Typed Array</em>를 만드는 두 번째 방법은 숫자 하나를 생성자에 전달하는 것입니다. 이 숫자는 <em>Array</em>에 할당할 요소 개수 (바이트가 아님)를 나타냅니다. 생성자는 <em>Array</em> 요소의 개수를 나타내는 올바른 바이트 수를 가진 새로운 <em>Buffer</em>를 만들고 <code>length</code> 프로퍼티를 사용하여 <em>Array</em>의 요소 개수를 액세스할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> ints = <span class="keyword">new</span> <span class="built_in">Int16Array</span>(<span class="number">2</span>),</div><div class="line">    floats = <span class="keyword">new</span> <span class="built_in">Float32Array</span>(<span class="number">5</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(ints.byteLength);       <span class="comment">// 4</span></div><div class="line"><span class="built_in">console</span>.log(ints.length);           <span class="comment">// 2</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(floats.byteLength);     <span class="comment">// 20</span></div><div class="line"><span class="built_in">console</span>.log(floats.length);         <span class="comment">// 5</span></div></pre></td></tr></table></figure>
<p><code>ints</code> <em>Array</em>는 두 요소를 위한 공간을 가지고 생성됩니다. 각 16 비트 정수는 값 당 2바이트를 필요로하므로 <em>Array</em>에는 4 바이트가 할당됩니다. <code>floats</code> <em>Array</em>는 5개의 원소를 저장하기 위해 만들어지므로 필요한 바이트 수는 20개 (요소 당 4 바이트)입니다. 두 경우 모두 새로운 <em>Buffer</em>가 생성되고 필요할 경우 <code>buffer</code> 프로퍼티를 사용하여 액세스 할 수 있습니다.</p>
<blockquote>
<p><em>Typed Array</em> 생성자에 파라미터가 전달되지 않으면 생성자는 <code>0</code>이 전달된 것처럼 작동합니다. 이렇게하면 0바이트가 <em>Buffer</em>에 할당되므로 데이터를 저장할 수 없는 <em>Typed Array</em>가 만들어집니다.</p>
</blockquote>
<p><em>Typed Array</em>을 만드는 세 번째 방법은 객체를 파라미터로 생성자에 전달하는 것입니다. 객체는 다음 중 하나일 수 있습니다.</p>
<ul>
<li><em>Typed Array</em> - 각 요소는 입력된 새로운 <em>Array</em>의 새 요소에 복사됩니다. 예를 들어 int8을 <code>Int16Array</code> 생성자에 전달하면 int8 값이 int16 <em>Array</em>에 복사됩니다. 새 <em>Typed Array</em>에는 전달된 <em>Array Buffer</em>와 다른 <em>Array Buffer</em>가 사용됩니다.</li>
<li><em>Iterable</em> - 객체의 <em>Iterator</em>가 호출되어 입력된 <em>Array</em>에 삽입할 항목을 검색합니다. <em>View</em> 타입에 대해 유효하지 않은 요소가 있으면 생성자에서 오류가 발생합니다.</li>
<li><em>Array</em> - <em>Array</em> 요소가 새로운 <em>Typed Array</em>로 복사됩니다. 타입에 대해 유효하지 않은 요소가 있으면 생성자에서 오류가 발생합니다.</li>
<li>유사 <em>Array</em> 객체 - <em>Array</em>와 동일하게 작동합니다.</li>
</ul>
<p>이 경우 각각 소스 객체의 데이터로 새로운 <em>Typed Array</em>가 만들어집니다. 이것은 다음과 같이 일부 값으로 입력된 <em>Array</em>를 초기화하려는 경우에 특히 유용할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> ints1 = <span class="keyword">new</span> <span class="built_in">Int16Array</span>([<span class="number">25</span>, <span class="number">50</span>]),</div><div class="line">    ints2 = <span class="keyword">new</span> <span class="built_in">Int32Array</span>(ints1);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(ints1.buffer === ints2.buffer);     <span class="comment">// false</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(ints1.byteLength);      <span class="comment">// 4</span></div><div class="line"><span class="built_in">console</span>.log(ints1.length);          <span class="comment">// 2</span></div><div class="line"><span class="built_in">console</span>.log(ints1[<span class="number">0</span>]);              <span class="comment">// 25</span></div><div class="line"><span class="built_in">console</span>.log(ints1[<span class="number">1</span>]);              <span class="comment">// 50</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(ints2.byteLength);      <span class="comment">// 8</span></div><div class="line"><span class="built_in">console</span>.log(ints2.length);          <span class="comment">// 2</span></div><div class="line"><span class="built_in">console</span>.log(ints2[<span class="number">0</span>]);              <span class="comment">// 25</span></div><div class="line"><span class="built_in">console</span>.log(ints2[<span class="number">1</span>]);              <span class="comment">// 50</span></div></pre></td></tr></table></figure>
<p>이 예제는 <code>Int16Array</code>를 생성하고 두개의 값을 가지는 <em>Array</em>로 초기화합니다. 그런 다음 <code>Int32Array</code>가 만들어지고 <code>Int16Array</code>가 전달됩니다. 값 25와 50은 두 개의 <em>Typed Array</em>가 완전히 별도의 <em>Buffer</em>를 가지므로 <code>ints1</code>에서 <code>ints2</code>로 복사됩니다. 동일한 숫자는 두 입력된 <em>Array</em> 모두에 표시되지만 <code>ints2</code>는 데이터를 나타내는 데 8바이트를 사용하고 <code>ints1</code>는 4바이트를 사용합니다.</p>
<h2 id="Typed-Array와-기존-Array의-유사점"><a href="#Typed-Array와-기존-Array의-유사점" class="headerlink" title="Typed Array와 기존 Array의 유사점"></a><em>Typed Array</em>와 기존 <em>Array</em>의 유사점</h2><p><em>Typed Array</em>와 일반 <em>Array</em>는 여러 가지면에서 비슷합니다. 이 장에서 이미 살펴본 것처럼 많은 경우 <em>Typed Array</em>를 일반 <em>Array</em> 처럼 사용할 수 있습니다. 예를 들어 <code>length</code> 프로퍼티를 사용하여 입력된 <em>Array</em>에 있는 요소의 수를 확인할 수 있으며 숫자 인덱스를 사용하여 입력된 <em>Array</em>의 요소에 직접 액세스할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> ints = <span class="keyword">new</span> <span class="built_in">Int16Array</span>([<span class="number">25</span>, <span class="number">50</span>]);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(ints.length);          <span class="comment">// 2</span></div><div class="line"><span class="built_in">console</span>.log(ints[<span class="number">0</span>]);              <span class="comment">// 25</span></div><div class="line"><span class="built_in">console</span>.log(ints[<span class="number">1</span>]);              <span class="comment">// 50</span></div><div class="line"></div><div class="line">ints[<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">ints[<span class="number">1</span>] = <span class="number">2</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(ints[<span class="number">0</span>]);              <span class="comment">// 1</span></div><div class="line"><span class="built_in">console</span>.log(ints[<span class="number">1</span>]);              <span class="comment">// 2</span></div></pre></td></tr></table></figure>
<p>이 코드에서는 두개의 요소가 있는 새로운 <code>Int16Array</code>이 만들어집니다. 요소은 숫자 인덱스를 사용하여 읽고 쓰며 작업의 일부로 값이 자동으로 저장되고 int16 값으로 변환됩니다. 유사점은 거기서 끝나지 않습니다.</p>
<blockquote>
<p>일반 <em>Array</em>와 달리 <code>length</code> 프로퍼티를 사용하여 입력된 <em>Array</em>의 크기를 변경할 수 없습니다. <code>length</code> 프로퍼티는 쓰기가 가능하지 않으므로 이를 변경하려는 시도는 non-strict 모드에서 무시되고 strict 모드에서 오류가 발생합니다.</p>
</blockquote>
<h3 id="공통-메서드"><a href="#공통-메서드" class="headerlink" title="공통 메서드"></a>공통 메서드</h3><p><em>Typed Array</em>에는 일반 <em>Array</em> 메서드와 기능적으로 동일한 많은 메서드가 포함되어 있습니다. <em>Typed Array</em>에서도 다음 <em>Array</em> 메서드를 사용할 수 있습니다.</p>
<ul>
<li><code>copyWithin()</code></li>
<li><code>entries()</code></li>
<li><code>fill()</code></li>
<li><code>filter()</code></li>
<li><code>find()</code></li>
<li><code>findIndex()</code></li>
<li><code>forEach()</code></li>
<li><code>indexOf()</code></li>
<li><code>join()</code></li>
<li><code>keys()</code></li>
<li><code>lastIndexOf()</code></li>
<li><code>map()</code></li>
<li><code>reduce()</code></li>
<li><code>reduceRight()</code></li>
<li><code>reverse()</code></li>
<li><code>slice()</code></li>
<li><code>some()</code></li>
<li><code>sort()</code></li>
<li><code>values()</code></li>
</ul>
<p>이 메서드들은 <code>Array.prototype</code>과 유사하지만 정확히 동일하지는 않습니다. <em>Typed Array</em> 메서드는 숫자 타입 안전성에 대한 추가 검사를 수행하며 <em>Array</em>가 반환되면 일반 <em>Array</em> 대신 <em>Typed Array</em>를 반환합니다 (<code>Symbol.species</code> 때문에). 다음은 그 차이를 보여주는 간단한 예입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> ints = <span class="keyword">new</span> <span class="built_in">Int16Array</span>([<span class="number">25</span>, <span class="number">50</span>]),</div><div class="line">    mapped = ints.map(<span class="function"><span class="params">v</span> =&gt;</span> v * <span class="number">2</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(mapped.length);        <span class="comment">// 2</span></div><div class="line"><span class="built_in">console</span>.log(mapped[<span class="number">0</span>]);            <span class="comment">// 50</span></div><div class="line"><span class="built_in">console</span>.log(mapped[<span class="number">1</span>]);            <span class="comment">// 100</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(mapped <span class="keyword">instanceof</span> <span class="built_in">Int16Array</span>);  <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>이 코드는 <code>map()</code> 메서드를 사용하여 <code>ints</code>의 값을 기반으로 새로운 <em>Array</em>를 만듭니다. 매핑 함수는 <em>Array</em>의 각 값을 두 배로 늘리고 새로운 <code>Int16Array</code>를 반환합니다.</p>
<h3 id="동일한-Iterator"><a href="#동일한-Iterator" class="headerlink" title="동일한 Iterator"></a>동일한 <em>Iterator</em></h3><p><em>Typed Array</em>에는 일반 <em>Array</em>와 동일한 3 개의 <em>Iterator</em>가 있습니다. 그것들은 <code>entries()</code>, <code>keys()</code>, <code>values()</code> 메서드입니다. 즉 일반 <em>Array</em>에서와 마찬가지로 <em>Spread</em> 연산자와 <code>for-of</code> 루프를 사용할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> ints = <span class="keyword">new</span> <span class="built_in">Int16Array</span>([<span class="number">25</span>, <span class="number">50</span>]),</div><div class="line">    intsArray = [...ints];</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(intsArray <span class="keyword">instanceof</span> <span class="built_in">Array</span>);    <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(intsArray[<span class="number">0</span>]);                  <span class="comment">// 25</span></div><div class="line"><span class="built_in">console</span>.log(intsArray[<span class="number">1</span>]);                  <span class="comment">// 50</span></div></pre></td></tr></table></figure>
<p>이 코드는 <em>Typed Array</em> <code>ints</code>와 동일한 데이터를 포함하는 새로운 <em>Array</em> <code>intsArray</code>를 만듭니다. 다른 <em>Iterable</em>과 마찮가지로 <em>Spread</em> 연산자는 <em>Typed Array</em>를 일반 <em>Array</em>로 쉽게 변환합니다.</p>
<h3 id="of-와-from-메서드"><a href="#of-와-from-메서드" class="headerlink" title="of()와 from() 메서드"></a>of()와 from() 메서드</h3><p>마지막으로, 모든 <em>Typed Array</em>에는 <code>Array.of()</code> 및 <code>Array.from()</code> 메서드와 같은 정적 메서드 <code>of()</code> 및 <code>from()</code>이 있습니다. 차이점은 <em>Typed Array</em>의 메서드는 일반 <em>Array</em> 대신 <em>Typed Array</em>를 반환한다는 것입니다. 다음은 이러한 메서드를 사용하여 <em>Typed Array</em>를 만드는 몇 가지 예제입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> ints = <span class="built_in">Int16Array</span>.of(<span class="number">25</span>, <span class="number">50</span>),</div><div class="line">    floats = <span class="built_in">Float32Array</span>.from([<span class="number">1.5</span>, <span class="number">2.5</span>]);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(ints <span class="keyword">instanceof</span> <span class="built_in">Int16Array</span>);        <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(floats <span class="keyword">instanceof</span> <span class="built_in">Float32Array</span>);    <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(ints.length);       <span class="comment">// 2</span></div><div class="line"><span class="built_in">console</span>.log(ints[<span class="number">0</span>]);           <span class="comment">// 25</span></div><div class="line"><span class="built_in">console</span>.log(ints[<span class="number">1</span>]);           <span class="comment">// 50</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(floats.length);     <span class="comment">// 2</span></div><div class="line"><span class="built_in">console</span>.log(floats[<span class="number">0</span>]);         <span class="comment">// 1.5</span></div><div class="line"><span class="built_in">console</span>.log(floats[<span class="number">1</span>]);         <span class="comment">// 2.5</span></div></pre></td></tr></table></figure>
<p>이 예제의 <code>of()</code> 및 <code>from()</code> 메서드는 각각 <code>Int16Array</code> 및 <code>Float32Array</code>를 만드는데 사용합니다. 이러한 방법을 통해 <em>Typed Array</em>를 일반 <em>Array</em>처럼 쉽게 만들 수 있습니다.</p>
<h2 id="Typed-Array와-기존-Array의-차이점"><a href="#Typed-Array와-기존-Array의-차이점" class="headerlink" title="Typed Array와 기존 Array의 차이점"></a><em>Typed Array</em>와 기존 <em>Array</em>의 차이점</h2><p><em>Typed Array</em>와 일반 <em>Array</em>의 가장 중요한 차이점은 <em>Typed Array</em>는 일반 <em>Array</em>가 아니라는 것입니다. <em>Typed Array</em>는 <code>Array</code>로부터 상속받지 않으며 <code>Array.isArray()</code>는 <em>Typed Array</em>를 전달할 때 <code>false</code>를 반환합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> ints = <span class="keyword">new</span> <span class="built_in">Int16Array</span>([<span class="number">25</span>, <span class="number">50</span>]);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(ints <span class="keyword">instanceof</span> <span class="built_in">Array</span>);     <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(ints));       <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p><code>ints</code> 변수는 <em>Typed Array</em>이므로 <code>Array</code>의 인스턴스가 아니며 그렇기 때문에 <em>Array</em>로 식별될 수 없습니다. <em>Typed Array</em>와 일반 <em>Array</em>는 비슷하지만 <em>Typed Array</em>가 다르게 동작하는 몇가지 메서드가 있기 때문에 이 구분은 매우 중요합니다.</p>
<h3 id="작동-방법상의-차이점"><a href="#작동-방법상의-차이점" class="headerlink" title="작동 방법상의 차이점"></a>작동 방법상의 차이점</h3><p>일반 <em>Array</em>는 상호 작용할 때 확장 및 축소될 수 있지만 <em>Typed Array</em>는 항상 동일한 크기를 유지합니다. 일반 <em>Array</em> 처럼 <em>Typed Array</em>의 존재하지 않는 숫자 인덱스에 값을 할당할 때 그 작업은 무시됩니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> ints = <span class="keyword">new</span> <span class="built_in">Int16Array</span>([<span class="number">25</span>, <span class="number">50</span>]);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(ints.length);          <span class="comment">// 2</span></div><div class="line"><span class="built_in">console</span>.log(ints[<span class="number">0</span>]);              <span class="comment">// 25</span></div><div class="line"><span class="built_in">console</span>.log(ints[<span class="number">1</span>]);              <span class="comment">// 50</span></div><div class="line"></div><div class="line">ints[<span class="number">2</span>] = <span class="number">5</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(ints.length);          <span class="comment">// 2</span></div><div class="line"><span class="built_in">console</span>.log(ints[<span class="number">2</span>]);              <span class="comment">// undefined</span></div></pre></td></tr></table></figure>
<p>이 예제에서 숫자 인덱스 <code>2</code>에 <code>5</code>를 할당하더라도 <code>ints</code> <em>Array</em>는 전혀 증가하지 않습니다. <code>length</code>는 동일하게 유지되고 값은 버려집니다.</p>
<p><em>Typed Array</em>에는 유효한 데이터 타입만 사용되는지 확인하는 검사 기능도 있습니다. 유효하지 않은 값은 대신 0이 사용됩니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> ints = <span class="keyword">new</span> <span class="built_in">Int16Array</span>([<span class="string">"hi"</span>]);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(ints.length);       <span class="comment">// 1</span></div><div class="line"><span class="built_in">console</span>.log(ints[<span class="number">0</span>]);           <span class="comment">// 0</span></div></pre></td></tr></table></figure>
<p>이 코드는 <code>Int16Array</code>에 문자열 값 <code>&quot;hi&quot;</code>를 사용하려고 시도합니다. 물론 문자열은 <em>Typed Array</em>에서 유효하지 않은 데이터 타입이므로 값은 대신 <code>0</code>으로 삽입됩니다. <em>Array</em>의 <code>length</code>는 여전히 하나이며, <code>ints[0]</code> 슬롯이 존재하더라도 <code>0</code> 값만 있습니다.</p>
<p><em>Typed Array</em>의 값을 수정하는 모든 메서드는 동일한 제한을 적용받습니다. 예를 들어 <code>map()</code>에 전달된 함수가 <em>Typed Array</em>에 대해 유효하지 않은 값을 반환하면 대신에 <code>0</code>이 사용됩니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> ints = <span class="keyword">new</span> <span class="built_in">Int16Array</span>([<span class="number">25</span>, <span class="number">50</span>]),</div><div class="line">    mapped = ints.map(<span class="function"><span class="params">v</span> =&gt;</span> <span class="string">"hi"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(mapped.length);        <span class="comment">// 2</span></div><div class="line"><span class="built_in">console</span>.log(mapped[<span class="number">0</span>]);            <span class="comment">// 0</span></div><div class="line"><span class="built_in">console</span>.log(mapped[<span class="number">1</span>]);            <span class="comment">// 0</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(mapped <span class="keyword">instanceof</span> <span class="built_in">Int16Array</span>);  <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(mapped <span class="keyword">instanceof</span> <span class="built_in">Array</span>);       <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p>문자열 값 <code>&quot;hi&quot;</code>는 16 비트 정수가 아니므로 결과 <em>Array</em>에서 <code>0</code>으로 바뀝니다. 이 오류 수정 동작으로 인해 <em>Typed Array</em>에는 항상 잘못된 데이터가 없기 때문에 잘못된 데이터가 있을때 오류를 던지는 것에 대해 걱정할 필요가 없습니다.</p>
<h3 id="누락된-메서드"><a href="#누락된-메서드" class="headerlink" title="누락된 메서드"></a>누락된 메서드</h3><p><em>Typed Array</em>에는 일반 <em>Array</em>와 동일한 메서드가 많이 있지만 <em>Array</em> 메서드중 몇개는 없습니다. <em>Typed Array</em>에서 다음 메서드는 사용할 수 없습니다.</p>
<ul>
<li><code>concat()</code></li>
<li><code>pop()</code></li>
<li><code>push()</code></li>
<li><code>shift()</code></li>
<li><code>splice()</code></li>
<li><code>unshift()</code></li>
</ul>
<p><code>concat()</code> 메서드를 제외하고 이 목록의 메서드는 크기를 변경할 수 있습니다. <em>Typed Array</em>는 크기를 변경할 수 없으므로 <em>Typed Array</em>에서 사용할 수 없습니다. 두 개의 <em>Typed Array</em>를 연결한 결과(특히 서로 다른 데이터 타입을 처리하는 경우)가 불확실할 수 있기 때문에 <code>concat()</code> 메서드를 사용할 수 없습니다. 이것은 처음에 <em>Typed Array</em>를 사용하는 이유에 반대되는 개념입니다.</p>
<h3 id="추가된-메서드"><a href="#추가된-메서드" class="headerlink" title="추가된 메서드"></a>추가된 메서드</h3><p>마지막으로 <em>Typed Array</em>는 <code>set()</code>과 <code>subarray()</code> 메서드와 같이 일반 <em>Array</em>에는 존재하지 않는 두가지 메서드를 가지고 있습니다. 이 두가지 메서드중 <code>set()</code>은 다른 <em>Array</em>를 기존의 <em>Typed Array</em>로 복사하는 반면 <code>subarray()</code>는 기존의 <em>Typed Array</em>의 일부를 새로운 <em>Typed Array</em>로 추출합니다.</p>
<p><code>set()</code> 메서드는 <em>Array</em>(<em>Typed Array</em> 또는 일반 <em>Array</em>)와 데이터를 선택적으로 삽입할 오프셋을 받습니다. 아무 것도 전달하지 않으면 오프셋의 기본값은 0입니다. 유효한 데이터 타입만 사용되도록 보장되며 <em>Array</em> 파라미터의 데이터는 대상 <em>Typed Array</em>에 복사됩니다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> ints = <span class="keyword">new</span> <span class="built_in">Int16Array</span>(<span class="number">4</span>);</div><div class="line"></div><div class="line">ints.set([<span class="number">25</span>, <span class="number">50</span>]);</div><div class="line">ints.set([<span class="number">75</span>, <span class="number">100</span>], <span class="number">2</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(ints.toString());   <span class="comment">// 25,50,75,100</span></div></pre></td></tr></table></figure>
<p>이 코드는 네 개의 요소가있는 <code>Int16Array</code>를 만듭니다. <code>set()</code>을 처음 호출하면 <em>Typed Array</em>의 첫번째와 두번째 요소에 두개의 값이 복사됩니다. <code>set()</code>에 대한 두번째 호출은 오프셋 <code>2</code>를 이용하여 호출이 되고, 이것은 세번째 요소에서부터 배치되어야 함을 나타냅니다.</p>
<p><code>subarray()</code> 메서드는 선택적인 시작 및 종료 인덱스 (<code>slice()</code> 메서드에서와 같이 종료 인덱스는 배타적입니다.)를 받아 들여 새로운 <em>Typed Array</em>를 반환합니다. 그리고, 두 파라미터를 모두 생략하여 <em>Typed Array</em>의 복제본을 만들 수도 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> ints = <span class="keyword">new</span> <span class="built_in">Int16Array</span>([<span class="number">25</span>, <span class="number">50</span>, <span class="number">75</span>, <span class="number">100</span>]),</div><div class="line">    subints1 = ints.subarray(),</div><div class="line">    subints2 = ints.subarray(<span class="number">2</span>),</div><div class="line">    subints3 = ints.subarray(<span class="number">1</span>, <span class="number">3</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(subints1.toString());   <span class="comment">// 25,50,75,100</span></div><div class="line"><span class="built_in">console</span>.log(subints2.toString());   <span class="comment">// 75,100</span></div><div class="line"><span class="built_in">console</span>.log(subints3.toString());   <span class="comment">// 50,75</span></div></pre></td></tr></table></figure>
<p>이 예제에서는 3 개의 <em>Typed Array</em>가 원래 <code>ints</code>에서 만들어집니다. <code>subints1</code> <em>Typed Array</em>는 동일한 정보를 포함하는 <code>ints</code>의 복사본입니다. <code>subints2</code> <em>Typed Array</em>는 인덱스 2에서 시작하는 데이터를 복사하기 때문에 <code>ints</code>의 마지막 두 요소만(75 및 100) 복사합니다. <code>subints3</code> <em>Typed Array</em>는 <code>subarray()</code>에서 시작 인덱스와 종료 인덱스가 모두 입력되어 호출되므로 <code>ints</code>의 가운데 두 요소만 복사됩니다.</p>
<h2 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h2><p>ECMAScript 6는 <em>Array</em>를 보다 유용하게 만드는 ECMAScript 5의 작업을 승계합니다. <em>Array</em>를 만드는 방법에는 <code>Array.of()</code> 및 <code>Array.from()</code> 메서드 두가지가 더 추가되었습니다. <code>Array.from()</code> 메서드는 <em>Iterable</em> 및 유사 <em>Array</em> 객체를 <em>Array</em>로 변환할 수<br> 있습니다. 두 메서드 모두 파생 <em>Array</em> 클래스에 상속되며 <code>Symbol.species</code> 프로퍼티를 사용하여 반환할 값 타입을 결정합니다.(다른 상속된 메서드 또한 <em>Array</em>를 반환할 때 <code>Symbol.species</code>를 사용합니다.)</p>
<p><em>Array</em>에는 몇가지 새로운 메서드가 있습니다. <code>fill()</code> 및 <code>copyWithin()</code> 메서드를 사용하면 <em>Array</em> 요소를 현재 위치에서 변경할 수 있습니다. <code>find()</code> 및 <code>findIndex()</code> 메서드는 일부 조건과 일치하는 <em>Array</em>의 첫번째 요소를 찾는데 유용합니다. 전자는 기준에 맞는 첫번째 요소를 반환하고 후자는 요소의 인덱스를 반환합니다.</p>
<p><em>Typed Array</em>는 기술적으로 <em>Array</em>가 아니며 <em>Array</em>를 상속하지 않지만, <em>Array</em>처럼 보이고 동작합니다. <em>Typed Array</em>는 8 개의 다른 숫자 데이터 타입중 하나를 포함하며 숫자 또는 일련의 숫자의 기본 비트를 나타내는 <code>ArrayBuffer</code> 객체를 기반으로 작성됩니다. <em>Typed Array</em>는 JavaScript 숫자 타입의 경우처럼 타입이 앞뒤로 변환되지 않기 때문에 비트 연산을 보다 효율적으로 수행하는 방법입니다.</p>
<hr>
<blockquote>
<p>이 내용은 나중에 참고하기 위해 제가 공부하며 정리한 내용입니다.<br>의역, 오역, 직역이 있을 수 있음을 알려드립니다.<br>This post is a translation of this original article [<a href="https://leanpub.com/understandinges6/read#leanpub-auto-improved-array-capabilities" target="_blank" rel="external">https://leanpub.com/understandinges6/read#leanpub-auto-improved-array-capabilities</a>]</p>
</blockquote>
<h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul>
<li><a href="https://infoscis.github.io/2018/01/24/ecmascript-6-block-binding/">ECMAScript 6 Block Binding</a></li>
<li><a href="https://infoscis.github.io/2018/01/24/ecmascript-6-strings-and-regular-expressions/">ECMAScript 6 문자열과 정규 표현식</a></li>
<li><a href="https://infoscis.github.io/2018/01/24/ecmascript-6-functions/">ECMAScript 6 함수</a></li>
<li><a href="https://infoscis.github.io/2018/01/25/ecmascript-6-expanded-object-functionality/">ECMAScript 6 객체의 확장된 기능</a></li>
<li><a href="https://infoscis.github.io/2018/01/26/ecmascript-6-destructuring-for-easier-data-access/">ECMAScript 6 쉬운 데이터 액세스를 위한 Destructuring</a></li>
<li><a href="https://infoscis.github.io/2018/01/27/ecmascript-6-symbols-and-symbol-properties/">ECMAScript 6 Symbol과 Symbol 프로퍼티</a></li>
<li><a href="https://infoscis.github.io/2018/01/27/ecmascript-6-sets-and-maps/">ECMAScript 6 Set과 Map</a></li>
<li><a href="https://infoscis.github.io/2018/01/31/ecmascript-6-iterators-and-generators/">ECMAScript 6 Iterator와 Generator</a></li>
<li><a href="https://infoscis.github.io/2018/02/13/ecmascript-6-introducing-javascript-classes/">ECMAScript 6 JavaScript 클래스 소개</a></li>
<li><a href="https://infoscis.github.io/2018/02/13/ecmascript-6-improved-array-capabilities/">ECMAScript 6 Array 기능 향상</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-promises-and-asynchronous-programming/">ECMAScript 6 Promise와 비동기 프로그램밍</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-proxies-and-the-reflection-api/">ECMAScript 6 프록시와 리플렉션 API</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-encapsulating-code-with-modules/">ECMAScript 6 Module로 코드 캡슐화하기</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-appendix-a-smaller-changes/">ECMAScript 6 부록 A. 작은 변경 사항</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-appendix-b-understanding-ecmascript-7/">ECMAScript 6 부록 B. ECMAScript 7(2016) 이해하기</a></li>
</ul>

        </div>
        <footer class="article-footer">
            



    <a data-url="http://infoscis.github.io/2018/02/13/ecmascript-6-improved-array-capabilities/" data-id="cjlfaydh6003llguzjwn948oz" class="article-share-link"><i class="fa fa-share"></i>공유하기</a>
<script>
    (function ($) {
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

        </footer>
    </div>
</article>

    <section id="comments">
    
        
    <div id="disqus_thread">
        <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>

    
    </section>


                        </div>
                    </section>
                    <aside id="sidebar">
    <a class="sidebar-toggle" title="Expand Sidebar"><i class="toggle icon"></i></a>
    <div class="sidebar-top">
        <p>팔로우:</p>
        <ul class="social-links">
            
                
                <li>
                    <a class="social-tooltip" title="github" href="https://github.com/infoscis" target="_blank">
                        <i class="icon fa fa-github"></i>
                    </a>
                </li>
                
            
        </ul>
    </div>
    
        
<nav id="article-nav">
    
        <a href="/2018/02/27/ecmascript-6-promises-and-asynchronous-programming/" id="article-nav-newer" class="article-nav-link-wrap">
        <strong class="article-nav-caption">새로운</strong>
        <p class="article-nav-title">
        
            ECMAScript 6 Promise와 비동기 프로그램밍
        
        </p>
        <i class="icon fa fa-chevron-right" id="icon-chevron-right"></i>
    </a>
    
    
        <a href="/2018/02/13/ecmascript-6-introducing-javascript-classes/" id="article-nav-older" class="article-nav-link-wrap">
        <strong class="article-nav-caption">오래된</strong>
        <p class="article-nav-title">JavaScript 클래스 소개</p>
        <i class="icon fa fa-chevron-left" id="icon-chevron-left"></i>
        </a>
    
</nav>

    
    <div class="widgets-container">
        
            
                
    <div class="widget-wrap">
        <h3 class="widget-title">최근 글</h3>
        <div class="widget">
            <ul id="recent-post" class="no-thumbnail">
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Kotlin/">Kotlin</a><i class="icon fa fa-angle-right"></i><a class="article-category-link" href="/categories/Kotlin/SpringBoot/">SpringBoot</a></p>
                            <p class="item-title"><a href="/2018/08/30/spring-boot-kotlin/" class="title">Spring Boot와 Kotlin으로 웹 애플리케이션 구축하기</a></p>
                            <p class="item-date"><time datetime="2018-08-29T15:30:20.000Z" itemprop="datePublished">2018-08-30</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Angular/">Angular</a></p>
                            <p class="item-title"><a href="/2018/08/08/angular-observables-and-rxjs/" class="title">Angular Observable &amp; RxJS</a></p>
                            <p class="item-date"><time datetime="2018-08-08T14:38:02.000Z" itemprop="datePublished">2018-08-08</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/JavaScript/">JavaScript</a><i class="icon fa fa-angle-right"></i><a class="article-category-link" href="/categories/JavaScript/ECMAScript-2015/">ECMAScript 2015</a></p>
                            <p class="item-title"><a href="/2018/02/27/ecmascript-6-appendix-b-understanding-ecmascript-7/" class="title">ECMAScript 6 부록 B. ECMAScript 7 (2016) 이해하기</a></p>
                            <p class="item-date"><time datetime="2018-02-27T13:32:48.000Z" itemprop="datePublished">2018-02-27</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/JavaScript/">JavaScript</a><i class="icon fa fa-angle-right"></i><a class="article-category-link" href="/categories/JavaScript/ECMAScript-2015/">ECMAScript 2015</a></p>
                            <p class="item-title"><a href="/2018/02/27/ecmascript-6-appendix-a-smaller-changes/" class="title">ECMAScript 6 부록 A. 작은 변경 사항</a></p>
                            <p class="item-date"><time datetime="2018-02-27T13:32:12.000Z" itemprop="datePublished">2018-02-27</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/JavaScript/">JavaScript</a><i class="icon fa fa-angle-right"></i><a class="article-category-link" href="/categories/JavaScript/ECMAScript-2015/">ECMAScript 2015</a></p>
                            <p class="item-title"><a href="/2018/02/27/ecmascript-6-encapsulating-code-with-modules/" class="title">ECMAScript 6 Module로 코드 캡슐화하기</a></p>
                            <p class="item-date"><time datetime="2018-02-27T13:31:45.000Z" itemprop="datePublished">2018-02-27</time></p>
                        </div>
                    </li>
                
            </ul>
        </div>
    </div>

            
                
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">카테고리</h3>
        <div class="widget">
            <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Angular/">Angular</a><span class="category-list-count">15</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hadoop/">Hadoop</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">5</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/Java9/">Java9</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/Spring/">Spring</a><span class="category-list-count">2</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/">JavaScript</a><span class="category-list-count">16</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/ECMAScript-2015/">ECMAScript 2015</a><span class="category-list-count">15</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kotlin/">Kotlin</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Kotlin/SpringBoot/">SpringBoot</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/TypeScript/">TypeScript</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Webpack/">Webpack</a><span class="category-list-count">1</span></li></ul>
        </div>
    </div>


            
                
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">아카이브</h3>
        <div class="widget">
            <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">8월 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">2월 2018</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">1월 2018</a><span class="archive-list-count">11</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">7월 2017</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">6월 2017</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">5월 2017</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">3월 2017</a><span class="archive-list-count">5</span></li></ul>
        </div>
    </div>


            
                
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">태그</h3>
        <div class="widget">
            <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Angular/">Angular</a><span class="tag-list-count">15</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ECMAScript-2015/">ECMAScript 2015</a><span class="tag-list-count">15</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Event/">Event</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hadoop/">Hadoop</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JDK9/">JDK9</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java9/">Java9</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript</a><span class="tag-list-count">29</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Jigsaw/">Jigsaw</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kotlin/">Kotlin</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nashorn/">Nashorn</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/">Spring</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringBoot/">SpringBoot</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TypeScript/">TypeScript</a><span class="tag-list-count">12</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Webpack/">Webpack</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/YARN/">YARN</a><span class="tag-list-count">1</span></li></ul>
        </div>
    </div>


            
                
    <div class="widget-wrap widget-float">
        <h3 class="widget-title">태그 클라우드</h3>
        <div class="widget tagcloud">
            <a href="/tags/Angular/" style="font-size: 18px;">Angular</a> <a href="/tags/ECMAScript-2015/" style="font-size: 18px;">ECMAScript 2015</a> <a href="/tags/Event/" style="font-size: 10px;">Event</a> <a href="/tags/Hadoop/" style="font-size: 10px;">Hadoop</a> <a href="/tags/JDK9/" style="font-size: 12px;">JDK9</a> <a href="/tags/Java/" style="font-size: 14px;">Java</a> <a href="/tags/Java9/" style="font-size: 12px;">Java9</a> <a href="/tags/JavaScript/" style="font-size: 20px;">JavaScript</a> <a href="/tags/Jigsaw/" style="font-size: 12px;">Jigsaw</a> <a href="/tags/Kotlin/" style="font-size: 10px;">Kotlin</a> <a href="/tags/Nashorn/" style="font-size: 10px;">Nashorn</a> <a href="/tags/Spring/" style="font-size: 12px;">Spring</a> <a href="/tags/SpringBoot/" style="font-size: 12px;">SpringBoot</a> <a href="/tags/TypeScript/" style="font-size: 16px;">TypeScript</a> <a href="/tags/Webpack/" style="font-size: 10px;">Webpack</a> <a href="/tags/YARN/" style="font-size: 10px;">YARN</a>
        </div>
    </div>


            
        
    </div>
</aside>
                </div>
            </div>
        </div>
        <footer id="footer">
    <div class="container">
        <div class="container-inner">
            <a id="back-to-top" href="javascript:;"><i class="icon fa fa-angle-up"></i></a>
            <div class="credit">
                <h1 class="logo-wrap">
                    <a href="/" class="logo"></a>
                </h1>
                <p>&copy; 2018 Jongcheol-Kim</p>
                <p>Powered by <a href="//hexo.io/" target="_blank">Hexo</a>. Theme by <a href="//github.com/ppoffice" target="_blank">PPOffice</a></p>
            </div>
        </div>
    </div>
</footer>
        
    
    <script>
    var disqus_shortname = 'infoscis';
    
    
    var disqus_url = 'http://infoscis.github.io/2018/02/13/ecmascript-6-improved-array-capabilities/';
    
    (function() {
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    </script>




    
        <script src="/libs/lightgallery/js/lightgallery.min.js"></script>
        <script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>
        <script src="/libs/lightgallery/js/lg-pager.min.js"></script>
        <script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>
        <script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>
        <script src="/libs/lightgallery/js/lg-zoom.min.js"></script>
        <script src="/libs/lightgallery/js/lg-hash.min.js"></script>
        <script src="/libs/lightgallery/js/lg-share.min.js"></script>
        <script src="/libs/lightgallery/js/lg-video.min.js"></script>
    
    
        <script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script>
    
    


<!-- Custom Scripts -->
<script src="/js/main.js"></script>

    </div>
</body>
</html>
