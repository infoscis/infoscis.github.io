<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    
    <title>JavaScript 클래스 소개 | Developer&#39;s Record</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
        <meta name="keywords" content="JavaScript,ECMAScript 2015" />
    
    <meta name="description" content="JavaScript 클래스 소개대부분의 공식적인 객체 지향 프로그래밍 언어와는 달리 JavaScript는 만들어질 때 부터 유사 객체 및 관련 객체를 정의하는 주요 방법으로 클래스와 클래스 상속을 지원하지 않았습니다. 이로 인해 많은 개발자들이 혼란 스러웠고, ECMAScript 1 이전 버전부터 ECMAScript 5 까지 많은 라이브러리가 클래스를 지원">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript 클래스 소개">
<meta property="og:url" content="http://infoscis.github.io/2018/02/13/ecmascript-6-introducing-javascript-classes/index.html">
<meta property="og:site_name" content="Developer's Record">
<meta property="og:description" content="JavaScript 클래스 소개대부분의 공식적인 객체 지향 프로그래밍 언어와는 달리 JavaScript는 만들어질 때 부터 유사 객체 및 관련 객체를 정의하는 주요 방법으로 클래스와 클래스 상속을 지원하지 않았습니다. 이로 인해 많은 개발자들이 혼란 스러웠고, ECMAScript 1 이전 버전부터 ECMAScript 5 까지 많은 라이브러리가 클래스를 지원">
<meta property="og:updated_time" content="2018-02-27T14:12:45.040Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JavaScript 클래스 소개">
<meta name="twitter:description" content="JavaScript 클래스 소개대부분의 공식적인 객체 지향 프로그래밍 언어와는 달리 JavaScript는 만들어질 때 부터 유사 객체 및 관련 객체를 정의하는 주요 방법으로 클래스와 클래스 상속을 지원하지 않았습니다. 이로 인해 많은 개발자들이 혼란 스러웠고, ECMAScript 1 이전 버전부터 ECMAScript 5 까지 많은 라이브러리가 클래스를 지원">
    
    <link rel="canonical" href="http://infoscis.github.io/2018/02/13/ecmascript-6-introducing-javascript-classes/"/>

    

    
        <link rel="icon" href="/favicon.png" />
    

    <link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="/libs/titillium-web/styles.css">
    <link rel="stylesheet" href="/libs/source-code-pro/styles.css">

    <link rel="stylesheet" href="/css/style.css">

    <script src="/libs/jquery/2.0.3/jquery.min.js"></script>
    
    
        <link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">
    
    
        <link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css">
    
    
        <script type="text/javascript">
(function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-100332906-1', 'auto');
ga('send', 'pageview');

</script>
    
    

</head>

<body>
    <div id="wrap">
        <header id="header">
    <div id="header-outer" class="outer">
        <div class="container">
            <div class="container-inner">
                <div id="header-title">
                    <h1 class="logo-wrap">
                        <a href="/" class="logo"></a>
                    </h1>
                    
                        <h2 class="subtitle-wrap">
                            <p class="subtitle">개발자의 기록 보관소</p>
                        </h2>
                    
                </div>
                <div id="header-inner" class="nav-container">
                    <a id="main-nav-toggle" class="nav-icon fa fa-bars"></a>
                    <div class="nav-container-inner">
                        <ul id="main-nav">
                            
                                <li class="main-nav-list-item" >
                                    <a class="main-nav-list-link" href="/">홈</a>
                                </li>
                            
                                        <ul class="main-nav-list"><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Angular/">Angular</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Hadoop/">Hadoop</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Java/">Java</a><ul class="main-nav-list-child"><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Java/Java9/">Java9</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Java/Spring/">Spring</a></li></ul></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/JavaScript/">JavaScript</a><ul class="main-nav-list-child"><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/JavaScript/ECMAScript-2015/">ECMAScript 2015</a></li></ul></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/TypeScript/">TypeScript</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Webpack/">Webpack</a></li></ul>
                                    
                                <li class="main-nav-list-item" >
                                    <a class="main-nav-list-link" href="https://about.me/jongcheol.kim">About</a>
                                </li>
                            
                        </ul>
                        <nav id="sub-nav">
                            <div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="검색" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="Type something..." />
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '포스트',
            PAGES: 'Pages',
            CATEGORIES: '카테고리',
            TAGS: '태그',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div>
                        </nav>
                    </div>
                </div>
            </div>
        </div>
    </div>
</header>
        <div class="container">
            <div class="main-body container-inner">
                <div class="main-body-inner">
                    <section id="main">
                        <div class="main-body-header">
    <h1 class="header">
    
    <a class="page-title-link" href="/categories/JavaScript/">JavaScript</a><i class="icon fa fa-angle-right"></i><a class="page-title-link" href="/categories/JavaScript/ECMAScript-2015/">ECMAScript 2015</a>
    </h1>
</div>
                        <div class="main-body-content">
                            <article id="post-ecmascript-6-introducing-javascript-classes" class="article article-single article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
            <header class="article-header">
                
    
        <h1 class="article-title" itemprop="name">
        JavaScript 클래스 소개
        </h1>
    

            </header>
        
        
            <div class="article-meta">
                
    <div class="article-date">
        <a href="/2018/02/13/ecmascript-6-introducing-javascript-classes/" class="article-date">
            <time datetime="2018-02-13T14:49:26.000Z" itemprop="datePublished">2018-02-13</time>
        </a>
    </div>

                
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/ECMAScript-2015/">ECMAScript 2015</a>, <a class="tag-link" href="/tags/JavaScript/">JavaScript</a>
    </div>

            </div>
        
        
        <div class="article-entry" itemprop="articleBody">
            <h1 id="JavaScript-클래스-소개"><a href="#JavaScript-클래스-소개" class="headerlink" title="JavaScript 클래스 소개"></a>JavaScript 클래스 소개</h1><p>대부분의 공식적인 객체 지향 프로그래밍 언어와는 달리 JavaScript는 만들어질 때 부터 유사 객체 및 관련 객체를 정의하는 주요 방법으로 클래스와 클래스 상속을 지원하지 않았습니다. 이로 인해 많은 개발자들이 혼란 스러웠고, ECMAScript 1 이전 버전부터 ECMAScript 5 까지 많은 라이브러리가 클래스를 지원하는 것처럼 보이게하는 유틸리티를 만들었습니다. 일부 JavaScript 개발자는 JavaScript에 클래스는 필요하지 않다고 강력하게 느낄수도 있지만, 클래스 지원을 목적으로 하는 많은 수의 라이브러리는 클래스를 ECMAScript 6에 포함 시키도록 했습니다.</p>
<p>클래스가 사용하는 기본 메커니즘을 이해하는 것이 ECMAScript 6 클래스를 공부하는데 도움이되므로 이 장에서는 ECMAScript 5 개발자가 클래스와 비슷한 동작을 하는 방법에 대해 논의함으로써 시작합니다. 그러나 나중에 보게 되겠지만, ECMAScript 6 클래스는 다른 언어의 클래스와 완전히 동일하지 않습니다. JavaScript의 동적 특성을 반영하는 독창적인 기능이 있습니다.</p>
<h2 id="ECMAScript-5의-클래스와-비슷한-구조"><a href="#ECMAScript-5의-클래스와-비슷한-구조" class="headerlink" title="ECMAScript 5의 클래스와 비슷한 구조"></a>ECMAScript 5의 클래스와 비슷한 구조</h2><p>ECMAScript 5 이전 버전의 JavaScript에는 클래스가 없었습니다. 클래스에 가장 가까운 방법은 생성자를 생성한 다음 생성자의 프로토 타입에 메서드를 할당하는 것으로, 일반적으로 사용자 정의 타입 생성이라고 하는 접근 방식입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">PersonType</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">PersonType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> PersonType(<span class="string">"Nicholas"</span>);</div><div class="line">person.sayName();   <span class="comment">// outputs "Nicholas"</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> PersonType);  <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> <span class="built_in">Object</span>);      <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>이 코드에서 <code>PersonType</code>은 <code>name</code>이라는 단일 프로퍼티를 생성하는 생성자 함수입니다. <code>sayName()</code> 메서드는 프로토 타입에 할당되어 동일한 함수가 <code>PersonType</code> 객체의 모든 인스턴스에 의해 공유됩니다. 그런 다음, <code>Person</code>의 새로운 인스턴스가 <code>new</code> 연산자를 통해 생성됩니다. <code>person</code> 객체는 프로토 타입 상속을 통해 <code>PersonType</code>과 <code>Object</code> 인스턴스로 간주됩니다.</p>
<p>이 기본 패턴은 클래스를 모방하는 많은 JavaScript 라이브러리의 근간을 이루며 ECMAScript 6 클래스가 시작됩니다.</p>
<h2 id="클래스-선언"><a href="#클래스-선언" class="headerlink" title="클래스 선언"></a>클래스 선언</h2><p>ECMAScript 6에서 가장 간단한 클래스 형식은 다른 언어의 클래스와 비슷한 클래스 선언입니다.</p>
<h3 id="클래스-선언의-기본"><a href="#클래스-선언의-기본" class="headerlink" title="클래스 선언의 기본"></a>클래스 선언의 기본</h3><p>클래스 선언은 <code>class</code> 키워드와 클래스의 이름으로 시작됩니다. 구문의 나머지 부분은 객체 리터럴의 간결한 메서드와 비슷하지만 쉼표가 필요하지 않습니다. 예를 들어, 다음은 간단한 클래스 선언입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonClass</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// PersonType 생성자와 동일합니다.</span></div><div class="line">    <span class="keyword">constructor</span>(name) &#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// PersonType.prototype.sayName과 동일합니다.</span></div><div class="line">    sayName() &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> PersonClass(<span class="string">"Nicholas"</span>);</div><div class="line">person.sayName();   <span class="comment">// outputs "Nicholas"</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> PersonClass);     <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> <span class="built_in">Object</span>);          <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> PersonClass);                    <span class="comment">// "function"</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> PersonClass.prototype.sayName);  <span class="comment">// "function"</span></div></pre></td></tr></table></figure>
<p><code>PersonClass</code> 클래스 선언은 이전 예제의 <code>PersonType</code>과 매우 유사하게 동작합니다. 그러나 함수를 생성자로 정의하는 대신 클래스 선언을 사용하면 특수한 <code>constructor</code> 메서드 이름을 사용하여 클래스 내부에 직접 생성자를 정의할 수 있습니다. 클래스 메서드는 간결한 구문을 사용하기 때문에 <code>function</code> 키워드를 사용할 필요가 없습니다. 그리고 다른 메서드 이름에는 특별한 의미가 없으므로 원하는 만큼 메서드를 추가할 수 있습니다.</p>
<blockquote>
<p><em>Own property</em>는 프로토 타입이 아닌 인스턴스에서 보여지는 프로퍼티는 클래스 생성자 또는 메서드 내부에서만 만들 수 있습니다. 이 예제에서 <code>name</code>은 <em>Own Property</em>입니다. 생성자 함수 내에서 가능한 모든 프로퍼티를 만드는 것이 좋습니다. 왜냐하면 클래스의 한 장소에서 모든 프로퍼티가 표현되기 때문입니다.</p>
</blockquote>
<p>흥미롭게도, 클래스 선언은 기존 사용자 정의 타입 선언의 Syntactic sugar입니다. <code>PersonClass</code> 선언은 실제로 <code>constructor</code> 메서드의 동작을 갖는 함수를 생성합니다. 이것이 <code>typeof PersonClass</code>가 “<code>function</code>“을 결과로 주는 이유입니다. <code>sayName()</code> 메서드는 앞의 예제에서 <code>sayName()</code>과 <code>PersonType.prototype</code> 사이의 관계와 비슷하게 이 예제에서 <code>PersonClass.prototype</code>에 대한 메서드로 끝납니다. 이러한 유사점을 사용하면 사용자가 사용하는 타입에 대해 너무 많이 걱정하지 않고도 사용자 정의 타입 및 클래스를 혼합할 수 있습니다.</p>
<h3 id="클래스-구문을-사용해야하는-이유"><a href="#클래스-구문을-사용해야하는-이유" class="headerlink" title="클래스 구문을 사용해야하는 이유"></a>클래스 구문을 사용해야하는 이유</h3><p>클래스와 사용자 정의 타입의 유사점에도 불구하고 유의해야 할 몇 가지 중요한 차이점이 있습니다.</p>
<ol>
<li>클래스 선언은 함수 선언과 달리 <em>Hoisting</em>되지 않습니다. 클래스 선언은 <code>let</code> 선언과 같이 행동하며, 실행이 선언에 도달할 때까지 Temporal dead zone에 존재합니다.</li>
<li>클래스 선언의 모든 코드는 <code>strict</code> 모드로 자동 실행됩니다. 클래스의 <code>strict</code> 모드를 거부할 수있는 방법이 없습니다.</li>
<li>모든 메서드는 Non-enumerable 입니다. <code>Object.defineProperty()</code>를 사용하여 메서드를 Non-enumerable하게 만드는 사용자 지정 타입과 다른 중요한 변경 사항입니다.</li>
<li>모든 메서드는 내부 <code>[[Construct]]</code> 메서드가 없으며 <code>new</code>로 호출하려고 하면 에러가 발생합니다.</li>
<li><code>new</code>를 사용하지 않고 클래스 생성자를 호출하면 오류가 발생합니다.</li>
<li>클래스 메서드 내에서 클래스 이름을 덮어 쓰려고하면 오류가 발생합니다.</li>
</ol>
<p>이 모든 것을 염두에 두고, 위 예제의 <code>PersonClass</code> 선언은 클래스 구문을 사용하지 않는 다음 코드와 동일합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// PersonClass와 동일합니다.</span></div><div class="line"><span class="keyword">let</span> PersonType2 = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line"><span class="meta"></span></div><div class="line">    "use strict";</div><div class="line"></div><div class="line">    <span class="keyword">const</span> PersonType2 = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">// new를 이용하여 호출이 되었는지 확인</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">new</span>.target === <span class="string">"undefined"</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Constructor must be called with new."</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">Object</span>.defineProperty(PersonType2.prototype, <span class="string">"sayName"</span>, &#123;</div><div class="line">        <span class="attr">value</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">            <span class="comment">// new를 이용하여 호출하지 않도록 함.</span></div><div class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">new</span>.target !== <span class="string">"undefined"</span>) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Method cannot be called with new."</span>);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">enumerable</span>: <span class="literal">false</span>,</div><div class="line">        <span class="attr">writable</span>: <span class="literal">true</span>,</div><div class="line">        <span class="attr">configurable</span>: <span class="literal">true</span></div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> PersonType2;</div><div class="line">&#125;());</div></pre></td></tr></table></figure>
<p>먼저 두 개의 <code>PersonType2</code> 선언이 있음을 주목하십시오(외부 scope에 있는 <code>let</code> 선언과 IIFE 내부에 있는 <code>const</code> 선언). 이것은 클래스 메서드가 클래스 이름을 덮어 쓰는 것을 금지하는 반면 클래스 외부의 코드는 이를 허용합니다. 생성자 함수는 <code>new.target</code>을 검사하여<br> <code>new</code>로 호출되는지 확인합니다. 그렇지 않은 경우 오류가 발생합니다. 다음으로, <code>sayName()</code>메소드는 Non-enumerable으로 정의되고 메t서드는 <code>new.target</code>을 검사하여 <code>new</code>로 호출되지 않았음을 확인합니다. 마지막 단계는 생성자 함수를 반환합니다.</p>
<p>이 예제는 새로운 구문을 사용하지 않고 클래스가 수행할 수있는 모든 작업할 수 있지만 클래스 구문은 모든 기능을 크게 단순화한다는 것을 보여줍니다.</p>
<h3 id="상수-클래스-이름"><a href="#상수-클래스-이름" class="headerlink" title="상수 클래스 이름"></a>상수 클래스 이름</h3><p>클래스의 이름은 클래스 내부에서 <code>const</code>를 사용하는 경우에만 지정됩니다. 즉, 클래스 외부의 클래스 이름은 덮어 쓸 수 있지만 클래스 메서드 내부에서는 덮어 쓸 수 없습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">   <span class="keyword">constructor</span>() &#123;</div><div class="line">       Foo = <span class="string">"bar"</span>;    <span class="comment">// 실행될때 에러가 발생합니다.</span></div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 클래스 선언 이후에는 가능합니다.</span></div><div class="line">Foo = <span class="string">"baz"</span>;</div></pre></td></tr></table></figure>
<p>이 코드에서 클래스 생성자 안에있는 <code>Foo</code>는 클래스 외부의 <code>Foo</code>와는 별도의 바인딩입니다. 내부의 <code>Foo</code>는 마치 <code>const</code>인 것처럼 정의되고 덮어 쓸 수 없습니다. 생성자가 <code>Foo</code>를 임의의 값으로 덮어 쓰려고하면 에러가 발생합니다. 그러나 외부 <code>Foo</code>는 <code>let</code> 선언처럼 정의되기 때문에 언제든지 값을 덮어 쓸 수 있습니다.</p>
<h2 id="클래스-표현식"><a href="#클래스-표현식" class="headerlink" title="클래스 표현식"></a>클래스 표현식</h2><p>클래스와 함수는 선언과 표현식이라는 두가지 형식을 가지고 있다는 점에서 비슷합니다. 함수와 클래스 선언은 적절한 키워드 (각각<code>function</code> 또는<code>class</code>)와 식별자로 시작됩니다. 함수는 <code>function</code> 다음에 식별자를 필요로하지 않는 표현식 형태를 가지고 있고, 비슷하게 클래스는 <code>class</code> 다음에 식별자를 필요로하지 않는 표현식 형태를 가지고 있습니다. 이 클래스 표현식은 변수 선언에 사용되거나 함수로 인수로 전달되도록 설계되었습니다.</p>
<h3 id="기본-클래스-표현식"><a href="#기본-클래스-표현식" class="headerlink" title="기본 클래스 표현식"></a>기본 클래스 표현식</h3><p>다음은 이전 <code>PersonClass</code> 예제에 해당하는 클래스 표현식과 그 코드를 사용하는 코드입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> PersonClass = <span class="class"><span class="keyword">class</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// PersonType constructor와 같습니다.</span></div><div class="line">    <span class="keyword">constructor</span>(name) &#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// PersonType.prototype.sayName과 같습니다.</span></div><div class="line">    sayName() &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> PersonClass(<span class="string">"Nicholas"</span>);</div><div class="line">person.sayName();   <span class="comment">// "Nicholas" 출력</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> PersonClass);     <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> <span class="built_in">Object</span>);          <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> PersonClass);                    <span class="comment">// "function"</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> PersonClass.prototype.sayName);  <span class="comment">// "function"</span></div></pre></td></tr></table></figure>
<p>이 예제에서 알 수 있듯이, 클래스 표현식은 <code>class</code> 다음에 식별자를 요구하지 않습니다. 구문 외에도 클래스 표현식은 클래스 선언과 기능적으로 동일합니다.</p>
<p>클래스 선언 또는 클래스 표현식 사용 여부는 주로 스타일의 문제입니다. 함수 선언 및 함수 표현식과 달리 클래스 선언과 클래스 표현식은 모두 <em>Hoisting</em> 되지 않기 때문에 코드의 런타임 동작에 거의 영향을 미치지 않습니다.</p>
<h3 id="이름이-부여된-클래스-표현식"><a href="#이름이-부여된-클래스-표현식" class="headerlink" title="이름이 부여된 클래스 표현식"></a>이름이 부여된 클래스 표현식</h3><p>이전 섹션 예제에서 익명 클래스 표현식을 사용했지만 함수 표현식과 마찬가지로 클래스 표현식의 이름을 지정할 수도 있습니다. 이렇게 하려면 다음과 같이 <code>class</code> 키워드 다음에 이름(식별자)를 포함 시킵니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> PersonClass = <span class="class"><span class="keyword">class</span> <span class="title">PersonClass2</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// PersonType constructor와 같습니다.</span></div><div class="line">    <span class="keyword">constructor</span>(name) &#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// PersonType.prototype.sayName와 같습니다.</span></div><div class="line">    sayName() &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> PersonClass);        <span class="comment">// "function"</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> PersonClass2);       <span class="comment">// "undefined"</span></div></pre></td></tr></table></figure>
<p>이 예제에서 클래스 표현식의 이름은 <code>PersonClass2</code>입니다. <code>PersonClass2</code> 식별자는 클래스 정의 내에서만 존재하기 때문에 (이 예제에서<code>sayName()</code> 메서드 처럼) 클래스 메서드 내부에서 사용될 수 있습니다. 하지만 클래스 밖에서 <code>typeof PersonClass2</code>는 <code>PersonClass2</code> 바인딩이 존재하지 않기 때문에 <code>&quot;undefined&quot;</code>입니다. 이러한 이유를 이해하기 위해 아래 예제처럼 클래스를 사용하지 않는 동일한 함수 선언을 살펴보겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// PersonClass에 이름이 부여된 클래스 표현식과 동일합니다.</span></div><div class="line"><span class="keyword">let</span> PersonClass = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line"><span class="meta"></span></div><div class="line">    "use strict";</div><div class="line"></div><div class="line">    <span class="keyword">const</span> PersonClass2 = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">// 함수가 new로 호출되었는지 확인합니다.</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">new</span>.target === <span class="string">"undefined"</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Constructor must be called with new."</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">Object</span>.defineProperty(PersonClass2.prototype, <span class="string">"sayName"</span>, &#123;</div><div class="line">        <span class="attr">value</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">            <span class="comment">// 함수가 new를 사용하지 않고 호출되었는지 확인합니다</span></div><div class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">new</span>.target !== <span class="string">"undefined"</span>) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Method cannot be called with new."</span>);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">enumerable</span>: <span class="literal">false</span>,</div><div class="line">        <span class="attr">writable</span>: <span class="literal">true</span>,</div><div class="line">        <span class="attr">configurable</span>: <span class="literal">true</span></div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> PersonClass2;</div><div class="line">&#125;());</div></pre></td></tr></table></figure>
<p>이름이 부여된 클래스 표현식을 작성하면 JavaScript 엔진에서 일어나는 일이 약간 바뀝니다. 클래스 선언의 경우, 외부 바인딩 (<code>let</code>으로 정의)은 내부 바인딩 (<code>const</code>로 정의)과 동일한 이름을 가집니다. 이름이 부여된 클래스 표현식은 <code>const</code> 정의에서 그 이름을 사용하므로<code>PersonClass2</code>는 클래스 내부에서만 사용하도록 정의됩니다.</p>
<p>이름이 부여된 클래스 표현식은 이름이 부여된 함수 표현식과 다르게 동작하지만, 두 표현식 사이에는 여전히 많은 유사점이 있습니다. 둘 다 값(Value)으로 사용할 수 있으며, 이는 많은 가능성을 열어줍니다. 이것은 아래에서 다루도록 하겠습니다.</p>
<h2 id="일급-시민-First-Class-Citizen-으로서의-클래스"><a href="#일급-시민-First-Class-Citizen-으로서의-클래스" class="headerlink" title="일급 시민(First-Class Citizen)으로서의 클래스"></a>일급 시민(First-Class Citizen)으로서의 클래스</h2><blockquote>
<p><a href="https://ko.wikipedia.org/wiki/%EC%9D%BC%EA%B8%89_%EA%B0%9D%EC%B2%B4" target="_blank" rel="external">일급 시민</a>: 컴퓨터 프로그래밍 언어 디자인에서, 특정 언어의 일급 객체 (first-class citizens, 일급 값, 일급 엔티티, 혹은 일급 시민)이라 함은 일반적으로 다른 객체들에 적용 가능한 연산을 모두 지원하는 객체를 가리킨다. 함수에 파라미터로 넘기기, 변수에 대입하기와 같은 연산들이 여기서 말하는 일반적인 연산의 예에 해당한다.</p>
</blockquote>
<p>프로그래밍 언어에서 어떤것은 값(Value)으로 사용될 수 있고, 이 경우에 <em>First-Class Citizen</em>이라고 말합니다. 즉, 함수로 전달되고 함수에서 반환되며 변수에 할당될 수 있습니다. JavaScript 함수는 <em>First-Class Citizen</em> (때로는 <em>First-Class Function</em>이라 부름)이며, 이는 JavaScript를 고유하게 만드는 요소의 일부입니다.</p>
<p>ECMAScript 6은 클래스를 <em>First-Class Citizen</em>으로 만들어 이러한 전통을 이어가고 있습니다. 이를 통해 클래스를 다양한 방식으로 사용할 수 있습니다. 예를 들어, 파라미터로 함수에 전달할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObject</span>(<span class="params">classDef</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> classDef();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> obj = createObject(<span class="class"><span class="keyword">class</span> </span>&#123;</div><div class="line"></div><div class="line">    sayHi() &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"Hi!"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">obj.sayHi();        <span class="comment">// "Hi!"</span></div></pre></td></tr></table></figure>
<p>이 예제에서, <code>createObject()</code> 함수는 익명의 클래스 표현식을 인수로하여 호출되고, <code>new</code>로 그 클래스의 인스턴스를 생성하여 인스턴스를 리턴합니다. 변수 <code>obj</code>는 반환된 인스턴스를 저장합니다.</p>
<p>클래스 표현식의 또 다른 흥미로운 사용법은 클래스 생성자를 즉시 호출하여 싱글톤을 생성하는 것입니다. 이렇게 하려면 클래스 표현식에<br> <code>new</code>를 사용해야 하고 마지막에 괄호를 포함해야합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="class"><span class="keyword">class</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">constructor</span>(name) &#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    sayName() &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;(<span class="string">"Nicholas"</span>);</div><div class="line"></div><div class="line">person.sayName();       <span class="comment">// "Nicholas"</span></div></pre></td></tr></table></figure>
<p>여기서 익명의 클래스 표현식이 생성되고 즉시 실행됩니다. 이 패턴을 사용하면 클래스 참조를 검사할 수 있게하지 않고도 싱글톤을 생성하기<br> 위한 클래스 구문을 사용할 수 있습니다(<code>PersonClass</code>는 바깥 쪽이 아닌 클래스 내에서만 바인딩을 생성한다는 것을 기억하십시오.). 클래스 표현식의 끝 부분에있는 괄호는 함수를 호출하는 동시에 인자를 전달할 수 있는 것을 나타냅니다.</p>
<p>지금까지 이 장의 예제는 메서드가 있는 클래스에 중점을 두었습니다. 그러나 객체 리터럴과 유사한 구문을 사용하여 클래스에 접근자(Accessor) 프로퍼티를 만들 수도 있습니다.</p>
<h2 id="접근자-Accessor-프로퍼티"><a href="#접근자-Accessor-프로퍼티" class="headerlink" title="접근자(Accessor) 프로퍼티"></a>접근자(Accessor) 프로퍼티</h2><p>클래스 생성자 내에서 자체 프로퍼티를 만들어야 하지만 클래스를 사용하면 프로토 타입에 접근자(Accessor) 프로퍼티를 정의할 수 있습니다. <em>Getter</em>를 만들려면 키워드 <code>get</code> 다음에 공백 문자와 식별자를 사용하합니다. <em>Setter</em>를 만들려면 <code>set</code> 키워드를 사용합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomHTMLElement</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">constructor</span>(element) &#123;</div><div class="line">        <span class="keyword">this</span>.element = element;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    get html() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.element.innerHTML;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    set html(value) &#123;</div><div class="line">        <span class="keyword">this</span>.element.innerHTML = value;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(CustomHTMLElement.prototype, <span class="string">"html"</span>);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"get"</span> <span class="keyword">in</span> descriptor);   <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"set"</span> <span class="keyword">in</span> descriptor);   <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(descriptor.enumerable); <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p>이 코드에서, <code>CustomHTMLElement</code> 클래스는 기존 DOM Element를 감싸는 래퍼로 만들어집니다. 그것은 Element 자체에 대한 <code>innerHTML</code> 메서드에 위임한 <code>html</code>을 위한 <em>Getter</em>와 <em>Setter</em>를 둘 다 가지고 있습니다. 이 접근자 프로퍼티는 <code>CustomHTMLElement.prototype</code>에서 생성되며, 다른 메서드와 마찬가지로 Non-enumerable로 생성됩니다. 클래스를 사용하지 않는 동일한 코드는 아래와 같습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 위 예제와 동일합니다.</span></div><div class="line"><span class="keyword">let</span> CustomHTMLElement = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line"><span class="meta"></span></div><div class="line">    "use strict";</div><div class="line"></div><div class="line">    <span class="keyword">const</span> CustomHTMLElement = <span class="function"><span class="keyword">function</span>(<span class="params">element</span>) </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">// new를 이용한 호출인지 확인 합니다.</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">new</span>.target === <span class="string">"undefined"</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Constructor must be called with new."</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.element = element;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">Object</span>.defineProperty(CustomHTMLElement.prototype, <span class="string">"html"</span>, &#123;</div><div class="line">        <span class="attr">enumerable</span>: <span class="literal">false</span>,</div><div class="line">        <span class="attr">configurable</span>: <span class="literal">true</span>,</div><div class="line">        <span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.element.innerHTML;</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">set</span>: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">            <span class="keyword">this</span>.element.innerHTML = value;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> CustomHTMLElement;</div><div class="line">&#125;());</div></pre></td></tr></table></figure>
<p>이전 예제와 마찬가지로 이 코드는 클래스를 이용하는 것이 동일한 기능을 하는 클래스를 사용하지 않는 코드에 비해 얼마나 코드를 줄일수 있는지 보여줍니다. <code>html</code> 접근자 프로퍼티 정의만이 거의 비슷한 크기입니다.</p>
<h2 id="계산된-멤버-이름"><a href="#계산된-멤버-이름" class="headerlink" title="계산된 멤버 이름"></a>계산된 멤버 이름</h2><p>객체 리터럴과 클래스 간의 유사점은 아직 끝나지 않았습니다. 클래스 메서드와 접근자 프로퍼티는 계산된 이름을 가질 수도 있습니다. 식별자를 사용하는 대신 표현식 주위에 대괄호를 사용합니다. 이 표현식은 객체 리터럴의 계산된 이름에 사용되는 구문과 동일합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> methodName = <span class="string">"sayName"</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonClass</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">constructor</span>(name) &#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    [methodName]() &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> me = <span class="keyword">new</span> PersonClass(<span class="string">"Nicholas"</span>);</div><div class="line">me.sayName();           <span class="comment">// "Nicholas"</span></div></pre></td></tr></table></figure>
<p>이 버전의 <code>PersonClass</code>는 변수를 사용하여 정의 안에 있는 메서드에 이름을 할당합니다. 문자열 <code>&quot;sayName&quot;</code>은 <code>methodName</code> 변수에 할당되고 메서드를 선언하기 위해 <code>methodName</code>이 사용됩니다. <code>sayName()</code> 메서드는 나중에 직접 액세스됩니다.</p>
<p>접근자 프로퍼티는 다음과 같은 방식으로 계산된 이름을 사용할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> propertyName = <span class="string">"html"</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomHTMLElement</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">constructor</span>(element) &#123;</div><div class="line">        <span class="keyword">this</span>.element = element;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    get [propertyName]() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.element.innerHTML;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    set [propertyName](value) &#123;</div><div class="line">        <span class="keyword">this</span>.element.innerHTML = value;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>여기서 <code>html</code>에 대한 <em>Getter</em>와 <em>Setter</em>는 <code>propertyName</code> 변수를 사용하여 설정됩니다. <code>.html</code>을 사용하여 프로퍼티에 접근하는 것은 정의에만 영향을 줍니다.</p>
<p>클래스와 객체 리터럴 간에는 메서드, 접근자 프로퍼티 및 계산된 이름등 많은 유사점이 있다는 것을 알았습니다. 그리고 <em>Generator</em>라는 유사점이 하나더 있습니다. </p>
<h2 id="Generator-메서드"><a href="#Generator-메서드" class="headerlink" title="Generator 메서드"></a><em>Generator</em> 메서드</h2><p>8 장에서 <em>Generator</em>를 소개할 때 메서드 이름에 별표 (<code>*</code>)를 추가하여 객체 리터럴에 <em>Generator</em>를 정의하는 방법을 배웠습니다. 클래스에 대해서도 동일한 구문이 적용되어 모든 메서드를 <em>Generator</em>로 사용할 수 있습니다. 다음은 그 예입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</div><div class="line"></div><div class="line">    *createIterator() &#123;</div><div class="line">        <span class="keyword">yield</span> <span class="number">1</span>;</div><div class="line">        <span class="keyword">yield</span> <span class="number">2</span>;</div><div class="line">        <span class="keyword">yield</span> <span class="number">3</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> MyClass();</div><div class="line"><span class="keyword">let</span> iterator = instance.createIterator();</div></pre></td></tr></table></figure>
<p>이 코드는 <code>createIterator()</code> <em>Generator</em> 메서드를 가지는 <code>MyClass</code>라는 클래스를 생성합니다. 이 메서드는 값이 <em>Generator</em>에 하드코딩된 <em>Iterator</em>를 반환합니다. <em>Generator</em> 메서드는 값의 컬렉션을 나타내는 객체가 있고 해당 값을 쉽게 반복할 때 유용합니다. <em>Array</em>, <em>Set</em>, <em>Map</em>은 모두 개발자들이 아이템과 상호 작용할 필요가 있는 다양한 방법을 설명하기 위해 여러 <em>Generator</em> 메서드를 가지고 있습니다.</p>
<p>클래스에 대한 기본 <em>Iterator</em>를 정의하면 클래스가 값 컬렉션을 나타내는 경우 훨씬 유용합니다. <code>Symbol.iterator</code>를 사용하여 다음과 같이 <em>Generator</em> 메서드를 정의하여 클래스의 기본 <em>Iterator</em>를 정의할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Collection</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">constructor</span>() &#123;</div><div class="line">        <span class="keyword">this</span>.items = [];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    *[<span class="built_in">Symbol</span>.iterator]() &#123;</div><div class="line">        <span class="keyword">yield</span> *<span class="keyword">this</span>.items.values();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> collection = <span class="keyword">new</span> Collection();</div><div class="line">collection.items.push(<span class="number">1</span>);</div><div class="line">collection.items.push(<span class="number">2</span>);</div><div class="line">collection.items.push(<span class="number">3</span>);</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> collection) &#123;</div><div class="line">    <span class="built_in">console</span>.log(x);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 결과:</span></div><div class="line"><span class="comment">// 1</span></div><div class="line"><span class="comment">// 2</span></div><div class="line"><span class="comment">// 3</span></div></pre></td></tr></table></figure>
<p>이 예제는 <code>this.items</code> 배열의 <code>values()</code> <em>Iterator</em>에 위임한 <em>Generator</em> 메서드에 대해 계산된 이름을 사용합니다. 컬렉션의 값을 관리하는 모든 클래스에는 기본 <em>Iterator</em>가 포함되어야 합니다. 컬렉션 관련 일부 작업에는 <em>Iterator</em>가 필요하기 때문입니다. 이제, <code>Collection</code>의 어떤 인스턴스도 <code>for-of</code> 루프나 <em>Spread</em> 연산자에 직접 사용될 수 있습니다.</p>
<p>클래스 프로토 타입에 메서드 및 접근자 프로퍼티를 추가하면 객체 인스턴스에 해당 메서드를 표시할 때 유용합니다. 반면에 클래스 자체의 메서드 또는 접근자 프로퍼티를 원하면 정적 멤버를 사용해야합니다.</p>
<h2 id="정적-멤버-Static-Member"><a href="#정적-멤버-Static-Member" class="headerlink" title="정적 멤버(Static Member)"></a>정적 멤버(Static Member)</h2><p>정적 멤버를 시뮬레이트하기 위해 생성자에 직접 메서드를 추가하는 것은 ECMAScript 5 및 이전 버전의 또 다른 공통 패턴입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">PersonType</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// static method</span></div><div class="line">PersonType.create = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PersonType(name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// instance method</span></div><div class="line">PersonType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person = PersonType.create(<span class="string">"Nicholas"</span>);</div></pre></td></tr></table></figure>
<p>다른 프로그래밍 언어에서, <code>PersonType.create()</code>라고 불리는 팩토리 메소드는 정적 메소드로 간주될 것입니다. 왜냐하면 <code>PersonType</code>의<br> 인스턴스에 의존하지 않기 때문입니다. ECMAScript 6 클래스는 메서드 또는 접근자 프로퍼티 이름 앞에 정식 <code>static</code> Annotation을 사용하여 정적 멤버 생성을 단순화합니다. 예를 들어, 다음은 이전 예제와 동일한 클래스입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonClass</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// PersonType constructor와 동일합니다.</span></div><div class="line">    <span class="keyword">constructor</span>(name) &#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// PersonType.prototype.sayName와 동일합니다.</span></div><div class="line">    sayName() &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// PersonType.create와 동일합니다.</span></div><div class="line">    <span class="keyword">static</span> create(name) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PersonClass(name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> person = PersonClass.create(<span class="string">"Nicholas"</span>);</div></pre></td></tr></table></figure>
<p><code>PersonClass</code> 정의는 <code>create()</code>라고 하는 하나의 정적 메서드를 가지고 있습니다. 메서드 구문은 <code>static</code> 키워드를 제외하고 <code>sayName()</code>과 동일합니다. <code>static</code> 키워드는 클래스 내의 임의의 메서드 또는 접근자 프로퍼티 정의에 사용할 수 있습니다. 유일한 제약은<code>static</code>을 <code>constructor</code> 메서드 정의와 함께 사용할 수 없다는 것입니다.</p>
<blockquote>
<p>정적 멤버는 인스턴스에서 액세스할 수 없습니다. 항상 클래스의 정적 멤버에 직접 액세스해야합니다.</p>
</blockquote>
<h2 id="파생-클래스를-사용한-상속"><a href="#파생-클래스를-사용한-상속" class="headerlink" title="파생 클래스를 사용한 상속"></a>파생 클래스를 사용한 상속</h2><p>ECMAScript 6 이전에는 사용자 정의 타입으로 상속을 구현할때 대규모 과정이 필요했습니다. 적절한 상속에는 여러 단계가 필요했습니다. 예를 들어 다음 예제를 살펴보겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params">length, width</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.length = length;</div><div class="line">    <span class="keyword">this</span>.width = width;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Rectangle.prototype.getArea = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.length * <span class="keyword">this</span>.width;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Square</span>(<span class="params">length</span>) </span>&#123;</div><div class="line">    Rectangle.call(<span class="keyword">this</span>, length, length);</div><div class="line">&#125;</div><div class="line"></div><div class="line">Square.prototype = <span class="built_in">Object</span>.create(Rectangle.prototype, &#123;</div><div class="line">    <span class="attr">constructor</span>: &#123;</div><div class="line">        <span class="attr">value</span>:Square,</div><div class="line">        <span class="attr">enumerable</span>: <span class="literal">true</span>,</div><div class="line">        <span class="attr">writable</span>: <span class="literal">true</span>,</div><div class="line">        <span class="attr">configurable</span>: <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">var</span> square = <span class="keyword">new</span> Square(<span class="number">3</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(square.getArea());              <span class="comment">// 9</span></div><div class="line"><span class="built_in">console</span>.log(square <span class="keyword">instanceof</span> Square);      <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(square <span class="keyword">instanceof</span> Rectangle);   <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p><code>Square</code>는 <code>Rectangle</code>을 상속받습니다. 그래서 <code>Square.prototype</code>을 <code>Rectangle.prototype</code>에서 생성한 새로운 객체로 덮어 쓰고<code>Rectangle.call()</code> 메서드를 호출해야합니다. 이 단계들은 종종 JavaScript 신참을 혼란스럽게 만들거나 경험 많은 개발자에게 오류의 원인이 되었습니다.</p>
<p>클래스는 익숙한 <code>extends</code> 키워드를 사용하여 클래스가 상속해야하는 함수를 지정함으로써 상속을 보다 쉽게 구현할 수 있도록합니다. 프로토 타입은 자동으로 조정되며 <code>super()</code> 메서드를 호출하여 기본 클래스 생성자에 액세스할 수 있습니다. 다음은 앞의 예제와 동일한 ECMAScript 6 코드입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(length, width) &#123;</div><div class="line">        <span class="keyword">this</span>.length = length;</div><div class="line">        <span class="keyword">this</span>.width = width;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    getArea() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.length * <span class="keyword">this</span>.width;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(length) &#123;</div><div class="line"></div><div class="line">        <span class="comment">// Rectangle.call(this, length, length)와 같습니다.</span></div><div class="line">        <span class="keyword">super</span>(length, length);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> square = <span class="keyword">new</span> Square(<span class="number">3</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(square.getArea());              <span class="comment">// 9</span></div><div class="line"><span class="built_in">console</span>.log(square <span class="keyword">instanceof</span> Square);      <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(square <span class="keyword">instanceof</span> Rectangle);   <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>이번에 <code>Square</code> 클래스는 <code>extends</code> 키워드를 사용하여 <code>Rectangle</code>에서 상속받습니다. <code>Square</code> 생성자는 <code>super()</code>를 사용하여 지정된 파라미터로 <code>Rectangle</code> 생성자를 호출합니다. ECMAScript 5 버전의 코드와 달리 식별자 <code>Rectangle</code>은 클래스 선언 (<code>extends</code>이후)에서만 사용됩니다.</p>
<p>다른 클래스로부터 상속받은 클래스를 파생 클래스(derived classes)라고합니다. 파생 클래스는 생성자를 지정하는 경우 <code>super()</code>를 사용해야합니다. 그렇지 않으면 오류가 발생합니다. 생성자를 사용하지 않기로 결정한 경우 클래스의 새 인스턴스를 만들 때 <code>super()</code>가 모든 파라미터와 함께 자동으로 호출됩니다. 예를 들어, 다음 두 클래스는 동일합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</div><div class="line">    <span class="comment">// 생성자가 없습니다.</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 위 클래스는 아래와 동일합니다.</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(...args) &#123;</div><div class="line">        <span class="keyword">super</span>(...args);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>이 예제의 두 번째 클래스는 모든 파생 클래스에 대한 기본 생성자와 동일합니다. 모든 파라미터는 순서대로 기본 클래스 생성자에 전달됩니다. 이전에 정의한 예제에서 <code>Square</code> 클래스의 생성자는 하나의 파라미터만 필요하기 때문에 <code>super(...args)</code>는 올바르지 않으므로 수동으로 생성자를 정의하는 것이 좋습니다.</p>
<blockquote>
<p><code>super()</code>를 사용할 때 유의해야할 몇 가지 사항이 있습니다.</p>
<ol>
<li><p>파생 클래스에서만 <code>super()</code>를 사용할 수 있습니다. 비 파생 클래스 (<code>extends</code>를 사용하지 않는 클래스) 또는 함수에서 사용하려고<br>하면 오류가 발생합니다.</p>
</li>
<li><p>생성자에서 <code>this</code>에 접근하기 전에 <code>super()</code>를 호출해야합니다. <code>super()</code>는 <code>this</code>를 초기화할 책임이 있기 때문에 <code>super()</code>를 호출하기 전에 <code>this</code>에 접근하려고 하면 에러가 발생합니다.</p>
</li>
<li><p><code>super()</code>를 호출하지 않는 유일한 방법은 클래스 생성자에서 객체를 반환하는 것입니다.</p>
</li>
</ol>
</blockquote>
<h3 id="클래스-메서드-숨기기"><a href="#클래스-메서드-숨기기" class="headerlink" title="클래스 메서드 숨기기"></a>클래스 메서드 숨기기</h3><p>파생 클래스의 메서드는 항상 기본 클래스에서 같은 이름의 메서드를 숨깁니다. 예를 들어, <code>Square</code>에 <code>getArea()</code>를 추가하면 그 기능을 재정의할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(length) &#123;</div><div class="line">        <span class="keyword">super</span>(length, length);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Rectangle.prototype.getArea()를 숨기고 재정의 합니다.</span></div><div class="line">    getArea() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.length * <span class="keyword">this</span>.length;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>getArea()</code>가 <code>Square</code>의 일부로 정의 되었기 때문에 <code>Rectangle.prototype.getArea()</code> 메서드는 <code>Square</code> 인스턴스에 의해 더이상 호출되지 않습니다. 물론, 다음과 같이 <code>super.getArea()</code> 메서드를 사용하여 메서드의 기본 클래스 버전을 호출하기로 결정할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(length) &#123;</div><div class="line">        <span class="keyword">super</span>(length, length);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Rectangle.prototype.getArea()를 숨기고 재정의 하여 호출 합니다.</span></div><div class="line">    getArea() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getArea();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>이런 방식으로 <code>super</code>를 사용하는 것은 4 장에서 논의된 <code>super</code> 참조와 똑같이 작동합니다 (“Super 참조를 사용한 쉬운 프로토 타입 액세스” 참조). <code>this</code> 값은 자동으로 올바르게 설정되어 간단하게 메소드 호출할 수 있습니다.</p>
<h3 id="정적-멤버-상속"><a href="#정적-멤버-상속" class="headerlink" title="정적 멤버 상속"></a>정적 멤버 상속</h3><p>기본 클래스에 정적 멤버가 있는 경우 해당 정적 멤버는 파생 클래스에서도 사용할 수 있습니다. 상속은 다른 언어의 경우와 마찬가지로 작동하지만 이는 JavaScript에서는 새로운 개념입니다. 다음은 그 예입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(length, width) &#123;</div><div class="line">        <span class="keyword">this</span>.length = length;</div><div class="line">        <span class="keyword">this</span>.width = width;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    getArea() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.length * <span class="keyword">this</span>.width;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> create(length, width) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Rectangle(length, width);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(length) &#123;</div><div class="line"></div><div class="line">        <span class="comment">// same as Rectangle.call(this, length, length)</span></div><div class="line">        <span class="keyword">super</span>(length, length);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> rect = Square.create(<span class="number">3</span>, <span class="number">4</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(rect <span class="keyword">instanceof</span> Rectangle);     <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(rect.getArea());                <span class="comment">// 12</span></div><div class="line"><span class="built_in">console</span>.log(rect <span class="keyword">instanceof</span> Square);        <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p>이 코드에서는 새로운 정적 <code>create()</code> 메서드가 <code>Rectangle</code> 클래스에 추가되었습니다. 이 메서드는 상속을 통해 <code>Square.create()</code>로 사용할 수 있으며 <code>Rectangle.create()</code> 메서드와 같은 방식으로 동작합니다.</p>
<h3 id="표현식에서-파생된-클래스"><a href="#표현식에서-파생된-클래스" class="headerlink" title="표현식에서 파생된 클래스"></a>표현식에서 파생된 클래스</h3><p>아마도 ECMAScript 6에서 파생 클래스의 가장 강력한 부분은 표현식에서 클래스를 파생시킬 수 있는 능력입니다. 표현식이 <code>[[Construct]]</code>와 프로토 타입을 가진 함수로 해석되는한 어떤 표현식이라도 <code>extends</code>을 사용할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params">length, width</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.length = length;</div><div class="line">    <span class="keyword">this</span>.width = width;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Rectangle.prototype.getArea = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.length * <span class="keyword">this</span>.width;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(length) &#123;</div><div class="line">        <span class="keyword">super</span>(length, length);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> Square(<span class="number">3</span>);</div><div class="line"><span class="built_in">console</span>.log(x.getArea());               <span class="comment">// 9</span></div><div class="line"><span class="built_in">console</span>.log(x <span class="keyword">instanceof</span> Rectangle);    <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p><code>Rectangle</code>은 ECMAScript 5 스타일 생성자로 정의되고 <code>Square</code>는 클래스입니다. <code>Rectangle</code>은 <code>[[Construct]]</code>와 프로토 타입을 가지고 있기 때문에 <code>Square</code> 클래스는 직접 상속받을 수 있습니다.</p>
<p><code>extends</code> 이후에 어떤 타입의 표현식이라도 받아들이면 상속받을 것을 동적으로 결정하는 것과 같은 강력한 가능성을 제공합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params">length, width</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.length = length;</div><div class="line">    <span class="keyword">this</span>.width = width;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Rectangle.prototype.getArea = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.length * <span class="keyword">this</span>.width;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getBase</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> Rectangle;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">getBase</span>() </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(length) &#123;</div><div class="line">        <span class="keyword">super</span>(length, length);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> Square(<span class="number">3</span>);</div><div class="line"><span class="built_in">console</span>.log(x.getArea());               <span class="comment">// 9</span></div><div class="line"><span class="built_in">console</span>.log(x <span class="keyword">instanceof</span> Rectangle);    <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p><code>getBase()</code> 함수는 클래스 선언의 일부로서 직접 호출되어 <code>Rectangle</code>을 반환합니다. 이 예제는 기능적으로 이전의 것과 같습니다. 그리고 기본 클래스를 동적으로 결정할 수 있으므로 서로 다른 상속 접근법을 만들 수 있습니다. 예를 들어 mixin을 효과적으로 만들 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> SerializableMixin = &#123;</div><div class="line">    serialize() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> AreaMixin = &#123;</div><div class="line">    getArea() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.length * <span class="keyword">this</span>.width;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mixin</span>(<span class="params">...mixins</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> base = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">    <span class="built_in">Object</span>.assign(base.prototype, ...mixins);</div><div class="line">    <span class="keyword">return</span> base;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">mixin</span>(<span class="title">AreaMixin</span>, <span class="title">SerializableMixin</span>) </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(length) &#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">        <span class="keyword">this</span>.length = length;</div><div class="line">        <span class="keyword">this</span>.width = length;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> Square(<span class="number">3</span>);</div><div class="line"><span class="built_in">console</span>.log(x.getArea());               <span class="comment">// 9</span></div><div class="line"><span class="built_in">console</span>.log(x.serialize());             <span class="comment">// "&#123;"length":3,"width":3&#125;"</span></div></pre></td></tr></table></figure>
<p>이 예에서는 클래식 상속 대신 mixin이 사용됩니다. <code>mixin()</code> 함수는 mixin 객체를 나타내는 파라미터를 취합니다. <code>base</code>라는 함수를 생성하고 각 mixin 객체의 프로퍼티를 프로토 타입에 할당합니다. <code>mixin()</code> 함수는 <code>Square</code>가 <code>extends</code>를 사용할 수 있도록 함수를 반환합니다. <code>extends</code>가 여전히 사용되기 때문에 생성자에서 <code>super()</code>를 호출해야 한다는 것을 명심하십시오.</p>
<p><code>Square</code>의 인스턴스는 <code>AreaMixin</code>의 <code>getArea()</code>와 <code>SerializableMixin</code>의 <code>serialize()</code>를 가지고 있습니다. 이는 프로토 타입 상속을 통해 수행됩니다. <code>mixin()</code> 함수는 새로운 함수의 프로토 타입을 각 <code>mixin</code>의 모든 프로퍼티로 동적으로 채웁니다. (여러 mixin이 동일한 속성을 갖는 경우 마지막 프로퍼티만 추가됩니다.)</p>
<blockquote>
<p>모든 표현식은<code>extends</code> 다음에 사용될 수 있지만, 모든 표현식이 유효한 클래스가되는 것은 아닙니다. 특히 다음 표현식 유형은 오류를 유발합니다.</p>
<ul>
<li><code>null</code></li>
<li>Generator 함수 (Chapter 8에서 설명함)</li>
</ul>
<p>이러한 경우, 호출할 <code>[[Construct]]</code>가 없으므로 클래스의 새 인스턴스를 만들려고하면 오류가 발생합니다.</p>
</blockquote>
<h3 id="내장-Built-in-상속"><a href="#내장-Built-in-상속" class="headerlink" title="내장(Built-in) 상속"></a>내장(Built-in) 상속</h3><p>JavaScript <em>Array</em>가 추가될때부터 개발자는 상속을 통해 자신만의 특별한 <em>Array</em> 타입을 만들고 싶어했습니다. ECMAScript 5 및 이전 버전에서는 이것이 가능하지 않았습니다. 고전적인 상속을 사용하려고 시도해도 코드가 작동하지 않았습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// built-in array 작동방법</span></div><div class="line"><span class="keyword">var</span> colors = [];</div><div class="line">colors[<span class="number">0</span>] = <span class="string">"red"</span>;</div><div class="line"><span class="built_in">console</span>.log(colors.length);         <span class="comment">// 1</span></div><div class="line"></div><div class="line">colors.length = <span class="number">0</span>;</div><div class="line"><span class="built_in">console</span>.log(colors[<span class="number">0</span>]);             <span class="comment">// undefined</span></div><div class="line"></div><div class="line"><span class="comment">// ES5에서 array를 상속하도록 시도함</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyArray</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">Array</span>.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">MyArray.prototype = <span class="built_in">Object</span>.create(<span class="built_in">Array</span>.prototype, &#123;</div><div class="line">    <span class="attr">constructor</span>: &#123;</div><div class="line">        <span class="attr">value</span>: MyArray,</div><div class="line">        <span class="attr">writable</span>: <span class="literal">true</span>,</div><div class="line">        <span class="attr">configurable</span>: <span class="literal">true</span>,</div><div class="line">        <span class="attr">enumerable</span>: <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> MyArray();</div><div class="line">colors[<span class="number">0</span>] = <span class="string">"red"</span>;</div><div class="line"><span class="built_in">console</span>.log(colors.length);         <span class="comment">// 0</span></div><div class="line"></div><div class="line">colors.length = <span class="number">0</span>;</div><div class="line"><span class="built_in">console</span>.log(colors[<span class="number">0</span>]);             <span class="comment">// "red"</span></div></pre></td></tr></table></figure>
<p>이 코드의 끝 부분에 있는 <code>console.log()</code> 출력은 <em>Array</em>에 JavaScript의 고전적인 상속 형태를 사용하여, 어떤 예기치 않은 동작을 일으키는 방법을 보여줍니다. <code>MyArray</code>의 인스턴스에서 <code>length</code>와 숫자 프로퍼티는 <code>Array.apply()</code> 또는 prototype을 할당해도 Built-in <em>Array</em>에서 처럼 동작하지 않습니다.</p>
<p>ECMAScript 6 클래스의 목표 중 하나는 모든 Built-in 함수에서 상속을 허용하는 것입니다. 이를 달성하기 위해 클래스의 상속 모델은 ECMAScript 5 및 이전 버전에서 보여준 고전적인 상속 모델과 약간 다릅니다.</p>
<p>ECMAScript 5 전통적인 상속에서 <code>this</code>의 값은 파생된 타입 (예를 들면, <code>MyArray</code>)에 의해 먼저 생성되고, <code>Array.apply()</code> 메서드와 같은 기본 타입 생성자가 호출됩니다. 즉, 이것은 <code>MyArray</code> 인스턴스로 시작하여 <em>Array</em>의 추가 프로퍼티로 꾸며져 있음을 의미합니다.</p>
<p>ECMAScript 6 클래스 기반 상속에서, <code>this</code>의 값은 먼저 기본타입(<code>Array</code>)에 의해 생성된 다음 파생 클래스 생성자 (<code>MyArray</code>)에 의해 수정됩니다. 결과적으로 <code>this</code>는 기본타입의 모든 Built-in 기능으로 시작하여 그에 관련된 모든 기능을 올바르게 상속합니다.</p>
<p>다음 예제는 클래스 기반 특수 Array의 실행을 보여줍니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</div><div class="line">    <span class="comment">// empty</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> MyArray();</div><div class="line">colors[<span class="number">0</span>] = <span class="string">"red"</span>;</div><div class="line"><span class="built_in">console</span>.log(colors.length);         <span class="comment">// 1</span></div><div class="line"></div><div class="line">colors.length = <span class="number">0</span>;</div><div class="line"><span class="built_in">console</span>.log(colors[<span class="number">0</span>]);             <span class="comment">// undefined</span></div></pre></td></tr></table></figure>
<p><code>MyArray</code>는 <code>Array</code>에서 직접 상속되므로 <code>Array</code>와 같이 작동합니다. 숫자 프로퍼티와 상호 작용하면 <code>length</code> 프로퍼티를 업데이트하고, <code>length</code> 프로퍼티를 조작하면 숫자 프로퍼티를 업데이트합니다. 즉, <code>Array</code>를 상속 받아서 자신만의 파생 <em>Array</em> 클래스를 만들고 다른 Built-in 함수를 상속받을 수 있다는 것을 의미합니다.</p>
<h3 id="Symbol-species-프로퍼티"><a href="#Symbol-species-프로퍼티" class="headerlink" title="Symbol.species 프로퍼티"></a>Symbol.species 프로퍼티</h3><p>Built-in 함수의 상속이 흥미로운 점은 Built-in 함수의 인스턴스를 반환하는 모든 메서드가 파생 클래스 인스턴스를 자동으로 반환한다는 것입니다. 그래서 <code>Array</code>를 상속받은 <code>MyArray</code>라는 파생 클래스가 있다면 <code>slice()</code>와 같은 메서드는 <code>MyArray</code>의 인스턴스를 리턴합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</div><div class="line">    <span class="comment">// empty</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> items = <span class="keyword">new</span> MyArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>),</div><div class="line">    subitems = items.slice(<span class="number">1</span>, <span class="number">3</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(items <span class="keyword">instanceof</span> MyArray);      <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(subitems <span class="keyword">instanceof</span> MyArray);   <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>이 코드에서 <code>slice()</code> 메서드는 <code>MyArray</code> 인스턴스를 반환합니다. <code>slice()</code> 메서드는 <code>Array</code>로부터 상속 받고 <code>Array</code>의 인스턴스를 정상적으로 리턴합니다. 하지만 뒤에서 이 변화를 일으키는 것은 <code>Symbol.species</code> 프로퍼티입니다.</p>
<p><code>Symbol.species</code> <em>Symbol</em>은 함수를 반환하는 정적(Static) 접근자(Accessor) 프로퍼티를 정의하는데 사용됩니다. 이 함수는 클래스의 인스턴스가 인스턴스 메서드 내부에서 만들어져야 할 때마다 생성자 대신 사용하는 생성자입니다. 아래의 Built-in 타입은 <code>Symbol.species</code>가 정의되어 있습니다.</p>
<ul>
<li>Array</li>
<li>ArrayBuffer (Chapter 10에서 논의 합니다.)</li>
<li>Map</li>
<li>Promise</li>
<li>RegExp</li>
<li>Set</li>
<li>Typed Array (Chapter 10에서 논의 합니다.)</li>
</ul>
<p>이 각각의 타입은 <code>this</code>를 반환하는 디폴트 <code>Symbol.species</code> 프로퍼티를 가지고 있습니다. 이것은 프로퍼티가 항상 생성자 함수를 반환한다는 것을 의미합니다. 커스텀 클래스에서 이 기능을 구현한다면 코드는 다음과 같이 보일 것입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 몇몇 builtin 타입은 이와 유사한 방법을 사용합니다.</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> get [<span class="built_in">Symbol</span>.species]() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">constructor</span>(value) &#123;</div><div class="line">        <span class="keyword">this</span>.value = value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    clone() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">this</span>.constructor[<span class="built_in">Symbol</span>.species](<span class="keyword">this</span>.value);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>이 예제에서 잘 알려진 <code>Symbol.species</code> <em>Symbol</em>은 <code>MyClass</code>에 정적 접근자 프로퍼티를 할당하는데 사용됩니다. 클래스의 타입 변경은 불가능하므로 setter가 없는 getter만 있습니다. <code>this.constructor [Symbol.species]</code>를 호출하면 <code>MyClass</code>가 리턴됩니다. <code>clone()</code> 메서드는 직접 <code>MyClass</code>를 사용하지 않고 클래스 정의(Class Definition)를 사용하여 새로운 인스턴스를 반환합니다. 그리고 파생 클래스가 그 값을 오버라이드(override) 할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> get [<span class="built_in">Symbol</span>.species]() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">constructor</span>(value) &#123;</div><div class="line">        <span class="keyword">this</span>.value = value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    clone() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">this</span>.constructor[<span class="built_in">Symbol</span>.species](<span class="keyword">this</span>.value);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDerivedClass1</span> <span class="keyword">extends</span> <span class="title">MyClass</span> </span>&#123;</div><div class="line">    <span class="comment">// empty</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDerivedClass2</span> <span class="keyword">extends</span> <span class="title">MyClass</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> get [<span class="built_in">Symbol</span>.species]() &#123;</div><div class="line">        <span class="keyword">return</span> MyClass;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> instance1 = <span class="keyword">new</span> MyDerivedClass1(<span class="string">"foo"</span>),</div><div class="line">    clone1 = instance1.clone(),</div><div class="line">    instance2 = <span class="keyword">new</span> MyDerivedClass2(<span class="string">"bar"</span>),</div><div class="line">    clone2 = instance2.clone();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(clone1 <span class="keyword">instanceof</span> MyClass);             <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(clone1 <span class="keyword">instanceof</span> MyDerivedClass1);     <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(clone2 <span class="keyword">instanceof</span> MyClass);             <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(clone2 <span class="keyword">instanceof</span> MyDerivedClass2);     <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p>여기에서 <code>MyDerivedClass1</code>은 <code>MyClass</code>를 상속 받고 <code>Symbol.species</code> 프로퍼티는 변경하지 않습니다. <code>clone()</code>이 호출되면, <code>this.constructor [Symbol.species]</code>가 <code>MyDerivedClass1</code>을 리턴하기 때문에 <code>MyDerivedClass1</code>의 인스턴스를 리턴합니다. <code>MyDerivedClass2</code> 클래스는 <code>MyClass</code>를 상속 받아 <code>Symbol.species</code>를 오버라이드하여 <code>MyClass</code>를 반환합니다. <code>MyDerivedClass2</code>의 인스턴스에서 <code>clone()</code>이 호출될 때, 반환 값은 <code>MyClass</code>의 인스턴스입니다. <code>Symbol.species</code>를 사용하여 파생 클래스는 메서드가 인스턴스를 리턴할 때 리턴되어야 하는 값의 타입을 판별할 수 있습니다.</p>
<p>예를 들어 <code>Array</code>는 <code>Symbol.species</code>를 사용하여 배열을 반환하는 메서드에 사용할 클래스를 지정합니다. <code>Array</code>에서 파생된 클래스에서 다음과 같이 상속된 메서드에서 반환된 객체의 타입을 결정할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> get [<span class="built_in">Symbol</span>.species]() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">Array</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> items = <span class="keyword">new</span> MyArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>),</div><div class="line">    subitems = items.slice(<span class="number">1</span>, <span class="number">3</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(items <span class="keyword">instanceof</span> MyArray);      <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(subitems <span class="keyword">instanceof</span> <span class="built_in">Array</span>);     <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(subitems <span class="keyword">instanceof</span> MyArray);   <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p>이 코드는 <code>Array</code>를 상속받은 <code>MyArray</code>의 <code>Symbol.species</code>를 오버라이드합니다. <em>Array</em>를 반환하는 모든 상속된 메서드는 이제<code>MyArray</code> 대신 <code>Array</code> 인스턴스를 사용합니다.</p>
<p>일반적으로 클래스 메서드에서 <code>this.constructor</code>를 사용하려고 할 때마다 <code>Symbol.species</code> 프로퍼티를 사용해야합니다. 이렇게하면 파생 클래스가 반환 형식을 쉽게 재정의할 수 있습니다. 또한 <code>Symbol.species</code>가 정의된 클래스에서 파생 클래스를 만드는 경우에도 생성자 대신 사용해야 합니다.</p>
<h2 id="클래스-생성자에서-new-target-사용"><a href="#클래스-생성자에서-new-target-사용" class="headerlink" title="클래스 생성자에서 new.target 사용"></a>클래스 생성자에서 new.target 사용</h2><p>3 장에서는 <code>new.target</code>과 함수가 호출되는 방식에 따라 값이 변경되는 방법에 대해 알게되었습니다. 클래스 생성자에서 <code>new.target</code>을 사용하여 클래스가 호출되는 방법을 결정할 수도 있습니다. <code>new.target</code>은 다음 예제와 같이 클래스 생성자 함수와 같습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(length, width) &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">new</span>.target === Rectangle);</div><div class="line">        <span class="keyword">this</span>.length = length;</div><div class="line">        <span class="keyword">this</span>.width = width;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// new.target은 Rectangle입니다.</span></div><div class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Rectangle(<span class="number">3</span>, <span class="number">4</span>);      <span class="comment">// true 출력</span></div></pre></td></tr></table></figure>
<p>이 코드의 <code>new.target</code>은 <code>new Rectangle(3, 4)</code>이 호출될 때 <code>Rectangle</code>과 동일하다는 것을 보여줍니다. 클래스 생성자는 <code>new</code>가 없으면 호출될 수 없으므로 <code>new.target</code> 프로퍼티는 항상 클래스 생성자 내부에서 정의됩니다. 그러나 그 값이 항상 같지는 않을 수도 있습니다. 다음 코드를 살펴보겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(length, width) &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">new</span>.target === Rectangle);</div><div class="line">        <span class="keyword">this</span>.length = length;</div><div class="line">        <span class="keyword">this</span>.width = width;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(length) &#123;</div><div class="line">        <span class="keyword">super</span>(length, length)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// new.target is Square</span></div><div class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Square(<span class="number">3</span>);      <span class="comment">// 결과는 false</span></div></pre></td></tr></table></figure>
<p><code>Square</code>는 <code>Rectangle</code> 생성자를 호출하고 <code>Rectangle</code> 생성자가 호출될 때 <code>new.target</code>은 <code>Square</code>와 같습니다. 이는 각 생성자에게 호출되는 방식에 따라 동작을 변경할 수있는 기능을 제공하므로 중요합니다. 예를 들어, 다음과 같이 <code>new.target</code>을 사용하여 추상적인 기본 클래스 (직접적으로 인스턴스화할 수없는 클래스)를 생성할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// abstract base class</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>() &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">new</span>.target === Shape) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"This class cannot be instantiated directly."</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(length, width) &#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">        <span class="keyword">this</span>.length = length;</div><div class="line">        <span class="keyword">this</span>.width = width;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> Shape();                <span class="comment">// throws error</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> y = <span class="keyword">new</span> Rectangle(<span class="number">3</span>, <span class="number">4</span>);        <span class="comment">// no error</span></div><div class="line"><span class="built_in">console</span>.log(y <span class="keyword">instanceof</span> Shape);    <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>이 예제에서 <code>Shape</code> 클래스 생성자는 <code>new.target</code>이 <code>Shape</code> 일 때마다 에러를 던집니다. 즉, <code>new Shape ()</code>는 항상 에러를 던집니다. 그러나 여전히 <code>Rectangle</code>에서 사용하는 것처럼 <code>Shape</code>을 기본 클래스로 사용할 수 있습니다.  <code>super()</code> 호출은 <code>Shape</code> 생성자를 실행하고 <code>new.target</code>은 <code>Rectangle</code>과 같습니다. 그래서 생성자는 오류없이 계속됩니다.</p>
<blockquote>
<p><code>new</code>가 없으면 클래스를 호출할 수 없으므로 <code>new.target</code> 프로퍼티는 결코 클래스 생성자 내부에서 정의되지 않습니다.</p>
</blockquote>
<h2 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h2><p>ECMAScript 6 클래스는 JavaScript에서 상속을 사용하기 쉽게하기 때문에 다른 언어에서 상속에 대한 기존의 이해를 버릴 필요가 없습니다. ECMAScript 6 클래스는 ECMAScript 5의 클래식 상속 모델에 대한 Syntactic sugar로 시작하지만 실수를 줄이기위한 많은 기능을 추가합니다.</p>
<p>ECMAScript 6 클래스는 클래스 프로토 타입에 비 정적 메서드를 정의하여 프로토 타입 상속과 함께 작동하고, 정적 메서드는 생성자 자체에서 끝납니다. 클래스의 모든 메소드는 Non-enumerable이며, 기본적으로 Non-enumerable인 Built-in 객체의 동작과 더 잘 일치하는 기능입니다. 또한 클래스 생성자는 <code>new</code>가 없으면 호출할 수 없으므로 실수로 클래스를 함수로 호출할 수 없습니다.</p>
<p>클래스 기반 상속을 사용하면 다른 클래스, 함수 또는 표현식에서 클래스를 파생시킬 수 있습니다. 이 기능을 사용하여 상속할 올바른 기준을 결정하는 함수를 호출할 수 있으므로 mixin 및 다른 여러 구성 패턴을 사용하여 새 클래스를 만들 수 있습니다. 상속은 <code>Array</code>와 같은 Built-in 객체를 상속하는 것이 가능합니다.</p>
<p>클래스 생성자에서 <code>new.target</code>을 사용하여 클래스가 어떻게 호출되는지에 따라 다르게 행동할 수 있습니다. 가장 보편적인 사용은 직접적으로 인스턴스화 될 때 오류를 던지지만 다른 클래스를 통해 상속을 허용하는 추상 기본 클래스를 만드는 것입니다.</p>
<p>전반적으로 클래스는 JavaScript에 중요한 추가 요소입니다. 보다 간결한 구문과 사용자 정의 객체 타입을 안전하고 일관된 방식으로 정의하기 위한 더 나은 기능을 제공합니다.</p>
<hr>
<blockquote>
<p>이 내용은 나중에 참고하기 위해 제가 공부하며 정리한 내용입니다.<br>의역, 오역, 직역이 있을 수 있음을 알려드립니다.<br>This post is a translation of this original article [<a href="https://leanpub.com/understandinges6/read#leanpub-auto-introducing-javascript-classes" target="_blank" rel="external">https://leanpub.com/understandinges6/read#leanpub-auto-introducing-javascript-classes</a>]</p>
</blockquote>
<h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul>
<li><a href="https://infoscis.github.io/2018/01/24/ecmascript-6-block-binding/">ECMAScript 6 Block Binding</a></li>
<li><a href="https://infoscis.github.io/2018/01/24/ecmascript-6-strings-and-regular-expressions/">ECMAScript 6 문자열과 정규 표현식</a></li>
<li><a href="https://infoscis.github.io/2018/01/24/ecmascript-6-functions/">ECMAScript 6 함수</a></li>
<li><a href="https://infoscis.github.io/2018/01/25/ecmascript-6-expanded-object-functionality/">ECMAScript 6 객체의 확장된 기능</a></li>
<li><a href="https://infoscis.github.io/2018/01/26/ecmascript-6-destructuring-for-easier-data-access/">ECMAScript 6 쉬운 데이터 액세스를 위한 Destructuring</a></li>
<li><a href="https://infoscis.github.io/2018/01/27/ecmascript-6-symbols-and-symbol-properties/">ECMAScript 6 Symbol과 Symbol 프로퍼티</a></li>
<li><a href="https://infoscis.github.io/2018/01/27/ecmascript-6-sets-and-maps/">ECMAScript 6 Set과 Map</a></li>
<li><a href="https://infoscis.github.io/2018/01/31/ecmascript-6-iterators-and-generators/">ECMAScript 6 Iterator와 Generator</a></li>
<li><a href="https://infoscis.github.io/2018/02/13/ecmascript-6-introducing-javascript-classes/">ECMAScript 6 JavaScript 클래스 소개</a></li>
<li><a href="https://infoscis.github.io/2018/02/13/ecmascript-6-improved-array-capabilities/">ECMAScript 6 Array 기능 향상</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-promises-and-asynchronous-programming/">ECMAScript 6 Promise와 비동기 프로그램밍</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-proxies-and-the-reflection-api/">ECMAScript 6 프록시와 리플렉션 API</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-encapsulating-code-with-modules/">ECMAScript 6 Module로 코드 캡슐화하기</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-appendix-a-smaller-changes/">ECMAScript 6 부록 A. 작은 변경 사항</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-appendix-b-understanding-ecmascript-7/">ECMAScript 6 부록 B. ECMAScript 7(2016) 이해하기</a></li>
</ul>

        </div>
        <footer class="article-footer">
            



    <a data-url="http://infoscis.github.io/2018/02/13/ecmascript-6-introducing-javascript-classes/" data-id="cjkl91034003cjguzkfxjt62o" class="article-share-link"><i class="fa fa-share"></i>공유하기</a>
<script>
    (function ($) {
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

        </footer>
    </div>
</article>

    <section id="comments">
    
        
    <div id="disqus_thread">
        <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>

    
    </section>


                        </div>
                    </section>
                    <aside id="sidebar">
    <a class="sidebar-toggle" title="Expand Sidebar"><i class="toggle icon"></i></a>
    <div class="sidebar-top">
        <p>팔로우:</p>
        <ul class="social-links">
            
                
                <li>
                    <a class="social-tooltip" title="github" href="https://github.com/infoscis" target="_blank">
                        <i class="icon fa fa-github"></i>
                    </a>
                </li>
                
            
        </ul>
    </div>
    
        
<nav id="article-nav">
    
        <a href="/2018/02/13/ecmascript-6-improved-array-capabilities/" id="article-nav-newer" class="article-nav-link-wrap">
        <strong class="article-nav-caption">새로운</strong>
        <p class="article-nav-title">
        
            Array 기능 향상
        
        </p>
        <i class="icon fa fa-chevron-right" id="icon-chevron-right"></i>
    </a>
    
    
        <a href="/2018/02/13/understanding-viewchildren-contentchildren-and-querylist-in-angular/" id="article-nav-older" class="article-nav-link-wrap">
        <strong class="article-nav-caption">오래된</strong>
        <p class="article-nav-title">Angular에서 ViewChildren, ContentChildren, 그리고 QueryList 이해하기</p>
        <i class="icon fa fa-chevron-left" id="icon-chevron-left"></i>
        </a>
    
</nav>

    
    <div class="widgets-container">
        
            
                
    <div class="widget-wrap">
        <h3 class="widget-title">최근 글</h3>
        <div class="widget">
            <ul id="recent-post" class="no-thumbnail">
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Angular/">Angular</a></p>
                            <p class="item-title"><a href="/2018/08/08/angular-observables-and-rxjs/" class="title">Angular Observable &amp; RxJS</a></p>
                            <p class="item-date"><time datetime="2018-08-08T14:38:02.000Z" itemprop="datePublished">2018-08-08</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/JavaScript/">JavaScript</a><i class="icon fa fa-angle-right"></i><a class="article-category-link" href="/categories/JavaScript/ECMAScript-2015/">ECMAScript 2015</a></p>
                            <p class="item-title"><a href="/2018/02/27/ecmascript-6-appendix-b-understanding-ecmascript-7/" class="title">ECMAScript 6 부록 B. ECMAScript 7 (2016) 이해하기</a></p>
                            <p class="item-date"><time datetime="2018-02-27T13:32:48.000Z" itemprop="datePublished">2018-02-27</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/JavaScript/">JavaScript</a><i class="icon fa fa-angle-right"></i><a class="article-category-link" href="/categories/JavaScript/ECMAScript-2015/">ECMAScript 2015</a></p>
                            <p class="item-title"><a href="/2018/02/27/ecmascript-6-appendix-a-smaller-changes/" class="title">ECMAScript 6 부록 A. 작은 변경 사항</a></p>
                            <p class="item-date"><time datetime="2018-02-27T13:32:12.000Z" itemprop="datePublished">2018-02-27</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/JavaScript/">JavaScript</a><i class="icon fa fa-angle-right"></i><a class="article-category-link" href="/categories/JavaScript/ECMAScript-2015/">ECMAScript 2015</a></p>
                            <p class="item-title"><a href="/2018/02/27/ecmascript-6-encapsulating-code-with-modules/" class="title">ECMAScript 6 Module로 코드 캡슐화하기</a></p>
                            <p class="item-date"><time datetime="2018-02-27T13:31:45.000Z" itemprop="datePublished">2018-02-27</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/JavaScript/">JavaScript</a><i class="icon fa fa-angle-right"></i><a class="article-category-link" href="/categories/JavaScript/ECMAScript-2015/">ECMAScript 2015</a></p>
                            <p class="item-title"><a href="/2018/02/27/ecmascript-6-proxies-and-the-reflection-api/" class="title">ECMAScript 6 프록시와 리플렉션 API</a></p>
                            <p class="item-date"><time datetime="2018-02-27T13:31:03.000Z" itemprop="datePublished">2018-02-27</time></p>
                        </div>
                    </li>
                
            </ul>
        </div>
    </div>

            
                
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">카테고리</h3>
        <div class="widget">
            <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Angular/">Angular</a><span class="category-list-count">15</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hadoop/">Hadoop</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">5</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/Java9/">Java9</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/Spring/">Spring</a><span class="category-list-count">2</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/">JavaScript</a><span class="category-list-count">16</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/ECMAScript-2015/">ECMAScript 2015</a><span class="category-list-count">15</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/TypeScript/">TypeScript</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Webpack/">Webpack</a><span class="category-list-count">1</span></li></ul>
        </div>
    </div>


            
                
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">아카이브</h3>
        <div class="widget">
            <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">8월 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">2월 2018</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">1월 2018</a><span class="archive-list-count">11</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">7월 2017</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">6월 2017</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">5월 2017</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">3월 2017</a><span class="archive-list-count">5</span></li></ul>
        </div>
    </div>


            
                
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">태그</h3>
        <div class="widget">
            <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Angular/">Angular</a><span class="tag-list-count">15</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ECMAScript-2015/">ECMAScript 2015</a><span class="tag-list-count">15</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Event/">Event</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hadoop/">Hadoop</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JDK9/">JDK9</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java9/">Java9</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript</a><span class="tag-list-count">29</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Jigsaw/">Jigsaw</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nashorn/">Nashorn</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/">Spring</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringBoot/">SpringBoot</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TypeScript/">TypeScript</a><span class="tag-list-count">12</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Webpack/">Webpack</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/YARN/">YARN</a><span class="tag-list-count">1</span></li></ul>
        </div>
    </div>


            
                
    <div class="widget-wrap widget-float">
        <h3 class="widget-title">태그 클라우드</h3>
        <div class="widget tagcloud">
            <a href="/tags/Angular/" style="font-size: 18px;">Angular</a> <a href="/tags/ECMAScript-2015/" style="font-size: 18px;">ECMAScript 2015</a> <a href="/tags/Event/" style="font-size: 10px;">Event</a> <a href="/tags/Hadoop/" style="font-size: 10px;">Hadoop</a> <a href="/tags/JDK9/" style="font-size: 12px;">JDK9</a> <a href="/tags/Java/" style="font-size: 14px;">Java</a> <a href="/tags/Java9/" style="font-size: 12px;">Java9</a> <a href="/tags/JavaScript/" style="font-size: 20px;">JavaScript</a> <a href="/tags/Jigsaw/" style="font-size: 12px;">Jigsaw</a> <a href="/tags/Nashorn/" style="font-size: 10px;">Nashorn</a> <a href="/tags/Spring/" style="font-size: 12px;">Spring</a> <a href="/tags/SpringBoot/" style="font-size: 10px;">SpringBoot</a> <a href="/tags/TypeScript/" style="font-size: 16px;">TypeScript</a> <a href="/tags/Webpack/" style="font-size: 10px;">Webpack</a> <a href="/tags/YARN/" style="font-size: 10px;">YARN</a>
        </div>
    </div>


            
        
    </div>
</aside>
                </div>
            </div>
        </div>
        <footer id="footer">
    <div class="container">
        <div class="container-inner">
            <a id="back-to-top" href="javascript:;"><i class="icon fa fa-angle-up"></i></a>
            <div class="credit">
                <h1 class="logo-wrap">
                    <a href="/" class="logo"></a>
                </h1>
                <p>&copy; 2018 Jongcheol-Kim</p>
                <p>Powered by <a href="//hexo.io/" target="_blank">Hexo</a>. Theme by <a href="//github.com/ppoffice" target="_blank">PPOffice</a></p>
            </div>
        </div>
    </div>
</footer>
        
    
    <script>
    var disqus_shortname = 'infoscis';
    
    
    var disqus_url = 'http://infoscis.github.io/2018/02/13/ecmascript-6-introducing-javascript-classes/';
    
    (function() {
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    </script>




    
        <script src="/libs/lightgallery/js/lightgallery.min.js"></script>
        <script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>
        <script src="/libs/lightgallery/js/lg-pager.min.js"></script>
        <script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>
        <script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>
        <script src="/libs/lightgallery/js/lg-zoom.min.js"></script>
        <script src="/libs/lightgallery/js/lg-hash.min.js"></script>
        <script src="/libs/lightgallery/js/lg-share.min.js"></script>
        <script src="/libs/lightgallery/js/lg-video.min.js"></script>
    
    
        <script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script>
    
    


<!-- Custom Scripts -->
<script src="/js/main.js"></script>

    </div>
</body>
</html>
