<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    
    <title>ECMAScript 6 Promise와 비동기 프로그램밍 | Developer&#39;s Record</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
        <meta name="keywords" content="JavaScript,ECMAScript 2015" />
    
    <meta name="description" content="ECMASCript 6 Promise와 비동기 프로그램밍JavaScript의 가장 강력한 부분중 하나는 비동기 프로그래밍을 쉽게 처리할 수 있다는 것입니다. 웹용으로 작성된 언어로서 JavaScript는 처음부터 클릭및 키누름과 같은 비동기 사용자 상호 작용에 응답할 수 있어야 했습니다. Node.js는 Event 대신에 Callback을 사용하여 Java">
<meta property="og:type" content="article">
<meta property="og:title" content="ECMAScript 6 Promise와 비동기 프로그램밍">
<meta property="og:url" content="http://infoscis.github.io/2018/02/27/ecmascript-6-promises-and-asynchronous-programming/index.html">
<meta property="og:site_name" content="Developer's Record">
<meta property="og:description" content="ECMASCript 6 Promise와 비동기 프로그램밍JavaScript의 가장 강력한 부분중 하나는 비동기 프로그래밍을 쉽게 처리할 수 있다는 것입니다. 웹용으로 작성된 언어로서 JavaScript는 처음부터 클릭및 키누름과 같은 비동기 사용자 상호 작용에 응답할 수 있어야 했습니다. Node.js는 Event 대신에 Callback을 사용하여 Java">
<meta property="og:updated_time" content="2018-02-27T14:11:08.031Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ECMAScript 6 Promise와 비동기 프로그램밍">
<meta name="twitter:description" content="ECMASCript 6 Promise와 비동기 프로그램밍JavaScript의 가장 강력한 부분중 하나는 비동기 프로그래밍을 쉽게 처리할 수 있다는 것입니다. 웹용으로 작성된 언어로서 JavaScript는 처음부터 클릭및 키누름과 같은 비동기 사용자 상호 작용에 응답할 수 있어야 했습니다. Node.js는 Event 대신에 Callback을 사용하여 Java">
    
    <link rel="canonical" href="http://infoscis.github.io/2018/02/27/ecmascript-6-promises-and-asynchronous-programming/"/>

    

    
        <link rel="icon" href="/favicon.png" />
    

    <link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="/libs/titillium-web/styles.css">
    <link rel="stylesheet" href="/libs/source-code-pro/styles.css">

    <link rel="stylesheet" href="/css/style.css">

    <script src="/libs/jquery/2.0.3/jquery.min.js"></script>
    
    
        <link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">
    
    
        <link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css">
    
    
        <script type="text/javascript">
(function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-100332906-1', 'auto');
ga('send', 'pageview');

</script>
    
    

</head>

<body>
    <div id="wrap">
        <header id="header">
    <div id="header-outer" class="outer">
        <div class="container">
            <div class="container-inner">
                <div id="header-title">
                    <h1 class="logo-wrap">
                        <a href="/" class="logo"></a>
                    </h1>
                    
                        <h2 class="subtitle-wrap">
                            <p class="subtitle">개발자의 기록 보관소</p>
                        </h2>
                    
                </div>
                <div id="header-inner" class="nav-container">
                    <a id="main-nav-toggle" class="nav-icon fa fa-bars"></a>
                    <div class="nav-container-inner">
                        <ul id="main-nav">
                            
                                <li class="main-nav-list-item" >
                                    <a class="main-nav-list-link" href="/">홈</a>
                                </li>
                            
                                        <ul class="main-nav-list"><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Angular/">Angular</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Hadoop/">Hadoop</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Java/">Java</a><ul class="main-nav-list-child"><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Java/Java9/">Java9</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Java/Spring/">Spring</a></li></ul></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/JavaScript/">JavaScript</a><ul class="main-nav-list-child"><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/JavaScript/ECMAScript-2015/">ECMAScript 2015</a></li></ul></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Kotlin/">Kotlin</a><ul class="main-nav-list-child"><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Kotlin/SpringBoot/">SpringBoot</a></li></ul></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/TypeScript/">TypeScript</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Webpack/">Webpack</a></li></ul>
                                    
                                <li class="main-nav-list-item" >
                                    <a class="main-nav-list-link" href="https://about.me/jongcheol.kim">About</a>
                                </li>
                            
                        </ul>
                        <nav id="sub-nav">
                            <div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="검색" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="Type something..." />
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '포스트',
            PAGES: 'Pages',
            CATEGORIES: '카테고리',
            TAGS: '태그',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div>
                        </nav>
                    </div>
                </div>
            </div>
        </div>
    </div>
</header>
        <div class="container">
            <div class="main-body container-inner">
                <div class="main-body-inner">
                    <section id="main">
                        <div class="main-body-header">
    <h1 class="header">
    
    <a class="page-title-link" href="/categories/JavaScript/">JavaScript</a><i class="icon fa fa-angle-right"></i><a class="page-title-link" href="/categories/JavaScript/ECMAScript-2015/">ECMAScript 2015</a>
    </h1>
</div>
                        <div class="main-body-content">
                            <article id="post-ecmascript-6-promises-and-asynchronous-programming" class="article article-single article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
            <header class="article-header">
                
    
        <h1 class="article-title" itemprop="name">
        ECMAScript 6 Promise와 비동기 프로그램밍
        </h1>
    

            </header>
        
        
            <div class="article-meta">
                
    <div class="article-date">
        <a href="/2018/02/27/ecmascript-6-promises-and-asynchronous-programming/" class="article-date">
            <time datetime="2018-02-27T13:30:33.000Z" itemprop="datePublished">2018-02-27</time>
        </a>
    </div>

                
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/ECMAScript-2015/">ECMAScript 2015</a>, <a class="tag-link" href="/tags/JavaScript/">JavaScript</a>
    </div>

            </div>
        
        
        <div class="article-entry" itemprop="articleBody">
            <h1 id="ECMASCript-6-Promise와-비동기-프로그램밍"><a href="#ECMASCript-6-Promise와-비동기-프로그램밍" class="headerlink" title="ECMASCript 6 Promise와 비동기 프로그램밍"></a>ECMASCript 6 Promise와 비동기 프로그램밍</h1><p>JavaScript의 가장 강력한 부분중 하나는 비동기 프로그래밍을 쉽게 처리할 수 있다는 것입니다. 웹용으로 작성된 언어로서 JavaScript는 처음부터 클릭및 키누름과 같은 비동기 사용자 상호 작용에 응답할 수 있어야 했습니다. Node.js는 <em>Event</em> 대신에 <em>Callback</em>을 사용하여 JavaScript에서 비동기 프로그래밍을 대중화했습니다. 비동기 프로그래밍을 사용하는 프로그램이 점점 더 많아짐에 따라 <em>Event</em> 및 <em>Callback</em>은 더 이상 개발자가 원하는 모든 것을 지원할만큼 강력하지 않았습니다. <em>Promise</em>는 이러한 문제에 대한 해결책입니다.</p>
<p><em>Promise</em>는 비동기 프로그래밍의 또 다른 옵션이며 다른 언어의 <em>Future</em>와 <em>Deferred</em>와 같이 작동합니다. <em>Promise</em>는 나중에 (<em>Event</em> 및 <em>Callback</em>과 같이) 실행될 코드를 지정하고 작업에서 코드의 성공 또는 실패 여부를 명시적으로 나타냅니다. 코드를 이해하고 디버그하기 쉽게 만드는 방법으로 성공 또는 실패를 기반으로 <em>Promise</em>를 연결할 수 있습니다.</p>
<p><em>Promise</em>가 어떻게 작동하는지 잘 이해하려면 처음 생성되었을 때의 기본 개념을 이해하는 것이 매우 중요합니다.</p>
<h2 id="비동기-프로그래밍-배경"><a href="#비동기-프로그래밍-배경" class="headerlink" title="비동기 프로그래밍 배경"></a>비동기 프로그래밍 배경</h2><p>JavaScript 엔진은 단일 스레드 <em>Event Loop</em> 개념을 기반으로 합니다. 단일 스레드는 한번에 하나의 코드만 실행한다는 것을 의미합니다. 이것을 스레드가 여러 다른 코드를 동시에 실행할 수 있는 Java 또는 C++과 같은 언어와 비교됩니다. 여러 코드가 특정 <em>State</em>를 액세스하여 변경할 수 있을때 <em>State</em>를 유지 및 보호하는 것은 어려운 문제이며 스레드 기반 소프트웨어의 빈번한 버그의 원인이 됩니다.</p>
<p>JavaScript 엔진은 한번에 하나의 코드만 실행할 수 있으므로 실행할 코드를 추적할 수 있어야 합니다. 이 코드는 <em>Job Queue(작업 대기열)</em>에 보관됩니다. 코드 조각은 실행할 준비가되면 <em>Job Queue</em>에 추가됩니다. JavaScript 엔진이 코드 실행을 완료하면 <em>Event Loop</em>는 <em>Queue</em>의 다음 작업을 실행합니다. <em>Event Loop</em>는 코드 실행을 모니터링하고 <em>Job Queue</em>를 관리하는 JavaScript 엔진 내부의 프로세스입니다. <em>Queue</em>의 작업 실행은 <em>Queue</em>의 첫 번째 작업에서 마지막 작업까지 실행됩니다</p>
<h3 id="Event-모델"><a href="#Event-모델" class="headerlink" title="Event 모델"></a>Event 모델</h3><p>사용자가 버튼을 클릭하거나 키보드의 키를 누르면 <code>onclick</code>과 같은 <em>Event</em>가 발생됩니다. 이 <em>Event</em>는 <em>Job Queue</em> 뒤쪽에 새 작업을 추가하여 상호 작용에 응답할 수 있습니다. 이것이 JavaScript의 가장 기본적인 비동기 프로그래밍 형식입니다. <em>Event</em> 핸들러 코드는 <em>Event</em>가 발생할 때까지 실행되지 않으며 작업이 실행될 때 적절한 컨텍스트를 갖습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> button = <span class="built_in">document</span>.getElementById(<span class="string">"my-btn"</span>);</div><div class="line">button.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Clicked"</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>이 코드에서,<code>console.log(&quot;Clicked&quot;)</code>는 <code>button</code>이 클릭될 때까지 실행되지 않습니다. <code>button</code>을 클릭하면 <code>onclick</code>에 할당된 기능이 <em>Job Queue</em>의 뒤쪽에 추가되고 이전 모든 작업이 완료되면 실행됩니다.</p>
<p><em>Event</em>는 간단한 상호 작용에는 잘 작동하지만 여러 개의 개별 비동기 호출을 함께 연결해야 할때, 각 <em>Event</em>에 대한 <em>Event</em> 대상 (앞의 예제에서 <code>button</code>)을 추적해야하기 때문에 더 복잡합니다. 또한 <em>Event</em>가 처음 발생하기 전에 모든 적절한 <em>Event</em> 핸들러를 추가 해야합니다. 예를 들어 <code>onclick</code>이 지정되기 전에 <code>button</code>이 클릭되면 아무 일도 일어나지 않을 것입니다. <em>Event</em>가 사용자 상호 작용 및 이와 유사한 기능에 대한 응답에 유용하기는 하지만 보다 복잡한 요구에 대해서는 매우 유연하지 않습니다.</p>
<h3 id="Callback-패턴"><a href="#Callback-패턴" class="headerlink" title="Callback 패턴"></a>Callback 패턴</h3><p>Node.js가 만들어지고 <em>Callback</em> 패턴 프로프래밍이 대중화하여 비동기 프로그래밍 모델을 발전 시킬수 있었습니다. 비동기 코드는 나중 시점까지 실행되지 않기 때문에 <em>Callback</em> 패턴은 <em>Event</em> 모델과 유사합니다. <em>Callback</em> 패턴은 다음과 같이 호출할 함수가 파라미터로 전달되기 때문에 <em>Event</em> 모델과 다릅니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">readFile(<span class="string">"example.txt"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, contents</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (err) &#123;</div><div class="line">        <span class="keyword">throw</span> err;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">console</span>.log(contents);</div><div class="line">&#125;);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"Hi!"</span>);</div></pre></td></tr></table></figure>
<p>이 예제는 기존 Node.js <em>Error-first Callback</em> 스타일을 사용합니다. <code>readFile()</code> 함수는 디스크의 파일 (첫 번째 파라미터로 지정된 파일)을 읽은 다음 완료될 때 <em>Callback</em>(두 번째 파라미터)을 실행하기 위한것입니다. 오류가 있으면 콜백의 <code>err</code> 파라미터는 오류 객체입니다. 그렇지 않은 경우, <code>contents</code> 파라미터는 파일 내용을 문자열로 포함합니다.</p>
<p><em>Callback</em> 패턴을 사용하여 <code>readFile()</code>은 즉시 실행을 시작하고 디스크에서 읽기를 시작할 때 일시 중지합니다. 즉, <code>console.log(contents)</code>가 어떤 것도 출력하기 전 <code>readFile()</code>이 호출된 직후에 <code>console.log( &quot;Hi!&quot;)</code>가 출력됩니다. <code>readFile()</code>이 끝나면 <em>Callback</em> 함수와 파라미터는 <em>Job Queue</em>의 끝에 추가됩니다. 그리고 그 앞에있는 다른 모든 작업이 완료되면 실행됩니다.</p>
<p><em>Callback</em> 패턴은 <em>Event</em>보다 융통성이 있습니다. <em>Callback</em>을 통해 여러개의 호출을 함께 연결하는 것이 쉬워지기 때문입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">readFile(<span class="string">"example.txt"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, contents</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (err) &#123;</div><div class="line">        <span class="keyword">throw</span> err;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    writeFile(<span class="string">"example.txt"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (err) &#123;</div><div class="line">            <span class="keyword">throw</span> err;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"File was written!"</span>);</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>이 코드에서 <code>readFile()</code>을 성공적으로 호출하면 또 다른 비동기 호출이 발생하며 이번에는 <code>writeFile()</code> 함수를 호출합니다. <code>err</code>을 검사하는 것과 같은 기본 패턴이 두 함수 모두에 존재한다는 것에 유의하십시오. <code>readFile()</code>이 완료되면 호출되는 <em>Job Queue</em>에 <code>writeFile()</code>을 호출하는 작업을 추가합니다 (오류가 없다고 가정). 그런 다음 <code>writeFile()</code>이 끝날때 <em>Job Queue</em>에 작업을 추가합니다.</p>
<p>이 패턴은 꽤 잘 작동하지만 여러분은 바로 <em>Callback hell</em>에 빠졌다는 것을 알게됩니다. <em>Callback hell</em>은 다음과 같이 너무 많은 <em>Callback</em>을 중첩할 때 발생합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">method1(<span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (err) &#123;</div><div class="line">        <span class="keyword">throw</span> err;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    method2(<span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (err) &#123;</div><div class="line">            <span class="keyword">throw</span> err;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        method3(<span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (err) &#123;</div><div class="line">                <span class="keyword">throw</span> err;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            method4(<span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (err) &#123;</div><div class="line">                    <span class="keyword">throw</span> err;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                method5(result);</div><div class="line">            &#125;);</div><div class="line"></div><div class="line">        &#125;);</div><div class="line"></div><div class="line">    &#125;);</div><div class="line"></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>이 예제는 여러개의 메서드 호출을 중첩하여 복잡하고, 이해 및 디버그가 어려운 웹을 만듭니다. <em>Callback</em>은 복잡한 기능을 구현하려는 경우에도 문제가 발생합니다. 두 개의 비동기 작업을 병렬로 실행하고 두 비동기 작업이 모두 완료될 때 알려주려면 어떻게 해야할까요? 한번에 두개의 비동기 작업을 시작하고 첫 번째 작업의 결과만 가져 오려면 어떻게 해야할까요?</p>
<p>이러한 경우 여러 <em>Callback</em> 및 <em>Cleanup</em> 작업을 추적해야 합니다. <em>Promise</em>는 이러한 상황을 크게 향상시킬 수 있습니다.</p>
<h2 id="Promise-기본"><a href="#Promise-기본" class="headerlink" title="Promise 기본"></a>Promise 기본</h2><p>Promise는 비동기 연산의 결과를 위한 Placeholder입니다. <em>Event</em>를 구독하거나 함수에 <em>Callback</em>을 전달하는 대신 함수는 다음과 같이 <em>Promise</em>을 리턴할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// readFile은 미래의 어떤 시점에서 완료할 것을 약속합니다.</span></div><div class="line"><span class="keyword">let</span> promise = readFile(<span class="string">"example.txt"</span>);</div></pre></td></tr></table></figure>
<p>이 코드에서 <code>readFile()</code>은 실제로 파일 읽기를 즉시 시작하지 않습니다. 그것은 나중에 일어날 일입니다. 대신이 함수는 비동기 읽기 작업을 나타내는 <em>Promise</em> 객체를 리턴하므로 향후 이 작업을 수행할 수 있습니다. 그 결과로 정확하게 일할 수 있는 때는 전적으로 <em>Promise</em>의 <em>Lifecycle</em>이 어떻게 진행되는지에 달려 있습니다.</p>
<h3 id="Promise-수명주기"><a href="#Promise-수명주기" class="headerlink" title="Promise 수명주기"></a>Promise 수명주기</h3><p>각 <em>Promise</em>는 <em>Pending State</em>에서 시작하는 짧은 <em>Lifecycle</em>을 거치며 비동기 작업이 아직 완료되지 않았음을 나타냅니다. <em>Pending State</em>의 <em>Promise</em>는 <em>불안정(unsettled)</em>한 것으로 간주됩니다. 마지막 예제의 <em>Promise</em>는 <code>readFile()</code> 함수가 리턴하는 즉시 <em>Pending State</em>입니다. 비동기 작업이 완료되면 <em>Promise</em>가 <em>확정(settled)</em>된 것으로 간주되어 두가지 상태중 하나가 됩니다.</p>
<ol>
<li><em>Fulfilled(완료됨)</em> : <em>Promise</em>의 비동기 작업이 성공적으로 완료되었습니다.</li>
<li><em>Rejected(거절됨)</em> : <em>Promise</em>의 비동기 작업이 오류 또는 다른 원인으로 인해 성공적으로 완료되지 않았습니다.</li>
</ol>
<p><em>Promise State</em>를 반영하기 위해 내부 <code>[[PromiseState]]</code> 프로퍼티가 <code>&quot;pending&quot;</code>, <code>&quot;fulfilled&quot;</code> 또는 <code>&quot;rejected&quot;</code>로 설정됩니다. 이 프로퍼티는 <em>Promise</em> 개체에 노출되지 않으므로 프로그래밍 방식으로 <em>Promise State</em>를 확인할 수 없습니다. 그러나 `then() 메서드를 사용하여 <em>Promise</em>의 <em>State</em>가 바꿀때 특정 동작을 취할 수 있습니다.</p>
<p><code>then()</code> 메서드는 모든 <em>Promise</em>에 존재하며 두개의 파라미터를 받습니다. 첫 번째 파라미터는 <em>Promise</em>가 수행될 때 호출할 함수입니다. 비동기 작업과 관련된 추가 데이터가 이 처리 함수에 전달됩니다. 두 번째 파라미터는 <em>Promise</em>가 거부될 때 호출할 함수입니다. 수행 기능과 마찬가지로 거부 기능에는 거부와 관련된 추가 데이터가 전달됩니다.</p>
<blockquote>
<p>이런 식으로 <code>then()</code> 메서드를 구현하는 객체를 모두 <em>Thenable</em>이라고 합니다. 모든 <em>Promise</em>는 <em>Thenable</em>이지만, 모든 <em>Thenable</em>이 <em>Promise</em>인 것은 아닙니다.</p>
</blockquote>
<p><code>then()</code>에 대한 두 파라미터는 모두 선택 사항이므로 수행 및 거부의 조합을 만들수 있습니다. 예를 들어, 다음의 <code>then()</code> 호출 집합을 보겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> promise = readFile(<span class="string">"example.txt"</span>);</div><div class="line"></div><div class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">contents</span>) </span>&#123;</div><div class="line">    <span class="comment">// fulfillment</span></div><div class="line">    <span class="built_in">console</span>.log(contents);</div><div class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</div><div class="line">    <span class="comment">// rejection</span></div><div class="line">    <span class="built_in">console</span>.error(err.message);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">contents</span>) </span>&#123;</div><div class="line">    <span class="comment">// fulfillment</span></div><div class="line">    <span class="built_in">console</span>.log(contents);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">promise.then(<span class="literal">null</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</div><div class="line">    <span class="comment">// rejection</span></div><div class="line">    <span class="built_in">console</span>.error(err.message);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>세번 모두 <code>then()</code> 호출은 같은 <em>Promise</em>에 작동합니다. 첫 번째 호출은 수행과 거절을 모두 받습니다. 두 번째는 수행만 받고 오류는 보고되지 않습니다. 세 번째는 거절을 받고 수행을 보고하지 않습니다.</p>
<p>또한 <em>Promise</em>는 거절 처리만 전달할 때 <code>then()</code>과 동일한 동작을하는 <code>catch()</code> 메서드가 있습니다. 예를 들어 다음과 같은 <code>catch()</code> 및 <code>then()</code> 호출은 기능적으로 동일합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">promise.catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</div><div class="line">    <span class="comment">// rejection</span></div><div class="line">    <span class="built_in">console</span>.error(err.message);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// is the same as:</span></div><div class="line"></div><div class="line">promise.then(<span class="literal">null</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</div><div class="line">    <span class="comment">// rejection</span></div><div class="line">    <span class="built_in">console</span>.error(err.message);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><code>then()</code>과 <code>catch()</code>의 목적은 비동기 작업의 결과를 적절하게 처리하기 위해 이들을 조합하여 사용하는 것입니다. 이 시스템은 작업이 성공했는지 또는 실패했는지를 확인하기 때문에 <em>Event</em>와 <em>Callback</em>보다 낫습니다. (<em>Event</em>는 오류가있을 때 실행되지 않는 경향이 있고 <em>Callback</em>은 오류 파라미터를 항상 확인해야합니다.) <em>Promise</em>에 거절를 추가하지 않으면 모든 실패가 조용히 발생합니다. 핸들러가 단지 실패만을 기록하는 경우라도 항상 거절 처리가 필요합니다.</p>
<p>수행 또는 거절 핸들러는 <em>Promise</em>가 이미 완료된 후에 <em>Job Queue</em>에 추가 되더라도 여전히 실행됩니다. 이를 통해 언제든지 새로운 수행 처리 및 거절 처리를 추가하고 호출을 보장 할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> promise = readFile(<span class="string">"example.txt"</span>);</div><div class="line"></div><div class="line"><span class="comment">// 원래의 수행 처리</span></div><div class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">contents</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(contents);</div><div class="line"></div><div class="line">    <span class="comment">// 새로운 처리를 추가</span></div><div class="line">    promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">contents</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(contents);</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>이 코드에서, 수행 핸들러는 동일한 수행 <em>Promise</em>에 또 다른 수행 핸들러를 추가합니다. <em>Promise</em>는 이 시점에서 이미 완료되었으므로 새 수행 핸들러가 작업 대기열에 추가되고 준비가되면 호출됩니다. 거절 핸들러도 같은 방식으로 작동합니다.</p>
<p><code>then()</code> 또는 <code>catch()</code>를 호출할 때마다 <em>Promise</em>가 해결될 때 실행될 새 <em>Job</em>이 만들어집니다. 그러나 이러한 <em>Job</em>은 <em>Promise</em>을 위해 엄격하게 예약된 별도의 <em>Job Queue</em>에서 끝납니다. 이 두 번째 <em>Job Queue</em>의 정확한 세부 사항은 일반적인 <em>Job Queue</em>가 작동하는 방식을 이해하는 정도면 됩니다. 이 사항은 <em>Promise</em> 사용 방법을 이해하는 데 중요하지 않습니다.</p>
<h3 id="Unsettled-불확실한-Promise-생성하기"><a href="#Unsettled-불확실한-Promise-생성하기" class="headerlink" title="Unsettled(불확실한) Promise 생성하기"></a><em>Unsettled(불확실한) Promise</em> 생성하기</h3><p>새로운 <em>Promise</em>는 <code>Promise</code> 생성자를 사용하여 생성됩니다. 이 생성자는 <em>Promise</em>를 초기화하는 코드를 포함하는 Executor라는 함수를 파라미터로 받아들입니다. Executor에는 <code>resolve()</code> 및 <code>reject()</code>라는 두개의 함수가 파라미터로 전달됩니다. <code>resolve()</code> 함수는 Executor가 성공적으로 완료되면 <em>Promise</em>가 해결될 준비가되었음을 알리기 위해 호출되고 <code>reject()</code> 함수는 Executor가 실패했음을 나타냅니다.</p>
<p>이 장의 앞 부분에서 보여주었던 <code>readFile()</code> 함수를 Node.js의 <em>Promise</em>을 사용하여 구현하는 예제를 살펴 보겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Node.js example</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">filename</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">// 비동기 동작 트리거</span></div><div class="line">        fs.readFile(filename, &#123; <span class="attr">encoding</span>: <span class="string">"utf8"</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err, contents</span>) </span>&#123;</div><div class="line"></div><div class="line">            <span class="comment">// check for errors</span></div><div class="line">            <span class="keyword">if</span> (err) &#123;</div><div class="line">                reject(err);</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// the read succeeded</span></div><div class="line">            resolve(contents);</div><div class="line"></div><div class="line">        &#125;);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> promise = readFile(<span class="string">"example.txt"</span>);</div><div class="line"></div><div class="line"><span class="comment">// 수행과 거절 모두를 처리한다.</span></div><div class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">contents</span>) </span>&#123;</div><div class="line">    <span class="comment">// 수행</span></div><div class="line">    <span class="built_in">console</span>.log(contents);</div><div class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</div><div class="line">    <span class="comment">// 거절</span></div><div class="line">    <span class="built_in">console</span>.error(err.message);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>이 예제는 Node.js의 기본 <code>fs.readFile()</code> 비동기 호출이 <em>Promise</em>로 래핑됩니다. Executor는 error 오브젝트를 <code>reject()</code> 함수에 전달하거나 파일 내용을 <code>resolve()</code> 함수에 전달합니다.</p>
<p><code>readFile()</code>이 호출되면 Executor가 즉시 실행된다는 점에 유의하십시오. Executor <code>resolve()</code> 또는 <code>reject()</code>가 호출되면 <em>Promise</em>을 해결하기 위해 작업이 <em>Job Queue</em>에 추가됩니다. 이를 <em>Job Scheduling</em>이라고하며, <code>setTimeout()</code> 또는 <code>setInterval()</code> 함수를 사용한 적이 있다면 이미 익숙한 것입니다. <em>Job Scheduling</em>에서 새로운 작업을 <em>Job Queue</em>에 추가하여 “지금 당장 실행하지 말고 나중에 실행하십시오.”라고 말합니다. 예를 들어 <code>setTimeout()</code> 함수를 사용하면 작업이 대기열에 추가되기 전에 지연을 지정할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 500ms가 지난 후에 이 함수를 작업 대기열에 추가하십시오.</span></div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Timeout"</span>);</div><div class="line">&#125;, <span class="number">500</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"Hi!"</span>);</div></pre></td></tr></table></figure>
<p>이 코드는 500ms 후에 <em>Job Queue</em>에 추가될 작업을 예약합니다. 두개의 <code>console.log()</code> 호출은 다음과 같은 내용을 출력합니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Hi!</div><div class="line">Timeout</div></pre></td></tr></table></figure>
<p>500ms 지연 덕분에 <code>console.log( &quot;Hi!&quot;)</code> 호출의 출력 후에 <code>setTimeout()</code>에 전달된 함수가 표시되었습니다.</p>
<p><em>Promise</em>도 비슷하게 작동합니다. <em>Promise</em> Executor는 소스 코드에서 그 이후에 나타나는 것보다 먼저 실행됩니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Promise"</span>);</div><div class="line">    resolve();</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"Hi!"</span>);</div></pre></td></tr></table></figure>
<p>이 코드의 출력은 다음과 같습니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Promise</div><div class="line">Hi!</div></pre></td></tr></table></figure>
<p><code>resolve()</code>를 호출하면 비동기 작업이 트리거됩니다. <code>then()</code> 및 <code>catch()</code>에 전달된 함수는 비동기적으로 실행됩니다. 이러한 함수도 <em>Job Queue</em>에 추가됩니다. 다음은 그 예입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Promise"</span>);</div><div class="line">    resolve();</div><div class="line">&#125;);</div><div class="line"></div><div class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Resolved."</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"Hi!"</span>)</div></pre></td></tr></table></figure>
<p>이 예제의 결과는 다음과 같습니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Promise</div><div class="line">Hi!</div><div class="line">Resolved</div></pre></td></tr></table></figure>
<p><code>then()</code>에 대한 호출이 <code>console.log( &quot;Hi!&quot;)</code> 행 앞에 나타나더라도 실제로 먼저(Executor와 달리) 실행되지는 않습니다. 이는 Executor가 완료된 후 수행 및 거절 핸들러가 <em>Job Queue</em>의 끝에 추가되기 때문입니다.</p>
<h3 id="Settled-확정된-Promise-생성하기"><a href="#Settled-확정된-Promise-생성하기" class="headerlink" title="Settled(확정된) Promise 생성하기"></a>Settled(확정된) Promise 생성하기</h3><p><code>Promise</code> 생성자는 <em>Promise</em> Executor의 역동적인 특성 때문에 불확실한 <em>Promise</em>를 만드는 가장 좋은 방법입니다. 그러나 알려진 단일 값을 나타내는 <em>Promise</em>를 원한다면 <code>resolve()</code> 함수에 값을 전달하는 <em>Job</em>을 스케쥴하는 것은 의미가 없습니다. 대신, 구체적인 가치를 부여한 Settled <em>Promise</em>를 만드는 두가지 방법이 있습니다.</p>
<h4 id="Promise-resolve-사용하기"><a href="#Promise-resolve-사용하기" class="headerlink" title="Promise.resolve() 사용하기"></a>Promise.resolve() 사용하기</h4><p><code>Promise.resolve()</code> 메서드는 단일 파라미터를 받아들이고 <em>Fulfilled State</em>의 <em>Promise</em>를 리턴합니다. 이는 <em>Job Scheduling</em>이 발생하지 않으며, 값을 검색하기 위한 <em>Promise</em>에 하나 이상의 수행 핸들러를 추가해야 함을 의미합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> promise = <span class="built_in">Promise</span>.resolve(<span class="number">42</span>);</div><div class="line"></div><div class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(value);         <span class="comment">// 42</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>이 코드는 수행 핸들러가 <code>value</code>로 42를 설정 하도록 수행 <em>Promise</em>를 작성합니다. 이 <em>Promise</em>는 절대 <em>Rejected State</em>가 되지 않기<br> 때문에 거절 핸들러가 추가되어도 호출되지 않습니다.</p>
<h4 id="Promise-reject-사용하기"><a href="#Promise-reject-사용하기" class="headerlink" title="Promise.reject() 사용하기"></a>Promise.reject() 사용하기</h4><p><code>Promise.reject()</code> 메서드를 사용하여 거절된 <em>Promise</em>를 만들수도 있습니다. <code>Promise.resolve()</code>와 같이 작동합니다. 단, 생성된 <em>Promise</em>는 다음과 같이 <em>Rejected State</em>입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> promise = <span class="built_in">Promise</span>.reject(<span class="number">42</span>);</div><div class="line"></div><div class="line">promise.catch(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(value);         <span class="comment">// 42</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>이 <em>Promise</em>에 추가된 모든 거절 핸들러는 호출되지만 수행 핸들러는 호출되지 않습니다.</p>
<blockquote>
<p><em>Promise</em>를 <code>Promise.resolve()</code> 또는 <code>Promise.reject()</code> 메서드에 전달하면 변경 내용없이 <em>Promise</em>가 리턴됩니다.</p>
</blockquote>
<h4 id="Promise가-아닌-Thenable"><a href="#Promise가-아닌-Thenable" class="headerlink" title="Promise가 아닌 Thenable"></a>Promise가 아닌 Thenable</h4><p><code>Promise.resolve()</code> 및 <code>Promise.reject()</code>는 Non-promise Thenable을 파라미터로 받을수 있습니다. Non-promise Thenable을 전달하면 이 메서드는 <code>then()</code> 함수 다음에 호출되는 새로운 <em>Promise</em>를 만듭니다.</p>
<p>Non-promise Thenable은 객체가 다음과 같이 <code>resolve</code>와 <code>reject</code> 파라미터를 받아들이는 <code>then()</code> 메서드를 가질 때 생성됩니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> thenable = &#123;</div><div class="line">    <span class="attr">then</span>: <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">        resolve(<span class="number">42</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>이 예제에서 <code>thenable</code> 객체는 <code>then()</code> 메서드 이외의 <em>Promise</em>와 관련된 특징이 없습니다. 여러분은 <code>Promise.resolve()</code>를 호출하여 다음과 같이 <code>thenable</code>을 수행된 <em>Promise</em>로 변환할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> thenable = &#123;</div><div class="line">    <span class="attr">then</span>: <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">        resolve(<span class="number">42</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(thenable);</div><div class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(value);     <span class="comment">// 42</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>이 예에서, <code>Promise.resolve()</code>는 <em>Promise</em> State를 결정할 수 있도록 <code>thenable.then()</code>을 호출합니다. <code>then()</code>메서드 내에서 <code>resolve(42)</code>가 호출되기 때문에 <code>thenable</code>에 대한 <em>Promise</em> State가 <em>Fulfilled</em>입니다. 새로운 <code>p1</code> <em>Promise</em>는 <code>thenable</code>(즉, 42)에서 전달된 값으로 <em>Fulfilled state</em>에서 생성되고 <code>p1</code>의 수행 핸들러는 값으로 42를 받습니다.</p>
<p>같은 프로세스를 <code>Promise.resolve()</code>와 함께 사용하여 다음과 같은 <em>Promise</em>을 거절할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> thenable = &#123;</div><div class="line">    <span class="attr">then</span>: <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">        reject(<span class="number">42</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(thenable);</div><div class="line">p1.catch(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(value);     <span class="comment">// 42</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>이 예제는 <code>thenable</code>이 거부된다는 것을 제외하고는 이전 예제와 유사합니다. <code>thenable.then()</code>이 실행되면, 값이 42 인 <em>Rejected State</em>에서 새로운 <em>Promise</em>가 생성됩니다. 그 값은 <code>p1</code>의 거절 처리기로 전달됩니다.</p>
<p><code>Promise.resolve()</code> 및 <code>Promise.reject()</code>는 이와 같이 동작하여 Non-promise Thenable에 대해 쉽게 작업할 수 있도록 합니다. 많은 라이브러리는 <em>Promise</em>가 ECMAScript 6에 도입되기 전에 <em>Promise</em>을 구현하기 위해 Thenable을 사용 했으므로, Thenable을 공식 <em>Promise</em>로 변환할 수 있는 이 기능은 기존 라이브러리와의 하위 호환성을 위해 중요합니다. 오브젝트가 <em>Promise</em>인지 확신 할 수 없을 때 <em>Promise</em>가 변경되지 않고 통과하기 하는 <code>Promise.resolve()</code> 또는 <code>Promise.reject()</code>(예상 결과에 따라 다름)를 통해 오브젝트를 전달하는 것이 가장 좋은 방법입니다.</p>
<h3 id="Executor-오류"><a href="#Executor-오류" class="headerlink" title="Executor 오류"></a>Executor 오류</h3><p>Executor 내에서 오류가 발생하면 <em>Promise</em>의 거절 핸들러가 호출됩니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Explosion!"</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">promise.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(error.message);     <span class="comment">// "Explosion!"</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>이 코드에서, Executor는 의도적으로 오류를 던집니다. 모든 Executor 내부에는 암묵적인 <code>try-catch</code>가 있어 오류가 포착된 다음 거절 처리기로 전달됩니다. 이전 예는 다음과 같습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Explosion!"</span>);</div><div class="line">    &#125; <span class="keyword">catch</span> (ex) &#123;</div><div class="line">        reject(ex);</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">promise.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(error.message);     <span class="comment">// "Explosion!"</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>Executor는 던져진 오류를 잡아서 이러한 일반적인 유스 케이스를 간소화하고, Executor에서 발생한 오류는 거절 처리기가 있을때만 보고됩니다. 그렇지 않으면 오류가 표시되지 않습니다. 이것은 개발자가 <em>Promise</em>를 사용하는 초기 단계에서 문제가되었고, JavaScript environment는 거절된 <em>Promise</em>를 잡아 내기 위해 Hook을 제공함으로써 문제를 해결합니다.</p>
<h2 id="Global-Promise-거절-처리"><a href="#Global-Promise-거절-처리" class="headerlink" title="Global Promise 거절 처리"></a>Global Promise 거절 처리</h2><p><em>Promise</em>의 가장 논란이되는 측면중 하나는 거절 핸들러 없이 <em>Promise</em>가 거절될 때 발생하는 침묵의 실패입니다. 어떤 이들은 JavaScript 언어에서 오류를 명백히 드러내지 않는 유일한 부분이기 때문에 이것이 사양의 가장 큰 결함이라고 생각하는 사람도 있습니다.</p>
<p><em>Promise</em> 거절이 처리되었는지 여부를 결정하는 것은 <em>Promise</em>의 본질 때문에 간단하지 않습니다. 예를 들어 다음 예제를 살펴보겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> rejected = <span class="built_in">Promise</span>.reject(<span class="number">42</span>);</div><div class="line"></div><div class="line"><span class="comment">// 이 시점에서 거절은 처리되지 않습니다.</span></div><div class="line"></div><div class="line"><span class="comment">// 잠시 후...</span></div><div class="line">rejected.catch(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="comment">// 이제 거절을 처리합니다.</span></div><div class="line">    <span class="built_in">console</span>.log(value);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>어떤 시점에서 <code>then()</code> 또는 <code>catch()</code>를 호출하여 <em>Promise</em>가 확정(settled) 되었는지 여부에 관계없이 올바르게 작동하게 함으로써 <em>Promise</em>를 처리할 때를 정확하게 알기가 어렵습니다. 이 경우 <em>Promise</em>는 즉시 거절되지만 나중에 처리될 때까지 처리되지 않습니다.</p>
<p>ECMAScript의 다음 버전이 이 문제를 해결할 가능성은 있지만, 브라우저와 Node.js는 이 문제점을 해결하기 위해 변경 사항을 구현했습니다. 이는 ECMAScript 6 사양의 일부는 아니지만 <em>Promise</em>를 사용할 때 유용한 도구가 됩니다.</p>
<h3 id="Node-js의-거절-핸들링"><a href="#Node-js의-거절-핸들링" class="headerlink" title="Node.js의 거절 핸들링"></a>Node.js의 거절 핸들링</h3><p>Node.js에는 <em>Promise</em> 거절 핸들링과 관련된 <code>process</code> 객체에 두개의 <em>Event</em>가 있습니다.</p>
<ul>
<li><code>unhandledRejection</code> : <em>Promise</em>가 거절되고 한회의 <em>Event Loop</em>에서 거절 핸들러가 호출되지 않은 경우에 발생합니다.</li>
<li><code>rejectionHandled</code> : <em>Promise</em>가 거절되고 한회의 <em>Event Loop</em> 후 거절 핸들러가 호출되면 발생합니다.</li>
</ul>
<p>이러한 <em>Event</em>는 거절되고 처리되지 않는 <em>Promise</em>를 식별하는데 도움이되도록 설계되었습니다.</p>
<p><code>unhandledRejection</code> <em>Event</em> 핸들러는 거절 이유 (흔히 오류 객체)와 파라미터로 거절된 <em>Promise</em>가 전달됩니다. 다음 코드는 실행중인 <code>unhandledRejection</code>을 보여줍니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> rejected;</div><div class="line"></div><div class="line">process.on(<span class="string">"unhandledRejection"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">reason, promise</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(reason.message);            <span class="comment">// "Explosion!"</span></div><div class="line">    <span class="built_in">console</span>.log(rejected === promise);      <span class="comment">// true</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line">rejected = <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Explosion!"</span>));</div></pre></td></tr></table></figure>
<p>이 예에서 오류 객체와 함께 거절된 <em>Promise</em>를 만들고 <code>unhandledRejection</code> <em>Event</em>를 수신합니다. <em>Event</em> 핸들러는 첫 번째 파라미터로 오류 객체를 받고 두 번째 파라미터로 <em>Promise</em>를 받습니다.</p>
<p><code>rejectionHandled</code> <em>Event</em> 핸들러에는 거절된 <em>Promise</em>인 하나의 파라미터만 받습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> rejected;</div><div class="line"></div><div class="line">process.on(<span class="string">"rejectionHandled"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">promise</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(rejected === promise);              <span class="comment">// true</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line">rejected = <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Explosion!"</span>));</div><div class="line"></div><div class="line"><span class="comment">// 거절 핸들러를 추가 할 때까지 기다립니다.</span></div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    rejected.catch(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(value.message);     <span class="comment">// "Explosion!"</span></div><div class="line">    &#125;);</div><div class="line">&#125;, <span class="number">1000</span>);</div></pre></td></tr></table></figure>
<p>여기서 <code>rejectionHandled</code> <em>Event</em>는 거절 핸들러가 최종적으로 호출될 때 생성됩니다. 거절 핸들러가 <code>rejected</code>가 생성된 후<br> <code>rejected</code>에 바로 첨부된 경우 <em>Event</em>가 발생하지 않습니다. 거절 핸들러가 <code>rejected</code>를 생성한 동일한 <em>Event Loop</em>에서<br> 호출 되는 것은 유용하지 않습니다.</p>
<p>잠재적으로 처리되지 않은 거절을 올바르게 추적하려면 <code>rejectionHandled</code> 및 <code>unhandledRejection</code> <em>Event</em>를 사용하여 처리되지 않은 거절 가능성이 있는 목록을 유지합니다.그리고 일정 기간 동안 목록을 검사합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> possiblyUnhandledRejections = <span class="keyword">new</span> <span class="built_in">Map</span>();</div><div class="line"></div><div class="line"><span class="comment">// 거절이 처리되지 않으면 Map에 추가합니다.</span></div><div class="line">process.on(<span class="string">"unhandledRejection"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">reason, promise</span>) </span>&#123;</div><div class="line">    possiblyUnhandledRejections.set(promise, reason);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">process.on(<span class="string">"rejectionHandled"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">promise</span>) </span>&#123;</div><div class="line">    possiblyUnhandledRejections.delete(promise);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">    possiblyUnhandledRejections.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">reason, promise</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(reason.message ? reason.message : reason);</div><div class="line"></div><div class="line">        <span class="comment">// 이 거절을 처리하기 위해 뭔가를 합니다.</span></div><div class="line">        handleRejection(promise, reason);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    possiblyUnhandledRejections.clear();</div><div class="line"></div><div class="line">&#125;, <span class="number">60000</span>);</div></pre></td></tr></table></figure>
<p>이코드는 처리되지 않는 거절을 추적하는 간단한 추적기입니다. 코드에서 <em>Map</em>을 사용하여 <em>Promise</em>와 거절 사유를 저장합니다. 각 <em>Promise</em>는 키이며, <em>Promise</em>의 이유는 연관된 값입니다. <code>unhandledRejection</code>이 발생할 때마다 <em>Promise</em>와 거절 이유가 <em>Map</em>에 추가됩니다. 그리고 <code>rejectionHandled</code>가 발생될 때마다 처리된 <em>Promise</em>가 <em>Map</em>에서 제거됩니다. 따라서 <em>Event</em>가 호출될 때 <code>possibleUnhandledRejections</code>가 커지고 축소됩니다. <code>setInterval()</code> 호출은 처리되지 않은 거절 목록을 주기적으로 검사하여 정보를 console에 출력합니다.(실제로는 로그를 남기거나 다른 방식으로 거절을 처리하기 위해 뭔가 다른 작업을 수행하려고합니다). 이 예제에서<br> <em>Weak Map</em>대신 <em>Map</em>을 사용합니다. <em>Map</em>을 주기적으로 검사하여 어떤 <em>Promise</em>가 있는지 확인해야 하지만 <em>Weak Map</em>은 가능하지 않습니다.</p>
<p>이 예제는 Node.js에만 해당 하고, 브라우저도 처리되지 않은 거절에 대해 개발자에게 알리는 비슷한 메커니즘을 구현했습니다.</p>
<h3 id="브라우저의-거절-핸들러"><a href="#브라우저의-거절-핸들러" class="headerlink" title="브라우저의 거절 핸들러"></a>브라우저의 거절 핸들러</h3><p>브라우저는 처리되지 않은 거절을 식별하는데 도움이되는 두가지 <em>Event</em>를 발생 시킵니다. 이러한 <em>Event</em>는 <code>window</code> 객체에 의해 발생되고 Node.js와 동일합니다.</p>
<ul>
<li><code>unhandledrejection</code> : <em>Promise</em>가 거절되고 한회의 <em>Event Loop</em>에서 거절 핸들러가 호출되지 않은 경우에 발생합니다.</li>
<li><code>rejectionhandled</code> : <em>Promise</em>가 거절되고 한회의 <em>Event Loop</em>가 실행된 후 거절 핸들러가 호출되면 발생합니다.</li>
</ul>
<p>Node.js의 구현은 개별 파라미터를 <em>Event</em> 핸들러에 전달하는 하지만, 브라우저의 <em>Event</em> 핸들러는 다음과 같은 프로퍼티를 갖는 <em>Event</em> 객체를 받습니다.</p>
<ul>
<li><code>type</code> : 이벤트 이름 ( <code>&quot;unhandledrejection&quot;</code> 또는 <code>&quot;rejectionhandled&quot;</code>).</li>
<li><code>promise</code> : 거절된 <em>Promise</em> 객체.</li>
<li><code>reason</code> : <em>Promise</em>의 거절된 값</li>
</ul>
<p>브라우저 구현의 다른점은 두 <em>Event</em> 모두에서 거절값(<code>reason</code>)을 사용할 수 있다는 것입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> rejected;</div><div class="line"></div><div class="line"><span class="built_in">window</span>.onunhandledrejection = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(event.type);                    <span class="comment">// "unhandledrejection"</span></div><div class="line">    <span class="built_in">console</span>.log(event.reason.message);          <span class="comment">// "Explosion!"</span></div><div class="line">    <span class="built_in">console</span>.log(rejected === event.promise);    <span class="comment">// true</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">window</span>.onrejectionhandled = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(event.type);                    <span class="comment">// "rejectionhandled"</span></div><div class="line">    <span class="built_in">console</span>.log(event.reason.message);          <span class="comment">// "Explosion!"</span></div><div class="line">    <span class="built_in">console</span>.log(rejected === event.promise);    <span class="comment">// true</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line">rejected = <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Explosion!"</span>));</div></pre></td></tr></table></figure>
<p>이 코드는 <code>onunhandledrejection</code> 및 <code>onrejectionhandled</code>의 DOM Level 0 표현식을 사용하여 두 <em>Event</em> 핸들러를 할당합니다. 원하는 경우 <code>addEventListener( &quot;unhandledrejection&quot;)</code> 및 <code>addEventListener(&quot;rejectionhandled&quot;)</code>를 사용할 수도 있습니다. 각 <em>Event</em> 핸들러는 거절된 <em>Promise</em>에 대한 정보를 포함하는 <em>Event</em> 객체를 받습니다. <code>type</code>, <code>promise</code> 및 <code>reason</code> 프로퍼티는 모두 두 <em>Event</em> 핸들러에서 사용할 수 있습니다.</p>
<p>브라우저에서 처리되지 않은 거절을 추적하는 코드는 Node.js 코드와 매우 유사합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> possiblyUnhandledRejections = <span class="keyword">new</span> <span class="built_in">Map</span>();</div><div class="line"></div><div class="line"><span class="comment">// 거절이 처리되지 않으면 Map에 추가합니다.</span></div><div class="line"><span class="built_in">window</span>.onunhandledrejection = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">    possiblyUnhandledRejections.set(event.promise, event.reason);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">window</span>.onrejectionhandled = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">    possiblyUnhandledRejections.delete(event.promise);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">    possiblyUnhandledRejections.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">reason, promise</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(reason.message ? reason.message : reason);</div><div class="line"></div><div class="line">        <span class="comment">// 이 거절을 처리하기 위해 뭔가를 합니다.</span></div><div class="line">        handleRejection(promise, reason);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    possiblyUnhandledRejections.clear();</div><div class="line"></div><div class="line">&#125;, <span class="number">60000</span>);</div></pre></td></tr></table></figure>
<p>이 구현은 Node.js 구현과 거의 동일합니다. <em>Promise</em>와 거절 값을 <em>Map</em>에 저장한 다음 나중에 검사하는 것과 같은 접근 방식을 사용합니다. 유일한 실제 차이점은 <em>Event</em> 핸드러에서 정보를 검색하는 위치입니다.</p>
<p><em>Promise</em> 거절을 처리하는 것은 까다로울 수 있지만, 실제로 얼마나 강력한 <em>Promise</em>가 될 수 있는지를 이제 알기 시작했습니다. 이제 다음 단계로 몇개의 <em>Promise</em>를 연결해서 처리할 때입니다.</p>
<h2 id="Promise-연결하기"><a href="#Promise-연결하기" class="headerlink" title="Promise 연결하기"></a>Promise 연결하기</h2><p>이 시점에서 <em>Promise</em>는 <em>Callback</em>과 <code>setTimeout()</code> 함수를 이용한 조합보다 조금더 개선된 것으로 보이지만, 눈에 보이는 것보다 훨씬더 많은 <em>Promise</em>가 있습니다. 보다 구체적으로, 보다 복잡한 비동기 동작을 수행하기 위해 <em>Promise</em>를 서로 연결하는 여러 가지 방법이 있습니다.</p>
<p><code>then()</code> 또는 <code>catch()</code>를 호출할 때마다 실제로 또 다른 <em>Promise</em>가 만들어지고 리턴됩니다. 이 두 번째 <em>Promise</em>는 첫 번째 <em>Promise</em>가 수행되거나 거절된 후에만 처리됩니다. 다음 예제를 살펴보겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    resolve(<span class="number">42</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(value);</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Finished"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>위 코드의 결과는 다음과 같습니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">42</div><div class="line">Finished</div></pre></td></tr></table></figure>
<p><code>p1.then()</code>에 대한 호출은 두 번째 <em>Promise</em>를 리턴하고 <code>then()</code>이 호출됩니다. 두 번째 <code>then()</code> 수행 핸들러는 첫 번째 <em>Promise</em>가 해결된 후에만 호출됩니다. 이 예제의 연결을 해제하면 다음과 같이 보입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    resolve(<span class="number">42</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">let</span> p2 = p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(value);</div><div class="line">&#125;)</div><div class="line"></div><div class="line">p2.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Finished"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>이 연결되지 않은 코드 버전에서 <code>p1.then()</code>의 결과는 <code>p2</code>에 저장되고 <code>p2.then()</code>은 최종 수행 핸들러를 추가하기 위해 호출됩니다. 여러분이 짐작 했겠지만, <code>p2.then()</code> 호출도 <em>Promise</em>를 리턴하지만 그 <em>Promise</em>는 사용하지 않습니다.</p>
<h3 id="Error-포착하기"><a href="#Error-포착하기" class="headerlink" title="Error 포착하기"></a>Error 포착하기</h3><p><em>Promise</em> 체인을 사용하면 이전 <em>Promise</em>에서 수행 또는 거절 핸들러에서 발생할 수 있는 에러를 포착 할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    resolve(<span class="number">42</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Boom!"</span>);</div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(error.message);     <span class="comment">// "Boom!"</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>이 코드에서 <code>p1</code>의 수행 핸들러는 에러를 던집니다. 두 번째 <em>Promise</em>인 <code>catch()</code> 메서드에 대한 연결된 호출은 거절 핸들러를 통해 해당 에러를 수신할 수 있습니다. 거절 핸들러가 에러를 throw 하는 경우에도 마찬가지입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Explosion!"</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">p1.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(error.message);     <span class="comment">// "Explosion!"</span></div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Boom!"</span>);</div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(error.message);     <span class="comment">// "Boom!"</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>여기에서 Executor가 오류를 발생시켜 다음 <code>p1</code> <em>Promise</em>의 거절 핸들러를 트리거합니다. 그 핸들러는 두 번째 <em>Promise</em>의 거절 핸들러가 포착할 또 다른 에러를 발생시킵니다. 연결된 <em>Promise</em> 호출은 체인의 다른 <em>Promise</em>의 에러를 인식합니다.</p>
<blockquote>
<p>에러가 발생할 때 올바르게 처리할 수 있도록 <em>Promise</em> 체인의 끝부분에는 항상 거절 핸들러가 있어야합니다.</p>
</blockquote>
<h3 id="Promise-체인의-리턴-값"><a href="#Promise-체인의-리턴-값" class="headerlink" title="Promise 체인의 리턴 값"></a>Promise 체인의 리턴 값</h3><p><em>Promise</em> 체인의 또 다른 중요한 부분은 하나의 <em>Promise</em>에서 다음 <em>Promise</em>로 데이터를 전달할 수 있다는 것입니다. Executor 내에서 <code>resolve()</code> 핸들러로 전달된 값이 해당 <em>Promise</em>에 대한 수행 핸들러로 전달되는 것을 이미 보았습니다. 수행 핸들러에서 리턴값을 지정하여 체인을 따라 데이터를 계속 전달할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    resolve(<span class="number">42</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(value);         <span class="comment">// "42"</span></div><div class="line">    <span class="keyword">return</span> value + <span class="number">1</span>;</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(value);         <span class="comment">// "43"</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><code>p1</code>에 대한 수행 핸들러는 실행될 때 <code>value + 1</code>을 리턴합니다. <code>value</code>는 Executor로부터 42를 입력 받고, 수행 핸들러는 43을 리턴합니다. 이 값은 두 번째 <em>Promise</em>의 수행 핸들러로 전달되어 콘솔로 출력됩니다.</p>
<p>거절 핸들러로도 똑같이 할 수 있습니다. 거절 핸들러가 호출되면 값을 리턴할 수 있습니다. 만약 그렇다면, 그 값은 다음과 같이 체인의 다음 <em>Promise</em>를 수행하는데 사용될수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    reject(<span class="number">42</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">p1.catch(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="comment">// first fulfillment handler</span></div><div class="line">    <span class="built_in">console</span>.log(value);         <span class="comment">// "42"</span></div><div class="line">    <span class="keyword">return</span> value + <span class="number">1</span>;</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="comment">// second fulfillment handler</span></div><div class="line">    <span class="built_in">console</span>.log(value);         <span class="comment">// "43"</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>여기서 Executor는 42로 <code>reject()</code>를 호출합니다. 이 값은 <em>Promise</em>의 거절 핸들러로 전달되며 여기서 <code>value + 1</code>이 리턴됩니다. 이 리턴 값은 거절 핸들러에서 가져오지만 체인에서 다음 <em>Promise</em>의 수행 핸들러에서 계속 사용됩니다. 만약 필요하다면 한 <em>Promise</em>의 실패는<br> 전체 체인에서 복구할 수 있습니다.</p>
<h3 id="Promise-체인에서-Promise-리턴하기"><a href="#Promise-체인에서-Promise-리턴하기" class="headerlink" title="Promise 체인에서 Promise 리턴하기"></a>Promise 체인에서 Promise 리턴하기</h3><p>수행 및 거절 핸들러에서 <em>Primitive</em> 값을 리턴하면 <em>Promise</em> 사이에 데이터를 전달할 수 있지만 객체를 리턴하려면 어떻게 해야 할까요? 객체가 <em>Promise</em>라면 진행 방법을 결정하기위한 추가 단계가 필요합니다. 다음 예제를 살펴보겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    resolve(<span class="number">42</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    resolve(<span class="number">43</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="comment">// first fulfillment handler</span></div><div class="line">    <span class="built_in">console</span>.log(value);     <span class="comment">// 42</span></div><div class="line">    <span class="keyword">return</span> p2;</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="comment">// second fulfillment handler</span></div><div class="line">    <span class="built_in">console</span>.log(value);     <span class="comment">// 43</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>이 코드에서 <code>p1</code>은 42로 해결(Resolve)되는 작업을 스케쥴합니다. <code>p1</code>의 수행 핸들러는 이미 해결된 상태인 <em>Promise</em>인 <code>p2</code>를 리턴합니다. <code>p2</code>가 완료되었으므로 두 번째 수행 핸들러가 호출됩니다. <code>p2</code>가 거부되면 두 번째 수행 핸들러 대신 거절 핸들러(있는 경우)가 호출됩니다.</p>
<p>이 패턴에 대해 알아야 할 중요한 점은 두 번째 수행 핸들러가 <code>p2</code>에 추가되지 않고 오히려 세 번째 <em>Promise</em>에 추가된다는 것입니다. 따라서 두 번째 수행 핸들러는 세 번째 <em>Promise</em>에 첨부되며, 앞의 예제를 다음과 같이 만들수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    resolve(<span class="number">42</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    resolve(<span class="number">43</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">let</span> p3 = p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="comment">// first fulfillment handler</span></div><div class="line">    <span class="built_in">console</span>.log(value);     <span class="comment">// 42</span></div><div class="line">    <span class="keyword">return</span> p2;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">p3.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="comment">// second fulfillment handler</span></div><div class="line">    <span class="built_in">console</span>.log(value);     <span class="comment">// 43</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>여기에서 두 번째 수행 처리기가 <code>p2</code>보다는 <code>p3</code>에 연결되어 있음이 명확합니다. <code>p2</code>가 거절되는 경우 두 번째 수행 핸들러가 호출되지 않으므로 이것은 미묘하지만 중요한 차이점입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    resolve(<span class="number">42</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    reject(<span class="number">43</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="comment">// first fulfillment handler</span></div><div class="line">    <span class="built_in">console</span>.log(value);     <span class="comment">// 42</span></div><div class="line">    <span class="keyword">return</span> p2;</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="comment">// second fulfillment handler</span></div><div class="line">    <span class="built_in">console</span>.log(value);     <span class="comment">// 절대 호출되지 않음</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>이 예제에서는 <code>p2</code>가 거절되므로 두 번째 이행 핸들러가 호출되지 않습니다. 하지만 대신 거절 핸들러를 연결할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    resolve(<span class="number">42</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    reject(<span class="number">43</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="comment">// first fulfillment handler</span></div><div class="line">    <span class="built_in">console</span>.log(value);     <span class="comment">// 42</span></div><div class="line">    <span class="keyword">return</span> p2;</div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="comment">// rejection handler</span></div><div class="line">    <span class="built_in">console</span>.log(value);     <span class="comment">// 43</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>여기서, 거절 핸들러는 <code>p2</code>가 거절된 결과 호출됩니다. <code>p2</code>에서 거절된 값 43은 해당 거절 핸들러로 전달됩니다.</p>
<p><em>Promise</em> Executor가 실행될 때 수행 또는 거절 핸들러로부터 <em>Thenable</em>을 리턴하는 것은 변하지 않습니다. 첫 번째 정의된 <em>Promise</em>는 먼저 Executor를 실행한 다음 두 번째 <em>Promise</em>의 Executor를 실행합니다. <em>Thenable</em>를 반환하면 간단하게 <em>Promise</em> 결과에 대한 추가 응답을 정의할 수 있습니다. 수행 핸들러 내에서 새로운 <em>Promise</em>를 작성하여 수행 핸들러의 실행을 연기할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    resolve(<span class="number">42</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(value);     <span class="comment">// 42</span></div><div class="line"></div><div class="line">    <span class="comment">// create a new promise</span></div><div class="line">    <span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">        resolve(<span class="number">43</span>);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> p2</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(value);     <span class="comment">// 43</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>이 예제에서 <code>p1</code>의 수행 핸들러에 새 <em>Promise</em>가 생성됩니다. 즉, 두 번째 수행 핸들러는 <code>p2가</code> 수행될 때까지 실행되지 않습니다. 이 패턴은 이전 <em>Promise</em>가 확정될 때까지 <em>Promise</em>가 기다리길 원할때 유용합니다.</p>
<h2 id="Multiple-Promise에-대한-대응"><a href="#Multiple-Promise에-대한-대응" class="headerlink" title="Multiple Promise에 대한 대응"></a>Multiple Promise에 대한 대응</h2><p>지금까지 이 장의 각 예제에서는 한번에 하나의 <em>Promise</em>에 응답하는 방법을 다루었습니다. 그러나 때로는 다음 작업을 결정하기 위해 여러 <em>Promise</em>의 진행 상태를 모니터링 해야할 수도 있습니다. ECMAScript 6은 <code>Promise.all()</code> 및 <code>Promise.race()</code>와 같이 여러 <em>Promise</em>를 모니터링하는 두가지 메서드를 제공합니다.</p>
<h3 id="Promise-all-메서드"><a href="#Promise-all-메서드" class="headerlink" title="Promise.all() 메서드"></a>Promise.all() 메서드</h3><p><code>Promise.all()</code> 메서드는 모니터링 할 <em>Promise</em>들을 <em>Iterable</em>(<em>Array</em>와 같은)하게 만든 단일 파라미터를 받아들이고 <em>Iterable</em>의 모든 <em>Promise</em>가 해결되었을 때 해결된 <em>Promise</em>를 리턴합니다. 리턴된 <em>Promise</em>는 아래 예제처럼 <em>Iterable</em>의 모든 <em>Promise</em>가 충족될 때 수행됩니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    resolve(<span class="number">42</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    resolve(<span class="number">43</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">let</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    resolve(<span class="number">44</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">let</span> p4 = <span class="built_in">Promise</span>.all([p1, p2, p3]);</div><div class="line"></div><div class="line">p4.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(value));  <span class="comment">// true</span></div><div class="line">    <span class="built_in">console</span>.log(value[<span class="number">0</span>]);              <span class="comment">// 42</span></div><div class="line">    <span class="built_in">console</span>.log(value[<span class="number">1</span>]);              <span class="comment">// 43</span></div><div class="line">    <span class="built_in">console</span>.log(value[<span class="number">2</span>]);              <span class="comment">// 44</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>각각의 <em>Promise</em>는 숫자로 Resolve됩니다. <code>Promise.all()</code>에 대한 호출은 <em>Promise</em> <code>p4</code>를 생성합니다. 이것은 <code>p1</code>, <code>p2</code> 및 <code>p3</code> <em>Promise</em>가 충족될 때 수행됩니다. <code>p4</code>의 수행 핸들러에 전달된 결과는 각 Resolve된 값 <code>42</code>, <code>43</code> 및 <code>44</code>를 포함하는 <em>Array</em>입니다. 값은 <em>Promise</em>가 <code>Promise.all</code>에 전달된 순서대로 저장되므로 <em>Promise</em> 결과를 Resolve한 <em>Promise</em>와 일치시킬 수 있습니다.</p>
<p><code>Promise.all()</code>에 전달된 <em>Promise</em>가 거절되면 다른 <em>Promise</em>가 완료될 때까지 기다리지 않고 즉시 반환된 <em>Promise</em>는 거절됩니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    resolve(<span class="number">42</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    reject(<span class="number">43</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">let</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    resolve(<span class="number">44</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">let</span> p4 = <span class="built_in">Promise</span>.all([p1, p2, p3]);</div><div class="line"></div><div class="line">p4.catch(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(value))   <span class="comment">// false</span></div><div class="line">    <span class="built_in">console</span>.log(value);                 <span class="comment">// 43</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>이 예제에서 <code>p2</code>는 43의 값을 사용하여 거절됩니다. <code>p4</code>에 대한 거절 핸들러는 <code>p1</code> 또는 <code>p3</code>가 실행 완료될 때까지 기다리지 않고 즉시 호출됩니다(여전히 실행은 완료하지만, <code>p4</code>가 대기하지 않습니다).</p>
<p>거절 핸들러는 항상 <em>Array</em>가 아닌 단일값을 받으며 그값은 거절된 <em>Promise</em>의 거절값입니다. 이 경우, 거절 핸들러에는 <code>p2</code>로부터의 거절을 반영하기 위해 43이 입력됩니다.</p>
<h3 id="Promise-race-메서드"><a href="#Promise-race-메서드" class="headerlink" title="Promise.race() 메서드"></a>Promise.race() 메서드</h3><p><code>Promise.race()</code> 메서드는 약간 다른 방법으로 여러 <em>Promise</em>를 모니터링하는 방법을 제공합니다. 이 메서드 또한 <em>Promise</em>의 <em>Iterable</em>을 파라미터로 받고 <em>Promise</em>를 리턴하지만, 리턴된 <em>Promise</em>는 입력된 <em>Iterable</em> <em>Promise</em>들 중 어떤 <em>Promise</em>가 처음으로 확정(settled) 되자마자 확정(settled) 됩니다. <code>Promise.all()</code> 메서드처럼 모든 <em>Promise</em>가 수행되기를 기다리는 대신 <code>Promise.race()</code> 메서드는 <em>Iterable</em> <em>Promise</em>가 수행되는 즉시 적절한 <em>Promise</em>를 리턴합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="number">42</span>);</div><div class="line"></div><div class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    resolve(<span class="number">43</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">let</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    resolve(<span class="number">44</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">let</span> p4 = <span class="built_in">Promise</span>.race([p1, p2, p3]);</div><div class="line"></div><div class="line">p4.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(value);     <span class="comment">// 42</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>이 코드에서 <code>p1</code>은 수행된 <em>Promise</em>로 만들어지며 다른것들은 스케쥴 작업으로 생성됩니다. <code>p4</code>에 대한 수행 핸들러는 <code>42</code>라는 값으로 호출되고 다른 <em>Promise</em>를 무시합니다. <code>Promise.race()</code>에 전달된 <em>Promise</em>는 어느 것이 먼저 확정(settled)되는지 보기위한 경쟁입니다. 첫 번째 <em>Promise</em>가 확정되면 리턴된 <em>Promise</em>가 수행됩니다. 첫 <em>Promise</em>의 확정이 거절되면 리턴된 <em>Promise</em>는 거절됩니다. 다음은 거절 사례입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    resolve(<span class="number">42</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">let</span> p2 = <span class="built_in">Promise</span>.reject(<span class="number">43</span>);</div><div class="line"></div><div class="line"><span class="keyword">let</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    resolve(<span class="number">44</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">let</span> p4 = <span class="built_in">Promise</span>.race([p1, p2, p3]);</div><div class="line"></div><div class="line">p4.catch(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(value);     <span class="comment">// 43</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><code>Promise.race()</code>가 호출될 때 이미 <code>p2</code>가 거절된 상태이므로 <code>p4</code>가 거절됩니다. <code>p1</code>과 <code>p3</code>가 수행 되더라도 <code>p2</code>가 거절된 후에 발생하므로 무시됩니다</p>
<h2 id="Promise에서-상속-받기"><a href="#Promise에서-상속-받기" class="headerlink" title="Promise에서 상속 받기"></a>Promise에서 상속 받기</h2><p>다른 <em>Built-in</em> 타입과 마찬가지로 파생 클래스의 기반으로 <em>Promise</em>를 사용할 수 있습니다. 이를 통해 자신만의 객체를 정의하여 <em>Built-in Promise</em>를 확장할 수 있습니다. 예를 들어, 일반적인 <code>then()</code> 및 <code>catch()</code> 메서드 외에도 <code>success()</code> 및 <code>failure()</code>라는 메서드를 사용할 수 있는 <em>Promise</em>를 만들고 싶다고 가정 해보십시오. 다음과 같이 <em>Promise</em> 타입을 작성할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> <span class="keyword">extends</span> <span class="title">Promise</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 기본 생성자를 사용</span></div><div class="line"></div><div class="line">    success(resolve, reject) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.then(resolve, reject);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    failure(reject) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.catch(reject);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    resolve(<span class="number">42</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">promise.success(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(value);             <span class="comment">// 42</span></div><div class="line">&#125;).failure(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(value);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>이 예에서 <code>MyPromise</code>는 <code>Promise</code>에서 파생되었으며 두가지 추가 메서드가 있습니다. <code>success()</code> 메서드는 <code>resolve()</code>를 모방하고 <code>failure()</code>는 <code>reject()</code> 메서드를 모방합니다.</p>
<p>추가된 각 메서드는 이를 사용하여 모방하는 메서드를 호출합니다. 파생된 <em>Promise</em>는 <em>Built-in Promise</em>와 동일하게 작동하지만 원하는 경우 <code>success()</code> 및 <code>failure()</code>를 호출할 수 있습니다.</p>
<p>정적 메서드도 상속되므로 <code>MyPromise.resolve()</code>, <code>MyPromise.reject()</code>, <code>MyPromise.race()</code> 및 <code>MyPromise.all()</code> 메서드는 파생된 <em>Promise</em>에도 있습니다. 마지막 두 메서드는 기본 제공 메서드와 동일하게 동작하지만 처음 두 메서드는 약간 다릅니다.</p>
<p><code>MyPromise.resolve()</code>와 <code>MyPromise.reject()</code>는 전달된 값에 관계없이 <code>MyPromise</code>의 인스턴스를 리턴합니다. 리턴할 <em>Promise</em>의 타입을 결정하기 위해 <code>Symbol.species</code> 프로퍼티(9 장에서 다뤘습니다.)를 사용하기 때문에 전달된 값에 관계없이 <code>MyPromise</code>의 인스턴스를 리턴합니다. <em>Built-in Promise</em>가 두 메서드 중 하나에 전달되면 <em>Promise</em>가 수행되거나 거절되고 메서드는 새로운 <code>MyPromise</code>를 반환하여 수행 및 거절 핸들러를 할당할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    resolve(<span class="number">42</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">let</span> p2 = MyPromise.resolve(p1);</div><div class="line">p2.success(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(value);         <span class="comment">// 42</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(p2 <span class="keyword">instanceof</span> MyPromise);   <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>여기에서 <code>p1</code>은 <code>MyPromise.resolve()</code> 메서드로 전달되는 <em>Built-in Promise</em>입니다. 결과 <code>p2</code>는 <code>p1</code>의 Resolve된 값이 수행 핸들러로 전달되는 <code>MyPromise</code>의 인스턴스입니다.</p>
<p><code>MyPromise</code> 인스턴스가 <code>MyPromise.resolve()</code> 또는 <code>MyPromise.reject()</code> 메서드에 전달되면 Resolve되지 않고 바로 리턴됩니다. 하지만 이 두 메서드의 다른 모든 실행은 <code>Promise.resolve()</code> 및 <code>Promise.reject()</code>와 동일하게 동작합니다.</p>
<h3 id="비동기-작업-실행"><a href="#비동기-작업-실행" class="headerlink" title="비동기 작업 실행"></a>비동기 작업 실행</h3><p>8 장에서는 <em>Generator</em>를 소개하고 이를 비동기 작업 실행에 사용할 수있는 방법을 보여주었습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">taskDef</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// iterator를 만들고 다른곳에서 사용할수 있게 만든다.</span></div><div class="line">    <span class="keyword">let</span> task = taskDef();</div><div class="line"></div><div class="line">    <span class="comment">// task 시작</span></div><div class="line">    <span class="keyword">let</span> result = task.next();</div><div class="line"></div><div class="line">    <span class="comment">// next() 호출을 유지하는 재귀 함수</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">// 할일이 더 있다면</span></div><div class="line">        <span class="keyword">if</span> (!result.done) &#123;</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> result.value === <span class="string">"function"</span>) &#123;</div><div class="line">                result.value(<span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</div><div class="line">                    <span class="keyword">if</span> (err) &#123;</div><div class="line">                        result = task.throw(err);</div><div class="line">                        <span class="keyword">return</span>;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    result = task.next(data);</div><div class="line">                    step();</div><div class="line">                &#125;);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                result = task.next(result.value);</div><div class="line">                step();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// process 시작</span></div><div class="line">    step();</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// task runner와 함께 사용할 함수를 정의</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">filename</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</div><div class="line">        fs.readFile(filename, callback);</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// task 실행</span></div><div class="line"></div><div class="line">run(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> contents = <span class="keyword">yield</span> readFile(<span class="string">"config.json"</span>);</div><div class="line">    doSomethingWith(contents);</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Done"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>이 구현에는 몇가지 문제점이 있습니다. 첫째, 함수를 리턴하는 함수에서 모든 함수를 래핑하는 것은 다소 혼란 스럽습니다 (이 문장조차 혼란 스럽습니다). 둘째, Task runner의 <em>Callback</em>으로 의도된 함수 리턴값과 <em>Callback</em>이 아닌 리턴값을 구별할 수있는 방법이 없습니다.</p>
<p><em>Promise</em>를 통해 각 비동기 작업이 <em>Promise</em>를 반환하도록 함으로써 이 프로세스를 크게 단순화하고 일반화할 수 있습니다. 공통 인터페이스는 비동기 코드를 크게 단순화할 수 있음을 의미합니다. Task runner를 단순화 할 수있는 방법은 다음과 같습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">taskDef</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// iterator 생성</span></div><div class="line">    <span class="keyword">let</span> task = taskDef();</div><div class="line"></div><div class="line">    <span class="comment">// task 시작</span></div><div class="line">    <span class="keyword">let</span> result = task.next();</div><div class="line"></div><div class="line">    <span class="comment">// 반복하는 재귀 함수</span></div><div class="line">    (<span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">// 할일이 더 있다면</span></div><div class="line">        <span class="keyword">if</span> (!result.done) &#123;</div><div class="line"></div><div class="line">            <span class="comment">// promise를 resolve 하면 쉽게 해결됩니다.</span></div><div class="line">            <span class="keyword">let</span> promise = <span class="built_in">Promise</span>.resolve(result.value);</div><div class="line">            promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">                result = task.next(value);</div><div class="line">                step();</div><div class="line">            &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</div><div class="line">                result = task.throw(error);</div><div class="line">                step();</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// task runner에서 사용할 함수를 정의</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">filename</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">        fs.readFile(filename, <span class="function"><span class="keyword">function</span>(<span class="params">err, contents</span>) </span>&#123;</div><div class="line">            <span class="keyword">if</span> (err) &#123;</div><div class="line">                reject(err);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                resolve(contents);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// task 실행</span></div><div class="line"></div><div class="line">run(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> contents = <span class="keyword">yield</span> readFile(<span class="string">"config.json"</span>);</div><div class="line">    doSomethingWith(contents);</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Done"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>이 버전의 코드에서 범용 <code>run()</code> 함수는 <em>Generator</em>를 실행하여 <em>Iterator</em>를 만듭니다. 작업을 시작하기 위해 <code>task.next()</code>를 호출하고 <em>Iterator</em>가 완료될 때까지 <code>step()</code>을 재귀적으로 호출합니다.</p>
<p><code>step()</code> 함수안에서 할일이 더 있다면 <code>result.done</code>은 <code>false</code>입니다. 그 시점에서 result.value는 <em>Promise</em>이어야합니다. 그러나 문제의 함수가 <em>Promise</em>를 반환하지 않은 경우 <code>Promise.resolve()</code>가 호출됩니다.(<code>Promise.resolve()</code>는 전달된 <em>Promise</em>는 통과시키고 <em>Non-promise</em>는 <em>Promise</em>로 래핑한다는 것을 기억하세요). 그런 다음 <em>Promise</em> 값을 검색하고 이 값을 <em>Iterator</em>에 전달하는 수행 핸들러가 추가됩니다. 그 후, <code>result</code>는 <code>step()</code> 함수가 스스로를 호출하기 전에 다음 <code>yield</code> 결과에 할당됩니다.</p>
<p>거절 핸들러는 거절 결과를 오류 객체에 저장합니다. <code>task.throw()</code> 메서드는 에러 객체를 <em>Iterator</em>로 되돌려 보내고, 만약 태스크에 에러가 잡히면 <code>result</code>가 다음 <code>yield</code> 결과에 할당됩니다. 마지막으로 <code>step()</code>은 <code>catch()</code> 내부에서 호출하여 계속 진행합니다.</p>
<p>이 <code>run()</code> 함수는 개발자에게 <em>Promise</em>(또는 <em>Callback</em>)을 노출시키지 않고 비동기 코드를 얻기 위해 <code>yield</code>를 사용하는 모든 <em>Generator</em>를 실행할 수 있습니다. 사실 함수 호출의 리턴 값은 항상 <em>Promise</em>로 래핑되어 있기 때문에 함수는 <em>Promise</em> 이외의 것을 리턴할 수도 있습니다. 즉, <code>yield</code>를 사용하여 호출할 때 동기및 비동기 메서드가 모두 올바르게 작동한다는 것을 의미하므로 리턴값이 <em>Promise</em>임을 확인할 필요가 없습니다.</p>
<p>유일한 관심사는 <code>readFile()</code>과 같은 비동기 함수가 해당 State를 올바르게 식별하는 <em>Promise</em>를 리턴하는지 확인하는 것입니다. Node.js <em>Built-in</em> 메서드의 경우 <em>Callback</em>을 사용하지 않고 <em>Promise</em>를 리턴하도록 이러한 메서드를 변환해야합니다.</p>
<h3 id="미래의-비동기-Task-실행"><a href="#미래의-비동기-Task-실행" class="headerlink" title="미래의 비동기 Task 실행"></a>미래의 비동기 Task 실행</h3><p>필자가 글을 쓰고있는 지금 JavaScript로 실행되는 비동기 태스크에 간단한 구문을 사용하는 작업이 진행중입니다. 이전 섹션의 <em>Promise</em> 기반 예제와 유사한 <code>await</code>구문으로 진행 중입니다. 기본적인 아이디어는 <em>Generator</em> 대신에 <code>async</code>로 표시된 함수를 사용하고 함수를 호출할 때 <code>yield</code> 대신에 <code>await</code>을 사용하는 것입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> contents = <span class="keyword">await</span> readFile(<span class="string">"config.json"</span>);</div><div class="line">    doSomethingWith(contents);</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Done"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><code>async</code> 키워드가 <code>function</code>보다 먼저 나오면 함수가 비동기 방식으로 실행된다는 의미입니다. <code>await</code> 키워드는 <code>readFile(&quot;config.json&quot;)</code> 함수 호출이 <em>Promise</em>를 리턴해야 한다는 것을 알려주고, 그렇지 않을 경우 응답을 <em>Promise</em>로 감싸야합니다. 앞절에서 <code>run()</code>을 구현한 것과 마찬가지로, <code>await</code>는 <em>Promise</em>가 거절되면 에러를 던지고 그렇지 않을 경우 값을 반환합니다. 최종 결과는 <em>Iterator</em> 기반 상태 시스템을 관리하는 오버 헤드없이 동기식인 것처럼 비동기 코드를 작성하는 것입니다.</p>
<p><code>await</code> 구문은 ECMAScript 2017 (ECMAScript 8)에서 완성될 것으로 예상됩니다.</p>
<h2 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h2><p><em>Promise</em>는 JavaScript에서 비동기 프로그래밍을 개선하기 위해 설계되었습니다. <em>Event</em> 및 <em>Callback</em>보다 비동기 작업에 대한 제어력과 합성 가능성을 향상시켜줍니다. <em>Promise</em> 스케줄 작업은 JavaScript 엔진의 <em>Job Queue</em>에 추가되어 나중에 실행될 수 있습니다. 그리고 두 번째 <em>Job Queue</em>는 적절한 실행을 보장하기 위해 <em>Promise</em> 수행 및 거절 핸들러를 추적합니다.</p>
<p><em>Promise</em>에는 Pending(보류), Fulfilled(수행), Rejected(거절)이라는 세가지 상태가 있습니다. <em>Promise</em>는 보류중 상태에서 시작하여 성공적인 실행에서 수행되거나 실패로 인해 거부됩니다. 두경우 모두 <em>Promise</em>가 확정(settled)되는 시점을 나타내는 핸들러를 추가할 수 있습니다. <code>then()</code> 메서드를 사용하면 수행 및 거절 핸들러를 할당할 수 있으며 <code>catch()</code> 메서드를 사용하면 거절 핸들러만 할당할 수 있습니다.</p>
<p><em>Promise</em>를 여러 가지 방식으로 연결하여 정보를 전달할 수 있습니다. <code>then()</code>을 호출할 때마다 이전 <em>Promise</em>가 Resolve될 때 Resolve<br>되는 새로운 <em>Promise</em>가 만들어지고 리턴됩니다. 이러한 체인을 사용하여 일련의 비동기 이벤트에 대한 응답을 트리거할 수 있습니다. 또한 <code>Promise.race()</code> 및 <code>Promise.all()</code>을 사용하여 여러 <em>Promise</em>의 진행 상황을 모니터링하고 그에 따라 응답할 수 있습니다.</p>
<p><em>Promise</em>는 비동기 작업이 리턴할 수 있는 공통 인터페이스를 제공하므로 <em>Generator</em>와 <em>Promise</em>를 결합할 때 비동기 작업 실행이 더 쉽습니다. <em>Generator</em>와 <code>yield</code> 연산자를 사용하여 비동기 응답을 기다리고 적절하게 응답할 수 있습니다.</p>
<p>대부분의 새로운 웹 API는 <em>Promise</em>를 바탕으로 구축되고 있으며 향후 더 많은 것을 기대할 수 있습니다.</p>
<hr>
<blockquote>
<p>이 내용은 나중에 참고하기 위해 제가 공부하며 정리한 내용입니다.<br>의역, 오역, 직역이 있을 수 있음을 알려드립니다.<br>This post is a translation of this original article [<a href="https://leanpub.com/understandinges6/read#leanpub-auto-promises-and-asynchronous-programming" target="_blank" rel="external">https://leanpub.com/understandinges6/read#leanpub-auto-promises-and-asynchronous-programming</a>]</p>
</blockquote>
<h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul>
<li><a href="https://infoscis.github.io/2018/01/24/ecmascript-6-block-binding/">ECMAScript 6 Block Binding</a></li>
<li><a href="https://infoscis.github.io/2018/01/24/ecmascript-6-strings-and-regular-expressions/">ECMAScript 6 문자열과 정규 표현식</a></li>
<li><a href="https://infoscis.github.io/2018/01/24/ecmascript-6-functions/">ECMAScript 6 함수</a></li>
<li><a href="https://infoscis.github.io/2018/01/25/ecmascript-6-expanded-object-functionality/">ECMAScript 6 객체의 확장된 기능</a></li>
<li><a href="https://infoscis.github.io/2018/01/26/ecmascript-6-destructuring-for-easier-data-access/">ECMAScript 6 쉬운 데이터 액세스를 위한 Destructuring</a></li>
<li><a href="https://infoscis.github.io/2018/01/27/ecmascript-6-symbols-and-symbol-properties/">ECMAScript 6 Symbol과 Symbol 프로퍼티</a></li>
<li><a href="https://infoscis.github.io/2018/01/27/ecmascript-6-sets-and-maps/">ECMAScript 6 Set과 Map</a></li>
<li><a href="https://infoscis.github.io/2018/01/31/ecmascript-6-iterators-and-generators/">ECMAScript 6 Iterator와 Generator</a></li>
<li><a href="https://infoscis.github.io/2018/02/13/ecmascript-6-introducing-javascript-classes/">ECMAScript 6 JavaScript 클래스 소개</a></li>
<li><a href="https://infoscis.github.io/2018/02/13/ecmascript-6-improved-array-capabilities/">ECMAScript 6 Array 기능 향상</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-promises-and-asynchronous-programming/">ECMAScript 6 Promise와 비동기 프로그램밍</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-proxies-and-the-reflection-api/">ECMAScript 6 프록시와 리플렉션 API</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-encapsulating-code-with-modules/">ECMAScript 6 Module로 코드 캡슐화하기</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-appendix-a-smaller-changes/">ECMAScript 6 부록 A. 작은 변경 사항</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-appendix-b-understanding-ecmascript-7/">ECMAScript 6 부록 B. ECMAScript 7(2016) 이해하기</a></li>
</ul>

        </div>
        <footer class="article-footer">
            



    <a data-url="http://infoscis.github.io/2018/02/27/ecmascript-6-promises-and-asynchronous-programming/" data-id="cjqtex2eg007opouziderf27o" class="article-share-link"><i class="fa fa-share"></i>공유하기</a>
<script>
    (function ($) {
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

        </footer>
    </div>
</article>

    <section id="comments">
    
        
    <div id="disqus_thread">
        <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>

    
    </section>


                        </div>
                    </section>
                    <aside id="sidebar">
    <a class="sidebar-toggle" title="Expand Sidebar"><i class="toggle icon"></i></a>
    <div class="sidebar-top">
        <p>팔로우:</p>
        <ul class="social-links">
            
                
                <li>
                    <a class="social-tooltip" title="github" href="https://github.com/infoscis" target="_blank">
                        <i class="icon fa fa-github"></i>
                    </a>
                </li>
                
            
        </ul>
    </div>
    
        
<nav id="article-nav">
    
        <a href="/2018/02/27/ecmascript-6-proxies-and-the-reflection-api/" id="article-nav-newer" class="article-nav-link-wrap">
        <strong class="article-nav-caption">새로운</strong>
        <p class="article-nav-title">
        
            ECMAScript 6 프록시와 리플렉션 API
        
        </p>
        <i class="icon fa fa-chevron-right" id="icon-chevron-right"></i>
    </a>
    
    
        <a href="/2018/02/13/ecmascript-6-improved-array-capabilities/" id="article-nav-older" class="article-nav-link-wrap">
        <strong class="article-nav-caption">오래된</strong>
        <p class="article-nav-title">Array 기능 향상</p>
        <i class="icon fa fa-chevron-left" id="icon-chevron-left"></i>
        </a>
    
</nav>

    
    <div class="widgets-container">
        
            
                
    <div class="widget-wrap">
        <h3 class="widget-title">최근 글</h3>
        <div class="widget">
            <ul id="recent-post" class="no-thumbnail">
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Kotlin/">Kotlin</a><i class="icon fa fa-angle-right"></i><a class="article-category-link" href="/categories/Kotlin/SpringBoot/">SpringBoot</a></p>
                            <p class="item-title"><a href="/2018/08/30/spring-boot-kotlin/" class="title">Spring Boot와 Kotlin으로 웹 애플리케이션 구축하기</a></p>
                            <p class="item-date"><time datetime="2018-08-29T15:30:20.000Z" itemprop="datePublished">2018-08-30</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Angular/">Angular</a></p>
                            <p class="item-title"><a href="/2018/08/08/angular-observables-and-rxjs/" class="title">Angular Observable &amp; RxJS</a></p>
                            <p class="item-date"><time datetime="2018-08-08T14:38:02.000Z" itemprop="datePublished">2018-08-08</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/JavaScript/">JavaScript</a><i class="icon fa fa-angle-right"></i><a class="article-category-link" href="/categories/JavaScript/ECMAScript-2015/">ECMAScript 2015</a></p>
                            <p class="item-title"><a href="/2018/02/27/ecmascript-6-appendix-b-understanding-ecmascript-7/" class="title">ECMAScript 6 부록 B. ECMAScript 7 (2016) 이해하기</a></p>
                            <p class="item-date"><time datetime="2018-02-27T13:32:48.000Z" itemprop="datePublished">2018-02-27</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/JavaScript/">JavaScript</a><i class="icon fa fa-angle-right"></i><a class="article-category-link" href="/categories/JavaScript/ECMAScript-2015/">ECMAScript 2015</a></p>
                            <p class="item-title"><a href="/2018/02/27/ecmascript-6-appendix-a-smaller-changes/" class="title">ECMAScript 6 부록 A. 작은 변경 사항</a></p>
                            <p class="item-date"><time datetime="2018-02-27T13:32:12.000Z" itemprop="datePublished">2018-02-27</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/JavaScript/">JavaScript</a><i class="icon fa fa-angle-right"></i><a class="article-category-link" href="/categories/JavaScript/ECMAScript-2015/">ECMAScript 2015</a></p>
                            <p class="item-title"><a href="/2018/02/27/ecmascript-6-encapsulating-code-with-modules/" class="title">ECMAScript 6 Module로 코드 캡슐화하기</a></p>
                            <p class="item-date"><time datetime="2018-02-27T13:31:45.000Z" itemprop="datePublished">2018-02-27</time></p>
                        </div>
                    </li>
                
            </ul>
        </div>
    </div>

            
                
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">카테고리</h3>
        <div class="widget">
            <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Angular/">Angular</a><span class="category-list-count">15</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hadoop/">Hadoop</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">5</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/Java9/">Java9</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/Spring/">Spring</a><span class="category-list-count">2</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/">JavaScript</a><span class="category-list-count">16</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/ECMAScript-2015/">ECMAScript 2015</a><span class="category-list-count">15</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kotlin/">Kotlin</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Kotlin/SpringBoot/">SpringBoot</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/TypeScript/">TypeScript</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Webpack/">Webpack</a><span class="category-list-count">1</span></li></ul>
        </div>
    </div>


            
                
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">아카이브</h3>
        <div class="widget">
            <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">8월 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">2월 2018</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">1월 2018</a><span class="archive-list-count">11</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">7월 2017</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">6월 2017</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">5월 2017</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">3월 2017</a><span class="archive-list-count">5</span></li></ul>
        </div>
    </div>


            
                
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">태그</h3>
        <div class="widget">
            <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Angular/">Angular</a><span class="tag-list-count">15</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ECMAScript-2015/">ECMAScript 2015</a><span class="tag-list-count">15</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Event/">Event</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hadoop/">Hadoop</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JDK9/">JDK9</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java9/">Java9</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript</a><span class="tag-list-count">29</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Jigsaw/">Jigsaw</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kotlin/">Kotlin</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nashorn/">Nashorn</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/">Spring</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringBoot/">SpringBoot</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TypeScript/">TypeScript</a><span class="tag-list-count">12</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Webpack/">Webpack</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/YARN/">YARN</a><span class="tag-list-count">1</span></li></ul>
        </div>
    </div>


            
                
    <div class="widget-wrap widget-float">
        <h3 class="widget-title">태그 클라우드</h3>
        <div class="widget tagcloud">
            <a href="/tags/Angular/" style="font-size: 18px;">Angular</a> <a href="/tags/ECMAScript-2015/" style="font-size: 18px;">ECMAScript 2015</a> <a href="/tags/Event/" style="font-size: 10px;">Event</a> <a href="/tags/Hadoop/" style="font-size: 10px;">Hadoop</a> <a href="/tags/JDK9/" style="font-size: 12px;">JDK9</a> <a href="/tags/Java/" style="font-size: 14px;">Java</a> <a href="/tags/Java9/" style="font-size: 12px;">Java9</a> <a href="/tags/JavaScript/" style="font-size: 20px;">JavaScript</a> <a href="/tags/Jigsaw/" style="font-size: 12px;">Jigsaw</a> <a href="/tags/Kotlin/" style="font-size: 10px;">Kotlin</a> <a href="/tags/Nashorn/" style="font-size: 10px;">Nashorn</a> <a href="/tags/Spring/" style="font-size: 12px;">Spring</a> <a href="/tags/SpringBoot/" style="font-size: 12px;">SpringBoot</a> <a href="/tags/TypeScript/" style="font-size: 16px;">TypeScript</a> <a href="/tags/Webpack/" style="font-size: 10px;">Webpack</a> <a href="/tags/YARN/" style="font-size: 10px;">YARN</a>
        </div>
    </div>


            
        
    </div>
</aside>
                </div>
            </div>
        </div>
        <footer id="footer">
    <div class="container">
        <div class="container-inner">
            <a id="back-to-top" href="javascript:;"><i class="icon fa fa-angle-up"></i></a>
            <div class="credit">
                <h1 class="logo-wrap">
                    <a href="/" class="logo"></a>
                </h1>
                <p>&copy; 2019 Jongcheol-Kim</p>
                <p>Powered by <a href="//hexo.io/" target="_blank">Hexo</a>. Theme by <a href="//github.com/ppoffice" target="_blank">PPOffice</a></p>
            </div>
        </div>
    </div>
</footer>
        
    
    <script>
    var disqus_shortname = 'infoscis';
    
    
    var disqus_url = 'http://infoscis.github.io/2018/02/27/ecmascript-6-promises-and-asynchronous-programming/';
    
    (function() {
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    </script>




    
        <script src="/libs/lightgallery/js/lightgallery.min.js"></script>
        <script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>
        <script src="/libs/lightgallery/js/lg-pager.min.js"></script>
        <script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>
        <script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>
        <script src="/libs/lightgallery/js/lg-zoom.min.js"></script>
        <script src="/libs/lightgallery/js/lg-hash.min.js"></script>
        <script src="/libs/lightgallery/js/lg-share.min.js"></script>
        <script src="/libs/lightgallery/js/lg-video.min.js"></script>
    
    
        <script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script>
    
    


<!-- Custom Scripts -->
<script src="/js/main.js"></script>

    </div>
</body>
</html>
