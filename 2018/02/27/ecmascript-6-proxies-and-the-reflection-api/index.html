<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    
    <title>ECMAScript 6 프록시와 리플렉션 API | Developer&#39;s Record</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
        <meta name="keywords" content="JavaScript,ECMAScript 2015" />
    
    <meta name="description" content="ECMAScript 6 프록시와 리플렉션 APIECMAScript 5와 ECMAScript 6 모두 명확한 JavaScript 기능을 염두에 두고 개발되었습니다. 예를 들어, ECMAScript 5 이전에는 JavaScript 환경에  nonenumerable , nonwritable 객체 속성이 있었지만 개발자는 자체적으로 nonenumerable 또는">
<meta property="og:type" content="article">
<meta property="og:title" content="ECMAScript 6 프록시와 리플렉션 API">
<meta property="og:url" content="http://infoscis.github.io/2018/02/27/ecmascript-6-proxies-and-the-reflection-api/index.html">
<meta property="og:site_name" content="Developer's Record">
<meta property="og:description" content="ECMAScript 6 프록시와 리플렉션 APIECMAScript 5와 ECMAScript 6 모두 명확한 JavaScript 기능을 염두에 두고 개발되었습니다. 예를 들어, ECMAScript 5 이전에는 JavaScript 환경에  nonenumerable , nonwritable 객체 속성이 있었지만 개발자는 자체적으로 nonenumerable 또는">
<meta property="og:updated_time" content="2018-02-27T14:11:20.585Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ECMAScript 6 프록시와 리플렉션 API">
<meta name="twitter:description" content="ECMAScript 6 프록시와 리플렉션 APIECMAScript 5와 ECMAScript 6 모두 명확한 JavaScript 기능을 염두에 두고 개발되었습니다. 예를 들어, ECMAScript 5 이전에는 JavaScript 환경에  nonenumerable , nonwritable 객체 속성이 있었지만 개발자는 자체적으로 nonenumerable 또는">
    
    <link rel="canonical" href="http://infoscis.github.io/2018/02/27/ecmascript-6-proxies-and-the-reflection-api/"/>

    

    
        <link rel="icon" href="/favicon.png" />
    

    <link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="/libs/titillium-web/styles.css">
    <link rel="stylesheet" href="/libs/source-code-pro/styles.css">

    <link rel="stylesheet" href="/css/style.css">

    <script src="/libs/jquery/2.0.3/jquery.min.js"></script>
    
    
        <link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">
    
    
        <link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css">
    
    
        <script type="text/javascript">
(function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-100332906-1', 'auto');
ga('send', 'pageview');

</script>
    
    

</head>

<body>
    <div id="wrap">
        <header id="header">
    <div id="header-outer" class="outer">
        <div class="container">
            <div class="container-inner">
                <div id="header-title">
                    <h1 class="logo-wrap">
                        <a href="/" class="logo"></a>
                    </h1>
                    
                        <h2 class="subtitle-wrap">
                            <p class="subtitle">개발자의 기록 보관소</p>
                        </h2>
                    
                </div>
                <div id="header-inner" class="nav-container">
                    <a id="main-nav-toggle" class="nav-icon fa fa-bars"></a>
                    <div class="nav-container-inner">
                        <ul id="main-nav">
                            
                                <li class="main-nav-list-item" >
                                    <a class="main-nav-list-link" href="/">홈</a>
                                </li>
                            
                                        <ul class="main-nav-list"><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Angular/">Angular</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Hadoop/">Hadoop</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Java/">Java</a><ul class="main-nav-list-child"><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Java/Java9/">Java9</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Java/Spring/">Spring</a></li></ul></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/JavaScript/">JavaScript</a><ul class="main-nav-list-child"><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/JavaScript/ECMAScript-2015/">ECMAScript 2015</a></li></ul></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/TypeScript/">TypeScript</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Webpack/">Webpack</a></li></ul>
                                    
                                <li class="main-nav-list-item" >
                                    <a class="main-nav-list-link" href="https://about.me/jongcheol.kim">About</a>
                                </li>
                            
                        </ul>
                        <nav id="sub-nav">
                            <div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="검색" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="Type something..." />
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '포스트',
            PAGES: 'Pages',
            CATEGORIES: '카테고리',
            TAGS: '태그',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div>
                        </nav>
                    </div>
                </div>
            </div>
        </div>
    </div>
</header>
        <div class="container">
            <div class="main-body container-inner">
                <div class="main-body-inner">
                    <section id="main">
                        <div class="main-body-header">
    <h1 class="header">
    
    <a class="page-title-link" href="/categories/JavaScript/">JavaScript</a><i class="icon fa fa-angle-right"></i><a class="page-title-link" href="/categories/JavaScript/ECMAScript-2015/">ECMAScript 2015</a>
    </h1>
</div>
                        <div class="main-body-content">
                            <article id="post-ecmascript-6-proxies-and-the-reflection-api" class="article article-single article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
            <header class="article-header">
                
    
        <h1 class="article-title" itemprop="name">
        ECMAScript 6 프록시와 리플렉션 API
        </h1>
    

            </header>
        
        
            <div class="article-meta">
                
    <div class="article-date">
        <a href="/2018/02/27/ecmascript-6-proxies-and-the-reflection-api/" class="article-date">
            <time datetime="2018-02-27T13:31:03.000Z" itemprop="datePublished">2018-02-27</time>
        </a>
    </div>

                
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/ECMAScript-2015/">ECMAScript 2015</a>, <a class="tag-link" href="/tags/JavaScript/">JavaScript</a>
    </div>

            </div>
        
        
        <div class="article-entry" itemprop="articleBody">
            <h1 id="ECMAScript-6-프록시와-리플렉션-API"><a href="#ECMAScript-6-프록시와-리플렉션-API" class="headerlink" title="ECMAScript 6 프록시와 리플렉션 API"></a>ECMAScript 6 프록시와 리플렉션 API</h1><p>ECMAScript 5와 ECMAScript 6 모두 명확한 JavaScript 기능을 염두에 두고 개발되었습니다. 예를 들어, ECMAScript 5 이전에는 JavaScript 환경에  nonenumerable , nonwritable 객체 속성이 있었지만 개발자는 자체적으로 nonenumerable 또는 nonwritable 속성을 정의할 수 없었습니다. ECMAScript 5에는 JavaScript 엔진이 할 수 있는 것을 개발자가 수행할 수 있도록 <code>Object.defineProperty()</code> 메서드가 포함되어 있습니다.</p>
<p>ECMAScript 6은 이전에 <em>Built-in</em> 객체에만 사용할 수 있었던 JavaScript 엔진 기능에 대한 개발자의 액세스를 제공합니다. JavaScript는 프록시를 통해 객체의 내부 동작을 노출할 수 있습니다. 프록시는 JavaScript 엔진의 저수준 동작을 가로 채고 변경할 수있는 래퍼입니다. 이 장에서는 프록시에서 세부적으로 다루어야 할 문제를 설명한 다음 프록시를 효과적으로 만들고 사용하는 방법에 대해 설명합니다.</p>
<h2 id="Array의-문제점"><a href="#Array의-문제점" class="headerlink" title="Array의 문제점"></a>Array의 문제점</h2><p>ECMAScript 6 이전에 JavaScript <em>Array</em> 객체는 개발자가 <em>Array</em> 객체를 모방할 수 없는 방식으로 동작합니다. <em>Array</em>의 <code>length</code> 프로퍼티는 특정 <em>Array</em> 항목에 값을 할당할 때 영향을 받으며 <code>length</code> 프로퍼티를 수정하여 <em>Array</em> 항목을 수정할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> colors = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>];</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(colors.length);         <span class="comment">// 3</span></div><div class="line"></div><div class="line">colors[<span class="number">3</span>] = <span class="string">"black"</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(colors.length);         <span class="comment">// 4</span></div><div class="line"><span class="built_in">console</span>.log(colors[<span class="number">3</span>]);             <span class="comment">// "black"</span></div><div class="line"></div><div class="line">colors.length = <span class="number">2</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(colors.length);         <span class="comment">// 2</span></div><div class="line"><span class="built_in">console</span>.log(colors[<span class="number">3</span>]);             <span class="comment">// undefined</span></div><div class="line"><span class="built_in">console</span>.log(colors[<span class="number">2</span>]);             <span class="comment">// undefined</span></div><div class="line"><span class="built_in">console</span>.log(colors[<span class="number">1</span>]);             <span class="comment">// "green"</span></div></pre></td></tr></table></figure>
<p><code>colors</code> <em>Array</em>는 3 개의 아이템으로 시작합니다. <code>&quot;black&quot;</code>을 <code>colors [3]</code>에 할당하면 <code>length</code> 프로퍼티가 <code>4</code>로 자동 증가합니다. <code>length</code> 프로퍼티를 <code>2</code>로 설정하면 <em>Array</em>의 마지막 두 항목이 제거되고 처음 두 항목만 남게됩니다. ECMAScript 5에서는 개발자가 작성한 객체에서 이러한 동작을 수행할 수 없지만 프록시는 이를 가능하게 합니다.</p>
<blockquote>
<p>이 비표준 동작이 ECMAScript 6에서 <em>Array</em>가 독특한 객체로 간주되는 이유입니다.</p>
</blockquote>
<h2 id="프록시와-리플렉션은-무엇인가"><a href="#프록시와-리플렉션은-무엇인가" class="headerlink" title="프록시와 리플렉션은 무엇인가?"></a>프록시와 리플렉션은 무엇인가?</h2><p><code>new Proxy()</code>를 호출하여 다른 객체(대상(Target)이라고 함) 대신 사용할 프록시를 생성할 수 있습니다. 프록시는 대상을 가상화하여 프록시와 대상이 사용하는 기능을 동일한 객체로 표시되도록합니다.</p>
<p>프록시를 사용하면 JavaScript 엔진의 내부에 있는 대상에서 하위 수준의 객체 작업을 가로 챌 수 있습니다. 이러한 하위 수준의 작업은 특정 작업에 응답하는 기능인 <em>Trap</em>을 사용하여 가로 채어집니다.</p>
<p><code>Reflect</code> 객체로 표현된 리플렉션 API는 프록시가 오버라이드 할 수있는 것과 동일한 로우 레벨 연산에 대한 기본 동작을 제공하는 메서드 컬렉션입니다. 모든 프록시 <em>Trap</em>에 대해 <code>Reflect</code> 메서드가 있습니다. 이러한 메서드는 동일한 이름을 가지며 각 프록시 <em>Trap</em>과 동일한 파라미터가 전달됩니다. 표 11-1에는 이 동작이 요약되어 있습니다.</p>
<p><strong>Table 11-1: JavaScript 안의 프록시 Trap</strong></p>
<table>
<thead>
<tr>
<th>프록시 Trap</th>
<th>동작을 재정의</th>
<th>기본 동작</th>
</tr>
</thead>
<tbody>
<tr>
<td>get</td>
<td>프로퍼티 값을 읽음</td>
<td>Reflect.get()</td>
</tr>
<tr>
<td>set</td>
<td>프로퍼티 값을 기록</td>
<td>Reflect.set()</td>
</tr>
<tr>
<td>has</td>
<td>in 연산자</td>
<td>Reflect.has()</td>
</tr>
<tr>
<td>deleteProperty</td>
<td>delete 연산자</td>
<td>Reflect.deleteProperty()</td>
</tr>
<tr>
<td>getPrototypeOf</td>
<td>Object.getPrototypeOf()</td>
<td>Reflect.getPrototypeOf()</td>
</tr>
<tr>
<td>setPrototypeOf</td>
<td>Object.setPrototypeOf()</td>
<td>Reflect.setPrototypeOf()</td>
</tr>
<tr>
<td>isExtensible</td>
<td>Object.isExtensible()</td>
<td>Reflect.isExtensible()</td>
</tr>
<tr>
<td>preventExtensions</td>
<td>Object.preventExtensions()</td>
<td>Reflect.preventExtensions()</td>
</tr>
<tr>
<td>getOwnPropertyDescriptor</td>
<td>Object.getOwnPropertyDescriptor()</td>
<td>Reflect.getOwnPropertyDescriptor()</td>
</tr>
<tr>
<td>defineProperty</td>
<td>Object.defineProperty()</td>
<td>Reflect.defineProperty</td>
</tr>
<tr>
<td>ownKeys</td>
<td>Object.keys, Object.getOwnPropertyNames(), Object.getOwnPropertySymbols()</td>
<td>Reflect.ownKeys()</td>
</tr>
<tr>
<td>apply</td>
<td>함수 호출</td>
<td>Reflect.apply()</td>
</tr>
<tr>
<td>construct</td>
<td>new를 이용한 함수 호출</td>
<td>Reflect.construct()</td>
</tr>
</tbody>
</table>
<p>각 Trap은 JavaScript 객체의 <em>Built-in</em> 동작을 재정의하므로 동작을 가로 채고 수정할 수 있습니다. 그래도 <em>Built-in</em> 동작을 사용해야하는 경우 해당하는 리플렉션 API 메서드를 사용할 수 있습니다. 프록시 생성과 리플렉션 API 간의 관계는 프록시 생성을 시작할 때 명확 해집니다. 그래서 몇 가지 예를 살펴보는 것이 가장 좋습니다.</p>
<blockquote>
<p>원래 ECMAScript 6 명세에는 <code>for-in</code>과 <code>Object.keys()</code>가 객체의 속성을 열거하는 방법을 변경하기 위해 고안된 <code>enumerate</code>라는 추가 Trap이 있습니다. 그러나 ECMAScript 7 (ECMAScript 2016이라고도 함)에서는 구현 중에 어려움이 발견되어 <code>enumerate</code> Trap이 제거되었습니다. <code>enumerate</code> Trap 더 이상 JavaScript 환경에 존재하지 않으므로 이 장에서 다루지 않습니다.</p>
</blockquote>
<h2 id="간단한-프록시-생성"><a href="#간단한-프록시-생성" class="headerlink" title="간단한 프록시 생성"></a>간단한 프록시 생성</h2><p><code>Proxy</code> 생성자를 사용하여 프록시를 만들 때, 두 개의 파라미터, 즉 대상과 핸들러를 넘깁니다. 핸들러는 하나 이상의 Trap을 정의하는 객체입니다. 프록시는 해당 작업에 대해 Trap이 정의된 경우를 제외하고 모든 작업에 대해 기본 동작을 사용합니다. 간단한 forwarding 프록시를 만들려면 Trap 없이 핸들러를 사용할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> target = &#123;&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;&#125;);</div><div class="line"></div><div class="line">proxy.name = <span class="string">"proxy"</span>;</div><div class="line"><span class="built_in">console</span>.log(proxy.name);        <span class="comment">// "proxy"</span></div><div class="line"><span class="built_in">console</span>.log(target.name);       <span class="comment">// "proxy"</span></div><div class="line"></div><div class="line">target.name = <span class="string">"target"</span>;</div><div class="line"><span class="built_in">console</span>.log(proxy.name);        <span class="comment">// "target"</span></div><div class="line"><span class="built_in">console</span>.log(target.name);       <span class="comment">// "target"</span></div></pre></td></tr></table></figure>
<p>이 예제에서 <code>proxy</code>는 모든 작업을 <code>target</code>에 직접 전달합니다. <code>&quot;proxy&quot;</code>가 <code>proxy.name</code> 프로퍼티에 할당되면 <code>name</code>이 <code>target</code>에 생성됩니다. 프록시 자체가 이 프로퍼티를 저장하지 않습니다. 이것은 단순히 작업을 <code>target</code>으로 전달하는 것입니다. 비슷하게, <code>proxy.name</code>과 <code>target.name</code>의 값은 <code>target.name</code>을 참조하기 때문에 동일합니다. 즉, <code>target.name</code>을 새로운 값으로 설정하면<br> <code>proxy.name</code>도 같은 변경을 반영합니다. 그리고 Trap이 없는 프록시는 별로 흥미롭지 않으므로 Trap을 정의하면 어떻게 될까요?</p>
<h2 id="set-Trap을-사용하여-프로퍼티-검증하기"><a href="#set-Trap을-사용하여-프로퍼티-검증하기" class="headerlink" title="set Trap을 사용하여 프로퍼티 검증하기"></a><code>set</code> Trap을 사용하여 프로퍼티 검증하기</h2><p>프로퍼티 값이 숫자여야 하는 객체를 만들고 싶다고 가정 해보겠습니다. 즉, 객체에 추가된 모든 새로운 프로퍼티에 대해 유효성 검사를 해야하며 값이 숫자가 아닌 경우 오류가 발생되어야 합니다. 이것을 달성하기 위해, 값을 설정하는 기본 동작을 무시하는 <code>set</code> Trap을 정의 할 수 있습니다. <code>set</code> Trap은 네개의 파라미터를 받습니다.</p>
<ol>
<li><code>trapTarget</code> - 프로퍼티를 수신하는 객체 (프록시의 타겟)</li>
<li><code>key</code> - 프로퍼티 키 (문자열 또는 <em>Symbol</em>)</li>
<li><code>value</code> - 프로퍼티 값</li>
<li><code>receiver</code> - 조작이 발생된 오브젝트 (일반적으로 프록시)</li>
</ol>
<p><code>Reflect.set()</code>은 <code>set</code> Trap에 대응하는 리플렉션 메서드이며, 이 연산의 기본 동작입니다. <code>Reflect.set()</code> 메서드는 <code>set</code> 프록시 Trap과 동일한 네개의 파라미터를 받아 Trap 내부에서 메서드를 사용하기 쉽게 만듭니다. Trap은 프로퍼티가 설정되면 <code>true</code>를 반환하고 그렇지 않으면 <code>false</code>를 반환합니다 (<code>Reflect.set()</code> 메서드는 작업이 성공했는지 여부에 따라 올바른 값을 반환합니다).</p>
<p>프로퍼티의 값을 검증하기 위해서는 <code>set</code> Trap을 사용하고 입력된 <code>value</code>를 검사 해야합니다. 다음은 그 예제입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> target = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">"target"</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</div><div class="line">    set(trapTarget, key, value, receiver) &#123;</div><div class="line"></div><div class="line">        <span class="comment">// 기존 프로퍼티를 무시하므로 영향을주지 않습니다.</span></div><div class="line">        <span class="keyword">if</span> (!trapTarget.hasOwnProperty(key)) &#123;</div><div class="line">            <span class="keyword">if</span> (<span class="built_in">isNaN</span>(value)) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Property must be a number."</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 프로퍼티를 추가합니다.</span></div><div class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(trapTarget, key, value, receiver);</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 새로운 프로퍼티를 추가합니다.</span></div><div class="line">proxy.count = <span class="number">1</span>;</div><div class="line"><span class="built_in">console</span>.log(proxy.count);       <span class="comment">// 1</span></div><div class="line"><span class="built_in">console</span>.log(target.count);      <span class="comment">// 1</span></div><div class="line"></div><div class="line"><span class="comment">// 이미 대상에 존재하기 때문에 name에 지정할 수 있습니다.</span></div><div class="line">proxy.name = <span class="string">"proxy"</span>;</div><div class="line"><span class="built_in">console</span>.log(proxy.name);        <span class="comment">// "proxy"</span></div><div class="line"><span class="built_in">console</span>.log(target.name);       <span class="comment">// "proxy"</span></div><div class="line"></div><div class="line"><span class="comment">// throws an error</span></div><div class="line">proxy.anotherName = <span class="string">"proxy"</span>;</div></pre></td></tr></table></figure>
<p>이 코드는 <code>target</code>에 추가되는 새로운 프로퍼티의 값을 확인하는 프록시 Trap을 정의합니다. <code>proxy.count=1</code>이 실행되면 <code>set</code> Trap이 호출됩니다. <code>trapTarget</code> 값은 <code>target</code>과 같고 <code>key</code>는 <code>count</code>, <code>value</code>는 <code>1</code>이며 <code>receiver</code>(이 예제에서는 사용되지 않음)는<code>proxy</code>입니다. <code>target</code>에 <code>count</code>라는 이름의 기존 프로퍼티가 없으므로 프록시는 <code>isNaN()</code>에 전달하여 값의 유효성을 검사합니다. 결과가 <code>NaN</code>의 경우, 숫자값이 아니기 때문에 에러가 발생됩니다. 이 코드는 <code>count</code>를 <code>1</code>로 설정하기 때문에, 프록시는 새 프로퍼티를 추가하기 위해 Trap에 전달된 네개의 파라미터를 사용하여 <code>Reflect.set()</code>을 호출합니다.</p>
<p><code>proxy.name</code>에 문자열이 지정되어도 작업은 성공적으로 완료됩니다. <code>target</code>은 이미 <code>name</code> 프로퍼티를 가지고 있기 때문에, <code>trapTarget.hasOwnProperty()</code> 메서드를 호출함으로써 유효성 체크에서 그 프라퍼티를 생략합니다. 이렇게 하면 기존의 비숫자 프로퍼티 값이 계속 지원됩니다.</p>
<p>그러나 <code>proxy.anotherName</code>에 문자열이 할당되면 오류가 발생합니다. <code>anotherName</code> 프로퍼티는 <code>target</code>에 없으므로 해당 값의 유효성을 검사 해야합니다. 유효성 검사에서 <code>&quot;proxy&quot;</code>가 숫자 값이 아니기 때문에 오류가 발생합니다.</p>
<p>프로퍼티가 쓰여질 때 <code>set</code> 프록시 Trap이 가로챌수 있고, <code>get</code> 프록시 Trap은 프로퍼티가 읽혀질 때 가로 챌 수있습니다.</p>
<h2 id="get-Trap을-사용하여-객체-모양-유효성-검사"><a href="#get-Trap을-사용하여-객체-모양-유효성-검사" class="headerlink" title="get Trap을 사용하여 객체 모양 유효성 검사"></a>get Trap을 사용하여 객체 모양 유효성 검사</h2><p>때때로 JavaScript의 흥미롭고 혼란스러운 부분 중 하나는 존재하지 않는 프로퍼티를 읽는 것이 오류를 발생시키지 않는다는 것입니다. 대신 다음 예와 같이 프로퍼티 값에 <code>undefined</code> 값이 사용됩니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> target = &#123;&#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(target.name);       <span class="comment">// undefined</span></div></pre></td></tr></table></figure>
<p>대부분의 다른 언어에서 <code>target.name</code>을 읽으려고 하면 프로퍼티가 존재하지 않기 때문에 오류가 발생합니다. 그러나 JavaScript는<br> <code>target.name</code> 프로퍼티 값에 <code>undefined</code>를 사용합니다. 대규모 코드 기반에서 작업한 적이 있다면, 특히 프로퍼티 이름에 오타가있을 때 이 동작이 어떻게 심각한 문제를 일으킬 수 있는지 보셨을 것입니다. 프록시를 사용하면 객체 모양의 유효성 검사를 통해 이 문제를 방지 할 수 있습니다.</p>
<p>객체 모양은 객체에서 사용할 수있는 프로퍼티 및 메서드의 모음입니다. JavaScript 엔진은 객체 모양을 사용하여 코드를 최적화하고 종종 객체를 나타내는 클래스를 만듭니다. 객체가 항상 동일한 프로퍼티 및 메서드 (<code>Object.preventExtensions()</code> 메서드, <code>Object.seal()</code> 메서드 또는 <code>Object.freeze()</code> 메서드로 적용 할 수있는 동작)를 항상 가지고 있다고 가정할 수 있는 경우, 존재하지 않는 프로퍼티에 액세스하려는 시도에 오류가 발생하면 도움이될 수 있습니다. 프록시는 객체 모양 유효성 검사를 쉽게 만들수 있게 합니다.</p>
<p>프로퍼티 검증은 프로퍼티가 읽혀질 때만 발생해야 하기때문에 <code>get</code> Trap을 사용합니다. <code>get</code> Trap은 프로퍼티가 객체 상에 존재하지 않더라도 프로퍼티가 읽힐 때 호출되며 세개의 파라미터를 받습니다.</p>
<ol>
<li><code>trapTarget</code> - 프로퍼티를 읽어내는 객체 (프록시의 타겟)</li>
<li><code>key</code> - 프로퍼티 키 (문자열 또는 <em>Symbol</em>)</li>
<li><code>receiver</code> - 조작이 발생된 오브젝트 (일반적으로 프록시)</li>
</ol>
<p>이 파라미터는 <code>set</code> Trap의 파라미터와 유사하며, 눈에 띄는 차이점이 하나 있습니다. <code>get</code> Trap은 값을 쓰지 않기 때문에 <code>value</code>는 여기서 아무런 가치가 없습니다. <code>Reflect.get()</code> 메서드는 <code>get</code> Trap과 동일한 세개의 파라미터를 받아들이고 프로퍼티의 기본값을 반환합니다.</p>
<p>다음과 같이 <code>get</code> Trap과 <code>Reflect.get()</code>를 사용하여 프로퍼티가 대상에 없을때 에러를 발생시킬 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</div><div class="line">        get(trapTarget, key, receiver) &#123;</div><div class="line">            <span class="keyword">if</span> (!(key <span class="keyword">in</span> receiver)) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Property "</span> + key + <span class="string">" doesn't exist."</span>);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(trapTarget, key, receiver);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line"><span class="comment">// 프로퍼티 추가는 잘 됩니다.</span></div><div class="line">proxy.name = <span class="string">"proxy"</span>;</div><div class="line"><span class="built_in">console</span>.log(proxy.name);            <span class="comment">// "proxy"</span></div><div class="line"></div><div class="line"><span class="comment">// 존재하지 않는 프로퍼티는 에러를 던집니다.</span></div><div class="line"><span class="built_in">console</span>.log(proxy.nme);             <span class="comment">// throws error</span></div></pre></td></tr></table></figure>
<p>이 예제에서, <code>get</code> Trap은 프로퍼티 읽기 연산을 가로 챕니다. <code>in</code> 연산자는 프로퍼티가 이미 <code>receiver</code>에 존재 하는지를 결정하는데 사용됩니다. <code>receiver</code>는 <code>receiver</code>가 <code>has</code> Trap을 가진 프록시인 경우에 <code>trapTarget</code> 대신에 <code>in</code>과 함께 사용됩니다. 다음 절에서 다루게될 타입입니다. 이 경우 <code>trapTarget</code>을 사용하면 <code>has</code> Trap을 회피하고 잠재적으로 잘못된 결과를 줄 수 있습니다. 프로퍼티가 없으면 오류가 발생하고 그렇지 않으면 기본 처리가 사용됩니다.</p>
<p>이 코드를 사용하면 <code>proxy.name</code>과 같은 새 프로퍼티는 아무 문제없이 추가하고 수정및 읽을 수 있습니다. 마지막 줄에는 오타가 있습니다. <code>proxy.nme</code>는 <code>proxy.name</code>이어야합니다. <code>nme</code>가 프로퍼티로 존재하지 않으므로 오류가 발생합니다.</p>
<h2 id="has-Trap을-사용하여-프로퍼티-숨기기"><a href="#has-Trap을-사용하여-프로퍼티-숨기기" class="headerlink" title="has Trap을 사용하여 프로퍼티 숨기기"></a>has Trap을 사용하여 프로퍼티 숨기기</h2><p><code>in</code> 연산자는 주어진 객체에 프로퍼티가 존재하는지 여부를 판단하고, 이름이나 <em>Symbol</em>과 일치하는 자체 프로퍼티나 프로토 타입 프로퍼티가 있으면 <code>true</code>를 반환합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> target = &#123;</div><div class="line">    <span class="attr">value</span>: <span class="number">42</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"value"</span> <span class="keyword">in</span> target);     <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"toString"</span> <span class="keyword">in</span> target);  <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p><code>value</code>와 <code>toString</code> 모두 <code>object</code>에 존재하기 때문에 <code>in</code> 연산자는 <code>true</code>를 리턴합니다. <code>value</code> 프로퍼티는 자신의 프로퍼티이고<code>toString</code>는 (Object<code>에서 상속받은) 프로토 타입 프로퍼티입니다. 프록시를 사용하면 이 작업을 가로 채고</code>has<code>Trap을 사용하여</code>in`에 다른 값을 반환할 수 있습니다.</p>
<p><code>has</code> Trap은 <code>in</code> 연산자가 사용될 때마다 호출됩니다. 호출될 때 두개의 파라미터가 <code>has</code> Trap에 전달됩니다.</p>
<ol>
<li><code>trapTarget</code> - 프로퍼티의 read 객체 (프록시의 타겟)</li>
<li><code>key</code> - 체크 대상의 프로퍼티 키 (문자열 또는 <em>Symbol</em>)</li>
</ol>
<p><code>Reflect.has()</code> 메서드는 동일한 파라미터를 받아 들여 <code>in</code> 연산자에 대한 기본 응답을 반환합니다. <code>has</code> Trap과 <code>Reflect.has()</code>를 사용하면 일부 프로퍼티는 <code>in</code>의 동작을 변경하고 다른 프로퍼티는 기본 동작으로 되돌릴 수 있습니다. 예를 들어, <code>value</code> 프로퍼티를 숨기고 싶다고 가정 해보십시오. 이렇게 할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> target = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">"target"</span>,</div><div class="line">    <span class="attr">value</span>: <span class="number">42</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</div><div class="line">    has(trapTarget, key) &#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (key === <span class="string">"value"</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="built_in">Reflect</span>.has(trapTarget, key);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"value"</span> <span class="keyword">in</span> proxy);      <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> proxy);       <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"toString"</span> <span class="keyword">in</span> proxy);   <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p><code>proxy</code>의 <code>has</code> Trap은 <code>key</code>가 <code>value</code>이면 <code>false</code>를 반환합니다. 그렇지 않으면 <code>Reflect.has()</code> 메서드를 호출하여 기본 동작을 사용합니다. 결과적으로 <code>in</code> 연산자는 <code>value</code>가 실제로 대상에 존재하더라도 <code>value</code> 프로퍼티에 대해 <code>false</code>를 반환합니다. <code>name</code>과<br> <code>toString</code>은 <code>in</code> 연산자와 함께 사용될 때 정확하게 <code>true</code>를 리턴합니다.</p>
<h2 id="deleteProperty-Trap을-사용하여-프로퍼티-삭제-방지"><a href="#deleteProperty-Trap을-사용하여-프로퍼티-삭제-방지" class="headerlink" title="deleteProperty Trap을 사용하여 프로퍼티 삭제 방지"></a>deleteProperty Trap을 사용하여 프로퍼티 삭제 방지</h2><p><code>delete</code> 연산자는 객체에서 프로퍼티를 제거하고, 성공하면 <code>true</code>를 실패하면 <code>false</code>를 반환합니다. strict 모드에서 <code>delete</code>는<code>nonconfigurable</code> 프로퍼티를 지울때 에러를 던집니다. nonstrict 모드에서 <code>delete</code>는 단순히 <code>false</code>를 반환합니다. 다음 예제를 참고하세요.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> target = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">"target"</span>,</div><div class="line">    <span class="attr">value</span>: <span class="number">42</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.defineProperty(target, <span class="string">"name"</span>, &#123; <span class="attr">configurable</span>: <span class="literal">false</span> &#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"value"</span> <span class="keyword">in</span> target);     <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> result1 = <span class="keyword">delete</span> target.value;</div><div class="line"><span class="built_in">console</span>.log(result1);               <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"value"</span> <span class="keyword">in</span> target);     <span class="comment">// false</span></div><div class="line"></div><div class="line"><span class="comment">// Note: 아래 라인은 strict 모드에서 에러가 발생합니다.</span></div><div class="line"><span class="keyword">let</span> result2 = <span class="keyword">delete</span> target.name;</div><div class="line"><span class="built_in">console</span>.log(result2);               <span class="comment">// false</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> target);      <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p><code>value</code> 프로퍼티는 <code>delete</code> 연산자를 사용하여 삭제되고 결과적으로 <code>in</code> 연산자는 세 번째 <code>console.log ()</code> 호출에서 <code>false</code>를 반환합니다. nonconfigurable  <code>name</code> 프로퍼티는 삭제될 수 없으므로 <code>delete</code> 연산자는 단순히 <code>false</code>를 반환합니다 (이 코드가 <code>strict</code> 모드로 실행되면 대신 에러가 발생합니다). 프록시에서 <code>deleteProperty</code> Trap을 사용하여 이 동작을 변경할 수 있습니다.</p>
<p><code>deleteProperty</code> Trap은 객체 속성에서 <code>delete</code> 연산자가 사용될 때마다 호출됩니다. Trap에는 두개의 파라미터가 전달됩니다.</p>
<ol>
<li><code>trapTarget</code> - 프로퍼티을 삭제해야 할 객체 (프록시의 대상)</li>
<li><code>key</code> - 삭제하는 프로퍼티 키 (문자열 또는 <em>Symbol</em>)</li>
</ol>
<p><code>Reflect.deleteProperty()</code> 메서드는 <code>deleteProperty</code> Trap의 기본 구현을 제공하고 동일한 두개의 파라미터를 받아들입니다. <code>Reflect.deleteProperty()</code>와 <code>deleteProperty</code> Trap을 결합하여 <code>delete</code> 연산자가 어떻게 동작 하는지를 변경할 수 있습니다. 예를 들어, <code>value</code> 프로퍼티를 삭제할수 없도록 할수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> target = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">"target"</span>,</div><div class="line">    <span class="attr">value</span>: <span class="number">42</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</div><div class="line">    deleteProperty(trapTarget, key) &#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (key === <span class="string">"value"</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="built_in">Reflect</span>.deleteProperty(trapTarget, key);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// Attempt to delete proxy.value</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"value"</span> <span class="keyword">in</span> proxy);      <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> result1 = <span class="keyword">delete</span> proxy.value;</div><div class="line"><span class="built_in">console</span>.log(result1);               <span class="comment">// false</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"value"</span> <span class="keyword">in</span> proxy);      <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="comment">// Attempt to delete proxy.name</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> proxy);       <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> result2 = <span class="keyword">delete</span> proxy.name;</div><div class="line"><span class="built_in">console</span>.log(result2);               <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> proxy);       <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p>이 코드는 <code>has</code> Trap 예제와 매우 비슷합니다. <code>deleteProperty</code> Trap은 <code>key</code>가 <code>&quot;value&quot;</code>인지 확인하고, 그렇다면 <code>false</code>를 리턴합니다. 그렇지 않으면 <code>Reflect.deleteProperty()</code> 메서드를 호출하여 기본 동작을 계속합니다. 연산이 Trap 되었기 때문에 <code>value</code> 프로퍼티는 프록시를 통해 삭제할 수 없지만 <code>name</code> 프로퍼티는 예상대로 삭제됩니다. 이 접근법은 strict 모드에서 오류를 던지지 않고 프로퍼티를 삭제되지 않도록 보호하려는 경우에 특히 유용합니다.</p>
<h2 id="Prototype-프록시-Trap"><a href="#Prototype-프록시-Trap" class="headerlink" title="Prototype 프록시 Trap"></a>Prototype 프록시 Trap</h2><p>4 장에서는 ECMAScript 5의 <code>Object.getPrototypeOf()</code> 메서드를 보완하기 위해 ECMAScript 6에 추가한 <code>Object.setPrototypeOf()</code> 메서드를 소개했습니다. 프록시를 사용하면 <code>setPrototypeOf</code>와 <code>getPrototypeOf</code> Trap을 통해 두 메서드의 실행을 가로챌 수 있습니다. 두 경우 모두<code>Object</code> 메서드는 프록시에서 해당 이름의 Trap을 호출하여 메서드의 동작을 변경할 수 있습니다.</p>
<p>프로토 타입 프록시와 관련된 두개의 Trap이 있고 각 Trap 유형과 관련된 메서드가 있습니다. <code>setPrototypeOf</code> Trap은 다음 파라미터를 받습니다.</p>
<ol>
<li><code>trapTarget</code> - 프로토 타입을 설정해야하는 객체 (프록시의 대상)</li>
<li><code>proto</code> - 프로토 타입으로 사용하는 객체</li>
</ol>
<p>이들은 <code>Object.setPrototypeOf()</code> 및 <code>Reflect.setPrototypeOf()</code> 메서드에 전달되는 동일한 파라미터입니다. 반면에 <code>getPrototypeOf</code> Trap은 <code>trapTarget</code> 파라미터만 받습니다. 파라미터는 <code>Object.getPrototypeOf()</code> 및 <code>Reflect.getPrototypeOf()</code> 메서드로 전달됩니다.</p>
<h3 id="프로토-타입-프록시-Trap의-작동-방식"><a href="#프로토-타입-프록시-Trap의-작동-방식" class="headerlink" title="프로토 타입 프록시 Trap의 작동 방식"></a>프로토 타입 프록시 Trap의 작동 방식</h3><p>이 Trap들에는 몇가지 제한 사항이 있습니다. 첫째, <code>getPrototypeOf</code> Trap은 객체 또는 <code>null</code>을 반환해야하고, 다른 반환 값은 런타임 오류를 발생시킵니다. 반환값 검사는 <code>Object.getPrototypeOf()</code>가 항상 예상값을 반환하도록 보장합니다. 비슷하게, 연산이 성공하지 못하면<br> <code>setPrototypeOf</code> Trap의 반환값은 <code>false</code>이어야합니다. <code>setPrototypeOf</code>가 <code>false</code>를 반환하면, <code>Object.setPrototypeOf()</code>는 에러를 던집니다. <code>setPrototypeOf</code>가 <code>false</code>가 아닌 다른 값을 반환하면 <code>Object.setPrototypeOf()</code>는 연산이 성공했다고 가정합니다.</p>
<p>다음 예제는 항상 <code>null</code>을 반환하여 프록시의 프로토 타입을 숨기며 프로토 타입을 변경할 수 없습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> target = &#123;&#125;;</div><div class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</div><div class="line">    getPrototypeOf(trapTarget) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">    &#125;,</div><div class="line">    setPrototypeOf(trapTarget, proto) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">let</span> targetProto = <span class="built_in">Object</span>.getPrototypeOf(target);</div><div class="line"><span class="keyword">let</span> proxyProto = <span class="built_in">Object</span>.getPrototypeOf(proxy);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(targetProto === <span class="built_in">Object</span>.prototype);      <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(proxyProto === <span class="built_in">Object</span>.prototype);       <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log(proxyProto);                            <span class="comment">// null</span></div><div class="line"></div><div class="line"><span class="comment">// succeeds</span></div><div class="line"><span class="built_in">Object</span>.setPrototypeOf(target, &#123;&#125;);</div><div class="line"></div><div class="line"><span class="comment">// throws error</span></div><div class="line"><span class="built_in">Object</span>.setPrototypeOf(proxy, &#123;&#125;);</div></pre></td></tr></table></figure>
<p>이 코드는 <code>target</code>과 <code>proxy</code>의 동작 사이의 차이점을 강조합니다. <code>Object.getPrototypeOf()</code>은 <code>target</code>에 대한 값을 반환하는 동안<br> <code>getPrototypeOf</code> Trap이 호출되기 때문에 <code>proxy</code>에 대해 <code>null</code>을 리턴합니다. 비슷하게 <code>Object.setPrototypeOf()</code>는 <code>target</code>에서 사용될 때 성공하지만 <code>setPrototypeOf</code> Trap으로 인해 <code>proxy</code>에서 사용될 때 에러를 던집니다.</p>
<p>이 두 Trap의 기본 동작을 사용하려면 <code>Reflect</code>에서 해당 메서드를 사용해야 합니다. 예를 들어, 이 코드는 <code>getPrototypeOf</code> 및<br> <code>setPrototypeOf</code> Trap의 기본 동작을 구현합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> target = &#123;&#125;;</div><div class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</div><div class="line">    getPrototypeOf(trapTarget) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.getPrototypeOf(trapTarget);</div><div class="line">    &#125;,</div><div class="line">    setPrototypeOf(trapTarget, proto) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.setPrototypeOf(trapTarget, proto);</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">let</span> targetProto = <span class="built_in">Object</span>.getPrototypeOf(target);</div><div class="line"><span class="keyword">let</span> proxyProto = <span class="built_in">Object</span>.getPrototypeOf(proxy);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(targetProto === <span class="built_in">Object</span>.prototype);      <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(proxyProto === <span class="built_in">Object</span>.prototype);       <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="comment">// succeeds</span></div><div class="line"><span class="built_in">Object</span>.setPrototypeOf(target, &#123;&#125;);</div><div class="line"></div><div class="line"><span class="comment">// also succeeds</span></div><div class="line"><span class="built_in">Object</span>.setPrototypeOf(proxy, &#123;&#125;);</div></pre></td></tr></table></figure>
<p>이 예에서, <code>getPrototypeOf</code> 및 <code>setPrototypeOf</code> Trap이 기본 실행을 사용하기 위해 통과하고 있기 때문에 <code>target</code>과 <code>proxy</code>를 교대로 사용할 수 있고 같은 결과를 얻을 수 있습니다. 이 예제는 몇가지 중요한 차이점 때문에 <code>Object</code>에서 같은 이름의 메서드보다는 <code>Reflect.getPrototypeOf()</code>와 <code>Reflect.setPrototypeOf()</code> 메서드를 사용하는 것이 중요합니다.</p>
<h3 id="왜-두개의-Set-메서드일까요"><a href="#왜-두개의-Set-메서드일까요" class="headerlink" title="왜 두개의 Set 메서드일까요?"></a>왜 두개의 Set 메서드일까요?</h3><p><code>Reflect.getPrototypeOf()</code> 및 <code>Reflect.setPrototypeOf()</code>의 혼란스러운 부분은 <code>Object.getPrototypeOf()</code> 및<br> <code>Object.setPrototypeOf()</code> 메서드와 유사하게 보입니다. 두 세트의 메서드가 유사한 기능을 수행하지만, 두 메서드 사이에 뚜렷한 차이점이 있습니다.</p>
<p>우선, <code>Object.getPrototypeOf()</code> 및 <code>Object.setPrototypeOf()</code>는 처음부터 개발자를 위해 만든 상위 수준의 기능입니다. <code>Reflect.getPrototypeOf()</code> 및 <code>Reflect.setPrototypeOf()</code> 메서드는 개발자가 이전의 내부 전용 <code>[[GetPrototypeOf]]</code> 및 <code>[[SetPrototypeOf]]</code> 작업에 액세스할 수 있도록하는 하위 수준의 기능입니다. <code>Reflect.getPrototypeOf()</code> 메서드는 내부 <code>[[GetPrototypeOf]]</code> 연산의 래퍼 (일부 입력 유효성 검사 포함)입니다. <code>Reflect.setPrototypeOf()</code> 메서드와 <code>[[SetPrototypeOf]]</code>은 같은 관계입니다. <code>Object</code>의 해당 메서드는 <code>[[GetPrototypeOf]]</code> 및 <code>[[SetPrototypeOf]]</code>를 호출하지만 호출 전에 몇 단계를 수행하고 반환 값을 검사하여 동작 방법을 결정합니다.</p>
<p><code>Reflect.getPrototypeOf()</code> 메서드는 파라미터가 객체가 아닌 경우 오류를 발생시키고 <code>Object.getPrototypeOf()</code>는 먼저 작업을 수행하기 전에 값을 객체에 강제 변환합니다. 각 메서드에 숫자를 전달하면 다른 결과가 나타납니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> result1 = <span class="built_in">Object</span>.getPrototypeOf(<span class="number">1</span>);</div><div class="line"><span class="built_in">console</span>.log(result1 === <span class="built_in">Number</span>.prototype);  <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="comment">// error가 발생</span></div><div class="line"><span class="built_in">Reflect</span>.getPrototypeOf(<span class="number">1</span>);</div></pre></td></tr></table></figure>
<p><code>Object.getPrototypeOf()</code> 메서드는 값을 <code>Number</code> 객체로 강제 변환한 다음 <code>Number.prototype</code>을 반환하기 때문에 <code>1</code>의 프로토 타입을 가져옵니다. <code>Reflect.getPrototypeOf()</code> 메서드는 값을 강제로 변환하지 않으며 <code>1</code>은 객체가 아니기 때문에 오류를 던집니다.</p>
<p><code>Reflect.setPrototypeOf()</code> 메서드는 <code>Object.setPrototypeOf()</code> 메서드와 몇가지 다른 점이 있습니다. 첫째로, <code>Reflect.setPrototypeOf()</code>는 작업이 성공했는지를 나타내는 부울 값을 반환합니다. 성공하면 <code>true</code> 값이 반환되고 실패하면 <code>false</code>가 반환됩니다. <code>Object.setPrototypeOf()</code>는 실패하면 에러를 발생합니다.</p>
<p>“프로토 타입 프록시 Trap의 작동 방식”의 첫 번째 예제에서 보듯이 <code>setPrototypeOf</code> 프록시 Trap이 <code>false</code>를 반환하면<br> <code>Object.setPrototypeOf()</code>는 오류를 발생시킵니다. <code>Object.setPrototypeOf()</code> 메서드는 첫 번째 인자를 값으로 반환하므로<code>setPrototypeOf</code> 프록시 Trap의 기본 실행을 구현하는데 적합하지 않습니다. 다음 코드는 이러한 차이점을 보여줍니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> target1 = &#123;&#125;;</div><div class="line"><span class="keyword">let</span> result1 = <span class="built_in">Object</span>.setPrototypeOf(target1, &#123;&#125;);</div><div class="line"><span class="built_in">console</span>.log(result1 === target1);                   <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> target2 = &#123;&#125;;</div><div class="line"><span class="keyword">let</span> result2 = <span class="built_in">Reflect</span>.setPrototypeOf(target2, &#123;&#125;);</div><div class="line"><span class="built_in">console</span>.log(result2 === target2);                   <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log(result2);                               <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>이 예제에서 <code>Object.setPrototypeOf()</code>는 <code>target1</code>을 값으로 반환하지만 <code>Reflect.setPrototypeOf()</code>는 <code>true</code>를 반환합니다. 이 미묘한 차이는 매우 중요합니다. <code>Object</code>와 <code>Reflect</code>에 중복된 메서드가 더많이 보일것입니다. 항상 프록시 Trap 내에서 <code>Reflect</code> 메서드를 사용해야합니다.</p>
<blockquote>
<p>두 메서드는 프록시에서 사용될 때 <code>getPrototypeOf</code> 및 <code>setPrototypeOf</code> 프록시 Trap을 호출합니다.</p>
</blockquote>
<h2 id="Object-확장-Trap"><a href="#Object-확장-Trap" class="headerlink" title="Object 확장 Trap"></a>Object 확장 Trap</h2><p>ECMAScript 5는 <code>Object.preventExtensions()</code> 및 <code>Object.isExtensible()</code> 메서드를 통해 객체 확장성 수정을 추가했으며 ECMAScript 6을 사용하면 프록시가 <code>preventExtensions</code> 및 <code>isExtensible</code> Trap을 통해 기본 객체에 대한 메서드 호출을 차단할 수 있습니다. 두 Trap 모두 메서드가 호출된 객체인 <code>trapTarget</code>이라는 단일 파라미터를 받습니다. <code>isExtensible</code> Trap은 객체가 확장 가능한지 여부를 나타내는 부울값을 반환해야 하고 <code>preventExtensions</code> Trap은 작업이 성공했는지를 나타내는 부울값을 반환해야합니다.</p>
<p>또한 기본 동작을 구현하기 위해 <code>Reflect.preventExtensions()</code>와 <code>Reflect.isExtensible()</code> 메서드가 있습니다. 둘 다 부울값을 반환하므로 해당 Trap에서 직접 사용할 수 있습니다.</p>
<h3 id="기본-예제-두개"><a href="#기본-예제-두개" class="headerlink" title="기본 예제 두개"></a>기본 예제 두개</h3><p>작업에서 객체 확장성 Trap을 확인 하기위해 <code>isExtensible</code> 및 <code>preventExtensions</code> Trap에 대한 기본 동작을 구현하는 다음 코드를 살펴보겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> target = &#123;&#125;;</div><div class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</div><div class="line">    isExtensible(trapTarget) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.isExtensible(trapTarget);</div><div class="line">    &#125;,</div><div class="line">    preventExtensions(trapTarget) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.preventExtensions(trapTarget);</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(target));       <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(proxy));        <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="built_in">Object</span>.preventExtensions(proxy);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(target));       <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(proxy));        <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p>이 예제는 <code>Object.preventExtensions()</code>와 <code>Object.isExtensible()</code> 모두 <code>proxy</code>에서 <code>target</code>으로 정확하게 전달되는 것을 보여줍니다. 물론 동작을 바꿀 수도 있습니다. 예를 들어 <code>Object.preventExtensions()</code>가 프록시에서 성공하지 못하도록하려는 경우<br> <code>preventExtensions</code> Trap에서 <code>false</code>를 반환할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> target = &#123;&#125;;</div><div class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</div><div class="line">    isExtensible(trapTarget) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.isExtensible(trapTarget);</div><div class="line">    &#125;,</div><div class="line">    preventExtensions(trapTarget) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(target));       <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(proxy));        <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="built_in">Object</span>.preventExtensions(proxy);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(target));       <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(proxy));        <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p><code>preventExtensions</code> Trap이 <code>false</code>를 반환하기 때문에 <code>Object.preventExtensions(proxy)</code>에 대한 호출이 무시됩니다. 작업은 기본<br> <code>target</code>으로 전달되지 않으므로 <code>Object.isExtensible()</code>은 <code>true</code>를 반환합니다.</p>
<h3 id="중복-확장-메서드"><a href="#중복-확장-메서드" class="headerlink" title="중복 확장 메서드"></a>중복 확장 메서드</h3><p>다시 한번, <code>Object</code>와 <code>Reflect</code>에 중복된 메서드가 있다는 것을 눈치챘을 것입니다. 이 경우에는 더 유사합니다. <code>Object.isExtensible()</code> 및 <code>Reflect.isExtensible()</code> 메서드는 비객체 값이 전달된 경우를 제외하고는 서로 비슷합니다. 이 경우 <code>Reflect.isExtensible()</code>이 오류를 발생하고 <code>Object.isExtensible()</code>은 항상 <code>false</code>를 반환합니다. 다음은 그 동작의 예제입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> result1 = <span class="built_in">Object</span>.isExtensible(<span class="number">2</span>);</div><div class="line"><span class="built_in">console</span>.log(result1);                       <span class="comment">// false</span></div><div class="line"></div><div class="line"><span class="comment">// error 발생</span></div><div class="line"><span class="keyword">let</span> result2 = <span class="built_in">Reflect</span>.isExtensible(<span class="number">2</span>);</div></pre></td></tr></table></figure>
<p>이 제한은 <code>Object.getPrototypeOf()</code>와 <code>Reflect.getPrototypeOf()</code> 메서드의 차이와 유사합니다. 하위 레벨 기능의 메서드는 상위 레벨 기능보다 더 엄격한 오류 확인 기능을 가지고 있기 때문입니다.</p>
<p><code>Object.preventExtensions()</code> 및 <code>Reflect.preventExtensions()</code> 메서드도 매우 비슷합니다. <code>Object.preventExtensions()</code> 메서드는 값이 객체가 아닌 경우에 파라미터로 전달된 값을 항상 반환합니다. 반대로 <code>Reflect.preventExtensions()</code> 메서드는 파라미터가 객체가 아닌 경우 오류를 발생시킵니다. 파라미터가 객체인 경우 <code>Reflect.preventExtensions()</code>는 작업이 성공하면 <code>true</code>를 반환하고 그렇지 않으면 <code>false</code>를 반환합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> result1 = <span class="built_in">Object</span>.preventExtensions(<span class="number">2</span>);</div><div class="line"><span class="built_in">console</span>.log(result1);                               <span class="comment">// 2</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> target = &#123;&#125;;</div><div class="line"><span class="keyword">let</span> result2 = <span class="built_in">Reflect</span>.preventExtensions(target);</div><div class="line"><span class="built_in">console</span>.log(result2);                               <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="comment">// throws error</span></div><div class="line"><span class="keyword">let</span> result3 = <span class="built_in">Reflect</span>.preventExtensions(<span class="number">2</span>);</div></pre></td></tr></table></figure>
<p>여기서 <code>Object.preventExtensions()</code>는 <code>2</code>가 객체가 아니더라도 <code>2</code>를 통과 시킵니다. <code>Reflect.preventExtensions()</code> 메서드는 객체가 전달될 때 <code>true</code>를 반환하고 <code>2</code>를 전달하면 오류를 발생시킵니다.</p>
<h2 id="프로퍼티-Descriptor-Trap"><a href="#프로퍼티-Descriptor-Trap" class="headerlink" title="프로퍼티 Descriptor Trap"></a>프로퍼티 Descriptor Trap</h2><p>ECMAScript 5의 가장 중요한 기능중 하나는 <code>Object.defineProperty()</code> 메서드를 사용하여 프로퍼티 속성을 정의하는 기능이었습니다. 이전 버전의 JavaScript에서는 Accessor 프로퍼티를 정의하거나, 속성을 Read-only로 만들거나, 속성을 Nonenumerable하게 만들 수있는 방법이 없었습니다. 이 모든 작업은 <code>Object.defineProperty()</code> 메서드를 사용하여 수행할 수 있으며 <code>Object.getOwnPropertyDescriptor()</code> 메서드를 사용하여 이러한 속성을 검색할 수 있습니다.</p>
<p>프록시를 사용하면 <code>defineProperty</code> 및 <code>getOwnPropertyDescriptor</code> Trap을 각각 사용하여 <code>Object.defineProperty()</code> 및 <code>Object.getOwnPropertyDescriptor()</code>에 대한 호출을 가로 채게할 수 있습니다. <code>defineProperty</code> Trap은 다음 파라미터를 받습니다.</p>
<ol>
<li><code>trapTarget</code> - 프로퍼티을 정의 할 필요가있는 객체 (프록시의 대상)</li>
<li><code>key</code> - 프로퍼티의 문자열 또는 <em>Symbol</em></li>
<li><code>descriptor</code> - 프로퍼티 설명 객체</li>
</ol>
<p><code>defineProperty</code> Trap은 작업이 성공하면 <code>true</code>를, 그렇지 않으면 <code>false</code>를 반환합니다. <code>getOwnPropertyDescriptor</code> Trap은<br> <code>trapTarget</code>과 <code>key</code>만 받으며, Descriptor를 리턴해야합니다. 상응하는 <code>Reflect.defineProperty()</code>와<br> <code>Reflect.getOwnPropertyDescriptor()</code> 메서드는 프록시 Trap과 동일한 파라미터를 받습니다. 다음은 각 Trap의 기본 동작을 구현하는 예제입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</div><div class="line">    defineProperty(trapTarget, key, descriptor) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.defineProperty(trapTarget, key, descriptor);</div><div class="line">    &#125;,</div><div class="line">    getOwnPropertyDescriptor(trapTarget, key) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.getOwnPropertyDescriptor(trapTarget, key);</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"></div><div class="line"><span class="built_in">Object</span>.defineProperty(proxy, <span class="string">"name"</span>, &#123;</div><div class="line">    <span class="attr">value</span>: <span class="string">"proxy"</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(proxy.name);            <span class="comment">// "proxy"</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(proxy, <span class="string">"name"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(descriptor.value);      <span class="comment">// "proxy"</span></div></pre></td></tr></table></figure>
<p>이 코드는 <code>Object.defineProperty()</code> 메서드를 사용하여 프록시에서 <code>&quot;name&quot;</code>이라는 프로퍼티를 정의합니다. 그런 다음 해당 프로퍼티의 Descriptor가 <code>Object.getOwnPropertyDescriptor()</code> 메서드에 의해 검색됩니다.</p>
<h3 id="Object-defineProperty-잠그기"><a href="#Object-defineProperty-잠그기" class="headerlink" title="Object.defineProperty() 잠그기"></a>Object.defineProperty() 잠그기</h3><p><code>defineProperty</code> Trap은 조작이 성공했는지 여부를 나타내기 위해 부울 값을 리턴하도록 요구합니다. <code>true</code>가 리턴되면, <code>Object.defineProperty()</code>는 평소대로 성공합니다; <code>false</code>가 리턴되면 <code>Object.defineProperty()</code>는 에러를 발생시킵니다. 이 기능을 사용하여 <code>Object.defineProperty()</code> 메서드가 정의할 수있는 프로퍼티의 종류를 제한할 수 있습니다. 예를 들어 <em>Symbol</em> 프로퍼티가 정의되지 않도록하려면 <code>key</code>가 문자열인지 확인하고 그렇지 않으면 <code>false</code>를 반환합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</div><div class="line">    defineProperty(trapTarget, key, descriptor) &#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> key === <span class="string">"symbol"</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.defineProperty(trapTarget, key, descriptor);</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"></div><div class="line"><span class="built_in">Object</span>.defineProperty(proxy, <span class="string">"name"</span>, &#123;</div><div class="line">    <span class="attr">value</span>: <span class="string">"proxy"</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(proxy.name);                    <span class="comment">// "proxy"</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> nameSymbol = <span class="built_in">Symbol</span>(<span class="string">"name"</span>);</div><div class="line"></div><div class="line"><span class="comment">// error 발생</span></div><div class="line"><span class="built_in">Object</span>.defineProperty(proxy, nameSymbol, &#123;</div><div class="line">    <span class="attr">value</span>: <span class="string">"proxy"</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><code>defineProperty</code> 프록시 Trap은 <code>key</code>가 <em>Symbol</em> 일 때 <code>false</code>를 리턴하고 그렇지 않으면 기본 동작을 진행합니다. <code>name</code>을 <code>key</code>로<br> 하여 <code>Object.defineProperty()</code>를 호출하면, <code>key</code>가 문자열이기 때문에 메서드가 성공합니다. <code>Object.defineProperty()</code>가<br> <code>nameSymbol</code>과 함께 호출되면 <code>defineProperty</code> Trap이 <code>false</code>를 반환하기 때문에 에러가 발생합니다.</p>
<blockquote>
<p>또한 <code>Reflect.defineProperty()</code> 메서드를 호출하지 않고 <code>true</code>를 리턴함으로써 <code>Object.defineProperty()</code>가 자동으로 실패하도록 할 수 있습니다. 실제로 프로퍼티를 정의하지 않는 동안 오류가 표시되지 않습니다.</p>
</blockquote>
<h3 id="Descriptor-객체-제한-사항"><a href="#Descriptor-객체-제한-사항" class="headerlink" title="Descriptor 객체 제한 사항"></a>Descriptor 객체 제한 사항</h3><p><code>Object.defineProperty()</code> 및 <code>Object.getOwnPropertyDescriptor()</code> 메서드를 사용할 때 일관된 동작을 보장하기 위해<br> <code>defineProperty</code> Trap에 전달된 Descriptor 객체가 정규화됩니다. <code>getOwnPropertyDescriptor</code> Trap에서 반환된 객체는 같은 이유로 항상 유효성이 검사됩니다.</p>
<p>어떤 객체가 <code>Object.defineProperty()</code> 메서드의 세 번째 파라미터로 전달 되더라도, <code>enumerable</code>, <code>configurable</code>, <code>value</code>, <code>writable</code>, <code>get</code> 및 <code>set</code> 속성들만 <code>defineProperty</code> Trap로 전달된 Descrptor 객체에 있을수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</div><div class="line">    defineProperty(trapTarget, key, descriptor) &#123;</div><div class="line">        <span class="built_in">console</span>.log(descriptor.value);              <span class="comment">// "proxy"</span></div><div class="line">        <span class="built_in">console</span>.log(descriptor.name);               <span class="comment">// undefined</span></div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.defineProperty(trapTarget, key, descriptor);</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"></div><div class="line"><span class="built_in">Object</span>.defineProperty(proxy, <span class="string">"name"</span>, &#123;</div><div class="line">    <span class="attr">value</span>: <span class="string">"proxy"</span>,</div><div class="line">    <span class="attr">name</span>: <span class="string">"custom"</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>여기서, <code>Object.defineProperty()</code>는 세 번째 파라미터에 비표준 <code>name</code> 프로퍼티를 가지고 호출됩니다. <code>defineProperty</code> Trap이 호출되면, <code>descriptor</code> 객체는 <code>name</code> 프로퍼티를 갖지 않고 <code>value</code> 프로퍼티는 갖습니다. 왜냐하면 <code>descriptor</code>는 <code>Object.defineProperty()</code> 메서드에 전달된 실제 세 번째 파라미터에 대한 참조가 아니라 허용 가능한 프로퍼티만을 포함하는 새로운 객체이기 때문입니다. <code>Reflect.defineProperty()</code> 메서드는 또한 Descriptor의 비표준 특성을 무시합니다.</p>
<p><code>getOwnPropertyDescriptor</code> Trap은 반환값이 <code>null</code>, <code>undefined</code> 또는 객체가되도록 약간 다른 제한이 있습니다. 객체가 반환되면 객체의 자체 프로퍼티로 <code>enumerable</code>, <code>configurable</code>, <code>value</code>, <code>writable</code>, <code>get</code> 및 <code>set</code> 만 허용됩니다. 아래 코드와 같이 허용되지 않는 자체 프로퍼티를 가진 객체를 반환하면 오류가 발생합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</div><div class="line">    getOwnPropertyDescriptor(trapTarget, key) &#123;</div><div class="line">        <span class="keyword">return</span> &#123;</div><div class="line">            <span class="attr">name</span>: <span class="string">"proxy"</span></div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// error 발생</span></div><div class="line"><span class="keyword">let</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(proxy, <span class="string">"name"</span>);</div></pre></td></tr></table></figure>
<p>프로퍼티 Descriptor에서 <code>name</code> 프로퍼티를 사용할 수 없으므로 <code>Object.getOwnPropertyDescriptor()</code>가 호출되면<br> <code>getOwnPropertyDescriptor</code> 반환값은 오류를 발생시킵니다. 이 제약은, <code>Object.getOwnPropertyDescriptor()</code>에 의해 돌려 주어지는 값이, 프록시상에서의 사용에 관계없이 항상 신뢰할 수있는 구조를 가지는 것을 보증합니다.</p>
<h3 id="중복된-Descriptor-메서드"><a href="#중복된-Descriptor-메서드" class="headerlink" title="중복된 Descriptor 메서드"></a>중복된 Descriptor 메서드</h3><p>다시 한번, ECMAScript 6는 <code>Object.defineProperty()</code> 및<code>Object.getOwnPropertyDescriptor()</code> 메서드가 <code>Reflect.defineProperty()</code> 및 <code>Reflect.getOwnPropertyDescriptor()</code> 메서드와 동일한 기능을 수행하는 것처럼 혼동을 불러 일으키는 유사한 메서드를 가지고 있습니다. 이 장의 앞 부분에서 논의된 다른 메서드와 마찬가지로, 이들은 미묘하지만 중요한 차이점이 있습니다.</p>
<h4 id="defineProperty-메서드"><a href="#defineProperty-메서드" class="headerlink" title="defineProperty() 메서드"></a>defineProperty() 메서드</h4><p><code>Object.defineProperty()</code> 및 <code>Reflect.defineProperty()</code> 메서드는 반환 값을 제외하고 완전히 동일합니다. <code>Object.defineProperty()</code> 메서드는 첫 번째 피라미터를 반환하고 <code>Reflect.defineProperty()</code>는 작업이 성공하면 <code>true</code>를 반환하고 그렇지 않으면 <code>false</code>를 반환합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> target = &#123;&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> result1 = <span class="built_in">Object</span>.defineProperty(target, <span class="string">"name"</span>, &#123; <span class="attr">value</span>: <span class="string">"target "</span>&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(target === result1);        <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> result2 = <span class="built_in">Reflect</span>.defineProperty(target, <span class="string">"name"</span>, &#123; <span class="attr">value</span>: <span class="string">"reflect"</span> &#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(result2);                   <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p><code>target</code>에서 <code>Object.defineProperty()</code>가 호출되면 반환값은 <code>target</code>입니다. <code>Reflect.defineProperty()</code>가 <code>target</code>에서 호출되면 반환값은 연산이 성공했음을 나타내는 <code>true</code>입니다. <code>defineProperty</code> 프록시 Trap은 반환될 부울 값을 필요로하기 때문에 필요할 때<br> <code>Reflect.defineProperty()</code>를 사용하여 기본 동작을 구현하는 것이 좋습니다.</p>
<h4 id="getOwnPropertyDescriptor-메서드"><a href="#getOwnPropertyDescriptor-메서드" class="headerlink" title="getOwnPropertyDescriptor() 메서드"></a>getOwnPropertyDescriptor() 메서드</h4><p><code>Object.getOwnPropertyDescriptor()</code> 메서드는 <em>Primitive</em> 값이 전달될 때 첫 번째 파라미터를 객체로 강제 변환한 다음 작업을 계속합니다. 반면에 첫 번째 파라미터가 <em>Primitive</em> 값이면 <code>Reflect.getOwnPropertyDescriptor()</code> 메서드는 오류를 발생시킵니다. 다음은 이 두 가지를 보여주는 예입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> descriptor1 = <span class="built_in">Object</span>.getOwnPropertyDescriptor(<span class="number">2</span>, <span class="string">"name"</span>);</div><div class="line"><span class="built_in">console</span>.log(descriptor1);       <span class="comment">// undefined</span></div><div class="line"></div><div class="line"><span class="comment">// throws an error</span></div><div class="line"><span class="keyword">let</span> descriptor2 = <span class="built_in">Reflect</span>.getOwnPropertyDescriptor(<span class="number">2</span>, <span class="string">"name"</span>);</div></pre></td></tr></table></figure>
<p><code>Object.getOwnPropertyDescriptor()</code> 메서드는 <code>2</code>를 객체로 강제변환하고 객체에는 <code>name</code> 프로퍼티가 없기 때문에  <code>undefined</code>를 반환합니다. 주어진 이름을 가진 프로퍼티가 객체에서 발견되지 않을때의 메서드 표준 동작입니다. 그러나 <code>Reflect.getOwnPropertyDescriptor()</code>가 호출되면 해당 메서드가 첫 번째 파라미터에 대한 <em>Primitive</em> 값을 허용하지 않기 때문에 오류가 즉시 발생합니다.</p>
<h2 id="ownKeys-Trap"><a href="#ownKeys-Trap" class="headerlink" title="ownKeys Trap"></a>ownKeys Trap</h2><p><code>ownKeys</code> 프록시 Trap은 내부 메서드 <code>[[OwnPropertyKeys]]</code>를 가로 채고, 여러분이 값의 <em>Array</em>를 반환함으로써 동작을 오버라이드할 수 있도록합니다. 이 <em>Array</em>는 <code>Object.keys()</code>, <code>Object.getOwnPropertyNames()</code>, <code>Object.getOwnPropertySymbols()</code> 및 <code>Object.assign()</code>의 네 가지 메서드를 사용합니다. <code>Object.assign()</code> 메서드는 <em>Array</em>를 사용하여 복사할 프로퍼티를 결정합니다.</p>
<p><code>ownKeys</code> Trap의 기본 동작은 <code>Reflect.ownKeys()</code> 메서드에 의해 구현되고 문자열과 <em>Symbol</em>을 포함한 모든 고유한 프로퍼티 키의 <em>Array</em>를 반환합니다. <code>Object.getOwnProperyNames()</code> 메서드 및 <code>Object.keys()</code> 메서드는 <em>Array</em>에서 <em>Symbol</em>을 필터링하고 결과를 반환하며 <code>Object.getOwnPropertySymbols()</code>는 <em>Array</em>에서 문자열을 필터링하여 결과를 반환합니다. <code>Object.assign()</code> 메서드는 문자열과 <em>Symbol</em>이 모두 포함된 <em>Array</em>를 사용합니다.</p>
<p><code>ownKeys</code> Trap은 대상을 하나의 파라미터로 받고, 항상 <em>Array</em>이나 유사 <em>Array</em>와 같은 객체를 반환해야합니다; 그렇지 않으면 오류가 발생합니다. <code>OwnKeys</code> Trap을 사용하면, 예를 들어, <code>Object.getOwnPropertyNames()</code>, <code>Object.getOwnPropertySymbols()</code>, <code>Object.getOwnPropertyNames()</code>, 또는 <code>Object.assign()</code> 메서드가 사용됩니다. JavaScript에서 필드가 비공개임을 나타내는 일반적인 표기법인 밑줄 문자(underscore)로 시작하는 프로퍼티 이름은 포함하지 않으려는 경우로 가정하여 <code>ownKeys</code> Trap을 사용하여 다음과 같이 키를 걸러낼 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</div><div class="line">    ownKeys(trapTarget) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.ownKeys(trapTarget).filter(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">typeof</span> key !== <span class="string">"string"</span> || key[<span class="number">0</span>] !== <span class="string">"_"</span>;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">let</span> nameSymbol = <span class="built_in">Symbol</span>(<span class="string">"name"</span>);</div><div class="line"></div><div class="line">proxy.name = <span class="string">"proxy"</span>;</div><div class="line">proxy._name = <span class="string">"private"</span>;</div><div class="line">proxy[nameSymbol] = <span class="string">"symbol"</span>;</div><div class="line"></div><div class="line"><span class="keyword">let</span> names = <span class="built_in">Object</span>.getOwnPropertyNames(proxy),</div><div class="line">    keys = <span class="built_in">Object</span>.keys(proxy);</div><div class="line">    symbols = <span class="built_in">Object</span>.getOwnPropertySymbols(proxy);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(names.length);      <span class="comment">// 1</span></div><div class="line"><span class="built_in">console</span>.log(names[<span class="number">0</span>]);          <span class="comment">// "name"</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(keys.length);      <span class="comment">// 1</span></div><div class="line"><span class="built_in">console</span>.log(keys[<span class="number">0</span>]);          <span class="comment">// "name"</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(symbols.length);    <span class="comment">// 1</span></div><div class="line"><span class="built_in">console</span>.log(symbols[<span class="number">0</span>]);        <span class="comment">// "Symbol(name)"</span></div></pre></td></tr></table></figure>
<p>이 예제는 <code>Reflect.ownKeys()</code>를 먼저 호출하여 대상의 기본 리스트를 얻는 <code>ownKeys</code> Trap을 사용합니다. 그런 다음 <code>filter()</code> 메서드는 문자열이며 밑줄 문자로 시작하는 키를 필터링하는데 사용됩니다. 그런 다음 <code>proxy</code> 객체에 세가지 프로퍼티가 추가됩니다.(<code>name</code>, <code>_name</code> 및 <code>nameSymbol</code>). <code>Object.getOwnPropertyNames()</code>와 <code>Object.keys()</code>가 <code>proxy</code>에서 호출되면 <code>name</code> 프로퍼티만 반환됩니다. 비슷하게 <code>Object.getOwnPropertySymbols()</code>가 <code>proxy</code>에서 호출될 때 <code>nameSymbol</code>만 반환됩니다. <code>_name</code> 프로퍼티는 필터링되어서 어느 결과에도 나타나지 않습니다.</p>
<blockquote>
<p><code>ownKeys</code> Trap은 또한 <code>for-in</code> 루프에 영향을 미칩니다.이 루프는 Trap을 호출하여 루프 내부에서 사용할 키를 결정합니다.</p>
</blockquote>
<h2 id="apply와-construct-Trap을-이용한-Function-프록시"><a href="#apply와-construct-Trap을-이용한-Function-프록시" class="headerlink" title="apply와 construct Trap을 이용한 Function 프록시"></a>apply와 construct Trap을 이용한 Function 프록시</h2><p>모든 프록시 Trap 중, <code>apply</code>와 <code>construct</code>만이 프록시 대상으로 함수가 필요합니다. 3장에서 함수는 각각 <code>new</code> 연산자를 사용하지 않고 함수를 호출할 때 실행되는 <code>[[Call]]</code> 및 <code>[[Construct]]</code>라는 두가지 내부 메서드를 가지고 있음을 설명했습니다. <code>apply</code> 및 <code>construct</code> Trap은 해당 내부 메서드를 재정의 하도록합니다. 함수가 <code>new</code> 없이 호출되면, <code>apply</code> Trap은 <code>Reflect.apply()</code>에 다음 파라미터가 필요합니다.</p>
<ol>
<li><code>trapTarget</code> - 실행중인 함수 (프록시의 대상)</li>
<li><code>thisArg</code> - 호출 중 함수 안에있는 <code>this</code>의 값</li>
<li><code>argumentsList</code> - 함수에게 건네진 파라미터 <em>Array</em></li>
</ol>
<p><code>new</code>를 사용하여 함수가 실행될 때 호출되는 <code>construct</code> Trap은 다음 파라미터를 받습니다.</p>
<ol>
<li><code>trapTarget</code> - 실행중인 함수 (프록시의 대상)</li>
<li><code>argumentsList</code> - 함수에게 건네진 파라미터 <em>Array</em></li>
</ol>
<p><code>Reflect.construct()</code> 메서드는 또한 이 두개의 파라미터를 받아들이며 <code>newTarget</code>이라는 선택적인 세 번째 파라미터를 받습니다. 주어진 경우, <code>newTarget</code> 파라미터는 함수 안에 <code>new.target</code>의 값을 지정합니다.</p>
<p><code>apply</code>와<code>construct</code> Trap은 모든 프록시 대상 함수의 동작을 완벽하게 제어합니다. 함수의 기본 동작을 모방하려면 다음과 같이 하면됩니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> target = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">42</span> &#125;,</div><div class="line">    proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</div><div class="line">        <span class="attr">apply</span>: <span class="function"><span class="keyword">function</span>(<span class="params">trapTarget, thisArg, argumentList</span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="built_in">Reflect</span>.apply(trapTarget, thisArg, argumentList);</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">construct</span>: <span class="function"><span class="keyword">function</span>(<span class="params">trapTarget, argumentList</span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="built_in">Reflect</span>.construct(trapTarget, argumentList);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line"><span class="comment">// 함수를 대상으로하는 프록시는 함수처럼 보입니다.</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> proxy);                  <span class="comment">// "function"</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(proxy());                       <span class="comment">// 42</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> proxy();</div><div class="line"><span class="built_in">console</span>.log(instance <span class="keyword">instanceof</span> proxy);     <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(instance <span class="keyword">instanceof</span> target);    <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>이 예제에서 숫자 42를 반환하는 함수를 가지고 있습니다. 이 함수의 프록시는 <code>apply</code>와 <code>construct</code> Trap을 사용하여 그 동작을 각각 <code>Reflect.apply()</code>와 <code>Reflect.construct()</code> 메서드에 위임합니다. 결과적으로 프록시 함수는 <code>typeof</code>가 사용될 때 함수로 자신을 식별하는 것을 포함하여 대상 함수와 똑같이 동작합니다. 프록시는 42를 반환하기 위해 <code>new</code> 없이 호출합니다. 그리고 <code>new</code>를 호출하여 <code>instance</code>라는 객체를 만듭니다. <code>instance</code> 객체는 프로토 타입 체인을 사용하여 이 정보를 결정하기 때문에 <code>proxy</code>와 <code>target</code>의 인스턴스로 간주됩니다. 프로토 타입 체인 조회는 이 프록시의 영향을 받지 않으므로 프록시와 대상이 JavaScript 엔진과 동일한 프로토 타입을 사용하는 것으로 보여집니다.</p>
<h3 id="함수-파라미터-유효성-검사"><a href="#함수-파라미터-유효성-검사" class="headerlink" title="함수 파라미터 유효성 검사"></a>함수 파라미터 유효성 검사</h3><p><code>apply</code>와 <code>construct</code> Trap은 함수가 실행되는 방식을 변경하는 많은 가능성을 열어줍니다. 예를 들어 모든 파라미터가 특정 타입인지 확인하려고 한다고 가정해 보겠습니다. <code>apply</code> Trap에서 파라미터를 확인할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 모든 파라미터를 더합니다.</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">...values</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> values.reduce(<span class="function">(<span class="params">previous, current</span>) =&gt;</span> previous + current, <span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> sumProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(sum, &#123;</div><div class="line">        <span class="attr">apply</span>: <span class="function"><span class="keyword">function</span>(<span class="params">trapTarget, thisArg, argumentList</span>) </span>&#123;</div><div class="line"></div><div class="line">            argumentList.forEach(<span class="function">(<span class="params">arg</span>) =&gt;</span> &#123;</div><div class="line">                <span class="keyword">if</span> (<span class="keyword">typeof</span> arg !== <span class="string">"number"</span>) &#123;</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"All arguments must be numbers."</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line"></div><div class="line">            <span class="keyword">return</span> <span class="built_in">Reflect</span>.apply(trapTarget, thisArg, argumentList);</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">construct</span>: <span class="function"><span class="keyword">function</span>(<span class="params">trapTarget, argumentList</span>) </span>&#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"This function can't be called with new."</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(sumProxy(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>));          <span class="comment">// 10</span></div><div class="line"></div><div class="line"><span class="comment">// error를 발생시킵니다.</span></div><div class="line"><span class="built_in">console</span>.log(sumProxy(<span class="number">1</span>, <span class="string">"2"</span>, <span class="number">3</span>, <span class="number">4</span>));</div><div class="line"></div><div class="line"><span class="comment">// 역시 error를 발생시킵니다.</span></div><div class="line"><span class="keyword">let</span> result = <span class="keyword">new</span> sumProxy();</div></pre></td></tr></table></figure>
<p>이 예제는 <code>apply</code> Trap을 사용하여 모든 파라미터가 숫자임을 확인합니다. <code>sum()</code> 함수는 전달된 모든 파라미터를 더합니다. 숫자가 아닌 값이 전달되면 이 함수는 계속 작업을 시도하므로 예기치 않은 결과가 발생할 수 있습니다. <code>sum()</code>을 <code>sumProxy()</code> 프록시 안에 넣음으로써 이 코드는 함수 호출을 가로 채고 호출이 진행되기 전에 각 파라미터가 숫자인지 확인합니다. 안전을 위해, 코드는 <code>construct</code> Trap을 사용하여 <code>new</code> 함수를 호출할 수 없도록합니다.</p>
<p>함수를 <code>new</code>로 호출하고 파라미터가 숫자인지 확인해야합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Numbers</span>(<span class="params">...values</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.values = values;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> NumbersProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(Numbers, &#123;</div><div class="line"></div><div class="line">        <span class="attr">apply</span>: <span class="function"><span class="keyword">function</span>(<span class="params">trapTarget, thisArg, argumentList</span>) </span>&#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"This function must be called with new."</span>);</div><div class="line">        &#125;,</div><div class="line"></div><div class="line">        <span class="attr">construct</span>: <span class="function"><span class="keyword">function</span>(<span class="params">trapTarget, argumentList</span>) </span>&#123;</div><div class="line">            argumentList.forEach(<span class="function">(<span class="params">arg</span>) =&gt;</span> &#123;</div><div class="line">                <span class="keyword">if</span> (<span class="keyword">typeof</span> arg !== <span class="string">"number"</span>) &#123;</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"All arguments must be numbers."</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line"></div><div class="line">            <span class="keyword">return</span> <span class="built_in">Reflect</span>.construct(trapTarget, argumentList);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> NumbersProxy(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</div><div class="line"><span class="built_in">console</span>.log(instance.values);               <span class="comment">// [1,2,3,4]</span></div><div class="line"></div><div class="line"><span class="comment">// throws error</span></div><div class="line">NumbersProxy(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</div></pre></td></tr></table></figure>
<p>여기서 <code>construct</code> Trap이 <code>Reflect.construct()</code> 메서드를 사용하여 입력값을 검증하고 새로운 인스턴스를 리턴할 때 <code>apply</code> Trap은 오류를 던집니다. 물론, 대신에 <code>new.target</code>을 사용하여 프록시없이 동일한 것을 수행할 수 있습니다.</p>
<h3 id="new가-없는-생성자-호출"><a href="#new가-없는-생성자-호출" class="headerlink" title="new가 없는 생성자 호출"></a><code>new</code>가 없는 생성자 호출</h3><p>3 장에서 <code>new.target</code> 메타 프로퍼티를 소개했습니다. <code>new.target</code>은 <code>new</code>가 호출되는 함수에 대한 참조입니다. 즉, <code>new.target</code>의 값을 다음과 같이 검사하여 <code>new</code>를 사용하여 함수를 호출했는지 여부를 알 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Numbers</span>(<span class="params">...values</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">new</span>.target === <span class="string">"undefined"</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"This function must be called with new."</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.values = values;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> Numbers(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</div><div class="line"><span class="built_in">console</span>.log(instance.values);               <span class="comment">// [1,2,3,4]</span></div><div class="line"></div><div class="line"><span class="comment">// throws error</span></div><div class="line">Numbers(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</div></pre></td></tr></table></figure>
<p>이 예제는 “함수 파라미터 유효성 검사” 섹션의 프록시를 사용하지 않는 예제와 유사하며, <code>new</code>를 사용하지 않고 <code>Numbers</code>가 호출될 때 에러를 던집니다. 유일한 목적이 <code>new</code>없이 함수를 호출하는 것을 방지하는 것이라면 이와 같은 코드를 작성하는 것은 프록시를 사용하는 것보다 훨씬 간단하며 바람직합니다. 그러나 때로는 동작을 수정해야하는 함수를 제어하지 못하는 경우가 있습니다. 이 경우 프록시를 사용하는 것이 좋습니다.</p>
<p><code>Numbers</code> 함수가 수정할 수 없는 코드에 정의되었다고 가정해 보겠습니다. 이 코드는 <code>new.target</code>에 의존하고 있으며 여전히 함수를 호출할 때 체크를 피하기를 원합니다. <code>new</code>를 사용할 때의 동작은 이미 설정되어 있으므로 <code>apply</code> Trap을 사용할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Numbers</span>(<span class="params">...values</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">new</span>.target === <span class="string">"undefined"</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"This function must be called with new."</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.values = values;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">let</span> NumbersProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(Numbers, &#123;</div><div class="line">        <span class="attr">apply</span>: <span class="function"><span class="keyword">function</span>(<span class="params">trapTarget, thisArg, argumentsList</span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="built_in">Reflect</span>.construct(trapTarget, argumentsList);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">let</span> instance = NumbersProxy(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</div><div class="line"><span class="built_in">console</span>.log(instance.values);               <span class="comment">// [1,2,3,4]</span></div></pre></td></tr></table></figure>
<p><code>NumbersProxy</code> 함수는 <code>new</code>를 사용하지 않고 <code>Numbers</code>를 호출하고 <code>new</code>가 사용된 것처럼 행동하게합니다. 그렇게하기 위해, <code>apply</code> Trap은 <code>Reflect.construct()</code>를 호출하고 <code>apply</code>에 전달된 파라미터를 사용합니다. <code>Numbers</code> 내부의 <code>new.target</code>은 <code>Numbers</code> 자체와 동일하며 에러는 발생하지 않습니다. 이것은 <code>new.target</code>을 변경하는 간단한 예제이지만, 더 직접적으로 할 수도 있습니다.</p>
<h3 id="추상-기본-클래스-생성자-Abstract-Base-Class-Constructor-재정의"><a href="#추상-기본-클래스-생성자-Abstract-Base-Class-Constructor-재정의" class="headerlink" title="추상 기본 클래스 생성자 (Abstract Base Class Constructor) 재정의"></a>추상 기본 클래스 생성자 (Abstract Base Class Constructor) 재정의</h3><p>한 걸음 더 나아가 <code>new.target</code>에 할당할 특정 값으로 <code>Reflect.construct()</code>의 세 번째 파라미터를 지정할 수 있습니다. 이는 함수가 추상 기본 클래스 생성자를 생성할 때(9 장에서 설명)와 같이 알려진 값에 대해 <code>new.target</code>을 검사할 때 유용합니다. 추상 기본 클래스 생성자에서, <code>new.target</code>은 이 예제에서와 같이 클래스 생성자 그 자체가 아닌 다른 것으로 예상됩니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractNumbers</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">constructor</span>(...values) &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">new</span>.target === AbstractNumbers) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"This function must be inherited from."</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.values = values;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Numbers</span> <span class="keyword">extends</span> <span class="title">AbstractNumbers</span> </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> Numbers(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</div><div class="line"><span class="built_in">console</span>.log(instance.values);           <span class="comment">// [1,2,3,4]</span></div><div class="line"></div><div class="line"><span class="comment">// throws error</span></div><div class="line"><span class="keyword">new</span> AbstractNumbers(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</div></pre></td></tr></table></figure>
<p><code>new AbstractNumbers()</code>가 호출되면, <code>new.target</code>은 <code>AbstractNumbers</code>와 같기 때문에 에러를 발생 시킵니다. <code>new.target</code>이 <code>Numbers</code>와 같기 때문에 <code>new Numbers()</code>는 여전히 작동합니다. 수동으로 <code>new.target</code>에 프록시를 할당함으로써 이 제약을 우회할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractNumbers</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">constructor</span>(...values) &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">new</span>.target === AbstractNumbers) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"This function must be inherited from."</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.values = values;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> AbstractNumbersProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(AbstractNumbers, &#123;</div><div class="line">        <span class="attr">construct</span>: <span class="function"><span class="keyword">function</span>(<span class="params">trapTarget, argumentList</span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="built_in">Reflect</span>.construct(trapTarget, argumentList, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> AbstractNumbersProxy(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</div><div class="line"><span class="built_in">console</span>.log(instance.values);               <span class="comment">// [1,2,3,4]</span></div></pre></td></tr></table></figure>
<p><code>AbstractNumbersProxy</code>는 <code>construct</code> Trap을 사용하여 <code>new AbstractNumbersProxy()</code> 메서드에 대한 호출을 가로챕니다. 그런 다음, <code>Reflect.construct()</code> 메서드가 Trap의 파라미터와 함께 호출되고 빈 함수를 세 번째 파라미터로 추가합니다. 그 빈 함수는 생성자 내부의 <code>new.target</code>의 값으로 사용됩니다. <code>new.target</code>이 <code>AbstractNumbers</code>와 같지 않기 때문에 오류가 발생하지 않고 생성자가 완전히 실행됩니다.</p>
<h3 id="호출가능한-클래스-생성자"><a href="#호출가능한-클래스-생성자" class="headerlink" title="호출가능한 클래스 생성자"></a>호출가능한 클래스 생성자</h3><p>9 장에서는 클래스 생성자가 항상 <code>new</code>로 호출되어야 한다고 설명했다. 이는 클래스 생성자에 대한 내부 <code>[[Call]]</code> 메서드가 오류를 throw 하도록 지정 되었기 때문에 발생합니다. 그러나 프록시는 <code>[[Call]]</code> 메서드에 대한 호출을 가로챌 수 있습니다. 즉, 프록시를 사용하여 호출 가능한 클래스 생성자를 효과적으로 만들 수 있습니다. 예를 들어, 클래스 생성자가 <code>new</code>를 사용하지 않고 동작하게 하려면, <code>apply</code> Trap을 사용하여 새로운 인스턴스를 생성 할 수 있습니다. 다음은 몇 가지 샘플 코드입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(name) &#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> PersonProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(Person, &#123;</div><div class="line">        <span class="attr">apply</span>: <span class="function"><span class="keyword">function</span>(<span class="params">trapTarget, thisArg, argumentList</span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> trapTarget(...argumentList);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">let</span> me = PersonProxy(<span class="string">"Nicholas"</span>);</div><div class="line"><span class="built_in">console</span>.log(me.name);                   <span class="comment">// "Nicholas"</span></div><div class="line"><span class="built_in">console</span>.log(me <span class="keyword">instanceof</span> Person);      <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(me <span class="keyword">instanceof</span> PersonProxy); <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p><code>PersonProxy</code> 객체는 <code>Person</code> 클래스 생성자의 프록시입니다. 클래스 생성자는 단지 함수이므로 프록시에서 사용될 때 함수처럼 작동합니다. <code>apply</code> Trap은 기본 동작을 재정의하고 대신 <code>Person</code>과 같은 <code>trapTarget</code>의 새로운 인스턴스를 반환합니다(이 예제에서 <code>trapTarget</code>을 사용하여 클래스를 수동으로 지정하지 않아도 된다는 것을 보여주기 위해 사용했습니다). <code>argumentList</code>는 <em>Spread</em> 연산자를 사용하여 각 파라미터가 개별적으로trapTarget<code>에 전달됩니다.</code>new<code>를 사용하지 않고</code>PersonProxy()<code>를 호출하면</code>Person<code>의 인스턴스를 반환합니다(</code>new<code>없이</code>Person()`을 호출하려고 하면 생성자는 여전히 오류를 던질 것입니다). 호출 가능한 클래스 생성자를 만드는 것은 프록시를 사용하는 경우에만 가능합니다.</p>
<h2 id="취소-가능한-프록시"><a href="#취소-가능한-프록시" class="headerlink" title="취소 가능한 프록시"></a>취소 가능한 프록시</h2><p>일반적으로 프록시가 생성되면 프록시는 대상에서 재배치할 수 없습니다. 이장의 모든 예제는 재배치할 수 없는 프록시를 사용했습니다. 그러나 더이상 사용할 수 없도록 프록시를 취소하려는 경우가 있을 수 있습니다. 보안을 위해 API를 통해 객체를 제공하고 언제든지 일부 기능에 대한 액세스를 차단할 수 있는 기능을 유지하려는 경우 프록시를 해지하는 것이 유용합니다.</p>
<p><code>Proxy.revocable()</code> 메서드로 취소 가능한 프록시를 생성할 수 있습니다. 이 메서드는 대상 객체와 프록시 핸들러인 <code>Proxy</code> 생성자와 같은 파라미터를 사용합니다. 반환 값은 다음과 같은 프로퍼티를 가진 객체입니다.</p>
<ol>
<li><code>proxy</code> - 취소할 수 있는 프록시 객체</li>
<li><code>revoke</code> - 프록시를 취소하기 위해서 호출하는 함수</li>
</ol>
<p><code>revoke()</code> 함수가 호출될 때, <code>proxy</code>를 통해 더 이상의 연산을 수행할 수 없습니다. 프록시 Trap을 발생시키는 방식으로 프록시 오브젝트와 상호 작용하려는 모든 시도는 오류를 발생시킵니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> target = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">"target"</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> &#123; proxy, revoke &#125; = <span class="built_in">Proxy</span>.revocable(target, &#123;&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(proxy.name);        <span class="comment">// "target"</span></div><div class="line"></div><div class="line">revoke();</div><div class="line"></div><div class="line"><span class="comment">// error 발생</span></div><div class="line"><span class="built_in">console</span>.log(proxy.name);</div></pre></td></tr></table></figure>
<p>이 예제는 취소 가능한 프록시를 만듭니다. <code>Proxy.revocable()</code> 메서드에 의해 반환된 객체에서 같은 이름의 프로퍼티에 <code>proxy</code>와 <code>revoke</code> 변수를 할당하기 위해 <em>Destructuring</em>을 사용합니다. 그 후, <code>proxy</code> 객체는 취소가 불가능한(nonrevocable) 프록시 객체처럼 사용될 수 있습니다. 그래서 <code>proxy.name</code>은 <code>target.name</code>을 그대로 통과하기 때문에 <code>&quot;target&quot;</code>을 리턴합니다. 그러나 일단 <code>revoke()</code> 함수가 호출되면, 프록시는 더이상 함수가 아닙니다. <code>proxy.name</code>에 접근하려고 시도하면 에러가 발생하고, 프록시에서 Trap을 발생시키는 다른 동작도 마찬가지입니다.</p>
<h2 id="Array의-문제점-해결하기"><a href="#Array의-문제점-해결하기" class="headerlink" title="Array의 문제점 해결하기"></a>Array의 문제점 해결하기</h2><p>이장의 시작 부분에서 개발자가 ECMAScript 6 이전의 JavaScript에서 <em>Array</em>의 동작을 정확하게 모방할 수 없다는 것을 설명했습니다. 프록시와 리플렉션 API를 사용하면 프로퍼티가 추가되고 제거될 때 <em>Built-in</em> <code>Array</code> 타입과 같은 방식으로 동작하는 객체를 생성할 수 있습니다. 기억을 되새겨 아래 예제는 프록시가 <em>Array</em>를 모방하는데 도움이되는 동작을 보여주는 예입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> colors = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>];</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(colors.length);         <span class="comment">// 3</span></div><div class="line"></div><div class="line">colors[<span class="number">3</span>] = <span class="string">"black"</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(colors.length);         <span class="comment">// 4</span></div><div class="line"><span class="built_in">console</span>.log(colors[<span class="number">3</span>]);             <span class="comment">// "black"</span></div><div class="line"></div><div class="line">colors.length = <span class="number">2</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(colors.length);         <span class="comment">// 2</span></div><div class="line"><span class="built_in">console</span>.log(colors[<span class="number">3</span>]);             <span class="comment">// undefined</span></div><div class="line"><span class="built_in">console</span>.log(colors[<span class="number">2</span>]);             <span class="comment">// undefined</span></div><div class="line"><span class="built_in">console</span>.log(colors[<span class="number">1</span>]);             <span class="comment">// "green"</span></div></pre></td></tr></table></figure>
<p>위 예제에서 주의해야할 두가지 중요한 동작이 있습니다.</p>
<ol>
<li><code>colors[3]</code>에 값이 할당되면 <code>length</code> 프로퍼티가 4로 증가합니다.</li>
<li><code>length</code> 프로퍼티가 2로 설정되면 <em>Array</em>의 마지막 두 항목이 삭제됩니다.</li>
</ol>
<p>이 두가지 동작은 <em>Built-in Array</em>의 작동 방식을 정확하게 재현하기 위해 모방되어야하는 중요한 동작입니다. 다음 몇 섹션에서는 올바르게 <em>Array</em> 객체를 모방하는 방법을 설명합니다.</p>
<h3 id="Array-색인-찾기"><a href="#Array-색인-찾기" class="headerlink" title="Array 색인 찾기"></a>Array 색인 찾기</h3><p>정수형 프로퍼티 키에 할당하는 것은 비 정수형 키와 다르게 취급되는 <em>Array</em>의 특별한 경우입니다. ECMAScript 6 사양에서는 프로퍼티 키가 <em>Array</em> 인덱스인지 확인하는 방법에 대한 지침을 제공합니다.</p>
<blockquote>
<p><code>toString(ToUint32(P))</code>이 <code>P</code>이고 <code>ToUint32(P)</code>가 <code>2 ^ 32-1</code>이 아니면 String 프로퍼티 이름 <code>P</code>는 <em>Array</em> 인덱스입니다.</p>
</blockquote>
<p>이  연산자는 다음과 같이 JavaScript로 구현될 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">toUint32</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.abs(<span class="built_in">Number</span>(value))) % <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">32</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArrayIndex</span>(<span class="params">key</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> numericKey = toUint32(key);</div><div class="line">    <span class="keyword">return</span> <span class="built_in">String</span>(numericKey) == key &amp;&amp; numericKey &lt; (<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">32</span>) - <span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>toUint32()</code> 함수는 사양에 설명된 알고리즘을 사용하여 주어진 값을 부호없는 32비트 정수로 변환합니다. <code>isArrayIndex()</code> 함수는 먼저 키를 uint32로 변환한 다음 비교를 수행하여 키가 <em>Array</em> 인덱스인지 여부를 확인합니다. 이러한 유틸리티 함수를 사용할 수 있으면 <em>Built-in Array</em>를 모방할 객체를 구현할 수 있습니다.</p>
<h3 id="새로운-요소를-추가할-때-length-증가"><a href="#새로운-요소를-추가할-때-length-증가" class="headerlink" title="새로운 요소를 추가할 때 length 증가"></a>새로운 요소를 추가할 때 <code>length</code> 증가</h3><p>설명한 두<em>Array</em>의 동작이 프로퍼티 할당에 의존한다는 것을 눈치 챘을 것입니다. 즉, 두가지 동작을 모두 수행하려면 <code>set</code> 프록시 Trap을 사용해야합니다. 먼저 <code>length-1</code>보다 큰 <em>Array</em> 인덱스가 사용되면 <code>length</code> 프로퍼티를 증가시켜 첫 번째 두가지 동작을 구현하는 예제를 보겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">toUint32</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.abs(<span class="built_in">Number</span>(value))) % <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">32</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArrayIndex</span>(<span class="params">key</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> numericKey = toUint32(key);</div><div class="line">    <span class="keyword">return</span> <span class="built_in">String</span>(numericKey) == key &amp;&amp; numericKey &lt; (<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">32</span>) - <span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createMyArray</span>(<span class="params">length=<span class="number">0</span></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123; length &#125;, &#123;</div><div class="line">        set(trapTarget, key, value) &#123;</div><div class="line"></div><div class="line">            <span class="keyword">let</span> currentLength = <span class="built_in">Reflect</span>.get(trapTarget, <span class="string">"length"</span>);</div><div class="line"></div><div class="line">            <span class="comment">// the special case</span></div><div class="line">            <span class="keyword">if</span> (isArrayIndex(key)) &#123;</div><div class="line">                <span class="keyword">let</span> numericKey = <span class="built_in">Number</span>(key);</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (numericKey &gt;= currentLength) &#123;</div><div class="line">                    <span class="built_in">Reflect</span>.set(trapTarget, <span class="string">"length"</span>, numericKey + <span class="number">1</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// always do this regardless of key type</span></div><div class="line">            <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(trapTarget, key, value);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> colors = createMyArray(<span class="number">3</span>);</div><div class="line"><span class="built_in">console</span>.log(colors.length);         <span class="comment">// 3</span></div><div class="line"></div><div class="line">colors[<span class="number">0</span>] = <span class="string">"red"</span>;</div><div class="line">colors[<span class="number">1</span>] = <span class="string">"green"</span>;</div><div class="line">colors[<span class="number">2</span>] = <span class="string">"blue"</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(colors.length);         <span class="comment">// 3</span></div><div class="line"></div><div class="line">colors[<span class="number">3</span>] = <span class="string">"black"</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(colors.length);         <span class="comment">// 4</span></div><div class="line"><span class="built_in">console</span>.log(colors[<span class="number">3</span>]);             <span class="comment">// "black"</span></div></pre></td></tr></table></figure>
<p>이 예제는 <code>set</code> 프록시 Trap을 사용하여 <em>Array</em> 인덱스의 설정을 가로챕니다. 키가 <em>Array</em> 인덱스인 경우 키는 항상 문자열로 전달되기 때문에 숫자로 변환됩니다. 그 숫자 값이 현재 <code>length</code> 프로퍼티보다 크거나 같으면 <code>length</code> 프로퍼티가 숫자 키보다 하나 더 업데이트됩니다 (위치 3의 항목 설정은 <code>length</code>가 4 여야 함을 의미합니다). 그 후에 프로퍼티를 설정하기위한 기본 동작은 <code>Reflect.set()</code>를 통해 사용됩니다. 프로퍼티가 지정된 값을 받기를 원하기 때문입니다.</p>
<p>최초의 커스텀 <em>Array</em>는 <code>length</code>가 3인 <code>createMyArray()</code>를 호출하여 생성되며, 그 세항목의 값은 바로 뒤에 추가됩니다. <code>length</code> 프로퍼티는 3번 위치에 <code>&quot;black&quot;</code>값이 할당될 때까지 정확히 3을 유지합니다. 그 시점에서 <code>length</code>는 4로 설정됩니다.</p>
<p>첫번째 동작이 작동하면 두 번째 동작으로 이동할 시간입니다.</p>
<h3 id="length-줄이기에-대한-요소-삭제"><a href="#length-줄이기에-대한-요소-삭제" class="headerlink" title="length 줄이기에 대한 요소 삭제"></a>length 줄이기에 대한 요소 삭제</h3><p>모방을 위한 첫 번째 <em>Array</em> 동작은 <em>Array</em> 인덱스가 <code>length</code> 프로퍼티보다 크거나 같은 경우에만 사용됩니다. 두 번째 동작은 <code>length</code>  프로퍼티가 이전에 포함된 값보다 작은 값으로 설정되면 값을 줄이고 남은 <em>Array</em> 항목을 제거합니다. 이는 <code>length</code> 프로퍼티를 변경하는 것뿐만 아니라 존재하지 않는 모든 항목을 삭제하는 것을 포함합니다. 예를 들어, <code>length</code>가 4인 <em>Array</em>가 <code>length</code>를 2로 설정하면, 2와 3 위치의 항목은 삭제됩니다. 첫 번째 동작과 함께 <code>set</code> 프록시 Trap에서 이것을 수행 할 수 있습니다. 아래 예제는 앞의 예제를 업데이트한<code>createMyArray</code> 메서드 입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">toUint32</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.abs(<span class="built_in">Number</span>(value))) % <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">32</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArrayIndex</span>(<span class="params">key</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> numericKey = toUint32(key);</div><div class="line">    <span class="keyword">return</span> <span class="built_in">String</span>(numericKey) == key &amp;&amp; numericKey &lt; (<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">32</span>) - <span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createMyArray</span>(<span class="params">length=<span class="number">0</span></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123; length &#125;, &#123;</div><div class="line">        set(trapTarget, key, value) &#123;</div><div class="line"></div><div class="line">            <span class="keyword">let</span> currentLength = <span class="built_in">Reflect</span>.get(trapTarget, <span class="string">"length"</span>);</div><div class="line"></div><div class="line">            <span class="comment">// the special case</span></div><div class="line">            <span class="keyword">if</span> (isArrayIndex(key)) &#123;</div><div class="line">                <span class="keyword">let</span> numericKey = <span class="built_in">Number</span>(key);</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (numericKey &gt;= currentLength) &#123;</div><div class="line">                    <span class="built_in">Reflect</span>.set(trapTarget, <span class="string">"length"</span>, numericKey + <span class="number">1</span>);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key === <span class="string">"length"</span>) &#123;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (value &lt; currentLength) &#123;</div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">let</span> index = currentLength - <span class="number">1</span>; index &gt;= value; index\</div><div class="line">--) &#123;</div><div class="line">                        <span class="built_in">Reflect</span>.deleteProperty(trapTarget, index);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 항상 키 타입에 관계없이 이 작업을 수행합니다.</span></div><div class="line">            <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(trapTarget, key, value);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> colors = createMyArray(<span class="number">3</span>);</div><div class="line"><span class="built_in">console</span>.log(colors.length);         <span class="comment">// 3</span></div><div class="line"></div><div class="line">colors[<span class="number">0</span>] = <span class="string">"red"</span>;</div><div class="line">colors[<span class="number">1</span>] = <span class="string">"green"</span>;</div><div class="line">colors[<span class="number">2</span>] = <span class="string">"blue"</span>;</div><div class="line">colors[<span class="number">3</span>] = <span class="string">"black"</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(colors.length);         <span class="comment">// 4</span></div><div class="line"></div><div class="line">colors.length = <span class="number">2</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(colors.length);         <span class="comment">// 2</span></div><div class="line"><span class="built_in">console</span>.log(colors[<span class="number">3</span>]);             <span class="comment">// undefined</span></div><div class="line"><span class="built_in">console</span>.log(colors[<span class="number">2</span>]);             <span class="comment">// undefined</span></div><div class="line"><span class="built_in">console</span>.log(colors[<span class="number">1</span>]);             <span class="comment">// "green"</span></div><div class="line"><span class="built_in">console</span>.log(colors[<span class="number">0</span>]);             <span class="comment">// "red"</span></div></pre></td></tr></table></figure>
<p>이 코드의 <code>set</code> 프록시 Trap은 나머지 객체를 정확하게 조정하기 위해 <code>key</code>가 <code>&quot;length&quot;</code>인지를 검사합니다. 이 경우 현재 <code>length</code>가<br> <code>Reflect.get()</code>을 사용하여 먼저 검색되고 새 값과 비교됩니다. 새로운 값이 현재 <code>length</code>보다 작으면 <code>for</code> 루프는 더이상 사용할 수 없는 대상의 모든 프로퍼티를 삭제합니다. <code>for</code> 루프는 현재 <em>Array</em>의 크기(currentLength)에서 뒤로 이동하고 새로운 <em>Array</em> 크기(value)에 도달할 때까지 각 프로퍼티를 삭제합니다.</p>
<p>이 예제는 네가지 색상을 <code>colors</code>에 추가한 다음 <code>length</code> 프로퍼티를 2로 설정합니다. 이렇게 하면 위치 2와 3의 항목을 효과적으로 제거하므로 액세스하려고할 때 <code>undefined</code>를 반환합니다. <code>length</code> 프로퍼티는 정확하게 2로 설정되고 위치 0과 1의 아이템은 여전히 접근 가능합니다.</p>
<p>두가지 동작을 모두 구현하면 <em>Built-in Array</em>의 동작을 모방한 객체를 쉽게 만들수 있습니다. 그러나 함수를 사용하여 이렇게하는 것은 이 동작을 캡슐화하는 클래스를 만드는 것보다 바람직하지 않습니다. 따라서 다음 단계는 이 함수를 클래스로 구현하는 것입니다.</p>
<h3 id="MyArray-클래스-구현"><a href="#MyArray-클래스-구현" class="headerlink" title="MyArray 클래스 구현"></a>MyArray 클래스 구현</h3><p>프록시를 사용하는 클래스를 만드는 가장 간단한 방법은 클래스를 평소대로 정의한 다음 생성자에서 프록시를 반환하는 것입니다. 이렇게하면 클래스가 인스턴스화될 때 반환되는 객체는 인스턴스가 아닌 프록시가됩니다. (인스턴스는 생성자 내의 `this ‘값입니다.) 인스턴스는 프록시의 대상이되고 프록시는 인스턴스인 것처럼 반환됩니다. 인스턴스는 완전히 비공개이며 직접 액세스할 수는 없지만 프록시를 통해 간접적으로 액세스할 수 있습니다.</p>
<p>다음은 클래스 생성자에서 프록시를 반환하는 간단한 예입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thing</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(<span class="keyword">this</span>, &#123;&#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> myThing = <span class="keyword">new</span> Thing();</div><div class="line"><span class="built_in">console</span>.log(myThing <span class="keyword">instanceof</span> Thing);      <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>이 예제에서 <code>Thing</code> 클래스는 생성자에서 프록시를 반환합니다. 프록시 대상은 <code>this</code>이며 프록시는 생성자에서 반환됩니다. 즉, <code>Thing</code> 생성자를 호출하여 <code>myThing</code>을 만들었지만 실제로 <code>myThing</code>은 프록시입니다. 프록시는 자신의 동작을 대상에 전달하기 때문에 <code>myThing</code>은 여전히 <code>Thing</code> 클래스로 간주되며 프록시는 <code>Thing</code> 클래스를 사용하는 모든 사람에게 완전히 투명합니다.</p>
<p>이를 염두에두고 상대적으로 간단한 방식으로 프록시를 사용하여 맞춤 <em>Array</em> 클래스를 만듭니다. 코드는 “length 줄이기에 대한 요소 삭제”절의 코드와 거의 같습니다. 동일한 프록시 코드가 사용되지만 이번에는 클래스 생성자 내부에 있습니다. 전체 예제는 다음과 같습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">toUint32</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.abs(<span class="built_in">Number</span>(value))) % <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">32</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArrayIndex</span>(<span class="params">key</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> numericKey = toUint32(key);</div><div class="line">    <span class="keyword">return</span> <span class="built_in">String</span>(numericKey) == key &amp;&amp; numericKey &lt; (<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">32</span>) - <span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(length=0) &#123;</div><div class="line">        <span class="keyword">this</span>.length = length;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(<span class="keyword">this</span>, &#123;</div><div class="line">            set(trapTarget, key, value) &#123;</div><div class="line"></div><div class="line">                <span class="keyword">let</span> currentLength = <span class="built_in">Reflect</span>.get(trapTarget, <span class="string">"length"</span>);</div><div class="line"></div><div class="line">                <span class="comment">// the special case</span></div><div class="line">                <span class="keyword">if</span> (isArrayIndex(key)) &#123;</div><div class="line">                    <span class="keyword">let</span> numericKey = <span class="built_in">Number</span>(key);</div><div class="line"></div><div class="line">                    <span class="keyword">if</span> (numericKey &gt;= currentLength) &#123;</div><div class="line">                        <span class="built_in">Reflect</span>.set(trapTarget, <span class="string">"length"</span>, numericKey + <span class="number">1</span>);</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key === <span class="string">"length"</span>) &#123;</div><div class="line"></div><div class="line">                    <span class="keyword">if</span> (value &lt; currentLength) &#123;</div><div class="line">                        <span class="keyword">for</span> (<span class="keyword">let</span> index = currentLength - <span class="number">1</span>; index &gt;= value; i\</div><div class="line">ndex--) &#123;</div><div class="line">                            <span class="built_in">Reflect</span>.deleteProperty(trapTarget, index);</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="comment">// always do this regardless of key type</span></div><div class="line">                <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(trapTarget, key, value);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">let</span> colors = <span class="keyword">new</span> MyArray(<span class="number">3</span>);</div><div class="line"><span class="built_in">console</span>.log(colors <span class="keyword">instanceof</span> MyArray);     <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(colors.length);         <span class="comment">// 3</span></div><div class="line"></div><div class="line">colors[<span class="number">0</span>] = <span class="string">"red"</span>;</div><div class="line">colors[<span class="number">1</span>] = <span class="string">"green"</span>;</div><div class="line">colors[<span class="number">2</span>] = <span class="string">"blue"</span>;</div><div class="line">colors[<span class="number">3</span>] = <span class="string">"black"</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(colors.length);         <span class="comment">// 4</span></div><div class="line"></div><div class="line">colors.length = <span class="number">2</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(colors.length);         <span class="comment">// 2</span></div><div class="line"><span class="built_in">console</span>.log(colors[<span class="number">3</span>]);             <span class="comment">// undefined</span></div><div class="line"><span class="built_in">console</span>.log(colors[<span class="number">2</span>]);             <span class="comment">// undefined</span></div><div class="line"><span class="built_in">console</span>.log(colors[<span class="number">1</span>]);             <span class="comment">// "green"</span></div><div class="line"><span class="built_in">console</span>.log(colors[<span class="number">0</span>]);             <span class="comment">// "red"</span></div></pre></td></tr></table></figure>
<p>이 코드는 생성자에서 프록시를 반환하는 <code>MyArray</code> 클래스를 만듭니다. <code>length</code> 프로퍼티는 생성자에 추가되고 (전달된 값이나 기본값 0으로 초기화 됨) 프록시가 생성되어 반환됩니다. 이것은 <code>colors</code> 변수에 <code>MyArray</code>의 인스턴스를 대입하는 모양이 되며 <em>Array</em>의 주요 동작을 구현합니다.</p>
<p>클래스 생성자에서 프록시를 반환하는 것은 쉽지만 모든 인스턴스에 대해 새 프록시가 만들어 짐을 의미합니다. 그러나 모든 인스턴스가 하나의 프록시를 공유하는 방법이 있습니다. 프록시를 프로토 타입으로 사용할 수 있습니다.</p>
<h2 id="프로토-타입으로-프록시-사용"><a href="#프로토-타입으로-프록시-사용" class="headerlink" title="프로토 타입으로 프록시 사용"></a>프로토 타입으로 프록시 사용</h2><p>프록시는 프로토 타입으로 사용될 수 있지만, 이장의 앞의 예제보다 약간 복잡합니다. 프록시가 프로토 타입일 때, 프록시 Trap은 기본 동작이 정상적으로 프로토 타입에 계속될 때만 호출되며, 프록시의 기능을 프로토 타입으로 제한합니다. 다음 예제를 살펴 보겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> target = &#123;&#125;;</div><div class="line"><span class="keyword">let</span> newTarget = <span class="built_in">Object</span>.create(<span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</div><div class="line"></div><div class="line">    <span class="comment">// never called</span></div><div class="line">    defineProperty(trapTarget, name, descriptor) &#123;</div><div class="line"></div><div class="line">        <span class="comment">// would cause an error if called</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;));</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.defineProperty(newTarget, <span class="string">"name"</span>, &#123;</div><div class="line">    <span class="attr">value</span>: <span class="string">"newTarget"</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(newTarget.name);                    <span class="comment">// "newTarget"</span></div><div class="line"><span class="built_in">console</span>.log(newTarget.hasOwnProperty(<span class="string">"name"</span>));  <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p><code>newTarget</code> 객체는 프록시를 프로토 타입으로 하여 생성됩니다. <code>target</code>을 프록시 타겟으로 만들면 프록시가 투명하기 때문에 효과적으로 <code>target</code>을<code>newTarget</code>의 프로토 타입으로 만듭니다. 이제, 프록시 Trap은 <code>newTarget</code>에 대한 연산이 <code>target</code>에서 일어날 연산을 통과할 때만 호출됩니다.</p>
<p><code>Object.defineProperty()</code> 메서드는 <code>newTarget</code>에 호출되어 <code>name</code>이라는 자체 프로퍼티를 생성합니다. 객체상에 프로퍼티를 정의하는 것은 일반적으로 객체의 프로토 타입으로 계속되는 연산이 아니기 때문에 프록시상의 <code>defineProperty</code> Trap은 결코 호출되지 않고 <code>name</code> 프로퍼티는 자신의 프로퍼티로 <code>newTarget</code>에 추가됩니다.</p>
<p>프로토 타입으로 사용할 경우 프록시가 심각하게 제한되지만 여전히 유용한 몇가지 Trap이 있습니다.</p>
<h3 id="프로토-타입에서-get-Trap-사용하기"><a href="#프로토-타입에서-get-Trap-사용하기" class="headerlink" title="프로토 타입에서 get Trap 사용하기"></a>프로토 타입에서 get Trap 사용하기</h3><p>내부 <code>[[Get]]</code> 메서드가 호출되어 프로퍼티를 읽으면 연산은 먼저 자신의 프로퍼티를 찾습니다. 지정된 이름을 가진 자체 프로퍼티를 찾을 수 없는 경우 연산은 프로토 타입을 계속 진행하고 거기에서 프로퍼티를 찾습니다. 검사할 프로토 타입이 더이상 없을 때까지 프로세스가 계속됩니다.</p>
<p>이 프로세스 덕분에, <code>get</code> 프록시 Trap을 설정하면 주어진 이름의 자체 프로퍼티가 존재하지 않을 때마다 프로토 타입에서 Trap이 호출됩니다. <code>get</code> Trap을 사용하면 존재한다고 보장할 수 없는 프로퍼티에 액세스할 때 예기치 않은 동작을 방지할 수 있습니다. 단지 존재하지 않는 프로퍼티에 액세스하려고 할 때마다 오류가 발생하는 객체를 만들면 됩니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> target = &#123;&#125;;</div><div class="line"><span class="keyword">let</span> thing = <span class="built_in">Object</span>.create(<span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</div><div class="line">    get(trapTarget, key, receiver) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">ReferenceError</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span> doesn't exist`</span>);</div><div class="line">    &#125;</div><div class="line">&#125;));</div><div class="line"></div><div class="line">thing.name = <span class="string">"thing"</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(thing.name);        <span class="comment">// "thing"</span></div><div class="line"></div><div class="line"><span class="comment">// error 발생</span></div><div class="line"><span class="keyword">let</span> unknown = thing.unknown;</div></pre></td></tr></table></figure>
<p>이 코드에서, <code>thing</code> 객체는 프록시를 프로토 타입으로 하여 생성됩니다. <code>get</code> Trap은 주어진 키가 <code>thing</code> 객체에 존재하지 않은 호출에 대해 에러를 발생시킵니다. <code>thing.name</code>을 읽을 때, 프로퍼티가 <code>thing</code>에 존재하기 때문에 연산은 결코 프로토 타입에서 <code>get</code> Trap을 호출하지 않습니다. <code>get</code> Trap은 존재하지 않는 <code>thing.unknown</code> 프로퍼티에 접근할 때에만 호출됩니다.</p>
<p>마지막 줄이 실행될 때 <code>unknown</code>은 <code>thing</code>의 자체 속성이 아니므로 연산은 프로토 타입으로 계속됩니다. 그리고 <code>get</code> Trap은 오류를 던집니다. 이러한 유형의 동작은 JavaScript에서 매우 유용할 수 있습니다. JavaScript는 알려지지 않은 프로퍼티는 오류를 발생(다른 언어에서처럼)하는 대신 <code>undefined</code>를 자동으로 반환합니다.</p>
<p>이 예제에서 <code>trapTarget</code>과 <code>receiver</code>는 다른 객체라는 것을 이해하는 것이 중요합니다. 프록시가 프로토 타입으로 사용될 때, <code>trapTarget</code>은 프로토 타입 객체 자체이고 <code>receiver</code>는 인스턴스 객체입니다. 이 경우 <code>trapTarget</code>은 <code>target</code>과 같고 <code>receiver</code>는 <code>thing</code>과 같습니다. 이렇게하면 원래 프록시 대상과 작업을 수행할 대상에 모두 액세스할 수 있습니다.</p>
<h3 id="프로토-타입에서-set-Trap-사용하기"><a href="#프로토-타입에서-set-Trap-사용하기" class="headerlink" title="프로토 타입에서 set Trap 사용하기"></a>프로토 타입에서 set Trap 사용하기</h3><p>내부 <code>[[Set]]</code> 메서드는 자체 프로퍼티를 확인한 다음 필요에 따라 프로토 타입을 계속 진행합니다. 오브젝트 프로퍼티에 값을 할당하면, 같은 이름의 프로퍼티에 값이 할당됩니다. 지정된 이름의 프로퍼티가 없는 경우 연산은 프로토 타입으로 계속 진행됩니다. 까다로운 부분은 할당 작업이 프로토 타입으로 계속 되더라도 해당 프로퍼티에 값을 할당하면 해당 이름의 프로퍼티가 프로토 타입에 있는지 여부에 관계없이 기본적으로 프로토 타입이 아닌 인스턴스에 대한 프로퍼티가 만들어집니다.</p>
<p>프로토 타입에<code>set</code>Trap이 호출될 때와 그렇지 않을 때를 더 잘 이해하려면, 기본 동작을 보여주는 다음 예제를 살펴보십시오.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> target = &#123;&#125;;</div><div class="line"><span class="keyword">let</span> thing = <span class="built_in">Object</span>.create(<span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</div><div class="line">    set(trapTarget, key, value, receiver) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(trapTarget, key, value, receiver);</div><div class="line">    &#125;</div><div class="line">&#125;));</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(thing.hasOwnProperty(<span class="string">"name"</span>));      <span class="comment">// false</span></div><div class="line"></div><div class="line"><span class="comment">// triggers the `set` proxy trap</span></div><div class="line">thing.name = <span class="string">"thing"</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(thing.name);                        <span class="comment">// "thing"</span></div><div class="line"><span class="built_in">console</span>.log(thing.hasOwnProperty(<span class="string">"name"</span>));      <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="comment">// does not trigger the `set` proxy trap</span></div><div class="line">thing.name = <span class="string">"boo"</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(thing.name);                        <span class="comment">// "boo"</span></div></pre></td></tr></table></figure>
<p>이 예제에서, <code>target</code>은 자신의 프로퍼티가 없이 시작됩니다. <code>thing</code> 객체는 새로운 프로퍼티의 생성을 위한 <code>set</code> Trap을 정의하는 프록시를 프로토 타입으로 가지고 있습니다. <code>thing.name</code>에 값으로 <code>&quot;thing&quot;</code>이 지정되면 <code>thing</code>에 <code>name</code>이라는 자체 프로퍼티가 없으므로<code>set</code> 프록시 Trap이 호출됩니다. <code>set</code> Trap 내에서 <code>trapTarget</code>은 <code>target</code>과 같고 <code>receiver</code>는 <code>thing</code>과 같습니다. 연산은 궁극적으로 <code>thing</code>에 새로운 프로퍼티를 만들어야하며, 다행히 <code>Reflect.set()</code>는 네 번째 파라미터로 <code>receiver</code>를 전달하면 이 기본 동작을 구현합니다.</p>
<p><code>name</code> 프로퍼티가 <code>thing</code>에 생성되면 <code>thing.name</code>을 다른 값으로 설정해도 더이상 <code>set</code> 프록시 Trap을 호출하지 않습니다. 이 시점에서, <code>name</code>은 자체 프로퍼티이므로 <code>[[Set]]</code> 연산은 프로토 타입으로 계속되지 않습니다.</p>
<h3 id="프로토-타입에서-has-Trap-사용하기"><a href="#프로토-타입에서-has-Trap-사용하기" class="headerlink" title="프로토 타입에서 has Trap 사용하기"></a>프로토 타입에서 has Trap 사용하기</h3><p><code>has</code> Trap은 객체에서 <code>in</code> 연산자의 사용을 가로챈다는 것을 설명했습니다. <code>in</code> 연산자는 먼저 주어진 이름을 가진 객체 자신의 프로퍼티를 검색합니다. 이름이 같은 자체 프로퍼티가 없으면 연산이 프로토 타입으로 계속 진행됩니다. 프로토 타입에 자체 프로퍼티가 없으면 프로토<br> 타입을 찾거나 검색할 프로토 타입이 더 이상 없을 때까지 프로토 타입 체인을 통해 검색이 계속됩니다.</p>
<p>따라서 <code>has</code> Trap은 검색이 프로토 타입 체인에서 프록시 객체에 도달할 때만 호출됩니다. 프로토 타입으로 프록시를 사용하는 경우 지정된 이름의 자체 프로퍼티가 없을 때만 발생합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> target = &#123;&#125;;</div><div class="line"><span class="keyword">let</span> thing = <span class="built_in">Object</span>.create(<span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</div><div class="line">    has(trapTarget, key) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.has(trapTarget, key);</div><div class="line">    &#125;</div><div class="line">&#125;));</div><div class="line"></div><div class="line"><span class="comment">// triggers the `has` proxy trap</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> thing);                   <span class="comment">// false</span></div><div class="line"></div><div class="line">thing.name = <span class="string">"thing"</span>;</div><div class="line"></div><div class="line"><span class="comment">// does not trigger the `has` proxy trap</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> thing);                   <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>이 코드는 <code>thing</code> 프로토 타입에 <code>has</code> 프록시 Trap을 만듭니다. <code>has</code> Trap은 <code>in</code> 연산자가 사용될 때 프로토 타입을 자동으로 검색하기 때문에 <code>get</code> 및 <code>set</code> Trap처럼 <code>receiver</code> 객체를 통과하지 않습니다. 대신, <code>has</code> Trap은 <code>target</code>과 같은 <code>trapTarget</code>에서만 작동해야합니다. 이 예제에서 처음으로 <code>in</code> 연산자가 사용되면, 프로퍼티 이름이 <code>thing</code>의 자체 프로퍼티로 존재하지 않기 때문에 <code>has</code> Trap이 호출됩니다. <code>thing.name</code>에 값이 주어지고 <code>in</code> 연산자가 다시 사용될 때 <code>has</code>에 자신의 프로퍼티 <code>name</code>을 찾은 후에 연산이 멈추기 때문에 <code>has</code> Trap이 호출되지 않습니다.</p>
<p>이 시점의 프로토 타입 예제는 <code>Object.create()</code> 메서드를 사용하여 생성된 객체를 중심으로 이루어졌습니다. 그러나 프록시를 프로토 타입으로 사용하는 클래스를 만들려면 프로세스가 좀 더 복잡합니다.</p>
<h3 id="클래스의-프로토-타입으로서의-프록시"><a href="#클래스의-프로토-타입으로서의-프록시" class="headerlink" title="클래스의 프로토 타입으로서의 프록시"></a>클래스의 프로토 타입으로서의 프록시</h3><p>프로토 타입 프로퍼티가 non-writable이기 때문에 클래스를 프록시 <code>prototype</code>으로 사용하도록 직접 수정할 수 없습니다. 그러나 상속을 사용하여 프록시를 프로토 타입으로 사용하는 클래스를 약간  다르게 사용할 수 있습니다. 시작하려면 생성자 함수를 사용하여 ECMAScript 5 스타일 형식 정의를 만들어야합니다. 그런 다음 프로토 타입을 프록시로 덮어 쓸수 있습니다. 다음은 그 예제입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">NoSuchProperty</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// empty</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">NoSuchProperty.prototype = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</div><div class="line">    get(trapTarget, key, receiver) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">ReferenceError</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span> doesn't exist`</span>);</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">let</span> thing = <span class="keyword">new</span> NoSuchProperty();</div><div class="line"></div><div class="line"><span class="comment">// `get` 프록시 Trap으로 인해 오류가 발생합니다.</span></div><div class="line"><span class="keyword">let</span> result = thing.name;</div></pre></td></tr></table></figure>
<p><code>NoSuchProperty</code> 함수는 클래스가 상속하는 기반을 나타냅니다. 함수의 프로토 타입 프로퍼티에는 제한이 없으므로 프록시로 이를 덮어 쓸 수 있습니다. <code>get</code> Trap은 프로퍼티가 존재하지 않을 때 오류를 던지기 위해 사용됩니다. <code>thing</code> 객체는 <code>NoSuchProperty</code> 인스턴스로 생성되고 존재하지 않는 <code>name</code> 프로퍼티에 접근할 때 오류를 던집니다.</p>
<p>다음 단계는 <code>NoSuchProperty</code>를 상속받은 클래스를 만드는 것입니다. 9장에서 논의된 <code>extends</code> 문법을 사용하여 클래스 프로토 타입 체인에 프록시를 도입 할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">NoSuchProperty</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// empty</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">NoSuchProperty.prototype = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</div><div class="line">    get(trapTarget, key, receiver) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">ReferenceError</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span> doesn't exist`</span>);</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">NoSuchProperty</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(length, width) &#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">        <span class="keyword">this</span>.length = length;</div><div class="line">        <span class="keyword">this</span>.width = width;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> shape = <span class="keyword">new</span> Square(<span class="number">2</span>, <span class="number">6</span>);</div><div class="line"></div><div class="line"><span class="keyword">let</span> area1 = shape.length * shape.width;</div><div class="line"><span class="built_in">console</span>.log(area1);                         <span class="comment">// 12</span></div><div class="line"></div><div class="line"><span class="comment">// "wdth"가 존재하지 않기 때문에 에러가 발생합니다.</span></div><div class="line"><span class="keyword">let</span> area2 = shape.length * shape.wdth;</div></pre></td></tr></table></figure>
<p><code>Square</code> 클래스는 <code>NoSuchProperty</code>를 상속받습니다. 그래서 프록시는 <code>Square</code> 클래스의 프로토 타입 체인에 있습니다. <code>shape</code> 객체는<code>Square</code>의 새로운 인스턴스로 생성되고 <code>length</code>와 <code>width</code>라는 두개의 프로퍼티를 갖습니다. <code>get</code> 프록시 Trap이 결코 호출되지 않기 때문에 이들 프로퍼티의 값을 읽는 것은 성공합니다. <code>shape</code>에 존재하지 않는 프로퍼티(<code>shape.wdth</code>, 명백한 오타)에 접근할 때만 <code>get</code> 프록시 Trap 트리거가 발생하고 오류가 발생합니다.</p>
<p>이는 프록시가 <code>shape</code>의 프로토 타입 체인에 있음을 증명하지만 프록시가 <code>shape</code>의 직접 프로토 타입이 아니라는 점은 분명하지 않을 수 있습니다. 실제로, 프록시는 <code>shape</code>에서 프로토 타입 체인까지 두단계입니다. 앞의 예를 약간 변경하면 더 명확하게 알 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">NoSuchProperty</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// empty</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 프로토 타입이 될 프록시에 대한 참조를 저장</span></div><div class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</div><div class="line">    get(trapTarget, key, receiver) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">ReferenceError</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span> doesn't exist`</span>);</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">NoSuchProperty.prototype = proxy;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">NoSuchProperty</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(length, width) &#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">        <span class="keyword">this</span>.length = length;</div><div class="line">        <span class="keyword">this</span>.width = width;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> shape = <span class="keyword">new</span> Square(<span class="number">2</span>, <span class="number">6</span>);</div><div class="line"></div><div class="line"><span class="keyword">let</span> shapeProto = <span class="built_in">Object</span>.getPrototypeOf(shape);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(shapeProto === proxy);                  <span class="comment">// false</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> secondLevelProto = <span class="built_in">Object</span>.getPrototypeOf(shapeProto);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(secondLevelProto === proxy);            <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>이 버전의 코드는 프록시를 <code>proxy</code>라는 변수에 저장하므로 나중에 쉽게 식별할 수 있습니다. <code>shape</code>의 프로토 타입은 <code>Shape.prototype</code>이고 프록시가 아닙니다. 그러나 <code>Shape.prototype</code>의 프로토 타입은 <code>NoSuchProperty</code>에서 상속된 프록시입니다.</p>
<p>상속은 프로토 타입 체인에 또 다른 단계를 추가합니다. 프록시에 <code>get</code> Trap을 호출할 때 발생할 수 있는 작업으로 인해 하나의 추가 단계가 필요하기 때문에 중요합니다. <code>Shape.prototype</code>에 프로퍼티가 있으면 다음과 같이 <code>get</code> 프록시 Trap이 호출되지 않습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">NoSuchProperty</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// empty</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">NoSuchProperty.prototype = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</div><div class="line">    get(trapTarget, key, receiver) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">ReferenceError</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span> doesn't exist`</span>);</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">NoSuchProperty</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(length, width) &#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">        <span class="keyword">this</span>.length = length;</div><div class="line">        <span class="keyword">this</span>.width = width;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    getArea() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.length * <span class="keyword">this</span>.width;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> shape = <span class="keyword">new</span> Square(<span class="number">2</span>, <span class="number">6</span>);</div><div class="line"></div><div class="line"><span class="keyword">let</span> area1 = shape.length * shape.width;</div><div class="line"><span class="built_in">console</span>.log(area1);                         <span class="comment">// 12</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> area2 = shape.getArea();</div><div class="line"><span class="built_in">console</span>.log(area2);                         <span class="comment">// 12</span></div><div class="line"></div><div class="line"><span class="comment">// "wdth"가 존재하지 않기 때문에 에러가 발생됩니다.</span></div><div class="line"><span class="keyword">let</span> area3 = shape.length * shape.wdth;</div></pre></td></tr></table></figure>
<p>여기에서 <code>Square</code> 클래스는 <code>getArea()</code> 메서드를 가지고 있습니다. <code>getArea()</code> 메서드는 <code>Square.prototype</code>에 자동으로 추가되므로<br> <code>shape.getArea()</code>가 호출되면 <code>getArea()</code> 메서드에 대한 검색은 <code>shape</code> 인스턴스에서 시작한 후 프로토 타입으로 진행됩니다. 프로토 타입에 <code>getArea ()</code>가 있기 때문에 검색이 멈추고 프록시는 호출되지 않습니다. <code>getArea()</code>가 호출됐을때 오류를 잘못 던지는 것을 원하지 않기 때문에 실제로 이 상황에서 우리가 원하는 동작입니다.</p>
<p>프로토 타입 체인에 프록시가있는 클래스를 만드는 데 약간의 추가 코드가 필요하지만 이러한 기능이 필요한 경우에는 노력할 가치가 있습니다.</p>
<h2 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h2><p>ECMAScript 6 이전에는 특정 객체(예 : <em>Array</em>)가 개발자가 복제할 수없는 비표준 동작을 표현했습니다. 프록시가 그것을 바꿉니다. 프록시를 사용하면 여러 저수준 JavaScript 작업에 대한 비표준 동작을 정의할 수 있으므로 프록시 Trap을 통해 <em>Built-in</em> JavaScript 객체의 모든 동작을 가로챌 수 있습니다. 이러한 Trap은 <code>in</code> 연산자를 사용하는 것처럼 다양한 작업이 수행되는 뒤에서 호출됩니다.</p>
<p>개발자가 각 프록시 Trap에 대한 기본 동작을 구현할 수 있도록 ECMAScript 6에 리플렉션 API도 도입되었습니다. 각 프록시 Trap에는 <code>Reflect</code> 객체에 동일한 이름의 해당 메서드가 있으며 ECMAScript 6에 추가되었습니다. 프록시 Trap 및 리플렉션 API 메서드의 조합을 사용하면 일부 동작만 필터링하여 특정 조건에서만 다르게 동작하도록 할 수 있으며 <em>Built-in</em> 동작을 기본값으로 사용할 수 있습니다.</p>
<p>취소 가능한 프록시는 <code>revoke()</code> 함수를 사용하여 효과적으로 비활성화 할 수있는 특수 프록시입니다. <code>revoke()</code> 함수는 프록시의 모든 기능을 종료하므로 <code>revoke()</code>가 호출된 후 프록시의 프로퍼티와 상호 작용하려는 동작은 오류가 발생합니다. 취소 가능한 프록시는 Third-party 개발자가 지정된 시간 동안 특정 객체에 액세스해야하는 응용 프로그램의 보안에 중요합니다.</p>
<p>프록시를 직접 사용하는 것이 가장 강력한 유스 케이스이지만 프록시를 다른 객체의 프로토 타입으로 사용할 수도 있습니다. 이 경우 효과적으로 사용할 수 있는 프록시 Trap 수가 크게 제한됩니다. 프로토 타입으로 사용될 때 프록시에서 <code>get</code>, <code>set</code> 및 <code>has</code> 프록시 Trap만 호출되어 사용가능 사례를 훨씬 더 좁힙니다.</p>
<hr>
<blockquote>
<p>이 내용은 나중에 참고하기 위해 제가 공부하며 정리한 내용입니다.<br>의역, 오역, 직역이 있을 수 있음을 알려드립니다.<br>This post is a translation of this original article [<a href="https://leanpub.com/understandinges6/read#leanpub-auto-proxies-and-the-reflection-api" target="_blank" rel="external">https://leanpub.com/understandinges6/read#leanpub-auto-proxies-and-the-reflection-api</a>]</p>
</blockquote>
<h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul>
<li><a href="https://infoscis.github.io/2018/01/24/ecmascript-6-block-binding/">ECMAScript 6 Block Binding</a></li>
<li><a href="https://infoscis.github.io/2018/01/24/ecmascript-6-strings-and-regular-expressions/">ECMAScript 6 문자열과 정규 표현식</a></li>
<li><a href="https://infoscis.github.io/2018/01/24/ecmascript-6-functions/">ECMAScript 6 함수</a></li>
<li><a href="https://infoscis.github.io/2018/01/25/ecmascript-6-expanded-object-functionality/">ECMAScript 6 객체의 확장된 기능</a></li>
<li><a href="https://infoscis.github.io/2018/01/26/ecmascript-6-destructuring-for-easier-data-access/">ECMAScript 6 쉬운 데이터 액세스를 위한 Destructuring</a></li>
<li><a href="https://infoscis.github.io/2018/01/27/ecmascript-6-symbols-and-symbol-properties/">ECMAScript 6 Symbol과 Symbol 프로퍼티</a></li>
<li><a href="https://infoscis.github.io/2018/01/27/ecmascript-6-sets-and-maps/">ECMAScript 6 Set과 Map</a></li>
<li><a href="https://infoscis.github.io/2018/01/31/ecmascript-6-iterators-and-generators/">ECMAScript 6 Iterator와 Generator</a></li>
<li><a href="https://infoscis.github.io/2018/02/13/ecmascript-6-introducing-javascript-classes/">ECMAScript 6 JavaScript 클래스 소개</a></li>
<li><a href="https://infoscis.github.io/2018/02/13/ecmascript-6-improved-array-capabilities/">ECMAScript 6 Array 기능 향상</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-promises-and-asynchronous-programming/">ECMAScript 6 Promise와 비동기 프로그램밍</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-proxies-and-the-reflection-api/">ECMAScript 6 프록시와 리플렉션 API</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-encapsulating-code-with-modules/">ECMAScript 6 Module로 코드 캡슐화하기</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-appendix-a-smaller-changes/">ECMAScript 6 부록 A. 작은 변경 사항</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-appendix-b-understanding-ecmascript-7/">ECMAScript 6 부록 B. ECMAScript 7(2016) 이해하기</a></li>
</ul>

        </div>
        <footer class="article-footer">
            



    <a data-url="http://infoscis.github.io/2018/02/27/ecmascript-6-proxies-and-the-reflection-api/" data-id="cjkl9106o008sjguzwr0hii04" class="article-share-link"><i class="fa fa-share"></i>공유하기</a>
<script>
    (function ($) {
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

        </footer>
    </div>
</article>

    <section id="comments">
    
        
    <div id="disqus_thread">
        <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>

    
    </section>


                        </div>
                    </section>
                    <aside id="sidebar">
    <a class="sidebar-toggle" title="Expand Sidebar"><i class="toggle icon"></i></a>
    <div class="sidebar-top">
        <p>팔로우:</p>
        <ul class="social-links">
            
                
                <li>
                    <a class="social-tooltip" title="github" href="https://github.com/infoscis" target="_blank">
                        <i class="icon fa fa-github"></i>
                    </a>
                </li>
                
            
        </ul>
    </div>
    
        
<nav id="article-nav">
    
        <a href="/2018/02/27/ecmascript-6-encapsulating-code-with-modules/" id="article-nav-newer" class="article-nav-link-wrap">
        <strong class="article-nav-caption">새로운</strong>
        <p class="article-nav-title">
        
            ECMAScript 6 Module로 코드 캡슐화하기
        
        </p>
        <i class="icon fa fa-chevron-right" id="icon-chevron-right"></i>
    </a>
    
    
        <a href="/2018/02/27/ecmascript-6-promises-and-asynchronous-programming/" id="article-nav-older" class="article-nav-link-wrap">
        <strong class="article-nav-caption">오래된</strong>
        <p class="article-nav-title">ECMAScript 6 Promise와 비동기 프로그램밍</p>
        <i class="icon fa fa-chevron-left" id="icon-chevron-left"></i>
        </a>
    
</nav>

    
    <div class="widgets-container">
        
            
                
    <div class="widget-wrap">
        <h3 class="widget-title">최근 글</h3>
        <div class="widget">
            <ul id="recent-post" class="no-thumbnail">
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Angular/">Angular</a></p>
                            <p class="item-title"><a href="/2018/08/08/angular-observables-and-rxjs/" class="title">Angular Observable &amp; RxJS</a></p>
                            <p class="item-date"><time datetime="2018-08-08T14:38:02.000Z" itemprop="datePublished">2018-08-08</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/JavaScript/">JavaScript</a><i class="icon fa fa-angle-right"></i><a class="article-category-link" href="/categories/JavaScript/ECMAScript-2015/">ECMAScript 2015</a></p>
                            <p class="item-title"><a href="/2018/02/27/ecmascript-6-appendix-b-understanding-ecmascript-7/" class="title">ECMAScript 6 부록 B. ECMAScript 7 (2016) 이해하기</a></p>
                            <p class="item-date"><time datetime="2018-02-27T13:32:48.000Z" itemprop="datePublished">2018-02-27</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/JavaScript/">JavaScript</a><i class="icon fa fa-angle-right"></i><a class="article-category-link" href="/categories/JavaScript/ECMAScript-2015/">ECMAScript 2015</a></p>
                            <p class="item-title"><a href="/2018/02/27/ecmascript-6-appendix-a-smaller-changes/" class="title">ECMAScript 6 부록 A. 작은 변경 사항</a></p>
                            <p class="item-date"><time datetime="2018-02-27T13:32:12.000Z" itemprop="datePublished">2018-02-27</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/JavaScript/">JavaScript</a><i class="icon fa fa-angle-right"></i><a class="article-category-link" href="/categories/JavaScript/ECMAScript-2015/">ECMAScript 2015</a></p>
                            <p class="item-title"><a href="/2018/02/27/ecmascript-6-encapsulating-code-with-modules/" class="title">ECMAScript 6 Module로 코드 캡슐화하기</a></p>
                            <p class="item-date"><time datetime="2018-02-27T13:31:45.000Z" itemprop="datePublished">2018-02-27</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/JavaScript/">JavaScript</a><i class="icon fa fa-angle-right"></i><a class="article-category-link" href="/categories/JavaScript/ECMAScript-2015/">ECMAScript 2015</a></p>
                            <p class="item-title"><a href="/2018/02/27/ecmascript-6-proxies-and-the-reflection-api/" class="title">ECMAScript 6 프록시와 리플렉션 API</a></p>
                            <p class="item-date"><time datetime="2018-02-27T13:31:03.000Z" itemprop="datePublished">2018-02-27</time></p>
                        </div>
                    </li>
                
            </ul>
        </div>
    </div>

            
                
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">카테고리</h3>
        <div class="widget">
            <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Angular/">Angular</a><span class="category-list-count">15</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hadoop/">Hadoop</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">5</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/Java9/">Java9</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/Spring/">Spring</a><span class="category-list-count">2</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/">JavaScript</a><span class="category-list-count">16</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/ECMAScript-2015/">ECMAScript 2015</a><span class="category-list-count">15</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/TypeScript/">TypeScript</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Webpack/">Webpack</a><span class="category-list-count">1</span></li></ul>
        </div>
    </div>


            
                
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">아카이브</h3>
        <div class="widget">
            <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">8월 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">2월 2018</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">1월 2018</a><span class="archive-list-count">11</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">7월 2017</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">6월 2017</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">5월 2017</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">3월 2017</a><span class="archive-list-count">5</span></li></ul>
        </div>
    </div>


            
                
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">태그</h3>
        <div class="widget">
            <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Angular/">Angular</a><span class="tag-list-count">15</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ECMAScript-2015/">ECMAScript 2015</a><span class="tag-list-count">15</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Event/">Event</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hadoop/">Hadoop</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JDK9/">JDK9</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java9/">Java9</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript</a><span class="tag-list-count">29</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Jigsaw/">Jigsaw</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nashorn/">Nashorn</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/">Spring</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringBoot/">SpringBoot</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TypeScript/">TypeScript</a><span class="tag-list-count">12</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Webpack/">Webpack</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/YARN/">YARN</a><span class="tag-list-count">1</span></li></ul>
        </div>
    </div>


            
                
    <div class="widget-wrap widget-float">
        <h3 class="widget-title">태그 클라우드</h3>
        <div class="widget tagcloud">
            <a href="/tags/Angular/" style="font-size: 18px;">Angular</a> <a href="/tags/ECMAScript-2015/" style="font-size: 18px;">ECMAScript 2015</a> <a href="/tags/Event/" style="font-size: 10px;">Event</a> <a href="/tags/Hadoop/" style="font-size: 10px;">Hadoop</a> <a href="/tags/JDK9/" style="font-size: 12px;">JDK9</a> <a href="/tags/Java/" style="font-size: 14px;">Java</a> <a href="/tags/Java9/" style="font-size: 12px;">Java9</a> <a href="/tags/JavaScript/" style="font-size: 20px;">JavaScript</a> <a href="/tags/Jigsaw/" style="font-size: 12px;">Jigsaw</a> <a href="/tags/Nashorn/" style="font-size: 10px;">Nashorn</a> <a href="/tags/Spring/" style="font-size: 12px;">Spring</a> <a href="/tags/SpringBoot/" style="font-size: 10px;">SpringBoot</a> <a href="/tags/TypeScript/" style="font-size: 16px;">TypeScript</a> <a href="/tags/Webpack/" style="font-size: 10px;">Webpack</a> <a href="/tags/YARN/" style="font-size: 10px;">YARN</a>
        </div>
    </div>


            
        
    </div>
</aside>
                </div>
            </div>
        </div>
        <footer id="footer">
    <div class="container">
        <div class="container-inner">
            <a id="back-to-top" href="javascript:;"><i class="icon fa fa-angle-up"></i></a>
            <div class="credit">
                <h1 class="logo-wrap">
                    <a href="/" class="logo"></a>
                </h1>
                <p>&copy; 2018 Jongcheol-Kim</p>
                <p>Powered by <a href="//hexo.io/" target="_blank">Hexo</a>. Theme by <a href="//github.com/ppoffice" target="_blank">PPOffice</a></p>
            </div>
        </div>
    </div>
</footer>
        
    
    <script>
    var disqus_shortname = 'infoscis';
    
    
    var disqus_url = 'http://infoscis.github.io/2018/02/27/ecmascript-6-proxies-and-the-reflection-api/';
    
    (function() {
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    </script>




    
        <script src="/libs/lightgallery/js/lightgallery.min.js"></script>
        <script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>
        <script src="/libs/lightgallery/js/lg-pager.min.js"></script>
        <script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>
        <script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>
        <script src="/libs/lightgallery/js/lg-zoom.min.js"></script>
        <script src="/libs/lightgallery/js/lg-hash.min.js"></script>
        <script src="/libs/lightgallery/js/lg-share.min.js"></script>
        <script src="/libs/lightgallery/js/lg-video.min.js"></script>
    
    
        <script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script>
    
    


<!-- Custom Scripts -->
<script src="/js/main.js"></script>

    </div>
</body>
</html>
