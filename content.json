{"meta":{"title":"Developer's Record","subtitle":"개발자의 기록 보관소","description":"어느 개발자의 기록을 보관하고 있습니다.","author":"Jongcheol-Kim","url":"http://infoscis.github.io"},"pages":[],"posts":[{"title":"Angular Observable & RxJS","slug":"angular-observables-and-rxjs","date":"2018-08-08T14:38:02.000Z","updated":"2018-08-08T14:44:11.432Z","comments":true,"path":"2018/08/08/angular-observables-and-rxjs/","link":"","permalink":"http://infoscis.github.io/2018/08/08/angular-observables-and-rxjs/","excerpt":"","text":"ObservableObservable은 Application의 Publisher와 Subscriber 사이의 메시지 전달을 지원하는 기능을 제공합니다. Observable은 이벤트 처리, 비동기 프로그래밍 및 다중 값 처리와 관련된 다른 기술에 비해 상당한 이점을 제공합니다. Observable은 선언적입니다. 즉, 여러분이 값을 게시하는 함수를 정의해도, Consumer가 구독 하기전까지 실행되지 않습니다. 그리고 구독된 Consumer는 함수가 완료되거나 구독을 취소 할 때까지 알림을 받습니다. Observable은 컨텍스트에 따라 리터럴(Literal), 메시지(Message) 또는 이벤트(Event)등 여러 값을 전달할 수 있습니다. 값을 수신하기 위한 API는 값이 동기적 또는 비동기적으로 전달되는지 여부에 관계없이 동일합니다. 설정 및 해체 로직은 모두 Observable에 의해 처리되고, 응용 프로그램에서는 값을 소비하기 위해 구독하고, 완료되면 구독을 취소하는 것에 신경을 써야 합니다. Stream이 Keystroke인지, HTTP 응답인지, 인터벌 타이머인지 여부와 관계없이 값을 구독하고 멈추는 인터페이스는 동일합니다. 이러한 이점 때문에 Observable은 Angular 내에서 광범위하게 사용되며 앱 개발에도 권장됩니다. 기본 사용법 및 용어Publisher는 subscriber 함수를 정의하는 Observable 인스턴스를 만듭니다. 이 함수는 Consumer가 subscribe()함수를 호출할 때 실행 됩니다. subscriber 함수는 게시될 값 또는 메시지를 얻거나 생성하는 방법을 정의합니다. 생성한 Observable 객체를 실행하고 알림 수신을 시작하려면 observer를 전달하여 subscribe() 메서드를 호출합니다. observer는 여러분이 수신한 알림을 처리하는 핸드러를 정의한 JavaScript 객체입니다. subscribe() 메서드는 Subscripotion 객체를 반환하는데, 이 객체에는 알림 수신을 중지하기 위해 호출하는 unsubscribe() 메서드가 있습니다. 다음은 Geolocation 업데이트 정보 제공에 Observable을 어떻게 사용할 수 있지 보여줌으로써 기본 사용 모델을 설명하는 예제입니다. 12345678910111213141516171819202122232425// Consumer가 구독할때 Geolocation 변경사항을 수신하는 *Observable*을 생성합니다.const locations = new Observable((observer) =&gt; &#123; // next와 error 콜백을 가져옵니다. 이것은 Consumer가 구독할때 넘겨줍니다. const &#123;next, error&#125; = observer; let watchId; // 게시할 값을 제공하는 간단한 geolocation API를 확인 if ('geolocation' in navigator) &#123; watchId = navigator.geolocation.watchPosition(next, error); &#125; else &#123; error('Geolocation not available'); &#125; // Consumer가 구독을 중지하면 다음 구독을 위해 준비한 데이터를 정리합니다. return &#123;unsubscribe() &#123; navigator.geolocation.clearWatch(watchId); &#125;&#125;;&#125;); // 변경사항 수신을 시작하기 위해 subscribe()를 호출합니다.const locationsSubscription = locations.subscribe(&#123; next(position) &#123; console.log('Current Position: ', position); &#125;, error(msg) &#123; console.log('Error Getting Location: ', msg); &#125;&#125;); // 10초후에 수신을 중지합니다.setTimeout(() =&gt; &#123; locationsSubscription.unsubscribe(); &#125;, 10000); Observer 정의Observable 알람을 수신하기 위한 핸들러는 Observer 인터페이스를 구현합니다. 이것은 Observable이 보낼수 있는 3가지 알람 타입을 처리할 수 있는 콜백 메서드가 정의된 객체입니다. 알람 종류 설명 next 필수. 전달된 각각의 값을 처리하는 핸들러. 실행 시작후 0번 또는 그 이상 호출됩니다. error 선택사항. 오류 알람에 대한 처리 핸들러. 오류로 인해 Observable 인스턴스의 실행이 중지됩니다. complete 선택사항. 실행 완료 알람에 대한 처리 핸들러. 지연된 값은 실행 완료 후에도 계속해서 next 핸들러로 전달될 수 있습니다. Observable 객체는 이러한 핸들러의 조합을 정의할 수 있습니다. 만약 알람 종류에 대한 핸들러를 제공하지 않으면, observer는 해당 종류의 알람을 무시합니다. 구독(Subscribing)Observable 인스턴스는 누군가가 구독할 때만 값을 게시 시작합니다. 여러분은 알람을 수신받을 observer 객체를 Observable 인스턴스의 subscribe() 메서드에 넘겨 구독을 시작합니다. 어떻게 구독(Subscribing)이 작동하는지 보여주기 위해 새로운 Observable을 만듭니다. 새로운 인스턴스를 생성하기 위해 사용할 수 있는 생성자가 있지만, 설명을 위해 Observable 클래스에서 자주 사용하는 간단한 Observable을 만드는 몇가지 정적 메서드를 사용할 수 있습니다. Observable.of(…items)-인수로 제공된 값을 동기적으로 전달하는 Observable 인스턴스를 반환합니다. Observable.from(iterable)-인수를 Observable 인스턴스로 변경합니다. 일반적으로 이 메서드는 Array를 Observable로 변환할 때 사용합니다. 다음은 수신받은 메시지를 console에 기록하는 간단한 observer를 이용하여 Observable을 생성하고 구독하는 예제입니다. 1234567891011121314151617// 값 3개를 발생시키는 간단한 observable 생성const myObservable = Observable.of(1, 2, 3);// observer 객체 생성const myObserver = &#123; next: x =&gt; console.log('Observer got a next value: ' + x), error: err =&gt; console.error('Observer got an error: ' + err), complete: () =&gt; console.log('Observer got a complete notification'),&#125;;// observer 객체를 이용해 실행시킴myObservable.subscribe(myObserver);// Logs:// Observer got a next value: 1// Observer got a next value: 2// Observer got a next value: 3// Observer got a complete notification 또는 subscribe() 메서드는 next, error 및 complete 핸들러에 대한 콜백 함수를 인수에서 정의하는 것을 허용합니다. 예를 들어, 다음 subscribe() 호출은 사전 정의된 observer를 지정하여 호출하는 것과 똑같습니다. 12345myObservable.subscribe( x =&gt; console.log('Observer got a next value: ' + x), err =&gt; console.error('Observer got an error: ' + err), () =&gt; console.log('Observer got a complete notification')); 위의 두가지 방법 모두 next는 필수사항이고, error와 complete는 선택사항입니다. next 메서드는 컨텍스트에 따라 메시지 문자열, 이벤트 객체, 숫자값 또는 구조체를 수신 받을수 있습니다. 일반적으로 우리는 Stream에 의해 Observable로 게시된 데이터를 참조합니다. 모든 타입은 Observable로 표시될 수 있으며, 해당 값은 Stream으로 게시됩니다. Observable 생성Observable 생성자를 사용하여 모든 타입의 Observable Stream을 만듭니다. 생성자는 Observable의 subscribe() 메서드가 호출될 때 실행시킬 subscriber 함수를 인수로 받습니다. subscriber 함수는 observer 객체를 받고, observer의 next 메서드에 값을 게시할 수 있습니다. 예를 들어 Observable.of(1, 2, 3)에 해당하는 Observable 객체를 만들려면 다음과 같이할 수 있습니다. 1234567891011121314151617181920212223242526// 이 함수는 subscribe()가 호출될 때 실행됩니다.function sequenceSubscriber(observer) &#123; // 순차적으로 1, 2, 그리고 3 을 전달하 후 완료(complete) 합니다. observer.next(1); observer.next(2); observer.next(3); observer.complete(); // 값이 순차적으로 전달되기 때문에 unsubscribe 함수는 아무것도 할 필요가 없습니다. return &#123;unsubscribe() &#123;&#125;&#125;;&#125; // 위의 시퀀스를 전달할 새로운 Observable을 생성합니다.const sequence = new Observable(sequenceSubscriber); // Observable을 실행 시키고 각 알람의 결과를 출력합니다.sequence.subscribe(&#123; next(num) &#123; console.log(num); &#125;, complete() &#123; console.log('Finished sequence'); &#125;&#125;); // Logs:// 1// 2// 3// Finished sequence 이 예를 좀 더 발전시키기 위해, 우리는 이벤트를 게시하는 Observable을 생성할 수 있습니다. 이 예제에서 subscriber함수가 인라인으로 정의 됩니다. 12345678910111213function fromEvent(target, eventName) &#123; return new Observable((observer) =&gt; &#123; const handler = (e) =&gt; observer.next(e); // target에 Event 핸들러를 붙입니다. target.addEventListener(eventName, handler); return () =&gt; &#123; // target에서 이벤트 핸들러를 제거합니다. target.removeEventListener(eventName, handler); &#125;; &#125;);&#125; 이제 이 함수를 keydown 이벤트를 게시하는 Observable을 생성하는데 사용할 수 있습니다. 123456789const ESC_KEY = 27;const nameInput = document.getElementById('name') as HTMLInputElement;const subscription = fromEvent(nameInput, 'keydown') .subscribe((e: KeyboardEvent) =&gt; &#123; if (e.keyCode === ESC_KEY) &#123; nameInput.value = ''; &#125; &#125;); 여러 Comsumer에게 동시에 보내기(Multicasting)일반적인 Observable 생성은, 구독하는 각각 observer에 대해 독립적으로 실행 됩니다. observer가 구독할 때 Observable은 이벤트 핸들러를 연결하고 그 observer에 값을 전달합니다. 두 번째 observer가 구독하면 Observable은 새로운 이벤트 핸들러에 연결하고 별도의 실행으로 두 번째 observer에 값을 전달합니다. Document 객체에 대한 클릭을 Observable하는 경우와 같이 각 subscriber가 독립된 실행으로 시작하는 대신에 이미 값이 발행되고 있다고 할지라도 각 구독자가 같은 값을 갖기를 원할 수도 있습니다. Multicasting은 단일 실행으로 여러 구독자 목록에 브로드 캐스트하는 기능입니다. Multicasting observable을 활용하면 Document에 여러개의 수신자(Listener)를 등록할 필요가 없고, 첫 번째 수신자(Listener)를 재사용하여 각 구독자에 값을 보냅니다. Observable을 생성할 때 Observable을 어떻게 사용 할지, 그리고 값을 Multicast 할지 말지를 결정합니다. 아래의 예제는 1부터 3까지 카운트 하며, 각 숫자가 발행된 후 1초가 지연됩니다. 12345678910111213141516171819202122232425262728293031323334353637function sequenceSubscriber(observer) &#123; const seq = [1, 2, 3]; let timeoutId; // 배열 끝에 도달 할 때까지 초당 하나의 값을 게시하는 숫자 배열을 따라 실행합니다. function doSequence(arr, idx) &#123; timeoutId = setTimeout(() =&gt; &#123; observer.next(arr[idx]); if (idx === arr.length - 1) &#123; observer.complete(); &#125; else &#123; doSequence(arr, idx++); &#125; &#125;, 1000); &#125; doSequence(seq, 0); // Unsubscribe 할때 timeout을 취소 합니다. return &#123;unsubscribe() &#123; clearTimeout(timeoutId); &#125;&#125;;&#125; // 위에 정의한 시퀀스를 전달하는 Observable을 새로 생성합니다.const sequence = new Observable(sequenceSubscriber); sequence.subscribe(&#123; next(num) &#123; console.log(num); &#125;, complete() &#123; console.log('Finished sequence'); &#125;&#125;); // 출력 결과:// (at 1 second): 1// (at 2 seconds): 2// (at 3 seconds): 3// (at 3 seconds): Finished sequence 두번 구독하면 매초 값이 게시되는 두개의 분리된 Stream이 생성되고, 아래와 같이 보여집니다. 1234567891011121314151617181920212223// 구독을 시작합니다. 1초후 값이 게시 됩니다.sequence.subscribe(&#123; next(num) &#123; console.log('1st subscribe: ' + num); &#125;, complete() &#123; console.log('1st sequence finished.'); &#125;&#125;); // 0.5초 후에 다시 구독합니다.setTimeout(() =&gt; &#123; sequence.subscribe(&#123; next(num) &#123; console.log('2nd subscribe: ' + num); &#125;, complete() &#123; console.log('2nd sequence finished.'); &#125; &#125;);&#125;, 500); // 출력:// (at 1 second): 1st subscribe: 1// (at 1.5 seconds): 2nd subscribe: 1// (at 2 seconds): 1st subscribe: 2// (at 2.5 seconds): 2nd subscribe: 2// (at 3 seconds): 1st subscribe: 3// (at 3 seconds): 1st sequence finished// (at 3.5 seconds): 2nd subscribe: 3// (at 3.5 seconds): 2nd sequence finished Observable을 Multicasting 으로 변경하면 다음과 같습니다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374function multicastSequenceSubscriber() &#123; const seq = [1, 2, 3]; // 각 observer를 추적합니다.(모든 활성 구독마다 하나씩). const observers = []; // 하나의 value set만 생성되고 각 subscriber로 Multicast 되기 때문에 하나의 timeoutId만 있습니다. let timeoutId; // subscribe() 함수가 invoke 될때 실행 되는 subscriber 함수를 리턴합니다. return (observer) =&gt; &#123; observers.push(observer); // 첫 번째 구독인 경우 시퀀스를 시작합니다. if (observers.length === 1) &#123; timeoutId = doSequence(&#123; next(val) &#123; // observer를 순회하면서 모든 구독에 알람을 줍니다. observers.forEach(obs =&gt; obs.next(val)); &#125;, complete() &#123; // 모든 complete 콜백에 알람을 줍니다. observers.forEach(obs =&gt; obs.complete()); &#125; &#125;, seq, 0); &#125; return &#123; unsubscribe() &#123; // observer 배열에서 제거합니다. 그리고 더이상 알람을 받지 않습니다. observers.splice(observers.indexOf(observer), 1); // Listener가 없을 경우 정리합니다. if (observers.length === 0) &#123; clearTimeout(timeoutId); &#125; &#125; &#125;; &#125;;&#125; // 배열을 순회하면서 배열의 끝에 다다를 때까지 1초에 하나의 값을 게시합니다.function doSequence(observer, arr, idx) &#123; return setTimeout(() =&gt; &#123; observer.next(arr[idx]); if (idx === arr.length - 1) &#123; observer.complete(); &#125; else &#123; doSequence(observer, arr, idx++); &#125; &#125;, 1000);&#125; // 위의 시퀀스를 전달하는 새로운 Observable을 생성합니다.const multicastSequence = new Observable(multicastSequenceSubscriber); // 구독을 시작하고 1초후에 게시를 시작합니다.multicastSequence.subscribe(&#123; next(num) &#123; console.log('1st subscribe: ' + num); &#125;, complete() &#123; console.log('1st sequence finished.'); &#125;&#125;); // 1.5초 후에 구독을 다시 시작 합니다. (첫 값은 받지 못합니다.)setTimeout(() =&gt; &#123; multicastSequence.subscribe(&#123; next(num) &#123; console.log('2nd subscribe: ' + num); &#125;, complete() &#123; console.log('2nd sequence finished.'); &#125; &#125;);&#125;, 1500); // 출력:// (at 1 second): 1st subscribe: 1// (at 2 seconds): 1st subscribe: 2// (at 2 seconds): 2nd subscribe: 2// (at 3 seconds): 1st subscribe: 3// (at 3 seconds): 1st sequence finished// (at 3 seconds): 2nd subscribe: 3// (at 3 seconds): 2nd sequence finished Multicast Observable은 조금더 많은 설정을 필요로 하지만, 어떤 어플리케이션에서는 이러한 사용법이 훨씬 더 유용할 수 있습니다. 나중에 Multicasting 프로세스를 간소화하는 도구를 살펴볼 예정이며, 또한 임의의 Observable을 가져와 Multicasting 할 수도 있습니다. 오류 처리Observable은 값을 동기적으로 생성하기 때문에 오류를 잡는데(catch) try/catch가 효율적이지 않습니다. 대신에 observer의 error 콜백을 지정하여 오류를 처리할 수 있습니다. 오류가 발생하면 Observable이 구독을 정리하고 값 생성을 중지합니다. Observable은 값을 생성하거나 (next 콜백을 호출할 수 있습니다.) complete 또는error 콜백을 호출하여 완료할 수 있습니다. 1234myObservable.subscribe(&#123; next(num) &#123; console.log('Next num: ' + num)&#125;, error(err) &#123; console.log('Received an errror: ' + err)&#125;&#125;); 오류 처리(특히 오류 복구)에 대해서는 다음 섹션에서 자세히 설명합니다. RxJS 라이브러리반응형 프로그래밍(Reactive programming)은 데이터 스트림 및 변경 전파와 관련된 비동기 프로그래밍 패러다임입니다. RxJS (Reactive Extensions for JavaScript)는 비동기 또는 콜백 기반 코드를 보다 쉽게 작성할 수 있도록 Observable을 이용한 반응형 프로그래밍 라이브러리 입니다. RxJS는 Observable 타입 구현을 제공합니다. 이 구현은 Observable이 언어(Language)의 일부 또는 브라우저가 지원할 때까지 필요합니다. 이 라이브러리는 Observable 객체를 생성하고 작업하기 위한 유틸리티 함수도 제공합니다. 이 유틸리티 함수는 다음과 같은 경우에 사용할 수 있습니다. 기존 코드를 Observable의 비동기 작업으로 변환 스트림의 값 순회 값을 다른 타입으로 매핑 스트림 필터링 여러 스트림 작성 Observable 생성 함수RxJS는 새로운 Observable을 생성하는데 사용할 수 있는 몇가지 함수를 제공합니다. 이러한 함수는 Event, Timer , Promise등으로 부터 Observable 객체를 만드는 프로세스를 단순화 할 수 있습니다. Promise로 부터 Observable 생성12345678910import &#123; fromPromise &#125; from 'rxjs';// Promise에서 Observable을 만듭니다.const data = fromPromise(fetch('/api/endpoint'));// 구독하여 비동기적으로 결과를 수신 시작data.subscribe(&#123; next(response) &#123; console.log(response); &#125;, error(err) &#123; console.error('Error: ' + err); &#125;, complete() &#123; console.log('Completed'); &#125;&#125;); Counter로 부터 Observable 생성1234567import &#123; interval &#125; from 'rxjs';// 주기적으로 값을 게시하는 Observable 생성const secondsCounter = interval(1000);// 구독하여 값의 게시를 시작secondsCounter.subscribe(n =&gt; console.log(`It's been $&#123;n&#125; seconds since subscribing!`)); 이벤트(Event)로 부터 Observable 생성1234567891011121314151617import &#123; fromEvent &#125; from 'rxjs'; const el = document.getElementById('my-element'); // 마우스 이동을 게시하는 Observable 생성const mouseMoves = fromEvent(el, 'mousemove'); // 구독하여 마우스 이동 이벤트를 수신 시작const subscription = mouseMoves.subscribe((evt: MouseEvent) =&gt; &#123; // 마우스 움직임 좌표를 로깅 console.log(`Coords: $&#123;evt.clientX&#125; X $&#123;evt.clientY&#125;`); // 마우스가 화면의 왼쪽 상단에 있을때 구독을 중지하여 마우스 이동정보 수신을 중지한다. if (evt.clientX &lt; 40 &amp;&amp; evt.clientY &lt; 40) &#123; subscription.unsubscribe(); &#125;&#125;); AJAX 요청을 생성하는 Observable 생성123456import &#123; ajax &#125; from 'rxjs/ajax';// AJAX 요청을 생성하는 Observable 생성const apiData = ajax('/api/data');// 구독하여 요청을 생성apiData.subscribe(res =&gt; console.log(res.status, res.response)); 연산자(Operator)연산자는 컬렉션의 정교한 조작을 가능하게하는 Observable의 기반이 되는 함수입니다. 예를 들어, RxJS는 map(), filter(), concat() 및 flatMap()과 같은 연산자를 정의합니다. 연산자는 설정 옵션을 사용하고 원본 Observable을 사용하는 함수를 반환합니다. 반환된 함수를 실행할 때, 연산자는 원본 Observable에서 생성된 값을 주시하여, 변환하고 변환된 값의 새로운 Observable 값을 반환합니다. 다음은 간단한 예입니다. 12345678910111213import &#123; map &#125; from 'rxjs/operators'; const nums = of(1, 2, 3); const squareValues = map((val: number) =&gt; val * val);const squaredNums = squareValues(nums); squaredNums.subscribe(x =&gt; console.log(x)); // Logs// 1// 4// 9 pipe를 사용하여 연산자를 함께 연결할 수 있습니다. pipe를 사용하면 여러 함수를 단일 함수로 결합할 수 있습니다. pipe() 함수는 결합하려는 함수를 인수로 받고, 실행될 때 작성된 순서대로 함수를 실행하는 새로운 함수를 반환합니다. Observable에 적용되는 연산자 집합은 레시피입니다. 즉, 원하는 값을 생성하기 위한 지침 집합입니다. 레시피 자체적으로는 아무 것도하지 않습니다. 레시피를 통해 결과를 얻으려면 subscribe()를 호출 해야합니다. 아래 예제를 보겠습니다. 123456789101112131415import &#123; filter, map &#125; from 'rxjs/operators'; const nums = of(1, 2, 3, 4, 5); // Observable을 받는 함수를 생성합니다.const squareOddVals = pipe( filter(n =&gt; n % 2), map(n =&gt; n * n)); // filter와 map 함수를 실행시키는 Observable을 생성합니다.const squareOdd = squareOddVals(nums); // 구독하여 결합된 함수를 실행합니다.squareOdd.subscribe(x =&gt; console.log(x)); pipe() 함수는 RxJS Observable의 메서드이기도 하므로 아래와 같이 짧은 표현식을 사용하여 동일한 연산을 정의할 수 있습니다. 12345678910import &#123; filter, map &#125; from 'rxjs/operators';const squareOdd = of(1, 2, 3, 4, 5) .pipe( filter(n =&gt; n % 2 !== 0), map(n =&gt; n * n) );// 구독하여 값을 받습니다.squareOdd.subscribe(x =&gt; console.log(x)); 일반 연산자RxJS는 많은 연산자(150개 이상)를 제공하지만 몇몇 연산자만 자주 사용됩니다. 다음은 일반 연산자 목록입니다. 사용 예는 RxJS 문서의 RxJS 5 연산자 사용 예제를 참조하십시오. Angular app의 경우 체인(chaining)을 연결하는 대신 연산자를 파이프(pipe)와 결합하는 것이 더 좋습니다. 하지만 체인(chaining)은 많은 RxJS 예제에서 사용됩니다. 영역 연산자들 생성 from , fromPromise , fromEvent , of 결합 combineLatest , concat , merge , startWith , withLatestFrom , zip 필터링 debounceTime , distinctUntilChanged , filter , take , takeUntil 변환 bufferTime , concatMap , map , mergeMap , scan , switchMap 유틸리티 tap 멀티캐스팅 share 오류 처리RxJS는 subscribe()서 사용할 수 있는 error() 핸들러 외에도 알려진 오류를 처리 할 수있는 catchError 연산자도 제공합니다. 예를 들어, API 요청을 만들고 서버의 응답에 매핑하는 Observable이 있다고 가정해 보겠습니다. 만약 서버에서 오류를 반환하거나 값이 없다면 오류가 발생합니다. 하지만 여러분이 이 오류를 잡아서 Default 값을 제공한다면, Stream은 오류 대신 계속 진행될 것입니다. 아래는 catchError 연산자를 사용하는 예제입니다. 1234567891011121314151617import &#123; ajax &#125; from 'rxjs/ajax';import &#123; map, catchError &#125; from 'rxjs/operators';// API에서 \"response\"를 반환합니다. 하지만 오류가 발생하면 빈 배열을 반환합니다.const apiData = ajax('/api/data').pipe( map(res =&gt; &#123; if (!res.response) &#123; throw new Error('Value expected!'); &#125; return res.response; &#125;), catchError(err =&gt; of([]))); apiData.subscribe(&#123; next(x) &#123; console.log('data: ', x); &#125;, error(err) &#123; console.log('errors already caught... will not run'); &#125;&#125;); 실패한 Observable 재시도catchError 연산자가 간단한 복구 경로를 제공하는 경우, retry 연산자를 사용하여 실패한 요청을 다시 시도할 수 있습니다. catchError 연산자 앞에 retry연산자를 사용합니다. 이는 Observable 원본 소스를 다시 구독하여 오류를 유발한 모든 동작 시퀀스를 다시 실행할 수 있습니다. 그리고 만약 HTTP 요청을 포함하고 있다면 HTTP 요청을 다시 보냅니다. 아래 예제는 이전 예제를 수정하여 오류를 발생하기 전에 요청을 다시 시도합니다. 123456789101112131415161718import &#123; ajax &#125; from 'rxjs/ajax';import &#123; map, retry, catchError &#125; from 'rxjs/operators'; const apiData = ajax('/api/data').pipe( retry(3), // 실패하기 전에 최대 3번 다시 시도합니다. map(res =&gt; &#123; if (!res.response) &#123; throw new Error('Value expected!'); &#125; return res.response; &#125;), catchError(err =&gt; of([]))); apiData.subscribe(&#123; next(x) &#123; console.log('data: ', x); &#125;, error(err) &#123; console.log('errors already caught... will not run'); &#125;&#125;); 인증 요청은 사용자 작업에 의해서만 시작되어야 하므로 다시 시도하지 마십시오. 사용자가 시작하지 않은 반복 로그인 요청으로 사용자 계정이 잠길수 있습니다. Observable에 대한 명명 규칙Angular 응용 프로그램은 대부분 TypeScript로 작성되기 때문에 일반적으로 변수가 Observable 일때 알 수 있습니다. 비록 Angular 프레임워크가 Observable에 대한 명명 규칙을 강제하지 않더라도 여러분은 종종 이름 끝에 “$”가 붙은 변수를 볼수 있습니다. 이러한 방법은 코드를 훑어 보며 Observable 값을 찾을때 유용할 수 있습니다. 또한, Observable에서 가장 최근의 값을 저장하는 프로퍼티를 원할 때 “$”의 유무와 상관없이 동일한 이름을 사용하는 것이 편리할 수 있습니다. 예를 들어 아래와 같습니다.123456789101112131415161718import &#123; Component &#125; from '@angular/core';import &#123; Observable &#125; from 'rxjs'; @Component(&#123; selector: 'app-stopwatch', templateUrl: './stopwatch.component.html'&#125;)export class StopwatchComponent &#123; stopwatchValue: number; stopwatchValue$: Observable&lt;number&gt;; start() &#123; this.stopwatchValue$.subscribe(num =&gt; this.stopwatchValue = num ); &#125;&#125; Angular에서 ObservableAngular는 Observable을 다양한 공통의 비동기 작업을 처리하기 위한 인터페이스로 사용합니다. 예를 들어: EventEmitter 클래스는 Observable를 상속받습니다. HTTP 모듈은 Observable을 사용하여 AJAX 요청 및 응답을 처리합니다. Router 및 Form 모듈은 Observable을 사용하여 사용자 입력 이벤트를 수신하고 응답합니다. Event EmitterAngular는 @Output() 데코레이터를 통해 Component의 값을 게시할 때 사용되는 EventEmitter 클래스를 제공합니다. EventEmitter는 Observable을 상속하고 emit() 메서드를 추가하여 임의의 값을 방출할 수 있습니다. emit() 메서드를 호출하면 방출된 값을 구독하고 있는 observer의 next() 메서드로 전달합니다. EventEmitter 문서에서 좋은 예제들을 찾을 수 있습니다. 다음은 open 및 close 이벤트를 수신하는 예제 Component 입니다. 1&lt;zippy (open)=\"onOpen($event)\" (close)=\"onClose($event)\"&gt;&lt;/zippy&gt; 아래는 Component에 대한 정의입니다. 123456789101112131415161718192021222324@Component(&#123; selector: 'zippy', template: ` &lt;div class=\"zippy\"&gt; &lt;div (click)=\"toggle()\"&gt;Toggle&lt;/div&gt; &lt;div [hidden]=\"!visible\"&gt; &lt;ng-content&gt;&lt;/ng-content&gt; &lt;/div&gt; &lt;/div&gt;`&#125;) export class ZippyComponent &#123; visible = true; @Output() open = new EventEmitter&lt;any&gt;(); @Output() close = new EventEmitter&lt;any&gt;(); toggle() &#123; this.visible = !this.visible; if (this.visible) &#123; this.open.emit(null); &#125; else &#123; this.close.emit(null); &#125; &#125;&#125; HTTPAngular의 HttpClient는 HTTP 메서드 호출에서 Observable을 반환합니다. 예를 들어 http.get(&#39;/api&#39;)은 Observable을 반환합니다. 이러한 방식은 Promise 기반의 API에 비해 몇가지 장점을 제공합니다. Observables는 서버 응답을 변경하지 않습니다 (Promise의 .then() 호출을 통해 발생할 수 있음). 대신에 필요하다면 일련의 연산자를 이용하여 값을 변형할 수 있습니다. unsubscribe() 메서드를 통해 HTTP 요청을 취소할 수 있습니다. 요청에 대한 설정을 통해 진행 이벤트 업데이트를 가져올 수 있습니다. 실패한 요청을 쉽게 재시도할 수 있습니다. 비동기 Pipe (Async Pipe)AsyncPipe는 Observable 또는 Promise를 구독하고 방출된 최신 값을 반환합니다. 새 값이 방출(emit)되면 Pipe는 변경 사항을 검사할 Component를 표시합니다. 아래 예제는 time Observable을 Component의 뷰에 바인딩 합니다. Observable은 연속적으로 현재 시각을 뷰에 업데이트 합니다.12345678910@Component(&#123; selector: 'async-observable-pipe', template: `&lt;div&gt;&lt;code&gt;observable|async&lt;/code&gt;: Time: &#123;&#123; time | async &#125;&#125;&lt;/div&gt;`&#125;)export class AsyncObservablePipeComponent &#123; time = new Observable(observer =&gt; setInterval(() =&gt; observer.next(new Date().toString()), 1000) );&#125; RouterRouter.events는 이벤트를 Observable로 제공합니다. RxJS의 filter() 연산자를 사용하여 관심있는 이벤트를 찾을수 있고 Navigation 프로세스의 이벤트 순서를 기반으로 의사 결정을 내리기 위해 구독할 수 있습니다. 예를 들어: 1234567891011121314151617181920212223import &#123; Router, NavigationStart &#125; from '@angular/router';import &#123; filter &#125; from 'rxjs/operators'; @Component(&#123; selector: 'app-routable', templateUrl: './routable.component.html', styleUrls: ['./routable.component.css']&#125;)export class Routable1Component implements OnInit &#123; navStart: Observable&lt;NavigationStart&gt;; constructor(private router: Router) &#123; // NavigationStart만 게시하기 위한 새로운 Observable을 생성합니다. this.navStart = router.events.pipe( filter(evt =&gt; evt instanceof NavigationStart) ) as Observable&lt;NavigationStart&gt;; &#125; ngOnInit() &#123; this.navStart.subscribe(evt =&gt; console.log('Navigation Started!')); &#125;&#125; ActivatedRoute는 Observable을 사용하여 Route path 및 파라미터에 대한 정보를 가져 오는 Inject된 Router Service입니다. 예를 들어, ActivateRoute.url]에는 Route path를 보고하는 Observable을 포함하고 있습니다. 123456789101112131415import &#123; ActivatedRoute &#125; from '@angular/router'; @Component(&#123; selector: 'app-routable', templateUrl: './routable.component.html', styleUrls: ['./routable.component.css']&#125;)export class Routable2Component implements OnInit &#123; constructor(private activatedRoute: ActivatedRoute) &#123;&#125; ngOnInit() &#123; this.activatedRoute.url .subscribe(url =&gt; console.log('The URL changed to: ' + url)); &#125;&#125; 반응형 Form (Reactive form)반응형 Form은 Observable을 사용하여 Form control 값을 모니터링하는 프로퍼티를 가지고 있습니다. FormControl 프로퍼티는 변경 이벤트를 발생시키는 valueChanges 및 statusChanges Observable을 포함합니다. Observable From control 프로퍼티를 구독하는 것은 Component 클래스 내에서 응용 프로그램 로직을 실행시키는 방법입니다. 1234567891011121314151617181920import &#123; FormGroup &#125; from '@angular/forms'; @Component(&#123; selector: 'my-component', template: 'MyComponent Template'&#125;)export class MyComponent implements OnInit &#123; nameChangeLog: string[] = []; heroForm: FormGroup; ngOnInit() &#123; this.logNameChange(); &#125; logNameChange() &#123; const nameControl = this.heroForm.get('name'); nameControl.valueChanges.forEach( (value: string) =&gt; this.nameChangeLog.push(value) ); &#125;&#125; Observable의 실제 사용방법다음은 Observable이 특히 유용한 도메인의 예입니다. 자동완성(Type-ahead suggestion)Observable은 자동완성(Type-ahead)의 구현을 간단히할 수 있습니다. 일반적으로 자동완성(Type-ahead)은 일련의 별도 작업을 수행해야합니다. 입력 데이터 수신합니다. 값에서 공백을 제거하고, 최소 길이인지 확인합니다. Debounce(모든 키 입력에 대해 API 요청을 보내지 않고 대신 키 입력이 중단될 때까지 대기). 값이 동일하게 유지되면 요청을 보내지 않습니다 (예를 들어 문자를 빠르게 치고 백스 페이스 하는등). 업데이트된 결과로 인해 결과가 무효화되는 경우 진행중인 AJAX 요청을 취소합니다. 이런 내용을 JavaScript로 전체 작성하면 상당히 복잡할 수 있습니다. 하지만 Observable를 사용하면 간단한 일련의 RxJS 연산자를 사용할 수 있습니다. 1234567891011121314151617import &#123; fromEvent &#125; from 'rxjs';import &#123; ajax &#125; from 'rxjs/ajax';import &#123; map, filter, debounceTime, distinctUntilChanged, switchMap &#125; from 'rxjs/operators'; const searchBox = document.getElementById('search-box'); const typeahead = fromEvent(searchBox, 'input').pipe( map((e: KeyboardEvent) =&gt; e.target.value), filter(text =&gt; text.length &gt; 2), debounceTime(10), distinctUntilChanged(), switchMap(() =&gt; ajax('/api/endpoint'))); typeahead.subscribe(data =&gt; &#123; // API로 부터 받은 데이터 처리&#125;); Exponential backoff 대규모 서비스를 설계할 때, 적절한 타임아웃 설정이 중요합니다. 실제로 어떤 요청에 대해 부하 상태 등으로 타임아웃이 발생하게 되면 그 다음 요청에 대한 응답을 조금 더 긴 시간에 랜덤으로 처리하는 방법을 엑스포넨셜 백오프(exponential backoff)라고 합니다. 엑스포넨셜 백오프는 API 요청 실패후 재시도하고, 연속적인 실패가 발생할 때마다 재시도 간격을 늘립니다. 그리고 최대 재시도 횟수이후 요청이 실패한 것으로 간주하는 기술입니다. 이러한 내용을 Promise와 AJAX 호출을 추적하는 다른 메서드로 구현하는 것은 꽤 복잡 할 수 있습니다. 하지만 Observable로 구현하는 것은 매우 쉽습니다. 1234567891011121314151617181920212223import &#123; pipe, range, timer, zip &#125; from 'rxjs';import &#123; ajax &#125; from 'rxjs/ajax';import &#123; retryWhen, map, mergeMap &#125; from 'rxjs/operators'; function backoff(maxTries, ms) &#123; return pipe( retryWhen(attempts =&gt; range(1, maxTries) .pipe( zip(attempts, (i) =&gt; i), map(i =&gt; i * i), mergeMap(i =&gt; timer(i * ms)) ) ) );&#125; ajax('/api/endpoint') .pipe(backoff(3, 250)) .subscribe(data =&gt; handleData(data)); function handleData(data) &#123; // ...&#125; 다른 기술들과 Observable 비교Observable을 이용하여 Promise 대신 값을 비동기로 전달할 수 있고, Event 핸들러 대신 사용할 수 있습니다. 그리고 Observable이 여러개의 값을 전달할 수 있기 때문에 Array를 만들고 처리할 수 있는 곳에 사용할 수 있습니다. Observable는 이러한 각각의 상황에서 대체 기술과 다소 다르게 동작하지만 중요한 이점을 제공합니다. 다음은 차이점에 대한 자세한 비교 내용입니다. Observable과 Promise 비교Observable은 종종 Promise와 비교됩니다. 주요 차이점은 다음과 같습니다. Observable은 선언적입니다. 구독이 될 때까지 실행을 하지 않습니다. 하지만 Promise는 생성즉시 실행이 됩니다. 따라서 Observable은 결과가 필요할 때마다 실행할 수 있는 레시피를 정의하는데 유용합니다. Observable 다수의 값을 제공할 수 있습니다. 하지만 Promise는 하나만 제공합니다. Observable은 시간이 지남에 따라 여러 값을 얻는데 유용할 수 있습니다. Observable는 체인과 구독을 구분합니다. 하지만 Promise에는 .then() 절만 있습니다. 이것은 Observable로 시스템의 다른 부분에서 사용할 수 있고, 작업이 바로 실행 되지 않는 복잡한 변환 레시피를 만드는데 유용하게 합니다. Observable의 subscribe()는 오류 처리를 담당합니다. Promise는 오류를 자식(Child) Promise로 넘깁니다. 따라서 Observable은 중앙 집중적이고 예측 가능한 오류 처리에 유용합니다. 생성과 구독 Observable은 Consumer가 구독할 때까지 실행되지 않습니다. subscribe()는 행위에 대한 정의를 한번 실행하고, 다시 호출할 수 있습니다. 각 구독은 고유한 계산이 존재 합니다. 그리고 재구독은 값의 재계산을 유발합니다. 123456// 게시 작업을 선언합니다.new Observable((observer) =&gt; &#123; subscriber_fn &#125;);// 실행을 시작observable.subscribe(() =&gt; &#123; // observer가 알람을 처리 &#125;); Promise는 즉시 한번만 실행이 됩니다. 결과 계산은 Promise가 만들어지면 시작됩니다. 작업을 재시작 할 수 있는 방법이 없습니다. 모든 then 절(구독)은 동일한 계산을 공유합니다. 123456// 실행 시작new Promise((resolve, reject) =&gt; &#123; executer_fn &#125;);// 반환값을 처리promise.then((value) =&gt; &#123; // 여기에서 결과값을 처리 &#125;); 체인(Chaining) Observable은 map과 같은 변환 함수와 구독(subscription)을 구분합니다. 구독(subscription)만 subscriber 함수를 활성화하여 값 계산을 시작합니다. 1observable.map((v) =&gt; 2*v); Promise는 마지막 .then 절(구독과 동일)과 중간 .then 절 (map과 동일)을 구별하지 않습니다. 1promise.then((v) =&gt; 2*v); 취소(Cancellation) Observable 구독을 취소할 수 있습니다. 구독 취소는 수신자(listener)가 더 이상 값을 받지 못하도록 하고 subscriber 함수에 작업 취소를 알립니다. 12const sub = obs.subscribe(...);sub.unsubscribe(); Promise는 취소가 가능하지 않습니다. 오류 처리 (Error handling) Observable 실행 오류는 subscriber의 오류 처리기로 전달되며 subscriber는 자동으로 Observable에서 구독을 취소합니다. 123obs.subscribe(() =&gt; &#123; throw Error('my error');&#125;); Promise는 자식 Promise에 오류를 넘깁니다. 123promise.then(() =&gt; &#123; throw Error('my error');&#125;); Cheat sheet아래 코드는 Observable과 Promise를 이용하여 같은 종류의 연산을 정의하는 방법을 보여줍니다. 생성 (Creation) Observable 123new Observable((observer) =&gt; &#123; observer.next(123);&#125;); Promise 123new Promise((resolve, reject) =&gt; &#123; resolve(123);&#125;); 변환 (Transform) Observable 1obs.map((value) =&gt; value * 2 ); Promise 1promise.then((value) =&gt; value * 2); 구독 (Subscribe) Observable 123sub = obs.subscribe((value) =&gt; &#123; console.log(value)&#125;); Promise 123promise.then((value) =&gt; &#123; console.log(value);&#125;); 구독 취소 (Unsubscribe) Observable 1sub.unsubscribe(); Promise : Promise의 해결(resolve)로 암묵적으로 처리 Observable과 Event API 비교Observable은 Event API를 사용하는 Event 핸들러와 매우 유사합니다. 이 두 개술은 모두 알람에 대한 핸들러를 정의하고 시간이 지남에 따라 전달되는 여러 값을 처리하는데 사용합니다. Observable을 구독하는 것은 Event Listener를 추가하는 것과 같습니다. 한가지 주요한 다른점은 Observable은 이벤트가 핸들러에 전달되기 전에 이벤트를 변환하도록 구성할 수 있다는 것입니다. Observable을 사용하여 Event 및 비동기 작업을 처리하면 HTTP 요청과 같은 컨텍스트에서 일관성이 향상됩니다. 다음은 Observable와 Event API를 사용하여 같은 종류의 연산을 정의하는 방법을 보여주는 코드 샘플입니다. 생성과 취소 (Creation &amp; cancellation) Observable 1234567// Setuplet clicks$ = fromEvent(buttonEl, ‘click’);// Begin listeninglet subscription = clicks$ .subscribe(e =&gt; console.log(‘Clicked’, e))// Stop listeningsubscription.unsubscribe(); Event API 1234567function handler(e) &#123; console.log(‘Clicked’, e);&#125;// Setup &amp; begin listeningbutton.addEventListener(‘click’, handler);// Stop listeningbutton.removeEventListener(‘click’, handler); 구독 (Subscription) Observable 123observable.subscribe(() =&gt; &#123; // notification handlers here&#125;); Event API 123element.addEventListener(eventName, (event) =&gt; &#123; // notification handler here&#125;); 구성 (Configuration) ObservableKeystroke를 Listen 하지만 입력 값을 나타내는 Stream을 제공합니다. 123fromEvent(inputEl, 'keydown').pipe( map(e =&gt; e.target.value)); Event API구성은 제공하지 않습니다. 123element.addEventListener(eventName, (event) =&gt; &#123; // 핸들러에 도착하기 전에 전달된 이벤트를 다른 값으로 변경할 수 없습니다.&#125;); Observable과 Array 비교Observable은 시간이 지남에 따라 값을 발생시킵니다. Array는 정적인 값 집합으로 만들어집니다. 어떤 의미에서, Observable은 Array가 동기적인 곳에서 비동기적입니다. 다음 예에서 ➞는 비동기 값 전달을 의미합니다. Given Observable 12obs: ➞1➞2➞3➞5➞7obsB: ➞'a'➞'b'➞'c' Array 12arr: [1, 2, 3, 5, 7]arrB: ['a', 'b', 'c'] concat() Observable 12obs.concat(obsB)➞1➞2➞3➞5➞7➞'a'➞'b'➞'c' Array 12arr.concat(arrB)[1,2,3,5,7,'a','b','c'] filter() Observable 12obs.filter((v) =&gt; v&gt;3)➞5➞7 Array 12arr.filter((v) =&gt; v&gt;3)[5, 7] find() Observable 12obs.find((v) =&gt; v&gt;3)➞5 Array 12arr.find((v) =&gt; v&gt;3)5 findIndex() Observable 12obs.findIndex((v) =&gt; v&gt;3)➞3 Array 12arr.findIndex((v) =&gt; v&gt;3)3 forEach() Observable 12345678obs.forEach((v) =&gt; &#123; console.log(v);&#125;)12357 Array 12345678arr.forEach((v) =&gt; &#123; console.log(v);&#125;)12357 map() Observable 12obs.map((v) =&gt; -v)➞-1➞-2➞-3➞-5➞-7 Array 12arr.map((v) =&gt; -v)[-1, -2, -3, -5, -7] reduce() Observable 12obs.scan((s,v)=&gt; s+v, 0)➞1➞3➞6➞11➞18 Array 12arr.reduce((s,v) =&gt; s+v, 0)18 이 내용은 나중에 참고하기 위해 Angular 6.0.4 기술 문서를 공부하며 정리한 내용입니다.의역, 오역, 직역이 있을 수 있음을 알려드립니다.This post is a translation of this original article [https://angular.io/guide/observables, https://angular.io/guide/rx-library, https://angular.io/guide/observables-in-angular, https://angular.io/guide/comparing-observables] 참고 Angular 튜토리얼 - 소개 Angular 튜터리얼 - Hero 에디터 Angular 튜터리얼 - Master/Detail Angular 튜터리얼 - 다중 콤포넌트 Angular 튜터리얼 - 서비스 Angular 튜터리얼 - 라우팅 Angular 튜터리얼 - HTTP Angular HttpClient Angular에서 간단하게 번역기능 구현하기 Angular 동적 컴포넌트 로딩 Angular에서 동적 컨텐츠 생성 Angular에서 ViewChildren, ContentChildren, 그리고 QueryList 이해하기","categories":[{"name":"Angular","slug":"Angular","permalink":"http://infoscis.github.io/categories/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://infoscis.github.io/tags/Angular/"}]},{"title":"ECMAScript 6 부록 B. ECMAScript 7 (2016) 이해하기","slug":"ecmascript-6-appendix-b-understanding-ecmascript-7","date":"2018-02-27T13:32:48.000Z","updated":"2018-02-27T14:11:41.460Z","comments":true,"path":"2018/02/27/ecmascript-6-appendix-b-understanding-ecmascript-7/","link":"","permalink":"http://infoscis.github.io/2018/02/27/ecmascript-6-appendix-b-understanding-ecmascript-7/","excerpt":"","text":"ECMAScript 6 부록 B. ECMAScript 7 (2016) 이해하기ECMAScript 6의 개발은 약 4년이 걸렸으며, 그후 TC-39는 이러한 긴 개발 프로세스가 지속 가능하지 않다고 결정했습니다. 대신, 매년 릴리즈하는 주기로 전환하여 새로운 기능 적용을 더 빨리 진행할 수 있도록 했습니다. 더자주 출시되려면 ECMAScript의 새버전은 ECMAScript 6보다 새로운 기능이 적어야합니다. 이 변경 사항을 나타내기 위해 새버전의 사양에는 더이상 버전 번호가 표시되지 않으며 대신 사양이 게시된 연도를 나타냅니다. 결과적으로 ECMAScript 6은 ECMAScript 2015로 알려져 있으며 ECMAScript 7은 공식적으로 ECMAScript 2016으로 알려져 있습니다. TC-39는 향후 모든 ECMAScript 에디션에 연도 기반 명명 시스템을 사용할 것으로 기대하고 있습니다. ECMAScript 2016은 2016년 3월에 완성되었으며 새로운 수학 연산자, 새로운 Array 메서드 및 새로운 구문 오류가 추가된 3가지 기능만 포함되었습니다. 모두 이 부록에서 다룹니다. 지수 연산자ECMAScript 2016에서 소개된 JavaScript 구문의 유일한 변경 사항은 지수 연산자입니다. 이는 베이스에 지수를 적용하는 수학 연산입니다. JavaScript는 지수 연산을 수행하기 위해 이미 Math.pow() 메서드를 가지고 있었지만 JavaScript는 공식 연산자가 아닌 메서드를 필요로하는 유일한 언어중 하나이기도합니다. (일부 개발자들은 연산자가 읽고 이해하기가 더 쉽다고 주장합니다.) 지수 연산은 두개의 별표(**)이며 왼쪽 피연산자는 베이스이고 오른쪽 피연산자는 지수입니다. 1234let result = 5 ** 2;console.log(result); // 25console.log(result === Math.pow(5, 2)); // true 이 예제에서는 5^2와 동일한 25를 계산합니다. Math.pow()를 사용하여 동일한 결과를 얻을 수 있습니다. 연산자 우선순위지수 연산자는 JavaScript에서 모든 2진 연산자중 우선 순위가 가장 높습니다 (단항 연산자는 **보다 우선 순위가 높음). 즉, 아래 예제에서와 같이 모든 복합 연산에서 처음에 적용됩니다. 12let result = 2 * 5 ** 2;console.log(result); // 50 먼저 5^2의 계산이 수행되고 결과 값에 2를 곱해 최종 결과 50을 얻습니다. 피연산자 제한지수 연산자는 다른 연산자에 대해 존재하지 않는 다소 특이한 제한이 있습니다. 지수 연산의 왼쪽은 ++ 또는 --이외의 단항식일 수 없습니다. 예를 들어 아래는 잘못된 구문입니다. 12// 구문 오류let result = -5 ** 2; 이 예제에서 -5는 연산 순서가 모호하기 때문에 구문 오류입니다. -는 5 또는 5 ** 2 표현식의 어떤 결과에 적용되어야 할까요? 지수 연산자의 왼쪽에 단항식을 허용하지 않으면 해당 모호성이 제거됩니다. 의도를 명확하게 지정하려면 다음과 같이 -5 또는 5 ** 2 주변에 괄호를 포함시켜야합니다. 12345// oklet result1 = -(5 ** 2); // equal to -25// also oklet result2 = (-5) ** 2; // equal to 25 식 주변에 괄호를 넣으면 -가 전체에 적용됩니다. 괄호가 -5를 둘러 싸면 -5의 2승에 대한 계산이 분명해집니다. 지수 연산자의 왼쪽에 ++ 및 --를 사용하면 두 연산자가 피연산자에 대해 명확하게 정의된 동작을 하기 때문에 괄호가 필요하지 않습니다. 접두어 ++ 또는 --는 다른 연산이 수행되기 전에 피연산자를 변경하며, 접미어 버전은 전체 표현식이 평가될 때까지 변경 사항을 적용하지 않습니다. 이 코드는 다음과 같이 이 연산자의 왼쪽에서 두 사례 모두 안전합니다. 12345678let num1 = 2, num2 = 2;console.log(++num1 ** 2); // 9console.log(num1); // 3console.log(num2-- ** 2); // 4console.log(num2); // 1 이 예제에서, 지수 연산자가 적용되기 전에 num1이 증가하기 때문에 num1은 3이되고 연산 결과는 9가됩니다. num2의 경우, 지수 연산값은 2를 유지한 다음 1로 감소합니다. Array.prototype.includes() 메서드주어진 문자열 내에 특정 부분 문자열이 존재하는지 확인하기 위해 ECMAScript 6에 String.prototype.includes()를 추가했음 기억하실 것입니다. 원래 ECMAScript 6에는 문자열과 Array를 비슷한 방식으로 처리하기 위해 Array.prototype.includes() 메서드를 도입했습니다. 그러나 Array.prototype.includes()에 대한 사양을 ECMAScript 6 마감 시한에 완료하지 못하고 Array.prototype.includes()는 ECMAScript 2016에서 완료되었습니다. Array.prototype.includes() 사용법Array.prototype.includes() 메서드는 검색할 값과 검색을 시작할 선택적 인덱스라는 두개의 파라미터를 받습니다. 두 번째 파라미터가 제공되면 includes()가 해당 인덱스에서 검색을 시작합니다. (기본 시작 인덱스는 0입니다.) 값이 Array 안에 있으면 true를 반환하고 그렇지 않으면 false를 반환합니다. 1234567let values = [1, 2, 3];console.log(values.includes(1)); // trueconsole.log(values.includes(0)); // false// 인덱스 2부터 검색 시작console.log(values.includes(1, 2)); // false 여기서 values.includes()를 호출하면 1의 값은 true를, 0은 Array에 없기 때문에 false를 반환합니다. 두 번째 파라미터가 인덱스 2 (값 3을 포함)에서 검색을 시작하는데 사용되고, 인덱스 2와 Array의 끝 사이에 숫자 1이 없기 때문에 values.includes() 메서드는 false를 반환합니다. 값 비교includes() 메서드에 의해 수행된 값 비교는 한가지 예외를 제외하고는 === 연산자를 사용합니다(NaN === NaN이 false로 평가 되더라도NaN은 NaN과 같은 것으로 간주됩니다). 이는 비교를 위해 엄격하게 ===를 사용하는 indexOf() 메서드의 동작과는 다릅니다. 차이점을 확인하기위해 다음 코드를 살펴 보겠습니다. 1234let values = [1, NaN, 2];console.log(values.indexOf(NaN)); // -1console.log(values.includes(NaN)); // true values.indexOf() 메서드는 NaN이 values Array에 포함되어 있더라도 NaN에 대해 -1을 반환합니다. 하지만, values.includes()는 다른 값 비교 연산자를 사용하기 때문에 NaN에 대해 true를 반환합니다. Array에서 값의 존재만을 확인하고 인덱스를 알 필요가 없는 경우 NaN을 처리하는 방법의 차이 때문에 includes()를 사용하는 것이 좋습니다. 하지만 Array의 어느 위치에 값이 있는지 알아야하는 경우 indexOf() 메서드를 사용해야합니다. 이 구현의 또 다른 단점은 +0과 -0이 같은 것으로 간주된다는 것입니다. 이 경우 indexOf() 및 includes()의 동작은 동일합니다. 1234let values = [1, +0, 2];console.log(values.indexOf(-0)); // 1console.log(values.includes(-0)); // true 여기에서 indexOf()와 includes()는 두값이 같다고 간주되어 -0이 전달되면 +0을 찾습니다. 이것은 +0 및 -0을 다른 값으로 간주하는 Object.is() 메서드의 동작과 다릅니다. 함수 Scope의 Strict 모드 변경strict 모드가 ECMAScript 5에 도입되었을 때, ECMAScript 6의 변화보다 더 단순했습니다. 그럼에도 불구하고 ECMAScript 6에서는 전역 Scope(모든 코드가 strict 모드로 실행됨) 또는 함수 Scope에서(함수만 strict 모드로 실행됨) “use strict” 지시문을 사용하여 strict 모드를 지정할 수있었습니다. 후자는 ECMAScript 6에서 파라미터를 정의할 수있는 보다 복잡한 방법, 특히 Destructuring 및 Default 파라미터로 인해 문제가되었습니다. 아래 코드를 살펴 보겠습니다. 12345function doSomething(first = this) &#123; \"use strict\"; return first;&#125; 여기서, 명명된 파라미터 first에는 Default 값으로 this가 할당됩니다. first의 값이 무엇이라고 기대 하시겠습니까? 이 경우, ECMAScript 6 사양은 strict 모드로 실행되는 파라미터를 처리하도록 JavaScript 엔진에 지시 했으므로 this는 undefined와 같아야합니다. 그러나 strict 모드에서 실행중인 파라미터를 구현할 때 “use strict” 기능이 있는 경우 파라미터 Default값이 기능을 수행할 수 있기 때문에 매우 어려웠습니다. 이러한 어려움으로 인해 대부분의 JavaScript 엔진은 이 기능을 구현하지 못했습니다 (따라서 this는 전역 객체와 동일합니다). 구현의 어려움으로 인해 ECMAScript 2016은 파라미터가 Destructuring되거나 Default값을 갖는 함수 내부에 “use strict” 지시문을 사용하는 것을 구문 오류로 판단합니다. 함수의 본문에 “use strict”가 있는 경우 단순 파라미터 목록(simple parameter list), 즉 Destructuring 또는 Default값을 포함하지 않는 파라미터 목록만 허용됩니다. 아래 예제를 살펴보겠습니다. 1234567891011121314151617181920// okay - using simple parameter listfunction okay(first, second) &#123; \"use strict\"; return first;&#125;// syntax errorfunction notOkay1(first, second=first) &#123; \"use strict\"; return first;&#125;// syntax errorfunction notOkay2(&#123; first, second &#125;) &#123; \"use strict\"; return first;&#125; 단순 파라미터 목록에서 “use strict”를 사용할 수 있습니다. 따라서 okay()가 예상대로 작동합니다(ECMAScript 5에서와 동일). notOkay1() 함수는 Default 파라미터 값을 가진 함수라서 더 이상 “use strict”를 사용할 수 없으므로 구문 오류입니다. 비슷하게, notOkay2() 함수는 Destructuring 파라미터를 가진 함수라서 “use strict”를 사용할 수 없기 때문에 마찮가지로 구문 오류입니다. 전반적으로 이러한 변경으로 인해 JavaScript 개발자가 느끼는 혼란스러운 점과 JavaScript 엔진의 구현상 문제가 모두 제거됩니다. 이 내용은 나중에 참고하기 위해 제가 공부하며 정리한 내용입니다.의역, 오역, 직역이 있을 수 있음을 알려드립니다.This post is a translation of this original article [https://leanpub.com/understandinges6/read#leanpub-auto-appendix-b-understanding-ecmascript-7-2016] 참고 ECMAScript 6 Block Binding ECMAScript 6 문자열과 정규 표현식 ECMAScript 6 함수 ECMAScript 6 객체의 확장된 기능 ECMAScript 6 쉬운 데이터 액세스를 위한 Destructuring ECMAScript 6 Symbol과 Symbol 프로퍼티 ECMAScript 6 Set과 Map ECMAScript 6 Iterator와 Generator ECMAScript 6 JavaScript 클래스 소개 ECMAScript 6 Array 기능 향상 ECMAScript 6 Promise와 비동기 프로그램밍 ECMAScript 6 프록시와 리플렉션 API ECMAScript 6 Module로 코드 캡슐화하기 ECMAScript 6 부록 A. 작은 변경 사항 ECMAScript 6 부록 B. ECMAScript 7(2016) 이해하기","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://infoscis.github.io/categories/JavaScript/"},{"name":"ECMAScript 2015","slug":"JavaScript/ECMAScript-2015","permalink":"http://infoscis.github.io/categories/JavaScript/ECMAScript-2015/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://infoscis.github.io/tags/JavaScript/"},{"name":"ECMAScript 2015","slug":"ECMAScript-2015","permalink":"http://infoscis.github.io/tags/ECMAScript-2015/"}]},{"title":"ECMAScript 6 부록 A. 작은 변경 사항","slug":"ecmascript-6-appendix-a-smaller-changes","date":"2018-02-27T13:32:12.000Z","updated":"2018-02-27T14:11:33.451Z","comments":true,"path":"2018/02/27/ecmascript-6-appendix-a-smaller-changes/","link":"","permalink":"http://infoscis.github.io/2018/02/27/ecmascript-6-appendix-a-smaller-changes/","excerpt":"","text":"ECMAScript 6 부록 A. 작은 변경 사항이 책에서 설명한 주요 변경 사항과 함께 ECMAScript 6은 작지만 JavaScript를 향상시키는데 도움이되는 몇가지 다른 변경 사항을 적용했습니다. 이러한 변경에는 정수를 더 쉽게 사용하고 계산하기 위한 새로운 메서드를 추가하였고, 유니 코드 식별자를 조정하고, __proto__ 프로퍼티를 공식화하는 작업이 포함됩니다. 부록에서 이 모든 내용을 설명합니다. 정수(Integer) 작업JavaScript는 IEEE 754 인코딩 시스템을 사용하여 정수와 부동 소수점을 모두 표현하므로 수년 동안 많은 혼란을 야기했습니다. JavaScript는 개발자가 숫자 인코딩의 세부사항에 대해 걱정할 필요가 없도록 하기위해 엄청난 노력을 기울였지만 문제는 계속되었습니다. ECMAScript 6은 정수를 쉽게 식별하고 사용할 수 있게함으로써 이 문제를 해결하려고 노력합니다. 정수 확인하기첫번째로, ECMAScript 6은 JavaScript에서 값(value)이 정수를 나타내는지 여부를 확인할 수있는 Number.isInteger() 메서드를 추가했습니다. JavaScript는 IEEE 754를 사용하여 두 타입의 숫자를 모두 나타내지만, 실수와 정수는 다르게 저장됩니다. Number.isInteger() 메서드는 이를 활용하여 메서드를 호출하면 JavaScript 엔진은 값의 기본 표현을 보고 해당 값이 정수인지 여부를 확인합니다. 즉, 실수처럼 보이는 숫자가 실제로 정수로 저장되어 있어도 Number.isInteger()가 true를 반환하도록 합니다. 123console.log(Number.isInteger(25)); // trueconsole.log(Number.isInteger(25.0)); // trueconsole.log(Number.isInteger(25.1)); // false 이 코드에서 Number.isInteger()는 25와 25.0 모두에 대해 후자가 실수처럼 보일지라도 true를 반환합니다. 숫자에 소수점을 추가하는 것만으로 자동으로 JavaScript에서 부동 소수점을 차지하지 않습니다. 25.0은 실제로 25와 같기 때문에 정수로 저장됩니다. 그러나 숫자 25.1는 분수 값이 있으므로 실수로 저장됩니다. 안전한 정수IEEE 754는 -2^53와 2^53 사이의 정수만 정확하게 나타낼 수 있으며 이 “안전” 범위를 벗어나면 바이너리 표현은 여러개의 숫자 값으로 재사용됩니다. 즉, JavaScript는 IEEE 754 범위 내의 정수만 안전하게 나타낼 수 있습니다. 예를 들어 다음 코드를 살펴보겠습니다. 12console.log(Math.pow(2, 53)); // 9007199254740992console.log(Math.pow(2, 53) + 1); // 9007199254740992 이 예제에서 두개의 다른 숫자가 동일한 JavaScript 정수로 표시됩니다. 값이 안전 범위를 벗어날수록 효과가 더 커집니다. ECMAScript 6에서는 JavaScript가 정확하게 나타낼 수 있는 정수를 보다 잘 식별할 수 있도록 Number.isSafeInteger() 메서드를 도입했습니다. 또한 정수 범위의 상한과 하한을 각각 나타내는 Number.MAX_SAFE_INTEGER 및 Number.MIN_SAFE_INTEGER 프로퍼티를 추가했습니다. Number.isSafeInteger() 메서드는 값이 정수이고 아래의 예제에서와 같이 정수값의 안전한 범위내에 있는지 확인합니다. 12345678var inside = Number.MAX_SAFE_INTEGER, outside = inside + 1;console.log(Number.isInteger(inside)); // trueconsole.log(Number.isSafeInteger(inside)); // trueconsole.log(Number.isInteger(outside)); // trueconsole.log(Number.isSafeInteger(outside)); // false inside는 가장 큰 안전한 정수이므로 Number.isInteger()와 Number.isSafeInteger() 메서드 모두에 대해 true를 반환합니다. outside는 의심되는 첫 번째 정수값이며, 정수이지만 안전하지 않은 것으로 간주됩니다. 대부분의 경우, JavaScript에서 정수 연산 또는 비교를 수행할 때 안전한 정수를 처리하기를 원하므로 입력 유효성 검사의 일부로 Number.isSafeInteger()를 사용하는 것이 좋습니다. 새로운 Math 메서드ECMAScript 6에서 Typed array가 JavaScript에 포함되어 게임 및 그래픽에 대한 JavaScript 엔진이 많은 수학적 계산을 보다 효율적으로 수행할 수 있다는 사실을 깨닫게됩니다. 그러나 asm.js와 같은 최적화 전략은 성능을 향상시키기 위해 JavaScript의 하위 집합에서 작동되고, 가능한 가장 빠른 방법으로 계산을 수행하는데 더 많은 정보가 필요합니다. 예를 들어, 숫자를 32비트 정수로 처리해야하는지 아니면 64비트 부동 소수점으로 처리해야하는지 여부를 아는 것이 중요하고, 소프트웨어 기반 연산보다 하드웨어 기반 연산이 훨씬 빠릅니다. 결과적으로, ECMAScript 6는 일반적인 수학적 계산의 속도를 향상시키기 위해 여러 가지 메서드를 Math 객체에 추가했습니다. 일반 계산 속도를 향상 시키면 그래픽 프로그램과 같이 많은 계산을 수행하는 응용 프로그램의 전체 속도가 향상됩니다. 새로운 메서드는 다음과 같습니다. Math.acosh(x) x의 역쌍곡선 코사인을 반환합니다. Math.asinh(x) x의 역쌍곡선 사인을 돌려줍니다. Math.atanh(x) x의 역쌍곡선 탄젠트를 반환합니다. Math.cbrt(x) x의 세제곱근을 구합니다. Math.clz32(x) x의 32 비트 정수 표현으로 선두의 제로의 비트의 수를 돌려줍니다. Math.cosh(x) x의 쌍곡선 코사인을 반환합니다. Math.expm1(x) x의 지수 함수에서 1을 뺀 결과를 반환합니다. Math.fround(x) 가장 가까운 x의 단정도 float를 반환합니다. Math.hypot(... values) 각 인수의 제곱의 합계의 제곱근을 반환합니다. Math.imul(x, y) 2 개의 인수의 진정한 32 비트 승수를 실행 한 결과를 돌려줍니다. Math.log1p(x) 1 + x의 자연 대수를 구합니다. Math.log10(x) x의 기본 10 로그를 구합니다. Math.log2(x) x의 기본 2 로그를 구합니다. Math.sign(x) x가 음수이면 -1을 반환하고 x가 +0 또는 -0이면 0을, x가 양수이면 1을 반환합니다. Math.sinh(x) x의 쌍곡선 사인을 돌려줍니다. Math.tanh(x) x의 쌍곡선 탄젠트를 반환합니다. Math.trunc(x) float에서 소수 자릿수를 제거하고 정수를 반환합니다. 각각의 새로운 메서드의 자세한 설명은 이 책의 범위를 벗어납니다. 그러나 응용 프로그램에서 합리적으로 공통적인 계산을 수행해야하는 경우 직접 구현하기 전에 새로운 Math 메서드를 확인하십시오 유니코드 식별자ECMAScript 6은 이전 버전의 JavaScript보다 더 나은 유니코드 지원을 제공하며 식별자로 사용할 수있는 문자도 변경합니다. ECMAScript 5에서는 이미 식별자에 유니코드 이스케이프 시퀀스를 사용할 수있었습니다.1234567// ECMAScript 5와 6에서 유효합니다.var \\u0061 = \"abc\";console.log(\\u0061); // \"abc\"// 아래와 동일합니다.console.log(a); // \"abc\" 이 예제에서 var 문장 다음에 \\u0061 또는 a를 사용하여 변수에 접근할 수 있습니다. ECMAScript 6에서는 다음과 같이 유니코드 코드포인트 이스케이프 시퀀스를 식별자로 사용할 수도 있습니다. 1234567// ECMAScript 5와 6에서 유효합니다.var \\u&#123;61&#125; = \"abc\";console.log(\\u&#123;61&#125;); // \"abc\"// 아래와 동일합니다. console.log(a); // \"abc\" 이 예제는 단지 \\u0061를 해당 코드포인트와 동일하게 대체합니다. 그리고 앞의 예제와 완전히 똑같습니다. 또한 ECMAScript 6은 유니코드 표준 Annex # 31 : 유니 코드 식별자 및 패턴 구문과 관련하여 유효한 식별자를 공식적으로 지정합니다. 이 식별자는 다음 규칙을 제공합니다. 첫 번째 문자는 $, _ 또는 ID_Start의 파생 코어 프로퍼티가 있는 모든 유니코드 여야합니다. 연속되는 각 문자는 $, _, \\u200c (zero-width non-joiner), \\u200d (zero-width joiner) 또는 ID_Continue의 파생 코어 프로퍼티가 있는 유니코드 여야합니다. ID_Start 및 ID_Continue의 파생 코어 프로퍼티는 변수 및 도메인 이름과 같은 식별자에 사용하기 적합한 기호를 식별하는 방법으로 유니 코드 식별자 및 패턴 구문에서 정의됩니다. 이 사양은 JavaScript에만 해당되는 것이 아닙니다. __proto__ 프로퍼티 공식화ECMAScript 5가 완성되기 전에 여러 JavaScript 엔진이 이미 [[Prototype]] 프로퍼티를 가져오고 설정할 수있는 __proto__라는 사용자 정의 프로퍼티를 구현했습니다. __proto__는 Object.getPrototypeOf() 및 Object.setPrototypeOf() 메서드의 효과적인 초기 선행 도구였습니다. 모든 JavaScript 엔진에서 이 프로퍼티 제거를 기대하는것은 비현실적입니다(__proto__를 사용하는 인기있는 JavaScript 라이브러리가 있으므로). 그래서 ECMAScript 6은 __proto__ 동작을 공식화합니다. 공식화는 아래의 경고와 함께 ECMA-262 부록 B에 설명되어 있습니다. 이러한 기능은 핵심 ECMAScript 언어의 일부로 간주되지 않습니다. 프로그래머는 새로운 ECMAScript 코드를 작성할 때 이러한 기능 및 동작을 사용하거나 가정해서는 안됩니다. ECMAScript 구현은 구현이 웹 브라우저의 일부이거나 웹 브라우저에서 발생하는 것과 동일한 레거시 ECMAScript 코드를 실행해야하는 경우가 아니면 이러한 기능을 구현하지 않는 것이 좋습니다. __proto__에는 다음과 같은 특성이 있으므로 ECMAScript 사양에서는 Object.getPrototypeOf() 및 Object.setPrototypeOf()를 대신 사용하도록 권장합니다. 객체 리터럴에서는 __proto__를 한번만 지정할 수 있습니다. 두개의 __proto__ 프로퍼티를 지정하면 오류가 발생합니다. 이것이 유일한 개체 리터럴 프로퍼티 제약입니다. 계산된 형식 [&quot;__proto__&quot;]는 일반 프로퍼티처럼 작동하며 현재 객체의 프로토 타입을 설정하거나 반환하지 않습니다. 객체 리터럴 프로퍼티와 관련된 모든 규칙이 이 형식으로 적용됩니다. 예외가있는 계산되지 않은 형식과는 대조적입니다. __proto__ 프로퍼티 사용을 피해야 하지만, 사양에서 정의한 방식은 흥미 롭습니다. ECMAScript 6 엔진에서 Object.prototype.__ proto__은 get 메서드가 Object.getPrototypeOf()를 호출하고 set 메서드가 Object.setPrototypeOf() 메서드를 호출하는 접근자 프로퍼티로 정의됩니다. 이것은 __proto__와 Object.getPrototypeOf() / Object.setPrototypeOf() 사이에 실제적인 차이를 남기지 않습니다. 단, __proto__를 사용하면 객체 리터럴의 프로토 타입을 직접 설정할 수 있습니다. 작동 방식은 다음과 같습니다. 12345678910111213141516171819202122232425let person = &#123; getGreeting() &#123; return \"Hello\"; &#125;&#125;;let dog = &#123; getGreeting() &#123; return \"Woof\"; &#125;&#125;;// prototype is personlet friend = &#123; __proto__: person&#125;;console.log(friend.getGreeting()); // \"Hello\"console.log(Object.getPrototypeOf(friend) === person); // trueconsole.log(friend.__proto__ === person); // true// set prototype to dogfriend.__proto__ = dog;console.log(friend.getGreeting()); // \"Woof\"console.log(friend.__proto__ === dog); // trueconsole.log(Object.getPrototypeOf(friend) === dog); // true 이 예는 Object.create()를 호출하여 friend 객체를 만드는 대신, __proto__ 프로퍼티에 값을 할당하는 표준 객체 리터럴을 만듭니다. 반면에 Object.create() 메서드를 사용하여 객체를 만들때는 추가 객체 프로퍼티에 대해 전체 프로퍼티 descriptor를 지정해야합니다. 이 내용은 나중에 참고하기 위해 제가 공부하며 정리한 내용입니다.의역, 오역, 직역이 있을 수 있음을 알려드립니다.This post is a translation of this original article [https://leanpub.com/understandinges6/read#leanpub-auto-appendix-a-smaller-changes] 참고 ECMAScript 6 Block Binding ECMAScript 6 문자열과 정규 표현식 ECMAScript 6 함수 ECMAScript 6 객체의 확장된 기능 ECMAScript 6 쉬운 데이터 액세스를 위한 Destructuring ECMAScript 6 Symbol과 Symbol 프로퍼티 ECMAScript 6 Set과 Map ECMAScript 6 Iterator와 Generator ECMAScript 6 JavaScript 클래스 소개 ECMAScript 6 Array 기능 향상 ECMAScript 6 Promise와 비동기 프로그램밍 ECMAScript 6 프록시와 리플렉션 API ECMAScript 6 Module로 코드 캡슐화하기 ECMAScript 6 부록 A. 작은 변경 사항 ECMAScript 6 부록 B. ECMAScript 7(2016) 이해하기","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://infoscis.github.io/categories/JavaScript/"},{"name":"ECMAScript 2015","slug":"JavaScript/ECMAScript-2015","permalink":"http://infoscis.github.io/categories/JavaScript/ECMAScript-2015/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://infoscis.github.io/tags/JavaScript/"},{"name":"ECMAScript 2015","slug":"ECMAScript-2015","permalink":"http://infoscis.github.io/tags/ECMAScript-2015/"}]},{"title":"ECMAScript 6 Module로 코드 캡슐화하기","slug":"ecmascript-6-encapsulating-code-with-modules","date":"2018-02-27T13:31:45.000Z","updated":"2018-02-27T14:11:26.929Z","comments":true,"path":"2018/02/27/ecmascript-6-encapsulating-code-with-modules/","link":"","permalink":"http://infoscis.github.io/2018/02/27/ecmascript-6-encapsulating-code-with-modules/","excerpt":"","text":"ECMAScript 6 Module로 코드 캡슐화하기JavaScript의 “모든 공유” 방식의 코드 로드는 JavaScript를 오류가 발생하기 쉬운 가장 혼란스러운 언어 중 하나로 만듭니다. 다른 언어에서는 패키지와 같은 개념을 사용하여 코드 범위를 정의하지만 ECMAScript 6 이전에는 응용 프로그램의 모든 JavaScript 파일에 정의된 모든 것이 하나의 전역 Scope을 공유했습니다. 웹 애플리케이션이 더욱 복잡해지고 JavaScript 코드가 더많이 사용됨에 따라 이러한 접근 방식은 이름 충돌 및 보안 문제와 같은 문제를 야기했습니다. ECMAScript 6의 한가지 목표는 Scope 문제를 해결하고 JavaScript 응용 프로그램에 순서를 지정하는 것이 었습니다. 이것이 Module이 도입된 이유입니다. Module은 무엇일까요?Module은 다른 모드로 로드되는 JavaScript 파일입니다 (Script는 JavaScript가 작동하는 원래 방식으로 로드 됨). Module은 Script와 매우 다른 의미를 가지고 있기 때문에 다른 모드가 필요합니다. Module 코드는 자동으로 strict 모드에서 실행되며 strict 모드를 거부 할 방법이 없습니다. Module의 최상위 레벨에서 작성된 변수는 공유된 전역 범위에 자동으로 추가되지 않습니다. Module의 최상위 범위에만 존재합니다. Module의 최상위 레벨에있는 this의 값은 `undefined ‘입니다. Module은 코드 내에서 HTML 스타일의 주석을 허용하지 않습니다 (JavaScript의 초기 브라우저 시절 남은 기능). Module은 Module 외부에서 사용할 수 있어야하는 모든 것을 export 해야합니다. Module은 다른 Module에서 바인딩을 가져올 수 있습니다. 이 차이는 언뜻보기에 작게 보일 수 있지만 JavaScript 코드가 로드되고 평가되는 방식에 중요한 변화를 나타냅니다. 이것은 이장 전체에서 논의 할 것입니다. Module의 진정한 힘은 파일의 모든 것보다는 필요한 바인딩만 내보내고 가져 오는 기능입니다. Module이 scripts와 어떻게 다른지 이해하기 위해서는 내보내기(export)와 가져 오기(import)를 잘 이해해야합니다. export 기초export 키워드를 사용하여 코드의 일부를 다른 Module에 노출할 수 있습니다. 가장 단순한 경우에, 변수, 함수 또는 클래스 선언 앞에export를 두어 다음과 같이 Module에서 내보낼 수 있습니다. 123456789101112131415161718192021222324252627282930// export dataexport var color = \"red\";export let name = \"Nicholas\";export const magicNumber = 7;// export functionexport function sum(num1, num2) &#123; return num1 + num1;&#125;// export classexport class Rectangle &#123; constructor(length, width) &#123; this.length = length; this.width = width; &#125;&#125;// 이 함수는 Module에서 private입니다.function subtract(num1, num2) &#123; return num1 - num2;&#125;// 함수를 정의하고...function multiply(num1, num2) &#123; return num1 * num2;&#125;// ...나중에 내보낼수 있습니다.export &#123; multiply &#125;; 이 예에서 주의해야 할 몇가지 사항이 있습니다. 첫째, export 키워드를 제외하고 모든 선언은 다른 경우와 완전히 동일합니다. 내보낸 각 함수 또는 클래스에는 이름이 있습니다. 왜냐하면 내보낸 함수와 클래스 선언에는 이름이 필요하기 때문입니다. default 키워드를 사용하지 않는 이상 이구문을 사용하여 익명 함수나 클래스를 내보낼 수 없습니다 (“Module의 Default값” 섹션 참조). 다음으로, 정의되었을 때 export하지 않은 multiply() 함수를 생각해 보겠습니다. 이는 항상 선언에서 export할 필요가 없기 때문에 효과적입니다. 참조를 export할 수도 있습니다. 마지막으로 이 예제에서는 subtract() 함수를 export하지 않습니다. 명시적으로 export하지 않은 변수, 함수 또는 클래스는 Module에 비공개로 남아 있기 때문에 이 함수는 이 Module 외부에서 액세스할 수 없습니다. import 기초export가 있는 Module이 있으면 import 키워드를 사용하여 다른 Module의 기능에 액세스할 수 있습니다. import 문의 두 부분은 가져올 식별자와 그 식별자를 가져올 Module입니다. 아래는 문장의 기본형태입니다. 1import &#123; identifier1, identifier2 &#125; from \"./example.js\"; import 뒤의 중괄호는 주어진 Module로부터 가져올 바인딩을 나타냅니다. 키워드 from은 지정된 바인딩을 가져올 Module을 나타냅니다. Module은 경로를 나타내는 문자열로 지정됩니다 (Module 지정자라고 함). 브라우저는 &lt;script&gt; 요소에 전달할 동일한 경로 형식을 사용합니다. 즉, 파일 확장명을 포함해야합니다. 반대로, Node.js는 파일 시스템 접두사를 기반으로 로컬 파일과 패키지를 구별하는 전통적인 규칙을 따릅니다. 예를 들어 example은 패키지이고 ./example.js는 로컬 파일입니다. import 할 바인딩 목록은 Destructured 객체와 유사하지만 보이지는 않습니다. Module로부터 바인딩을 import할 때 바인딩은 const를 사용하여 정의된 것처럼 동작합니다. 즉, 동일한 이름의 다른 변수를 정의할 수 없으며 (같은 이름의 다른 바인딩을 가져 오는 것을 포함하여), import 문 앞에 식별자를 사용하거나 값을 변경할 수 없다는 뜻입니다. 단일 바인딩 import“export 기초” 섹션의 첫 번째 예제가 파일 example.js의 Module에 있다고 가정합니다. 여러 가지 방법으로 해당 Module에서 바인딩을 가져오고 사용할 수 있습니다. 예를 들어 하나의 식별자만 가져올 수 있습니다. 123456// 하나만 가져 오기import &#123; sum &#125; from \"./example.js\";console.log(sum(1, 2)); // 3sum = 1; // error example.js는 하나 이상의 함수를 export하지만, 이 예제는 sum()함수만 import합니다. sum에 새로운 값을 할당하려고하면, 가져온 바인딩을 재할당할 수 없기 때문에 결과는 오류입니다. 브라우저와 Node.js간에 최상의 호환성을 위해 import하는 파일의 시작 부분에 /, ./ 또는 ../을 포함시킵니다. 여러 바인딩 import예제 Module에서 여러 바인딩을 import하기위해 다음과 같이 명시적으로 나열할 수 있습니다. 1234// import multipleimport &#123; sum, multiply, magicNumber &#125; from \"./example.js\";console.log(sum(1, magicNumber)); // 8console.log(multiply(1, 2)); // 2 여기 예제 Module에서 sum, multiply, magicNumber의 세 가지 바인딩을 import합니다. 그런 다음 로컬에 정의된 것처럼 사용합니다. Module에서 모두 import또한 Module의 전체를 단일 객체로 import할 수있는 특별한 경우가 있습니다. 그런 다음 해당 객체에서 export한 모든 것을 프로퍼티로로 사용할 수 있습니다. 12345// import everythingimport * as example from \"./example.js\";console.log(example.sum(1, example.magicNumber)); // 8console.log(example.multiply(1, 2)); // 2 이 코드에서,example.js에 있는 export한 모든 바인딩은 example이라는 객체에 로드됩니다. 그러면 이름이 지정된 export (sum() 함수, multiple() 함수 및 magicNumber)는 example의 프로퍼티로 액세스할 수 있습니다. 이 import 형식을 namespace import라고합니다. 왜냐하면 example 객체는 example.js 파일안에 존재하지 않고 example.js의 export한 모든 멤버들에 대한 네임 스페이스 객체로 사용되기 위해 생성되기 때문입니다. 그러나 import 문에서 Module을 몇번이나 사용하더라도 Module은 한번만 실행됩니다. Module을 import한 코드가 실행된 후에, 인스턴스화된 Module은 메모리에 유지되고 다른 import 문이 그것을 참조할 때마다 재사용됩니다. 다음을 살펴보겠습니다. 123import &#123; sum &#125; from \"./example.js\";import &#123; multiply &#125; from \"./example.js\";import &#123; magicNumber &#125; from \"./example.js\"; 이 Module에는 import문이 세개 있지만 example.js는 한번만 실행됩니다. 동일한 애플리케이션의 다른 Module이 example.js에서 바인딩을 import하는 경우 이 Module은 이 코드에서 사용하는 것과 동일한 Module 인스턴스를 사용합니다. Module 구문 제한 사항export와 import의 중요한 제한 사항은 구문과 함수 밖에서 사용해야한다는 것입니다. 예를 들어 이 코드는 구문 오류를 발생시킵니다. 123if (flag) &#123; export flag; // syntax error&#125; export 문장이 if문 안에 있습니다. 이것은 허용되지 않습니다. export는 어떤 방식으로든 조건부 이거나 동적일 수 없습니다. Module 구문이 존재하는 한가지 이유는 JavaScript 엔진이 export하는 것을 정적으로 결정하게 하기 위해서입니다. 따라서 Module의 최상위 레벨에서만 export를 사용할 수 있습니다. 마찬가지로 명령문 내부에서는 import를 사용할 수 없습니다. 최상위 레벨에서만 사용할 수 있습니다. 즉, 아래 코드는 구문 오류입니다. 123function tryImport() &#123; import flag from \"./example.js\"; // syntax error&#125; 동적으로 바인딩을 export할 수 없는 것과 같은 이유로 동적으로 바인딩을 import할 수 없습니다. export와 import 키워드는 텍스트 편집기와 같은 도구가 Module에서 어떤 정보를 사용할 수 있는지 쉽게 알수있도록 정적으로 설계되었습니다. import한 바인딩의 미묘한 특성ECMAScript 6의 import 문은 일반 변수와 같이 원래 바인딩을 단순히 참조하는 것이 아니라 변수, 함수 및 클래스에 대한 읽기 전용 바인딩을 만듭니다. 바인딩을 import하는 Module은 값을 변경할 수 없지만 해당 식별자를 export하는 Module은 값을 변경할 수 있습니다. 예를 들어, 이 Module을 사용한다고 가정 해보겠습니다. 1234export var name = \"Nicholas\";export function setName(newName) &#123; name = newName;&#125; 이 두 바인딩을 import하면 setName() 함수는 name의 값을 바꿀 수 있습니다. 1234567import &#123; name, setName &#125; from \"./example.js\";console.log(name); // \"Nicholas\"setName(\"Greg\");console.log(name); // \"Greg\"name = \"Nicholas\"; // error setName(&quot;Greg&quot;)에 대한 호출은 setName()을 export한 Module로 돌아가서 실행이 되고 name을 &quot;Greg&quot;로 설정합니다. 이 변경은 import한 name 바인딩에 자동으로 반영됩니다. name은 export한 name 식별자의 로컬 이름이기 때문입니다. 위의 코드에서 사용된 name과 import한 Module에서 사용된 name은 같지 않습니다. 이름을 변경하여 export와 import때로는 Module에서 import한 변수, 함수 또는 클래스의 원래 이름을 사용하지 않을 수도 있습니다. 다행히도 export 및 import하는 동안 export의 이름을 변경할 수 있습니다. 첫번째 경우, 다른 이름으로 export하려는 함수가 있다고 가정합니다. as 키워드를 사용하여 함수가 Module 외부로 알려진 이름을 지정할 수 있습니다. 12345function sum(num1, num2) &#123; return num1 + num2;&#125;export &#123; sum as add &#125;; 여기서 sum() 함수(sum은 로컬 이름입니다)는 add()(add는 export한 이름입니다)로 export됩니다. 즉, 다른 Module이 이 함수를 import하기 원할 때 sum 대신 add라는 이름을 사용해야 합니다. 1import &#123; add &#125; from \"./example.js\"; 함수를 import하는 Module이 다른 이름을 사용하고 싶다면, as를 사용할 수도 있습니다. 123import &#123; add as sum &#125; from \"./example.js\";console.log(typeof add); // \"undefined\"console.log(sum(1, 2)); // 3 이 코드는 import name을 사용하여 add() 함수를 import해서 sum()(로컬 이름)으로 이름을 바꿉니다. 즉, 이 Module에는 add라는 이름의 식별자가 없습니다. Module의 Default 값Module 구문은 실제로 Module에서 Default값을 export하고 import하는데 최적화되어 있습니다. 이 패턴은 CommonJS(브라우저 외부에서 JavaScript를 사용하기위한 또 다른 사양)와 같이 다른 Module 시스템에서 상당히 일반적이었습니다. Module의 Default값은 default 키워드로 지정된 단일 변수, 함수 또는 클래스이며 Module 당 하나의 Default export만 설정할 수 있습니다. default 키워드를 다중 export와 함께 사용하는 것은 구문 오류입니다. Default 값 export다음은default 키워드를 사용하는 간단한 예제입니다. 123export default function(num1, num2) &#123; return num1 + num2;&#125; 이 Module은 함수를 Default값으로 export합니다. default 키워드는 이것이 Default export 임을 나타냅니다. 이 함수는 Module 자체가 함수를 나타내기 때문에 이름을 요구하지 않습니다. 다음과 같이 export default 다음에 식별자를 배치하여 식별자를 Default export로 지정할 수도 있습니다. 12345function sum(num1, num2) &#123; return num1 + num2;&#125;export default sum; 여기에서 sum() 함수가 먼저 정의되고 나중에 Module의 Default값으로 export됩니다. Default값으로 계산을 사용해야하는 경우 이방법을 선택할 수 있습니다. 식별자를 Default export로 지정하는 세 번째 방법은 다음과 같이 이름 바꾸기 구문을 사용하는 것입니다. 12345function sum(num1, num2) &#123; return num1 + num2;&#125;export &#123; sum as default &#125;; 식별자 default는 이름 바꿔서 export에서 특별한 의미를 가지며 값이 Module의 Default값이어야 함을 나타냅니다. default는 JavaScript에서 키워드이기 때문에 변수, 함수 또는 클래스 이름으로 사용할 수 없습니다 (프로퍼티 이름으로 사용할 수 있음). 그래서 export의 이름을 바꾸기 위해 default를 사용하는 것은 Default값이 아닌 export에 정의된 방법과 일관성을 유지하는 특별한 경우입니다. 이 구문은 단일 export 문을 사용하여 Default값을 포함한 여러 export를 동시에 지정하려는 경우 유용합니다. Default 값 import다음 구문을 사용하여 Module에서 Default값을 import할 수 있습니다. 1234// import the defaultimport sum from \"./example.js\";console.log(sum(1, 2)); // 3 이 import 명령문은 Module example.js에서 Default값을 import합니다. Default가 아닌 import에서 볼 수있는 것과는 달리 중괄호는 사용되지 않습니다. 로컬 이름 sum은 Module이 export하는 Default 함수을 나타내는데 사용됩니다. 이 구문은 가장 깨끗하고, ECMAScript 6의 제작자는 이것이 웹상에서 가장 많이 사용되는 형식이기를 기대하며 이미 존재하는 객체를 사용할 수 있습니다. Default 바인딩과 하나 이상의 Default가 아닌 바인딩을 모두 export하는 Module의 경우 하나의 명령문으로 모든 export 바인딩을 가져올 수 있습니다. 예를 들어, 이 Module을 가지고 있다고 가정해 보겠습니다. 12345export let color = \"red\";export default function(num1, num2) &#123; return num1 + num2;&#125; 다음의 import 문을 사용하여color와 Default 함수를 모두 import할 수 있습니다. 1234import sum, &#123; color &#125; from \"./example.js\";console.log(sum(1, 2)); // 3console.log(color); // \"red\" 쉼표는 Default 로컬 이름을 중괄호로 묶인 Default값이 아닌 값과 구분합니다. Default값은 import 문에서 Default가 아닌값 앞에 와야한다는 것을 명심하십시오. Default값을 export하는 것과 마찬가지로, 이름 바꾸기 구문을 이용하여 Default값을 import할 수 있습니다. 12345// 이전 예제와 동일합니다.import &#123; default as sum, color &#125; from \"example\";console.log(sum(1, 2)); // 3console.log(color); // \"red\" 이 코드에서 Default export(default)는 sum으로 이름이 바뀌고 추가적으로 color export 또한 가져옵니다. 이 예제는 앞의 예제와 동일합니다. 바인딩을 다시 exportModule이 import한 내용을 다시 export하고 싶을 때가 있을 수 있습니다 (예 : 여러 개의 작은 Module로 라이브러리를 만드는 경우). 이 장에서 이미 설명한 패턴을 사용하여 import한 값을 다음과 같이 다시 export할 수 있습니다. 12import &#123; sum &#125; from \"./example.js\";export &#123; sum &#125; 이게 효과가 있지만, 하나의 문장으로 똑같은 일을 할 수 있습니다. 1export &#123; sum &#125; from \"./example.js\"; 이 형태의 export는 sum의 선언을 위해 지정된 Module을 export합니다. 물론 동일한 값에 대해 다른 이름을 export하도록 선택할 수도 있습니다. 1export &#123; sum as add &#125; from \"./example.js\"; 여기서 sum은 &quot;./example.js&quot;에서 import한 후 add라는 이름으로 export합니다. 다른 Module의 모든 것을 export하려면 * 패턴을 사용할 수 있습니다. 1export * from \"./example.js\"; 모든 것을 export하면 이름이 있는 export뿐만 아니라 Default값도 포함되기 때문에 Module에서 export할 수있는 것에 영향을 줄 수 있습니다. 예를 들어, example.js에 Default export가 있는 경우 이 구문을 사용하면 새로운 Default export를 정의할 수 없습니다. 바인딩없이 import일부 Module은 아무것도 export할 수 없으며 전역 범위의 객체만 수정하기도 합니다. Module 내의 최상위 변수, 함수 및 클래스가 전역 범위에서 자동으로 끝나지는 않지만 이것은 Module이 전역 범위에 액세스 할 수 없다는 것을 의미하지는 않습니다. Array와 Object와 같은 Built-in 객체의 공유된 정의는 Module 내에서 접근 가능하며, 그 객체에 대한 변경은 다른 Module에 반영됩니다. 예를 들어, 모든 Array에 pushAll() 메서드를 추가하려면 다음과 같이 Module을 정의할 수 있습니다. 1234567891011// export 또는 import가 없는 module 코드Array.prototype.pushAll = function(items) &#123; // items은 array여야만 합니다. if (!Array.isArray(items)) &#123; throw new TypeError(\"Argument must be an array.\"); &#125; // Built-in된 push() 및 spread 연산자 사용 return this.push(...items);&#125;; 이것은 export 또는 import가 없더라도 유효한 Module입니다. 이 코드는 Module과 script로 모두 사용할 수 있습니다. 아무 것도 export할 수 없기 때문에 import를 사용하여 바인딩을 가져 오지 않고 Module 코드를 실행할 수 있습니다. 이 코드는 pushAll() 메서드가 포함된 Module을 import해서 실행하므로 pushAll()이 Array 프로토 타입에 추가됩니다. 즉, 이 Module 내부의 모든 Array에서 pushAll()을 사용할 수 있습니다. 바인딩이없는 import하는 대부분의 경우 polyfill과 shim을 만드는 데 사용됩니다. Module 로딩ECMAScript 6에서는 Module 구문을 정의하지만 로드하는 방법은 정의하지 않습니다. 모든 JavaScript 환경에서 작동할 수있는 단일 사양을 작성하는 대신 ECMAScript 6은 구문만 지정하고 로드 메커니즘을 HostResolveImportedModule이라는 정의되지 않은 내부 작업으로 추상화합니다. 웹 브라우저와 Node.js는 각각의 환경에 적합한 방식으로 HostResolveImportedModule을 구현하는 방법을 결정해야합니다. 웹 브라우저에서 Module 사용하기ECMAScript 6 이전에도 웹 브라우저에는 웹 응용 프로그램에 JavaScript를 포함시키는 여러 가지 방법이 있었습니다. 이러한 script 로드 옵션은 다음과 같습니다. 코드를 로드 할 위치를 지정하는 src Attribute와 함께 &lt;script&gt; 요소를 사용하여 JavaScript 코드 파일로드. src Attribute 없이 &lt;script&gt; 요소를 사용하여 JavaScript 코드를 인라인으로 포함. 웹 Worker 또는 서비스 Worker와 같이 Worker로 실행되는 JavaScript 코드 파일로드. Module을 완벽하게 지원하려면 웹 브라우저가 이러한 각 메커니즘을 업데이트 해야했습니다. 이러한 세부 사항은 HTML 사양에 정의되어 있으며 이 섹션에서 설명합니다. 로 Module 사용하기&lt;script&gt; 요소의 기본 동작은 JavaScript 파일에서 Script를 (Module이 아닌)로드하는 것입니다. 이것은 type Attribute가 없거나 type Attribute가 JavaScript 콘텐츠 유형 (예 : &quot;text/javascript&quot;)을 포함할 때 발생합니다. &lt;script&gt; 요소는 인라인 코드를 실행하거나 src에 지정된 파일을 로드할 수 있습니다. Module을 지원하기 위해 &quot;module&quot;값이 type 옵션으로 추가되었습니다. type을 &quot;module&quot;로 설정하면 브라우저가 src에 지정된 파일에 포함된 인라인 코드 또는 코드를 Script 대신 Module로 로드합니다. 다음은 간단한 예제입니다. 1234567891011&lt;!-- JavaScript파일을 module로 로드 --&gt;&lt;script type=\"module\" src=\"module.js\"&gt;&lt;/script&gt;&lt;!-- 인라인 module로 가져옴 --&gt;&lt;script type=\"module\"&gt;import &#123; sum &#125; from \"./example.js\";let result = sum(1, 2);&lt;/script&gt; 이 예제의 첫 번째 &lt;script&gt; 엘리먼트는 src Attribute를 사용하여 외부 Module 파일을 로드합니다. Script를 로딩하는 것과 유일한 차이점은 &quot;module&quot;이 type의 값으로 주어진다는 것입니다. 두 번째 &lt;script&gt; 엘리먼트는 웹 페이지에 직접 삽입되는 형태로 Module을 포함합니다. 변수 result는 Module 내에서만 존재하기 때문에 (&lt;script&gt; 요소로 정의됨) 전역적으로 노출되지 않으므로 프로퍼티로 window에 추가되지 않습니다. 웹 페이지에 Module을 포함하는 것이 매우 간단하고, Script를 포함하는 것과 유사합니다. 그러나 Module 로드 방법에는 몇가지 차이점이 있습니다. &quot;module&quot;이 &quot;text/javascript&quot;과 같은 타입이 아니라는 사실을 알고있을 것입니다. Module JavaScript 파일은 Script JavaScript 파일과 동일한 콘텐츠 유형으로 제공되므로 콘텐츠 유형에 따라 차별화할 수 없습니다. 또한 브라우저는 type이 인식되지 않을 때 &lt;script&gt; 요소를 무시하므로 Module을 지원하지 않는 브라우저는 자동으로 &lt;script type=&quot;module&quot;&gt; 행을 무시하므로 하위 호환성을 유지할 수 있습니다. 웹 브라우저에서 Module 로딩 순서Script와 달리 Module은 import를 사용하여 다른 파일에서 올바르게 실행되도록 지정해야한다는 점에서 독특합니다. 이 기능을 지원하기 위해 &lt;script type=&quot;module&quot;&gt;은 항상 defer Attribute가 적용된 것처럼 실행됩니다. defer Attribute는 Script 파일을 로딩할 때 선택 사항이지만 항상 Module 파일 로딩에 적용됩니다. HTML 파서가 src Attribute로&lt;script type=&quot;module&quot;&gt;을 만나면 Document가 완전히 파싱된 후에야 실행됩니다. Module은 HTML 파일에 나타나는 순서대로 실행됩니다. 즉, 첫 번째 &lt;script type=&quot;module&quot;&gt;은 src를 지정하는 대신 Module에 인라인 코드가 포함되어 있어도 두 번째 Module보다 먼저 실행되도록 보장됩니다. 123456789101112&lt;!-- 첫 번째로 실행됩니다. --&gt;&lt;script type=\"module\" src=\"module1.js\"&gt;&lt;/script&gt;&lt;!-- 두 번째로 실행됩니다. --&gt;&lt;script type=\"module\"&gt;import &#123; sum &#125; from \"./example.js\";let result = sum(1, 2);&lt;/script&gt;&lt;!-- 세 번째로 실행 됩니다. --&gt;&lt;script type=\"module\" src=\"module2.js\"&gt;&lt;/script&gt; 이 세개의 &lt;script&gt; 요소는 지정된 순서대로 실행되므로 module1.js는 인라인 Module보다 먼저 실행되도록 보장되며 인라인 Module은 module2.js보다 먼저 실행되도록 보장됩니다. 각 Module은 하나 이상의 다른 Module에서 가져올 수 있으므로 문제가 복잡해집니다. 그래서 Module은 모든 import 문을 식별하기 위해 완전히 파싱됩니다. 각각의 import 문은 (네트워크나 캐시로부터) 파일 내용을 모두 전송 받고, import 리소스가 모두 로드되어 실행될 때까지 Module은 실행되지 않습니다. &lt;script type=&quot;module&quot;&gt;을 사용하여 명시적으로 포함된 Module과 import를 사용하여 암시적으로 포함된 Module 모두 로드되고 순서대로 실행됩니다. 앞의 예제에서 전체 로드 순서는 다음과 같습니다. module1.js를 다운로드하고 파싱합니다. module1.js에서 import 리소스를 반복적으로 다운로드하고 구문 분석합니다. 인라인 Module을 구문 분석합니다. 인라인 Module에서 import 리소스를 반복적으로 다운로드하고 구문 분석합니다. module2.js를 다운로드하고 파싱합니다. module2.js에서 import 리소스를 반복적으로 다운로드하고 구문 분석합니다. 로딩이 완료되면 Document가 완전히 파싱될 때까지 아무 것도 실행되지 않습니다. Document 구문 분석이 완료되면 다음 작업이 수행됩니다. module1.js에 대한 import 리소스를 반복적으로 실행합니다. module1.js를 실행합니다. 인라인 Module에 대한 import 리소스를 반복적으로 실행합니다. 인라인 Module을 실행합니다. module2.js에 import 오기 리소스를 반복적으로 실행합니다. module2.js를 실행합니다. 인라인 Module은 코드를 먼저 다운로드 할 필요가 없다는 것을 제외하고는 다른 두 Module과 같이 작동합니다. import 리소스를 로드하고 Module을 실행하는 순서가 완전히 동일합니다. defer Attribute는 &lt;script type=&quot;module&quot;&gt;에서 무시됩니다. 왜냐하면 이미 defer가 적용된 것처럼 행동하기 때문입니다. 웹 브라우저에서 비동기로 Module 로드여러분은 이미 &lt;script&gt; 요소에 async Attribute를 잘 알고있을 것입니다. Script와 함께 사용될 때, async는 파일이 완전히 다운로드되고 파싱 되자마자 Script 파일이 실행되도록합니다. 그러나 Document에서 async Script의 순서는 Script가 실행되는 순서에 영향을 미치지 않습니다. Script는 포함된 Document의 구문 분석을 기다리지 않고 다운로드가 끝나면 항상 실행됩니다. async Attribute는 Module에도 적용할 수 있습니다. &lt;script type=&quot;module&quot;&gt;에 async를 사용하면 Module이 Script와 비슷한 방식으로 실행됩니다. 유일한 차이점은 Module 자체가 실행되기 전에 Module에 대한 모든 import 리소스가 다운로드된다는 것입니다. Module을 실행하기 전에 Module이 작동하는데 필요한 모든 자원이 다운로드됩니다. Module이 언제 실행되는지는 보장 할 수 없습니다. 다음 코드를 살펴보겠습니다. 123&lt;!-- 어떤것이 먼저 실행될지 보장할 수 없습니다. --&gt;&lt;script type=\"module\" async src=\"module1.js\"&gt;&lt;/script&gt;&lt;script type=\"module\" async src=\"module2.js\"&gt;&lt;/script&gt; 이 예제에서는 두개의 Module 파일이 비동기적으로 로드됩니다. 이 코드를 보면 어떤 Module이 먼저 실행되는지 알 수 없습니다. module1.js가 먼저 다운로드를 끝내면 (import 리소스 모두 포함), 먼저 실행될 것입니다. module2.js가 먼저 다운로드를 끝내면 그 Module이 먼저 실행됩니다. Module을 Worker로 로딩하기웹 Worker 및 서비스 Worker와 같은 Worker는 웹 페이지 컨텍스트 외부에서 JavaScript 코드를 실행합니다. 새로운 Worker를 생성하려면 새로운 인스턴스인 Worker(또는 클래스)를 생성하고 JavaScript 파일의 위치를 전달해야합니다. 기본 로딩 메커니즘은 다음과 같이 파일을 Script로 로드하는 것입니다. 12// script.js를 script로 로드.let worker = new Worker(\"script.js\"); Module 로드를 지원하기 위해 HTML 표준의 개발자는 두 번째 파라미터를 생성자에 추가했습니다. 두 번째 파라미터는 기본값이 &quot;script&quot;인type Attribute가 있는 객체입니다. Module 파일을 로드하기 위해 type을 “module”로 설정할 수 있습니다. 12// module.js를 module로 로드let worker = new Worker(\"module.js\", &#123; type: \"module\" &#125;); 이 예제는 module.js를 Script 대신 Module로 로드합니다. 두 번째 파라미터에는 Module을 type 프로퍼티의 값으로 전달합니다. (type 프로퍼티는 script의 type Attribute가 Module과 Script를 구별하는 방법을 모방한 것입니다.) 두 번째 파라미터는 브라우저의 모든 Worker 타입에 지원됩니다. Worker Module은 일반적으로 Worker Script와 동일하지만 두가지 예외가 있습니다. 첫째, Worker Script는 참조되는 웹 페이지와 동일한 출처에서 로드되는 것으로 제한되지만 Worker Module은 제한되지 않습니다. Worker Module에도 동일한 기본 제한 사항이 있지만 CORS (Cross-Origin Resource Sharing) 헤더가있는 파일을 로드하여 액세스를 허용할 수도 있습니다. 둘째, Worker Script는 self.importScripts() 메서드를 사용하여 추가 Script를 Worker에 로드 할 수 있지만 Worker Module에서는 self.importScripts()가 실패합니다. 대신 import를 사용해야 합니다. 브라우저 Module 지정자이장의 모든 예제는 &quot;./example.js&quot;와 같이 Module 상대 지정자 경로를 사용했습니다. 브라우저는 Module 지정자가 다음 형식 중 하나에 있어야합니다. /로 시작하면 루트 디렉토리에서 확인합니다. ./로 시작하면 현재 디렉토리에서 확인합니다. ../로 시작하면 상위 디렉토리에서 확인합니다. URL 형식 예를 들어 아래의 코드가 포함된 https://www.example.com/modules/module.js에 Module 파일이 있다고 가정합니다. 1234567891011// https://www.example.com/modules/example1.js에서 import 합니다.import &#123; first &#125; from \"./example1.js\";// https://www.example.com/example2.js에서 import합니다.import &#123; second &#125; from \"../example2.js\";// https://www.example.com/example3.js에서 import합니다.import &#123; third &#125; from \"/example3.js\";// https://www2.example.com/example4.js에서 import합니다.import &#123; fourth &#125; from \"https://www2.example.com/example4.js\"; 이 예제의 각 Module 지정자는 브라우저에서 사용하기에 적합하며 최종행의 전체 URL을 포함합니다(www.example.com이 교차 도메인 로드를 허용하기 위해 Cross-Origin Resource Sharing (CORS) 헤더를 올바르게 구성했는지 확인해야합니다). 이것은 브라우저가 기본적으로 확인할 수 있는 유일한 Module 지정자 형식입니다 (아직 완성되지 않은 Module 로더 사양이 다른 형식을 해결할 수있는 방법을 제공 할지라도).즉, 정상적으로 보이는 일부 Module 지정자는 실제로 브라우저에서 유효하지 않으므로 다음과 같은 오류가 발생합니다. 12345// 오류 - /, ./, 또는 ../로 시작하지 않았습니다.import &#123; first &#125; from \"example.js\";// 오류 - /, ./, 또는 ../로 시작하지 않았습니다.import &#123; second &#125; from \"example/index.js\"; 각 Module 지정자는 브라우저에서 로드할 수 없습니다. &lt;script&gt; 태그에서 src의 값으로 사용되더라도 두 Module 지정자가 모두 올바르지 않은 형식(올바른 시작 문자가 누락됨)이 아니기 때문에 오류입니다. 이것은 &lt;script&gt;와 import 사이의 의도적인 동작 차이입니다. 요약ECMAScript 6은 함수를 패키지화하고 캡슐화하는 방법으로 언어에 Module을 추가했습니다. Module은 최상위 변수, 함수 및 클래스로 전역 범위를 수정하지 않으므로 Script와 다르게 동작합니다. this는 undefined입니다. 이러한 동작을 수행하기 위해 Module은 다른 모드를 사용하여 로드됩니다. Module을 사용자가 사용할 수 있게하려면 export해야 합니다. 변수, 함수 및 클래스를 export할 수 있으며 Module당 하나의 기본 export가 허용됩니다. export 후에 다른 Module은 export한 이름의 전부 또는 일부를 import할 수 있습니다. 이 이름은 let에 의해 정의된 것처럼 행동하고 동일한 Module에서 다시 선언할 수 없는 블록 바인딩으로 작동합니다. Module은 전역 범위에서 무언가를 조작하는 경우 아무 것도 export할 필요가 없습니다. 실제로 Module Scope에서 바인딩을 사용하지 않고 이러한 Module을 import할 수 있습니다. Module은 다른 모드에서 실행해야 하므로 브라우저는 소스 파일이나 인라인 코드를 Module로 실행해야 함을 알리기 위해 &lt;script type=&quot;module&quot;&gt;을 도입했습니다. &lt;script type=&quot;module&quot;&gt;로 로드된 Module 파일은 defer Attribute가 적용된 것처럼 로드됩니다. Module은 Document가 완전히 구문 분석되면 포함된 Document에 나타나는 순서대로 실행됩니다. 이 내용은 나중에 참고하기 위해 제가 공부하며 정리한 내용입니다.의역, 오역, 직역이 있을 수 있음을 알려드립니다.This post is a translation of this original article [https://leanpub.com/understandinges6/read#leanpub-auto-encapsulating-code-with-modules] 참고 ECMAScript 6 Block Binding ECMAScript 6 문자열과 정규 표현식 ECMAScript 6 함수 ECMAScript 6 객체의 확장된 기능 ECMAScript 6 쉬운 데이터 액세스를 위한 Destructuring ECMAScript 6 Symbol과 Symbol 프로퍼티 ECMAScript 6 Set과 Map ECMAScript 6 Iterator와 Generator ECMAScript 6 JavaScript 클래스 소개 ECMAScript 6 Array 기능 향상 ECMAScript 6 Promise와 비동기 프로그램밍 ECMAScript 6 프록시와 리플렉션 API ECMAScript 6 Module로 코드 캡슐화하기 ECMAScript 6 부록 A. 작은 변경 사항 ECMAScript 6 부록 B. ECMAScript 7(2016) 이해하기","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://infoscis.github.io/categories/JavaScript/"},{"name":"ECMAScript 2015","slug":"JavaScript/ECMAScript-2015","permalink":"http://infoscis.github.io/categories/JavaScript/ECMAScript-2015/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://infoscis.github.io/tags/JavaScript/"},{"name":"ECMAScript 2015","slug":"ECMAScript-2015","permalink":"http://infoscis.github.io/tags/ECMAScript-2015/"}]},{"title":"ECMAScript 6 프록시와 리플렉션 API","slug":"ecmascript-6-proxies-and-the-reflection-api","date":"2018-02-27T13:31:03.000Z","updated":"2018-02-27T14:11:20.585Z","comments":true,"path":"2018/02/27/ecmascript-6-proxies-and-the-reflection-api/","link":"","permalink":"http://infoscis.github.io/2018/02/27/ecmascript-6-proxies-and-the-reflection-api/","excerpt":"","text":"ECMAScript 6 프록시와 리플렉션 APIECMAScript 5와 ECMAScript 6 모두 명확한 JavaScript 기능을 염두에 두고 개발되었습니다. 예를 들어, ECMAScript 5 이전에는 JavaScript 환경에 nonenumerable , nonwritable 객체 속성이 있었지만 개발자는 자체적으로 nonenumerable 또는 nonwritable 속성을 정의할 수 없었습니다. ECMAScript 5에는 JavaScript 엔진이 할 수 있는 것을 개발자가 수행할 수 있도록 Object.defineProperty() 메서드가 포함되어 있습니다. ECMAScript 6은 이전에 Built-in 객체에만 사용할 수 있었던 JavaScript 엔진 기능에 대한 개발자의 액세스를 제공합니다. JavaScript는 프록시를 통해 객체의 내부 동작을 노출할 수 있습니다. 프록시는 JavaScript 엔진의 저수준 동작을 가로 채고 변경할 수있는 래퍼입니다. 이 장에서는 프록시에서 세부적으로 다루어야 할 문제를 설명한 다음 프록시를 효과적으로 만들고 사용하는 방법에 대해 설명합니다. Array의 문제점ECMAScript 6 이전에 JavaScript Array 객체는 개발자가 Array 객체를 모방할 수 없는 방식으로 동작합니다. Array의 length 프로퍼티는 특정 Array 항목에 값을 할당할 때 영향을 받으며 length 프로퍼티를 수정하여 Array 항목을 수정할 수 있습니다. 123456789101112131415let colors = [\"red\", \"green\", \"blue\"];console.log(colors.length); // 3colors[3] = \"black\";console.log(colors.length); // 4console.log(colors[3]); // \"black\"colors.length = 2;console.log(colors.length); // 2console.log(colors[3]); // undefinedconsole.log(colors[2]); // undefinedconsole.log(colors[1]); // \"green\" colors Array는 3 개의 아이템으로 시작합니다. &quot;black&quot;을 colors [3]에 할당하면 length 프로퍼티가 4로 자동 증가합니다. length 프로퍼티를 2로 설정하면 Array의 마지막 두 항목이 제거되고 처음 두 항목만 남게됩니다. ECMAScript 5에서는 개발자가 작성한 객체에서 이러한 동작을 수행할 수 없지만 프록시는 이를 가능하게 합니다. 이 비표준 동작이 ECMAScript 6에서 Array가 독특한 객체로 간주되는 이유입니다. 프록시와 리플렉션은 무엇인가?new Proxy()를 호출하여 다른 객체(대상(Target)이라고 함) 대신 사용할 프록시를 생성할 수 있습니다. 프록시는 대상을 가상화하여 프록시와 대상이 사용하는 기능을 동일한 객체로 표시되도록합니다. 프록시를 사용하면 JavaScript 엔진의 내부에 있는 대상에서 하위 수준의 객체 작업을 가로 챌 수 있습니다. 이러한 하위 수준의 작업은 특정 작업에 응답하는 기능인 Trap을 사용하여 가로 채어집니다. Reflect 객체로 표현된 리플렉션 API는 프록시가 오버라이드 할 수있는 것과 동일한 로우 레벨 연산에 대한 기본 동작을 제공하는 메서드 컬렉션입니다. 모든 프록시 Trap에 대해 Reflect 메서드가 있습니다. 이러한 메서드는 동일한 이름을 가지며 각 프록시 Trap과 동일한 파라미터가 전달됩니다. 표 11-1에는 이 동작이 요약되어 있습니다. Table 11-1: JavaScript 안의 프록시 Trap 프록시 Trap 동작을 재정의 기본 동작 get 프로퍼티 값을 읽음 Reflect.get() set 프로퍼티 값을 기록 Reflect.set() has in 연산자 Reflect.has() deleteProperty delete 연산자 Reflect.deleteProperty() getPrototypeOf Object.getPrototypeOf() Reflect.getPrototypeOf() setPrototypeOf Object.setPrototypeOf() Reflect.setPrototypeOf() isExtensible Object.isExtensible() Reflect.isExtensible() preventExtensions Object.preventExtensions() Reflect.preventExtensions() getOwnPropertyDescriptor Object.getOwnPropertyDescriptor() Reflect.getOwnPropertyDescriptor() defineProperty Object.defineProperty() Reflect.defineProperty ownKeys Object.keys, Object.getOwnPropertyNames(), Object.getOwnPropertySymbols() Reflect.ownKeys() apply 함수 호출 Reflect.apply() construct new를 이용한 함수 호출 Reflect.construct() 각 Trap은 JavaScript 객체의 Built-in 동작을 재정의하므로 동작을 가로 채고 수정할 수 있습니다. 그래도 Built-in 동작을 사용해야하는 경우 해당하는 리플렉션 API 메서드를 사용할 수 있습니다. 프록시 생성과 리플렉션 API 간의 관계는 프록시 생성을 시작할 때 명확 해집니다. 그래서 몇 가지 예를 살펴보는 것이 가장 좋습니다. 원래 ECMAScript 6 명세에는 for-in과 Object.keys()가 객체의 속성을 열거하는 방법을 변경하기 위해 고안된 enumerate라는 추가 Trap이 있습니다. 그러나 ECMAScript 7 (ECMAScript 2016이라고도 함)에서는 구현 중에 어려움이 발견되어 enumerate Trap이 제거되었습니다. enumerate Trap 더 이상 JavaScript 환경에 존재하지 않으므로 이 장에서 다루지 않습니다. 간단한 프록시 생성Proxy 생성자를 사용하여 프록시를 만들 때, 두 개의 파라미터, 즉 대상과 핸들러를 넘깁니다. 핸들러는 하나 이상의 Trap을 정의하는 객체입니다. 프록시는 해당 작업에 대해 Trap이 정의된 경우를 제외하고 모든 작업에 대해 기본 동작을 사용합니다. 간단한 forwarding 프록시를 만들려면 Trap 없이 핸들러를 사용할 수 있습니다. 1234567891011let target = &#123;&#125;;let proxy = new Proxy(target, &#123;&#125;);proxy.name = \"proxy\";console.log(proxy.name); // \"proxy\"console.log(target.name); // \"proxy\"target.name = \"target\";console.log(proxy.name); // \"target\"console.log(target.name); // \"target\" 이 예제에서 proxy는 모든 작업을 target에 직접 전달합니다. &quot;proxy&quot;가 proxy.name 프로퍼티에 할당되면 name이 target에 생성됩니다. 프록시 자체가 이 프로퍼티를 저장하지 않습니다. 이것은 단순히 작업을 target으로 전달하는 것입니다. 비슷하게, proxy.name과 target.name의 값은 target.name을 참조하기 때문에 동일합니다. 즉, target.name을 새로운 값으로 설정하면 proxy.name도 같은 변경을 반영합니다. 그리고 Trap이 없는 프록시는 별로 흥미롭지 않으므로 Trap을 정의하면 어떻게 될까요? set Trap을 사용하여 프로퍼티 검증하기프로퍼티 값이 숫자여야 하는 객체를 만들고 싶다고 가정 해보겠습니다. 즉, 객체에 추가된 모든 새로운 프로퍼티에 대해 유효성 검사를 해야하며 값이 숫자가 아닌 경우 오류가 발생되어야 합니다. 이것을 달성하기 위해, 값을 설정하는 기본 동작을 무시하는 set Trap을 정의 할 수 있습니다. set Trap은 네개의 파라미터를 받습니다. trapTarget - 프로퍼티를 수신하는 객체 (프록시의 타겟) key - 프로퍼티 키 (문자열 또는 Symbol) value - 프로퍼티 값 receiver - 조작이 발생된 오브젝트 (일반적으로 프록시) Reflect.set()은 set Trap에 대응하는 리플렉션 메서드이며, 이 연산의 기본 동작입니다. Reflect.set() 메서드는 set 프록시 Trap과 동일한 네개의 파라미터를 받아 Trap 내부에서 메서드를 사용하기 쉽게 만듭니다. Trap은 프로퍼티가 설정되면 true를 반환하고 그렇지 않으면 false를 반환합니다 (Reflect.set() 메서드는 작업이 성공했는지 여부에 따라 올바른 값을 반환합니다). 프로퍼티의 값을 검증하기 위해서는 set Trap을 사용하고 입력된 value를 검사 해야합니다. 다음은 그 예제입니다. 12345678910111213141516171819202122232425262728293031let target = &#123; name: \"target\"&#125;;let proxy = new Proxy(target, &#123; set(trapTarget, key, value, receiver) &#123; // 기존 프로퍼티를 무시하므로 영향을주지 않습니다. if (!trapTarget.hasOwnProperty(key)) &#123; if (isNaN(value)) &#123; throw new TypeError(\"Property must be a number.\"); &#125; &#125; // 프로퍼티를 추가합니다. return Reflect.set(trapTarget, key, value, receiver); &#125;&#125;);// 새로운 프로퍼티를 추가합니다.proxy.count = 1;console.log(proxy.count); // 1console.log(target.count); // 1// 이미 대상에 존재하기 때문에 name에 지정할 수 있습니다.proxy.name = \"proxy\";console.log(proxy.name); // \"proxy\"console.log(target.name); // \"proxy\"// throws an errorproxy.anotherName = \"proxy\"; 이 코드는 target에 추가되는 새로운 프로퍼티의 값을 확인하는 프록시 Trap을 정의합니다. proxy.count=1이 실행되면 set Trap이 호출됩니다. trapTarget 값은 target과 같고 key는 count, value는 1이며 receiver(이 예제에서는 사용되지 않음)는proxy입니다. target에 count라는 이름의 기존 프로퍼티가 없으므로 프록시는 isNaN()에 전달하여 값의 유효성을 검사합니다. 결과가 NaN의 경우, 숫자값이 아니기 때문에 에러가 발생됩니다. 이 코드는 count를 1로 설정하기 때문에, 프록시는 새 프로퍼티를 추가하기 위해 Trap에 전달된 네개의 파라미터를 사용하여 Reflect.set()을 호출합니다. proxy.name에 문자열이 지정되어도 작업은 성공적으로 완료됩니다. target은 이미 name 프로퍼티를 가지고 있기 때문에, trapTarget.hasOwnProperty() 메서드를 호출함으로써 유효성 체크에서 그 프라퍼티를 생략합니다. 이렇게 하면 기존의 비숫자 프로퍼티 값이 계속 지원됩니다. 그러나 proxy.anotherName에 문자열이 할당되면 오류가 발생합니다. anotherName 프로퍼티는 target에 없으므로 해당 값의 유효성을 검사 해야합니다. 유효성 검사에서 &quot;proxy&quot;가 숫자 값이 아니기 때문에 오류가 발생합니다. 프로퍼티가 쓰여질 때 set 프록시 Trap이 가로챌수 있고, get 프록시 Trap은 프로퍼티가 읽혀질 때 가로 챌 수있습니다. get Trap을 사용하여 객체 모양 유효성 검사때때로 JavaScript의 흥미롭고 혼란스러운 부분 중 하나는 존재하지 않는 프로퍼티를 읽는 것이 오류를 발생시키지 않는다는 것입니다. 대신 다음 예와 같이 프로퍼티 값에 undefined 값이 사용됩니다. 123let target = &#123;&#125;;console.log(target.name); // undefined 대부분의 다른 언어에서 target.name을 읽으려고 하면 프로퍼티가 존재하지 않기 때문에 오류가 발생합니다. 그러나 JavaScript는 target.name 프로퍼티 값에 undefined를 사용합니다. 대규모 코드 기반에서 작업한 적이 있다면, 특히 프로퍼티 이름에 오타가있을 때 이 동작이 어떻게 심각한 문제를 일으킬 수 있는지 보셨을 것입니다. 프록시를 사용하면 객체 모양의 유효성 검사를 통해 이 문제를 방지 할 수 있습니다. 객체 모양은 객체에서 사용할 수있는 프로퍼티 및 메서드의 모음입니다. JavaScript 엔진은 객체 모양을 사용하여 코드를 최적화하고 종종 객체를 나타내는 클래스를 만듭니다. 객체가 항상 동일한 프로퍼티 및 메서드 (Object.preventExtensions() 메서드, Object.seal() 메서드 또는 Object.freeze() 메서드로 적용 할 수있는 동작)를 항상 가지고 있다고 가정할 수 있는 경우, 존재하지 않는 프로퍼티에 액세스하려는 시도에 오류가 발생하면 도움이될 수 있습니다. 프록시는 객체 모양 유효성 검사를 쉽게 만들수 있게 합니다. 프로퍼티 검증은 프로퍼티가 읽혀질 때만 발생해야 하기때문에 get Trap을 사용합니다. get Trap은 프로퍼티가 객체 상에 존재하지 않더라도 프로퍼티가 읽힐 때 호출되며 세개의 파라미터를 받습니다. trapTarget - 프로퍼티를 읽어내는 객체 (프록시의 타겟) key - 프로퍼티 키 (문자열 또는 Symbol) receiver - 조작이 발생된 오브젝트 (일반적으로 프록시) 이 파라미터는 set Trap의 파라미터와 유사하며, 눈에 띄는 차이점이 하나 있습니다. get Trap은 값을 쓰지 않기 때문에 value는 여기서 아무런 가치가 없습니다. Reflect.get() 메서드는 get Trap과 동일한 세개의 파라미터를 받아들이고 프로퍼티의 기본값을 반환합니다. 다음과 같이 get Trap과 Reflect.get()를 사용하여 프로퍼티가 대상에 없을때 에러를 발생시킬 수 있습니다. 12345678910111213141516let proxy = new Proxy(&#123;&#125;, &#123; get(trapTarget, key, receiver) &#123; if (!(key in receiver)) &#123; throw new TypeError(\"Property \" + key + \" doesn't exist.\"); &#125; return Reflect.get(trapTarget, key, receiver); &#125; &#125;);// 프로퍼티 추가는 잘 됩니다.proxy.name = \"proxy\";console.log(proxy.name); // \"proxy\"// 존재하지 않는 프로퍼티는 에러를 던집니다.console.log(proxy.nme); // throws error 이 예제에서, get Trap은 프로퍼티 읽기 연산을 가로 챕니다. in 연산자는 프로퍼티가 이미 receiver에 존재 하는지를 결정하는데 사용됩니다. receiver는 receiver가 has Trap을 가진 프록시인 경우에 trapTarget 대신에 in과 함께 사용됩니다. 다음 절에서 다루게될 타입입니다. 이 경우 trapTarget을 사용하면 has Trap을 회피하고 잠재적으로 잘못된 결과를 줄 수 있습니다. 프로퍼티가 없으면 오류가 발생하고 그렇지 않으면 기본 처리가 사용됩니다. 이 코드를 사용하면 proxy.name과 같은 새 프로퍼티는 아무 문제없이 추가하고 수정및 읽을 수 있습니다. 마지막 줄에는 오타가 있습니다. proxy.nme는 proxy.name이어야합니다. nme가 프로퍼티로 존재하지 않으므로 오류가 발생합니다. has Trap을 사용하여 프로퍼티 숨기기in 연산자는 주어진 객체에 프로퍼티가 존재하는지 여부를 판단하고, 이름이나 Symbol과 일치하는 자체 프로퍼티나 프로토 타입 프로퍼티가 있으면 true를 반환합니다. 123456let target = &#123; value: 42;&#125;console.log(\"value\" in target); // trueconsole.log(\"toString\" in target); // true value와 toString 모두 object에 존재하기 때문에 in 연산자는 true를 리턴합니다. value 프로퍼티는 자신의 프로퍼티이고toString는 (Object에서 상속받은) 프로토 타입 프로퍼티입니다. 프록시를 사용하면 이 작업을 가로 채고hasTrap을 사용하여in`에 다른 값을 반환할 수 있습니다. has Trap은 in 연산자가 사용될 때마다 호출됩니다. 호출될 때 두개의 파라미터가 has Trap에 전달됩니다. trapTarget - 프로퍼티의 read 객체 (프록시의 타겟) key - 체크 대상의 프로퍼티 키 (문자열 또는 Symbol) Reflect.has() 메서드는 동일한 파라미터를 받아 들여 in 연산자에 대한 기본 응답을 반환합니다. has Trap과 Reflect.has()를 사용하면 일부 프로퍼티는 in의 동작을 변경하고 다른 프로퍼티는 기본 동작으로 되돌릴 수 있습니다. 예를 들어, value 프로퍼티를 숨기고 싶다고 가정 해보십시오. 이렇게 할 수 있습니다. 1234567891011121314151617181920let target = &#123; name: \"target\", value: 42&#125;;let proxy = new Proxy(target, &#123; has(trapTarget, key) &#123; if (key === \"value\") &#123; return false; &#125; else &#123; return Reflect.has(trapTarget, key); &#125; &#125;&#125;);console.log(\"value\" in proxy); // falseconsole.log(\"name\" in proxy); // trueconsole.log(\"toString\" in proxy); // true proxy의 has Trap은 key가 value이면 false를 반환합니다. 그렇지 않으면 Reflect.has() 메서드를 호출하여 기본 동작을 사용합니다. 결과적으로 in 연산자는 value가 실제로 대상에 존재하더라도 value 프로퍼티에 대해 false를 반환합니다. name과 toString은 in 연산자와 함께 사용될 때 정확하게 true를 리턴합니다. deleteProperty Trap을 사용하여 프로퍼티 삭제 방지delete 연산자는 객체에서 프로퍼티를 제거하고, 성공하면 true를 실패하면 false를 반환합니다. strict 모드에서 delete는nonconfigurable 프로퍼티를 지울때 에러를 던집니다. nonstrict 모드에서 delete는 단순히 false를 반환합니다. 다음 예제를 참고하세요. 12345678910111213141516171819let target = &#123; name: \"target\", value: 42&#125;;Object.defineProperty(target, \"name\", &#123; configurable: false &#125;);console.log(\"value\" in target); // truelet result1 = delete target.value;console.log(result1); // trueconsole.log(\"value\" in target); // false// Note: 아래 라인은 strict 모드에서 에러가 발생합니다.let result2 = delete target.name;console.log(result2); // falseconsole.log(\"name\" in target); // true value 프로퍼티는 delete 연산자를 사용하여 삭제되고 결과적으로 in 연산자는 세 번째 console.log () 호출에서 false를 반환합니다. nonconfigurable name 프로퍼티는 삭제될 수 없으므로 delete 연산자는 단순히 false를 반환합니다 (이 코드가 strict 모드로 실행되면 대신 에러가 발생합니다). 프록시에서 deleteProperty Trap을 사용하여 이 동작을 변경할 수 있습니다. deleteProperty Trap은 객체 속성에서 delete 연산자가 사용될 때마다 호출됩니다. Trap에는 두개의 파라미터가 전달됩니다. trapTarget - 프로퍼티을 삭제해야 할 객체 (프록시의 대상) key - 삭제하는 프로퍼티 키 (문자열 또는 Symbol) Reflect.deleteProperty() 메서드는 deleteProperty Trap의 기본 구현을 제공하고 동일한 두개의 파라미터를 받아들입니다. Reflect.deleteProperty()와 deleteProperty Trap을 결합하여 delete 연산자가 어떻게 동작 하는지를 변경할 수 있습니다. 예를 들어, value 프로퍼티를 삭제할수 없도록 할수 있습니다. 123456789101112131415161718192021222324252627282930313233let target = &#123; name: \"target\", value: 42&#125;;let proxy = new Proxy(target, &#123; deleteProperty(trapTarget, key) &#123; if (key === \"value\") &#123; return false; &#125; else &#123; return Reflect.deleteProperty(trapTarget, key); &#125; &#125;&#125;);// Attempt to delete proxy.valueconsole.log(\"value\" in proxy); // truelet result1 = delete proxy.value;console.log(result1); // falseconsole.log(\"value\" in proxy); // true// Attempt to delete proxy.nameconsole.log(\"name\" in proxy); // truelet result2 = delete proxy.name;console.log(result2); // trueconsole.log(\"name\" in proxy); // false 이 코드는 has Trap 예제와 매우 비슷합니다. deleteProperty Trap은 key가 &quot;value&quot;인지 확인하고, 그렇다면 false를 리턴합니다. 그렇지 않으면 Reflect.deleteProperty() 메서드를 호출하여 기본 동작을 계속합니다. 연산이 Trap 되었기 때문에 value 프로퍼티는 프록시를 통해 삭제할 수 없지만 name 프로퍼티는 예상대로 삭제됩니다. 이 접근법은 strict 모드에서 오류를 던지지 않고 프로퍼티를 삭제되지 않도록 보호하려는 경우에 특히 유용합니다. Prototype 프록시 Trap4 장에서는 ECMAScript 5의 Object.getPrototypeOf() 메서드를 보완하기 위해 ECMAScript 6에 추가한 Object.setPrototypeOf() 메서드를 소개했습니다. 프록시를 사용하면 setPrototypeOf와 getPrototypeOf Trap을 통해 두 메서드의 실행을 가로챌 수 있습니다. 두 경우 모두Object 메서드는 프록시에서 해당 이름의 Trap을 호출하여 메서드의 동작을 변경할 수 있습니다. 프로토 타입 프록시와 관련된 두개의 Trap이 있고 각 Trap 유형과 관련된 메서드가 있습니다. setPrototypeOf Trap은 다음 파라미터를 받습니다. trapTarget - 프로토 타입을 설정해야하는 객체 (프록시의 대상) proto - 프로토 타입으로 사용하는 객체 이들은 Object.setPrototypeOf() 및 Reflect.setPrototypeOf() 메서드에 전달되는 동일한 파라미터입니다. 반면에 getPrototypeOf Trap은 trapTarget 파라미터만 받습니다. 파라미터는 Object.getPrototypeOf() 및 Reflect.getPrototypeOf() 메서드로 전달됩니다. 프로토 타입 프록시 Trap의 작동 방식이 Trap들에는 몇가지 제한 사항이 있습니다. 첫째, getPrototypeOf Trap은 객체 또는 null을 반환해야하고, 다른 반환 값은 런타임 오류를 발생시킵니다. 반환값 검사는 Object.getPrototypeOf()가 항상 예상값을 반환하도록 보장합니다. 비슷하게, 연산이 성공하지 못하면 setPrototypeOf Trap의 반환값은 false이어야합니다. setPrototypeOf가 false를 반환하면, Object.setPrototypeOf()는 에러를 던집니다. setPrototypeOf가 false가 아닌 다른 값을 반환하면 Object.setPrototypeOf()는 연산이 성공했다고 가정합니다. 다음 예제는 항상 null을 반환하여 프록시의 프로토 타입을 숨기며 프로토 타입을 변경할 수 없습니다. 12345678910111213141516171819202122let target = &#123;&#125;;let proxy = new Proxy(target, &#123; getPrototypeOf(trapTarget) &#123; return null; &#125;, setPrototypeOf(trapTarget, proto) &#123; return false; &#125;&#125;);let targetProto = Object.getPrototypeOf(target);let proxyProto = Object.getPrototypeOf(proxy);console.log(targetProto === Object.prototype); // trueconsole.log(proxyProto === Object.prototype); // falseconsole.log(proxyProto); // null// succeedsObject.setPrototypeOf(target, &#123;&#125;);// throws errorObject.setPrototypeOf(proxy, &#123;&#125;); 이 코드는 target과 proxy의 동작 사이의 차이점을 강조합니다. Object.getPrototypeOf()은 target에 대한 값을 반환하는 동안 getPrototypeOf Trap이 호출되기 때문에 proxy에 대해 null을 리턴합니다. 비슷하게 Object.setPrototypeOf()는 target에서 사용될 때 성공하지만 setPrototypeOf Trap으로 인해 proxy에서 사용될 때 에러를 던집니다. 이 두 Trap의 기본 동작을 사용하려면 Reflect에서 해당 메서드를 사용해야 합니다. 예를 들어, 이 코드는 getPrototypeOf 및 setPrototypeOf Trap의 기본 동작을 구현합니다. 123456789101112131415161718192021let target = &#123;&#125;;let proxy = new Proxy(target, &#123; getPrototypeOf(trapTarget) &#123; return Reflect.getPrototypeOf(trapTarget); &#125;, setPrototypeOf(trapTarget, proto) &#123; return Reflect.setPrototypeOf(trapTarget, proto); &#125;&#125;);let targetProto = Object.getPrototypeOf(target);let proxyProto = Object.getPrototypeOf(proxy);console.log(targetProto === Object.prototype); // trueconsole.log(proxyProto === Object.prototype); // true// succeedsObject.setPrototypeOf(target, &#123;&#125;);// also succeedsObject.setPrototypeOf(proxy, &#123;&#125;); 이 예에서, getPrototypeOf 및 setPrototypeOf Trap이 기본 실행을 사용하기 위해 통과하고 있기 때문에 target과 proxy를 교대로 사용할 수 있고 같은 결과를 얻을 수 있습니다. 이 예제는 몇가지 중요한 차이점 때문에 Object에서 같은 이름의 메서드보다는 Reflect.getPrototypeOf()와 Reflect.setPrototypeOf() 메서드를 사용하는 것이 중요합니다. 왜 두개의 Set 메서드일까요?Reflect.getPrototypeOf() 및 Reflect.setPrototypeOf()의 혼란스러운 부분은 Object.getPrototypeOf() 및 Object.setPrototypeOf() 메서드와 유사하게 보입니다. 두 세트의 메서드가 유사한 기능을 수행하지만, 두 메서드 사이에 뚜렷한 차이점이 있습니다. 우선, Object.getPrototypeOf() 및 Object.setPrototypeOf()는 처음부터 개발자를 위해 만든 상위 수준의 기능입니다. Reflect.getPrototypeOf() 및 Reflect.setPrototypeOf() 메서드는 개발자가 이전의 내부 전용 [[GetPrototypeOf]] 및 [[SetPrototypeOf]] 작업에 액세스할 수 있도록하는 하위 수준의 기능입니다. Reflect.getPrototypeOf() 메서드는 내부 [[GetPrototypeOf]] 연산의 래퍼 (일부 입력 유효성 검사 포함)입니다. Reflect.setPrototypeOf() 메서드와 [[SetPrototypeOf]]은 같은 관계입니다. Object의 해당 메서드는 [[GetPrototypeOf]] 및 [[SetPrototypeOf]]를 호출하지만 호출 전에 몇 단계를 수행하고 반환 값을 검사하여 동작 방법을 결정합니다. Reflect.getPrototypeOf() 메서드는 파라미터가 객체가 아닌 경우 오류를 발생시키고 Object.getPrototypeOf()는 먼저 작업을 수행하기 전에 값을 객체에 강제 변환합니다. 각 메서드에 숫자를 전달하면 다른 결과가 나타납니다. 12345let result1 = Object.getPrototypeOf(1);console.log(result1 === Number.prototype); // true// error가 발생Reflect.getPrototypeOf(1); Object.getPrototypeOf() 메서드는 값을 Number 객체로 강제 변환한 다음 Number.prototype을 반환하기 때문에 1의 프로토 타입을 가져옵니다. Reflect.getPrototypeOf() 메서드는 값을 강제로 변환하지 않으며 1은 객체가 아니기 때문에 오류를 던집니다. Reflect.setPrototypeOf() 메서드는 Object.setPrototypeOf() 메서드와 몇가지 다른 점이 있습니다. 첫째로, Reflect.setPrototypeOf()는 작업이 성공했는지를 나타내는 부울 값을 반환합니다. 성공하면 true 값이 반환되고 실패하면 false가 반환됩니다. Object.setPrototypeOf()는 실패하면 에러를 발생합니다. “프로토 타입 프록시 Trap의 작동 방식”의 첫 번째 예제에서 보듯이 setPrototypeOf 프록시 Trap이 false를 반환하면 Object.setPrototypeOf()는 오류를 발생시킵니다. Object.setPrototypeOf() 메서드는 첫 번째 인자를 값으로 반환하므로setPrototypeOf 프록시 Trap의 기본 실행을 구현하는데 적합하지 않습니다. 다음 코드는 이러한 차이점을 보여줍니다. 12345678let target1 = &#123;&#125;;let result1 = Object.setPrototypeOf(target1, &#123;&#125;);console.log(result1 === target1); // truelet target2 = &#123;&#125;;let result2 = Reflect.setPrototypeOf(target2, &#123;&#125;);console.log(result2 === target2); // falseconsole.log(result2); // true 이 예제에서 Object.setPrototypeOf()는 target1을 값으로 반환하지만 Reflect.setPrototypeOf()는 true를 반환합니다. 이 미묘한 차이는 매우 중요합니다. Object와 Reflect에 중복된 메서드가 더많이 보일것입니다. 항상 프록시 Trap 내에서 Reflect 메서드를 사용해야합니다. 두 메서드는 프록시에서 사용될 때 getPrototypeOf 및 setPrototypeOf 프록시 Trap을 호출합니다. Object 확장 TrapECMAScript 5는 Object.preventExtensions() 및 Object.isExtensible() 메서드를 통해 객체 확장성 수정을 추가했으며 ECMAScript 6을 사용하면 프록시가 preventExtensions 및 isExtensible Trap을 통해 기본 객체에 대한 메서드 호출을 차단할 수 있습니다. 두 Trap 모두 메서드가 호출된 객체인 trapTarget이라는 단일 파라미터를 받습니다. isExtensible Trap은 객체가 확장 가능한지 여부를 나타내는 부울값을 반환해야 하고 preventExtensions Trap은 작업이 성공했는지를 나타내는 부울값을 반환해야합니다. 또한 기본 동작을 구현하기 위해 Reflect.preventExtensions()와 Reflect.isExtensible() 메서드가 있습니다. 둘 다 부울값을 반환하므로 해당 Trap에서 직접 사용할 수 있습니다. 기본 예제 두개작업에서 객체 확장성 Trap을 확인 하기위해 isExtensible 및 preventExtensions Trap에 대한 기본 동작을 구현하는 다음 코드를 살펴보겠습니다. 123456789101112131415161718let target = &#123;&#125;;let proxy = new Proxy(target, &#123; isExtensible(trapTarget) &#123; return Reflect.isExtensible(trapTarget); &#125;, preventExtensions(trapTarget) &#123; return Reflect.preventExtensions(trapTarget); &#125;&#125;);console.log(Object.isExtensible(target)); // trueconsole.log(Object.isExtensible(proxy)); // trueObject.preventExtensions(proxy);console.log(Object.isExtensible(target)); // falseconsole.log(Object.isExtensible(proxy)); // false 이 예제는 Object.preventExtensions()와 Object.isExtensible() 모두 proxy에서 target으로 정확하게 전달되는 것을 보여줍니다. 물론 동작을 바꿀 수도 있습니다. 예를 들어 Object.preventExtensions()가 프록시에서 성공하지 못하도록하려는 경우 preventExtensions Trap에서 false를 반환할 수 있습니다. 123456789101112131415161718let target = &#123;&#125;;let proxy = new Proxy(target, &#123; isExtensible(trapTarget) &#123; return Reflect.isExtensible(trapTarget); &#125;, preventExtensions(trapTarget) &#123; return false &#125;&#125;);console.log(Object.isExtensible(target)); // trueconsole.log(Object.isExtensible(proxy)); // trueObject.preventExtensions(proxy);console.log(Object.isExtensible(target)); // trueconsole.log(Object.isExtensible(proxy)); // true preventExtensions Trap이 false를 반환하기 때문에 Object.preventExtensions(proxy)에 대한 호출이 무시됩니다. 작업은 기본 target으로 전달되지 않으므로 Object.isExtensible()은 true를 반환합니다. 중복 확장 메서드다시 한번, Object와 Reflect에 중복된 메서드가 있다는 것을 눈치챘을 것입니다. 이 경우에는 더 유사합니다. Object.isExtensible() 및 Reflect.isExtensible() 메서드는 비객체 값이 전달된 경우를 제외하고는 서로 비슷합니다. 이 경우 Reflect.isExtensible()이 오류를 발생하고 Object.isExtensible()은 항상 false를 반환합니다. 다음은 그 동작의 예제입니다. 12345let result1 = Object.isExtensible(2);console.log(result1); // false// error 발생let result2 = Reflect.isExtensible(2); 이 제한은 Object.getPrototypeOf()와 Reflect.getPrototypeOf() 메서드의 차이와 유사합니다. 하위 레벨 기능의 메서드는 상위 레벨 기능보다 더 엄격한 오류 확인 기능을 가지고 있기 때문입니다. Object.preventExtensions() 및 Reflect.preventExtensions() 메서드도 매우 비슷합니다. Object.preventExtensions() 메서드는 값이 객체가 아닌 경우에 파라미터로 전달된 값을 항상 반환합니다. 반대로 Reflect.preventExtensions() 메서드는 파라미터가 객체가 아닌 경우 오류를 발생시킵니다. 파라미터가 객체인 경우 Reflect.preventExtensions()는 작업이 성공하면 true를 반환하고 그렇지 않으면 false를 반환합니다. 123456789let result1 = Object.preventExtensions(2);console.log(result1); // 2let target = &#123;&#125;;let result2 = Reflect.preventExtensions(target);console.log(result2); // true// throws errorlet result3 = Reflect.preventExtensions(2); 여기서 Object.preventExtensions()는 2가 객체가 아니더라도 2를 통과 시킵니다. Reflect.preventExtensions() 메서드는 객체가 전달될 때 true를 반환하고 2를 전달하면 오류를 발생시킵니다. 프로퍼티 Descriptor TrapECMAScript 5의 가장 중요한 기능중 하나는 Object.defineProperty() 메서드를 사용하여 프로퍼티 속성을 정의하는 기능이었습니다. 이전 버전의 JavaScript에서는 Accessor 프로퍼티를 정의하거나, 속성을 Read-only로 만들거나, 속성을 Nonenumerable하게 만들 수있는 방법이 없었습니다. 이 모든 작업은 Object.defineProperty() 메서드를 사용하여 수행할 수 있으며 Object.getOwnPropertyDescriptor() 메서드를 사용하여 이러한 속성을 검색할 수 있습니다. 프록시를 사용하면 defineProperty 및 getOwnPropertyDescriptor Trap을 각각 사용하여 Object.defineProperty() 및 Object.getOwnPropertyDescriptor()에 대한 호출을 가로 채게할 수 있습니다. defineProperty Trap은 다음 파라미터를 받습니다. trapTarget - 프로퍼티을 정의 할 필요가있는 객체 (프록시의 대상) key - 프로퍼티의 문자열 또는 Symbol descriptor - 프로퍼티 설명 객체 defineProperty Trap은 작업이 성공하면 true를, 그렇지 않으면 false를 반환합니다. getOwnPropertyDescriptor Trap은 trapTarget과 key만 받으며, Descriptor를 리턴해야합니다. 상응하는 Reflect.defineProperty()와 Reflect.getOwnPropertyDescriptor() 메서드는 프록시 Trap과 동일한 파라미터를 받습니다. 다음은 각 Trap의 기본 동작을 구현하는 예제입니다. 12345678910111213141516171819let proxy = new Proxy(&#123;&#125;, &#123; defineProperty(trapTarget, key, descriptor) &#123; return Reflect.defineProperty(trapTarget, key, descriptor); &#125;, getOwnPropertyDescriptor(trapTarget, key) &#123; return Reflect.getOwnPropertyDescriptor(trapTarget, key); &#125;&#125;);Object.defineProperty(proxy, \"name\", &#123; value: \"proxy\"&#125;);console.log(proxy.name); // \"proxy\"let descriptor = Object.getOwnPropertyDescriptor(proxy, \"name\");console.log(descriptor.value); // \"proxy\" 이 코드는 Object.defineProperty() 메서드를 사용하여 프록시에서 &quot;name&quot;이라는 프로퍼티를 정의합니다. 그런 다음 해당 프로퍼티의 Descriptor가 Object.getOwnPropertyDescriptor() 메서드에 의해 검색됩니다. Object.defineProperty() 잠그기defineProperty Trap은 조작이 성공했는지 여부를 나타내기 위해 부울 값을 리턴하도록 요구합니다. true가 리턴되면, Object.defineProperty()는 평소대로 성공합니다; false가 리턴되면 Object.defineProperty()는 에러를 발생시킵니다. 이 기능을 사용하여 Object.defineProperty() 메서드가 정의할 수있는 프로퍼티의 종류를 제한할 수 있습니다. 예를 들어 Symbol 프로퍼티가 정의되지 않도록하려면 key가 문자열인지 확인하고 그렇지 않으면 false를 반환합니다. 123456789101112131415161718192021222324let proxy = new Proxy(&#123;&#125;, &#123; defineProperty(trapTarget, key, descriptor) &#123; if (typeof key === \"symbol\") &#123; return false; &#125; return Reflect.defineProperty(trapTarget, key, descriptor); &#125;&#125;);Object.defineProperty(proxy, \"name\", &#123; value: \"proxy\"&#125;);console.log(proxy.name); // \"proxy\"let nameSymbol = Symbol(\"name\");// error 발생Object.defineProperty(proxy, nameSymbol, &#123; value: \"proxy\"&#125;); defineProperty 프록시 Trap은 key가 Symbol 일 때 false를 리턴하고 그렇지 않으면 기본 동작을 진행합니다. name을 key로 하여 Object.defineProperty()를 호출하면, key가 문자열이기 때문에 메서드가 성공합니다. Object.defineProperty()가 nameSymbol과 함께 호출되면 defineProperty Trap이 false를 반환하기 때문에 에러가 발생합니다. 또한 Reflect.defineProperty() 메서드를 호출하지 않고 true를 리턴함으로써 Object.defineProperty()가 자동으로 실패하도록 할 수 있습니다. 실제로 프로퍼티를 정의하지 않는 동안 오류가 표시되지 않습니다. Descriptor 객체 제한 사항Object.defineProperty() 및 Object.getOwnPropertyDescriptor() 메서드를 사용할 때 일관된 동작을 보장하기 위해 defineProperty Trap에 전달된 Descriptor 객체가 정규화됩니다. getOwnPropertyDescriptor Trap에서 반환된 객체는 같은 이유로 항상 유효성이 검사됩니다. 어떤 객체가 Object.defineProperty() 메서드의 세 번째 파라미터로 전달 되더라도, enumerable, configurable, value, writable, get 및 set 속성들만 defineProperty Trap로 전달된 Descrptor 객체에 있을수 있습니다. 1234567891011121314let proxy = new Proxy(&#123;&#125;, &#123; defineProperty(trapTarget, key, descriptor) &#123; console.log(descriptor.value); // \"proxy\" console.log(descriptor.name); // undefined return Reflect.defineProperty(trapTarget, key, descriptor); &#125;&#125;);Object.defineProperty(proxy, \"name\", &#123; value: \"proxy\", name: \"custom\"&#125;); 여기서, Object.defineProperty()는 세 번째 파라미터에 비표준 name 프로퍼티를 가지고 호출됩니다. defineProperty Trap이 호출되면, descriptor 객체는 name 프로퍼티를 갖지 않고 value 프로퍼티는 갖습니다. 왜냐하면 descriptor는 Object.defineProperty() 메서드에 전달된 실제 세 번째 파라미터에 대한 참조가 아니라 허용 가능한 프로퍼티만을 포함하는 새로운 객체이기 때문입니다. Reflect.defineProperty() 메서드는 또한 Descriptor의 비표준 특성을 무시합니다. getOwnPropertyDescriptor Trap은 반환값이 null, undefined 또는 객체가되도록 약간 다른 제한이 있습니다. 객체가 반환되면 객체의 자체 프로퍼티로 enumerable, configurable, value, writable, get 및 set 만 허용됩니다. 아래 코드와 같이 허용되지 않는 자체 프로퍼티를 가진 객체를 반환하면 오류가 발생합니다. 12345678910let proxy = new Proxy(&#123;&#125;, &#123; getOwnPropertyDescriptor(trapTarget, key) &#123; return &#123; name: \"proxy\" &#125;; &#125;&#125;);// error 발생let descriptor = Object.getOwnPropertyDescriptor(proxy, \"name\"); 프로퍼티 Descriptor에서 name 프로퍼티를 사용할 수 없으므로 Object.getOwnPropertyDescriptor()가 호출되면 getOwnPropertyDescriptor 반환값은 오류를 발생시킵니다. 이 제약은, Object.getOwnPropertyDescriptor()에 의해 돌려 주어지는 값이, 프록시상에서의 사용에 관계없이 항상 신뢰할 수있는 구조를 가지는 것을 보증합니다. 중복된 Descriptor 메서드다시 한번, ECMAScript 6는 Object.defineProperty() 및Object.getOwnPropertyDescriptor() 메서드가 Reflect.defineProperty() 및 Reflect.getOwnPropertyDescriptor() 메서드와 동일한 기능을 수행하는 것처럼 혼동을 불러 일으키는 유사한 메서드를 가지고 있습니다. 이 장의 앞 부분에서 논의된 다른 메서드와 마찬가지로, 이들은 미묘하지만 중요한 차이점이 있습니다. defineProperty() 메서드Object.defineProperty() 및 Reflect.defineProperty() 메서드는 반환 값을 제외하고 완전히 동일합니다. Object.defineProperty() 메서드는 첫 번째 피라미터를 반환하고 Reflect.defineProperty()는 작업이 성공하면 true를 반환하고 그렇지 않으면 false를 반환합니다. 123456789let target = &#123;&#125;;let result1 = Object.defineProperty(target, \"name\", &#123; value: \"target \"&#125;);console.log(target === result1); // truelet result2 = Reflect.defineProperty(target, \"name\", &#123; value: \"reflect\" &#125;);console.log(result2); // true target에서 Object.defineProperty()가 호출되면 반환값은 target입니다. Reflect.defineProperty()가 target에서 호출되면 반환값은 연산이 성공했음을 나타내는 true입니다. defineProperty 프록시 Trap은 반환될 부울 값을 필요로하기 때문에 필요할 때 Reflect.defineProperty()를 사용하여 기본 동작을 구현하는 것이 좋습니다. getOwnPropertyDescriptor() 메서드Object.getOwnPropertyDescriptor() 메서드는 Primitive 값이 전달될 때 첫 번째 파라미터를 객체로 강제 변환한 다음 작업을 계속합니다. 반면에 첫 번째 파라미터가 Primitive 값이면 Reflect.getOwnPropertyDescriptor() 메서드는 오류를 발생시킵니다. 다음은 이 두 가지를 보여주는 예입니다. 12345let descriptor1 = Object.getOwnPropertyDescriptor(2, \"name\");console.log(descriptor1); // undefined// throws an errorlet descriptor2 = Reflect.getOwnPropertyDescriptor(2, \"name\"); Object.getOwnPropertyDescriptor() 메서드는 2를 객체로 강제변환하고 객체에는 name 프로퍼티가 없기 때문에 undefined를 반환합니다. 주어진 이름을 가진 프로퍼티가 객체에서 발견되지 않을때의 메서드 표준 동작입니다. 그러나 Reflect.getOwnPropertyDescriptor()가 호출되면 해당 메서드가 첫 번째 파라미터에 대한 Primitive 값을 허용하지 않기 때문에 오류가 즉시 발생합니다. ownKeys TrapownKeys 프록시 Trap은 내부 메서드 [[OwnPropertyKeys]]를 가로 채고, 여러분이 값의 Array를 반환함으로써 동작을 오버라이드할 수 있도록합니다. 이 Array는 Object.keys(), Object.getOwnPropertyNames(), Object.getOwnPropertySymbols() 및 Object.assign()의 네 가지 메서드를 사용합니다. Object.assign() 메서드는 Array를 사용하여 복사할 프로퍼티를 결정합니다. ownKeys Trap의 기본 동작은 Reflect.ownKeys() 메서드에 의해 구현되고 문자열과 Symbol을 포함한 모든 고유한 프로퍼티 키의 Array를 반환합니다. Object.getOwnProperyNames() 메서드 및 Object.keys() 메서드는 Array에서 Symbol을 필터링하고 결과를 반환하며 Object.getOwnPropertySymbols()는 Array에서 문자열을 필터링하여 결과를 반환합니다. Object.assign() 메서드는 문자열과 Symbol이 모두 포함된 Array를 사용합니다. ownKeys Trap은 대상을 하나의 파라미터로 받고, 항상 Array이나 유사 Array와 같은 객체를 반환해야합니다; 그렇지 않으면 오류가 발생합니다. OwnKeys Trap을 사용하면, 예를 들어, Object.getOwnPropertyNames(), Object.getOwnPropertySymbols(), Object.getOwnPropertyNames(), 또는 Object.assign() 메서드가 사용됩니다. JavaScript에서 필드가 비공개임을 나타내는 일반적인 표기법인 밑줄 문자(underscore)로 시작하는 프로퍼티 이름은 포함하지 않으려는 경우로 가정하여 ownKeys Trap을 사용하여 다음과 같이 키를 걸러낼 수 있습니다. 1234567891011121314151617181920212223242526let proxy = new Proxy(&#123;&#125;, &#123; ownKeys(trapTarget) &#123; return Reflect.ownKeys(trapTarget).filter(key =&gt; &#123; return typeof key !== \"string\" || key[0] !== \"_\"; &#125;); &#125;&#125;);let nameSymbol = Symbol(\"name\");proxy.name = \"proxy\";proxy._name = \"private\";proxy[nameSymbol] = \"symbol\";let names = Object.getOwnPropertyNames(proxy), keys = Object.keys(proxy); symbols = Object.getOwnPropertySymbols(proxy);console.log(names.length); // 1console.log(names[0]); // \"name\"console.log(keys.length); // 1console.log(keys[0]); // \"name\"console.log(symbols.length); // 1console.log(symbols[0]); // \"Symbol(name)\" 이 예제는 Reflect.ownKeys()를 먼저 호출하여 대상의 기본 리스트를 얻는 ownKeys Trap을 사용합니다. 그런 다음 filter() 메서드는 문자열이며 밑줄 문자로 시작하는 키를 필터링하는데 사용됩니다. 그런 다음 proxy 객체에 세가지 프로퍼티가 추가됩니다.(name, _name 및 nameSymbol). Object.getOwnPropertyNames()와 Object.keys()가 proxy에서 호출되면 name 프로퍼티만 반환됩니다. 비슷하게 Object.getOwnPropertySymbols()가 proxy에서 호출될 때 nameSymbol만 반환됩니다. _name 프로퍼티는 필터링되어서 어느 결과에도 나타나지 않습니다. ownKeys Trap은 또한 for-in 루프에 영향을 미칩니다.이 루프는 Trap을 호출하여 루프 내부에서 사용할 키를 결정합니다. apply와 construct Trap을 이용한 Function 프록시모든 프록시 Trap 중, apply와 construct만이 프록시 대상으로 함수가 필요합니다. 3장에서 함수는 각각 new 연산자를 사용하지 않고 함수를 호출할 때 실행되는 [[Call]] 및 [[Construct]]라는 두가지 내부 메서드를 가지고 있음을 설명했습니다. apply 및 construct Trap은 해당 내부 메서드를 재정의 하도록합니다. 함수가 new 없이 호출되면, apply Trap은 Reflect.apply()에 다음 파라미터가 필요합니다. trapTarget - 실행중인 함수 (프록시의 대상) thisArg - 호출 중 함수 안에있는 this의 값 argumentsList - 함수에게 건네진 파라미터 Array new를 사용하여 함수가 실행될 때 호출되는 construct Trap은 다음 파라미터를 받습니다. trapTarget - 실행중인 함수 (프록시의 대상) argumentsList - 함수에게 건네진 파라미터 Array Reflect.construct() 메서드는 또한 이 두개의 파라미터를 받아들이며 newTarget이라는 선택적인 세 번째 파라미터를 받습니다. 주어진 경우, newTarget 파라미터는 함수 안에 new.target의 값을 지정합니다. apply와construct Trap은 모든 프록시 대상 함수의 동작을 완벽하게 제어합니다. 함수의 기본 동작을 모방하려면 다음과 같이 하면됩니다. 123456789101112131415161718let target = function() &#123; return 42 &#125;, proxy = new Proxy(target, &#123; apply: function(trapTarget, thisArg, argumentList) &#123; return Reflect.apply(trapTarget, thisArg, argumentList); &#125;, construct: function(trapTarget, argumentList) &#123; return Reflect.construct(trapTarget, argumentList); &#125; &#125;);// 함수를 대상으로하는 프록시는 함수처럼 보입니다.console.log(typeof proxy); // \"function\"console.log(proxy()); // 42var instance = new proxy();console.log(instance instanceof proxy); // trueconsole.log(instance instanceof target); // true 이 예제에서 숫자 42를 반환하는 함수를 가지고 있습니다. 이 함수의 프록시는 apply와 construct Trap을 사용하여 그 동작을 각각 Reflect.apply()와 Reflect.construct() 메서드에 위임합니다. 결과적으로 프록시 함수는 typeof가 사용될 때 함수로 자신을 식별하는 것을 포함하여 대상 함수와 똑같이 동작합니다. 프록시는 42를 반환하기 위해 new 없이 호출합니다. 그리고 new를 호출하여 instance라는 객체를 만듭니다. instance 객체는 프로토 타입 체인을 사용하여 이 정보를 결정하기 때문에 proxy와 target의 인스턴스로 간주됩니다. 프로토 타입 체인 조회는 이 프록시의 영향을 받지 않으므로 프록시와 대상이 JavaScript 엔진과 동일한 프로토 타입을 사용하는 것으로 보여집니다. 함수 파라미터 유효성 검사apply와 construct Trap은 함수가 실행되는 방식을 변경하는 많은 가능성을 열어줍니다. 예를 들어 모든 파라미터가 특정 타입인지 확인하려고 한다고 가정해 보겠습니다. apply Trap에서 파라미터를 확인할 수 있습니다. 12345678910111213141516171819202122232425262728// 모든 파라미터를 더합니다.function sum(...values) &#123; return values.reduce((previous, current) =&gt; previous + current, 0);&#125;let sumProxy = new Proxy(sum, &#123; apply: function(trapTarget, thisArg, argumentList) &#123; argumentList.forEach((arg) =&gt; &#123; if (typeof arg !== \"number\") &#123; throw new TypeError(\"All arguments must be numbers.\"); &#125; &#125;); return Reflect.apply(trapTarget, thisArg, argumentList); &#125;, construct: function(trapTarget, argumentList) &#123; throw new TypeError(\"This function can't be called with new.\"); &#125; &#125;);console.log(sumProxy(1, 2, 3, 4)); // 10// error를 발생시킵니다.console.log(sumProxy(1, \"2\", 3, 4));// 역시 error를 발생시킵니다.let result = new sumProxy(); 이 예제는 apply Trap을 사용하여 모든 파라미터가 숫자임을 확인합니다. sum() 함수는 전달된 모든 파라미터를 더합니다. 숫자가 아닌 값이 전달되면 이 함수는 계속 작업을 시도하므로 예기치 않은 결과가 발생할 수 있습니다. sum()을 sumProxy() 프록시 안에 넣음으로써 이 코드는 함수 호출을 가로 채고 호출이 진행되기 전에 각 파라미터가 숫자인지 확인합니다. 안전을 위해, 코드는 construct Trap을 사용하여 new 함수를 호출할 수 없도록합니다. 함수를 new로 호출하고 파라미터가 숫자인지 확인해야합니다. 1234567891011121314151617181920212223242526function Numbers(...values) &#123; this.values = values;&#125;let NumbersProxy = new Proxy(Numbers, &#123; apply: function(trapTarget, thisArg, argumentList) &#123; throw new TypeError(\"This function must be called with new.\"); &#125;, construct: function(trapTarget, argumentList) &#123; argumentList.forEach((arg) =&gt; &#123; if (typeof arg !== \"number\") &#123; throw new TypeError(\"All arguments must be numbers.\"); &#125; &#125;); return Reflect.construct(trapTarget, argumentList); &#125; &#125;);let instance = new NumbersProxy(1, 2, 3, 4);console.log(instance.values); // [1,2,3,4]// throws errorNumbersProxy(1, 2, 3, 4); 여기서 construct Trap이 Reflect.construct() 메서드를 사용하여 입력값을 검증하고 새로운 인스턴스를 리턴할 때 apply Trap은 오류를 던집니다. 물론, 대신에 new.target을 사용하여 프록시없이 동일한 것을 수행할 수 있습니다. new가 없는 생성자 호출3 장에서 new.target 메타 프로퍼티를 소개했습니다. new.target은 new가 호출되는 함수에 대한 참조입니다. 즉, new.target의 값을 다음과 같이 검사하여 new를 사용하여 함수를 호출했는지 여부를 알 수 있습니다. 1234567891011121314function Numbers(...values) &#123; if (typeof new.target === \"undefined\") &#123; throw new TypeError(\"This function must be called with new.\"); &#125; this.values = values;&#125;let instance = new Numbers(1, 2, 3, 4);console.log(instance.values); // [1,2,3,4]// throws errorNumbers(1, 2, 3, 4); 이 예제는 “함수 파라미터 유효성 검사” 섹션의 프록시를 사용하지 않는 예제와 유사하며, new를 사용하지 않고 Numbers가 호출될 때 에러를 던집니다. 유일한 목적이 new없이 함수를 호출하는 것을 방지하는 것이라면 이와 같은 코드를 작성하는 것은 프록시를 사용하는 것보다 훨씬 간단하며 바람직합니다. 그러나 때로는 동작을 수정해야하는 함수를 제어하지 못하는 경우가 있습니다. 이 경우 프록시를 사용하는 것이 좋습니다. Numbers 함수가 수정할 수 없는 코드에 정의되었다고 가정해 보겠습니다. 이 코드는 new.target에 의존하고 있으며 여전히 함수를 호출할 때 체크를 피하기를 원합니다. new를 사용할 때의 동작은 이미 설정되어 있으므로 apply Trap을 사용할 수 있습니다. 12345678910111213141516171819function Numbers(...values) &#123; if (typeof new.target === \"undefined\") &#123; throw new TypeError(\"This function must be called with new.\"); &#125; this.values = values;&#125;let NumbersProxy = new Proxy(Numbers, &#123; apply: function(trapTarget, thisArg, argumentsList) &#123; return Reflect.construct(trapTarget, argumentsList); &#125; &#125;);let instance = NumbersProxy(1, 2, 3, 4);console.log(instance.values); // [1,2,3,4] NumbersProxy 함수는 new를 사용하지 않고 Numbers를 호출하고 new가 사용된 것처럼 행동하게합니다. 그렇게하기 위해, apply Trap은 Reflect.construct()를 호출하고 apply에 전달된 파라미터를 사용합니다. Numbers 내부의 new.target은 Numbers 자체와 동일하며 에러는 발생하지 않습니다. 이것은 new.target을 변경하는 간단한 예제이지만, 더 직접적으로 할 수도 있습니다. 추상 기본 클래스 생성자 (Abstract Base Class Constructor) 재정의한 걸음 더 나아가 new.target에 할당할 특정 값으로 Reflect.construct()의 세 번째 파라미터를 지정할 수 있습니다. 이는 함수가 추상 기본 클래스 생성자를 생성할 때(9 장에서 설명)와 같이 알려진 값에 대해 new.target을 검사할 때 유용합니다. 추상 기본 클래스 생성자에서, new.target은 이 예제에서와 같이 클래스 생성자 그 자체가 아닌 다른 것으로 예상됩니다. 123456789101112131415161718class AbstractNumbers &#123; constructor(...values) &#123; if (new.target === AbstractNumbers) &#123; throw new TypeError(\"This function must be inherited from.\"); &#125; this.values = values; &#125;&#125;class Numbers extends AbstractNumbers &#123;&#125;let instance = new Numbers(1, 2, 3, 4);console.log(instance.values); // [1,2,3,4]// throws errornew AbstractNumbers(1, 2, 3, 4); new AbstractNumbers()가 호출되면, new.target은 AbstractNumbers와 같기 때문에 에러를 발생 시킵니다. new.target이 Numbers와 같기 때문에 new Numbers()는 여전히 작동합니다. 수동으로 new.target에 프록시를 할당함으로써 이 제약을 우회할 수 있습니다. 1234567891011121314151617181920class AbstractNumbers &#123; constructor(...values) &#123; if (new.target === AbstractNumbers) &#123; throw new TypeError(\"This function must be inherited from.\"); &#125; this.values = values; &#125;&#125;let AbstractNumbersProxy = new Proxy(AbstractNumbers, &#123; construct: function(trapTarget, argumentList) &#123; return Reflect.construct(trapTarget, argumentList, function() &#123;&#125;); &#125; &#125;);let instance = new AbstractNumbersProxy(1, 2, 3, 4);console.log(instance.values); // [1,2,3,4] AbstractNumbersProxy는 construct Trap을 사용하여 new AbstractNumbersProxy() 메서드에 대한 호출을 가로챕니다. 그런 다음, Reflect.construct() 메서드가 Trap의 파라미터와 함께 호출되고 빈 함수를 세 번째 파라미터로 추가합니다. 그 빈 함수는 생성자 내부의 new.target의 값으로 사용됩니다. new.target이 AbstractNumbers와 같지 않기 때문에 오류가 발생하지 않고 생성자가 완전히 실행됩니다. 호출가능한 클래스 생성자9 장에서는 클래스 생성자가 항상 new로 호출되어야 한다고 설명했다. 이는 클래스 생성자에 대한 내부 [[Call]] 메서드가 오류를 throw 하도록 지정 되었기 때문에 발생합니다. 그러나 프록시는 [[Call]] 메서드에 대한 호출을 가로챌 수 있습니다. 즉, 프록시를 사용하여 호출 가능한 클래스 생성자를 효과적으로 만들 수 있습니다. 예를 들어, 클래스 생성자가 new를 사용하지 않고 동작하게 하려면, apply Trap을 사용하여 새로운 인스턴스를 생성 할 수 있습니다. 다음은 몇 가지 샘플 코드입니다. 1234567891011121314151617class Person &#123; constructor(name) &#123; this.name = name; &#125;&#125;let PersonProxy = new Proxy(Person, &#123; apply: function(trapTarget, thisArg, argumentList) &#123; return new trapTarget(...argumentList); &#125; &#125;);let me = PersonProxy(\"Nicholas\");console.log(me.name); // \"Nicholas\"console.log(me instanceof Person); // trueconsole.log(me instanceof PersonProxy); // true PersonProxy 객체는 Person 클래스 생성자의 프록시입니다. 클래스 생성자는 단지 함수이므로 프록시에서 사용될 때 함수처럼 작동합니다. apply Trap은 기본 동작을 재정의하고 대신 Person과 같은 trapTarget의 새로운 인스턴스를 반환합니다(이 예제에서 trapTarget을 사용하여 클래스를 수동으로 지정하지 않아도 된다는 것을 보여주기 위해 사용했습니다). argumentList는 Spread 연산자를 사용하여 각 파라미터가 개별적으로trapTarget에 전달됩니다.new를 사용하지 않고PersonProxy()를 호출하면Person의 인스턴스를 반환합니다(new없이Person()`을 호출하려고 하면 생성자는 여전히 오류를 던질 것입니다). 호출 가능한 클래스 생성자를 만드는 것은 프록시를 사용하는 경우에만 가능합니다. 취소 가능한 프록시일반적으로 프록시가 생성되면 프록시는 대상에서 재배치할 수 없습니다. 이장의 모든 예제는 재배치할 수 없는 프록시를 사용했습니다. 그러나 더이상 사용할 수 없도록 프록시를 취소하려는 경우가 있을 수 있습니다. 보안을 위해 API를 통해 객체를 제공하고 언제든지 일부 기능에 대한 액세스를 차단할 수 있는 기능을 유지하려는 경우 프록시를 해지하는 것이 유용합니다. Proxy.revocable() 메서드로 취소 가능한 프록시를 생성할 수 있습니다. 이 메서드는 대상 객체와 프록시 핸들러인 Proxy 생성자와 같은 파라미터를 사용합니다. 반환 값은 다음과 같은 프로퍼티를 가진 객체입니다. proxy - 취소할 수 있는 프록시 객체 revoke - 프록시를 취소하기 위해서 호출하는 함수 revoke() 함수가 호출될 때, proxy를 통해 더 이상의 연산을 수행할 수 없습니다. 프록시 Trap을 발생시키는 방식으로 프록시 오브젝트와 상호 작용하려는 모든 시도는 오류를 발생시킵니다. 123456789101112let target = &#123; name: \"target\"&#125;;let &#123; proxy, revoke &#125; = Proxy.revocable(target, &#123;&#125;);console.log(proxy.name); // \"target\"revoke();// error 발생console.log(proxy.name); 이 예제는 취소 가능한 프록시를 만듭니다. Proxy.revocable() 메서드에 의해 반환된 객체에서 같은 이름의 프로퍼티에 proxy와 revoke 변수를 할당하기 위해 Destructuring을 사용합니다. 그 후, proxy 객체는 취소가 불가능한(nonrevocable) 프록시 객체처럼 사용될 수 있습니다. 그래서 proxy.name은 target.name을 그대로 통과하기 때문에 &quot;target&quot;을 리턴합니다. 그러나 일단 revoke() 함수가 호출되면, 프록시는 더이상 함수가 아닙니다. proxy.name에 접근하려고 시도하면 에러가 발생하고, 프록시에서 Trap을 발생시키는 다른 동작도 마찬가지입니다. Array의 문제점 해결하기이장의 시작 부분에서 개발자가 ECMAScript 6 이전의 JavaScript에서 Array의 동작을 정확하게 모방할 수 없다는 것을 설명했습니다. 프록시와 리플렉션 API를 사용하면 프로퍼티가 추가되고 제거될 때 Built-in Array 타입과 같은 방식으로 동작하는 객체를 생성할 수 있습니다. 기억을 되새겨 아래 예제는 프록시가 Array를 모방하는데 도움이되는 동작을 보여주는 예입니다. 123456789101112131415let colors = [\"red\", \"green\", \"blue\"];console.log(colors.length); // 3colors[3] = \"black\";console.log(colors.length); // 4console.log(colors[3]); // \"black\"colors.length = 2;console.log(colors.length); // 2console.log(colors[3]); // undefinedconsole.log(colors[2]); // undefinedconsole.log(colors[1]); // \"green\" 위 예제에서 주의해야할 두가지 중요한 동작이 있습니다. colors[3]에 값이 할당되면 length 프로퍼티가 4로 증가합니다. length 프로퍼티가 2로 설정되면 Array의 마지막 두 항목이 삭제됩니다. 이 두가지 동작은 Built-in Array의 작동 방식을 정확하게 재현하기 위해 모방되어야하는 중요한 동작입니다. 다음 몇 섹션에서는 올바르게 Array 객체를 모방하는 방법을 설명합니다. Array 색인 찾기정수형 프로퍼티 키에 할당하는 것은 비 정수형 키와 다르게 취급되는 Array의 특별한 경우입니다. ECMAScript 6 사양에서는 프로퍼티 키가 Array 인덱스인지 확인하는 방법에 대한 지침을 제공합니다. toString(ToUint32(P))이 P이고 ToUint32(P)가 2 ^ 32-1이 아니면 String 프로퍼티 이름 P는 Array 인덱스입니다. 이 연산자는 다음과 같이 JavaScript로 구현될 수 있습니다. 12345678function toUint32(value) &#123; return Math.floor(Math.abs(Number(value))) % Math.pow(2, 32);&#125;function isArrayIndex(key) &#123; let numericKey = toUint32(key); return String(numericKey) == key &amp;&amp; numericKey &lt; (Math.pow(2, 32) - 1);&#125; toUint32() 함수는 사양에 설명된 알고리즘을 사용하여 주어진 값을 부호없는 32비트 정수로 변환합니다. isArrayIndex() 함수는 먼저 키를 uint32로 변환한 다음 비교를 수행하여 키가 Array 인덱스인지 여부를 확인합니다. 이러한 유틸리티 함수를 사용할 수 있으면 Built-in Array를 모방할 객체를 구현할 수 있습니다. 새로운 요소를 추가할 때 length 증가설명한 두Array의 동작이 프로퍼티 할당에 의존한다는 것을 눈치 챘을 것입니다. 즉, 두가지 동작을 모두 수행하려면 set 프록시 Trap을 사용해야합니다. 먼저 length-1보다 큰 Array 인덱스가 사용되면 length 프로퍼티를 증가시켜 첫 번째 두가지 동작을 구현하는 예제를 보겠습니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243function toUint32(value) &#123; return Math.floor(Math.abs(Number(value))) % Math.pow(2, 32);&#125;function isArrayIndex(key) &#123; let numericKey = toUint32(key); return String(numericKey) == key &amp;&amp; numericKey &lt; (Math.pow(2, 32) - 1);&#125;function createMyArray(length=0) &#123; return new Proxy(&#123; length &#125;, &#123; set(trapTarget, key, value) &#123; let currentLength = Reflect.get(trapTarget, \"length\"); // the special case if (isArrayIndex(key)) &#123; let numericKey = Number(key); if (numericKey &gt;= currentLength) &#123; Reflect.set(trapTarget, \"length\", numericKey + 1); &#125; &#125; // always do this regardless of key type return Reflect.set(trapTarget, key, value); &#125; &#125;);&#125;let colors = createMyArray(3);console.log(colors.length); // 3colors[0] = \"red\";colors[1] = \"green\";colors[2] = \"blue\";console.log(colors.length); // 3colors[3] = \"black\";console.log(colors.length); // 4console.log(colors[3]); // \"black\" 이 예제는 set 프록시 Trap을 사용하여 Array 인덱스의 설정을 가로챕니다. 키가 Array 인덱스인 경우 키는 항상 문자열로 전달되기 때문에 숫자로 변환됩니다. 그 숫자 값이 현재 length 프로퍼티보다 크거나 같으면 length 프로퍼티가 숫자 키보다 하나 더 업데이트됩니다 (위치 3의 항목 설정은 length가 4 여야 함을 의미합니다). 그 후에 프로퍼티를 설정하기위한 기본 동작은 Reflect.set()를 통해 사용됩니다. 프로퍼티가 지정된 값을 받기를 원하기 때문입니다. 최초의 커스텀 Array는 length가 3인 createMyArray()를 호출하여 생성되며, 그 세항목의 값은 바로 뒤에 추가됩니다. length 프로퍼티는 3번 위치에 &quot;black&quot;값이 할당될 때까지 정확히 3을 유지합니다. 그 시점에서 length는 4로 설정됩니다. 첫번째 동작이 작동하면 두 번째 동작으로 이동할 시간입니다. length 줄이기에 대한 요소 삭제모방을 위한 첫 번째 Array 동작은 Array 인덱스가 length 프로퍼티보다 크거나 같은 경우에만 사용됩니다. 두 번째 동작은 length 프로퍼티가 이전에 포함된 값보다 작은 값으로 설정되면 값을 줄이고 남은 Array 항목을 제거합니다. 이는 length 프로퍼티를 변경하는 것뿐만 아니라 존재하지 않는 모든 항목을 삭제하는 것을 포함합니다. 예를 들어, length가 4인 Array가 length를 2로 설정하면, 2와 3 위치의 항목은 삭제됩니다. 첫 번째 동작과 함께 set 프록시 Trap에서 이것을 수행 할 수 있습니다. 아래 예제는 앞의 예제를 업데이트한createMyArray 메서드 입니다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556function toUint32(value) &#123; return Math.floor(Math.abs(Number(value))) % Math.pow(2, 32);&#125;function isArrayIndex(key) &#123; let numericKey = toUint32(key); return String(numericKey) == key &amp;&amp; numericKey &lt; (Math.pow(2, 32) - 1);&#125;function createMyArray(length=0) &#123; return new Proxy(&#123; length &#125;, &#123; set(trapTarget, key, value) &#123; let currentLength = Reflect.get(trapTarget, \"length\"); // the special case if (isArrayIndex(key)) &#123; let numericKey = Number(key); if (numericKey &gt;= currentLength) &#123; Reflect.set(trapTarget, \"length\", numericKey + 1); &#125; &#125; else if (key === \"length\") &#123; if (value &lt; currentLength) &#123; for (let index = currentLength - 1; index &gt;= value; index\\--) &#123; Reflect.deleteProperty(trapTarget, index); &#125; &#125; &#125; // 항상 키 타입에 관계없이 이 작업을 수행합니다. return Reflect.set(trapTarget, key, value); &#125; &#125;);&#125;let colors = createMyArray(3);console.log(colors.length); // 3colors[0] = \"red\";colors[1] = \"green\";colors[2] = \"blue\";colors[3] = \"black\";console.log(colors.length); // 4colors.length = 2;console.log(colors.length); // 2console.log(colors[3]); // undefinedconsole.log(colors[2]); // undefinedconsole.log(colors[1]); // \"green\"console.log(colors[0]); // \"red\" 이 코드의 set 프록시 Trap은 나머지 객체를 정확하게 조정하기 위해 key가 &quot;length&quot;인지를 검사합니다. 이 경우 현재 length가 Reflect.get()을 사용하여 먼저 검색되고 새 값과 비교됩니다. 새로운 값이 현재 length보다 작으면 for 루프는 더이상 사용할 수 없는 대상의 모든 프로퍼티를 삭제합니다. for 루프는 현재 Array의 크기(currentLength)에서 뒤로 이동하고 새로운 Array 크기(value)에 도달할 때까지 각 프로퍼티를 삭제합니다. 이 예제는 네가지 색상을 colors에 추가한 다음 length 프로퍼티를 2로 설정합니다. 이렇게 하면 위치 2와 3의 항목을 효과적으로 제거하므로 액세스하려고할 때 undefined를 반환합니다. length 프로퍼티는 정확하게 2로 설정되고 위치 0과 1의 아이템은 여전히 접근 가능합니다. 두가지 동작을 모두 구현하면 Built-in Array의 동작을 모방한 객체를 쉽게 만들수 있습니다. 그러나 함수를 사용하여 이렇게하는 것은 이 동작을 캡슐화하는 클래스를 만드는 것보다 바람직하지 않습니다. 따라서 다음 단계는 이 함수를 클래스로 구현하는 것입니다. MyArray 클래스 구현프록시를 사용하는 클래스를 만드는 가장 간단한 방법은 클래스를 평소대로 정의한 다음 생성자에서 프록시를 반환하는 것입니다. 이렇게하면 클래스가 인스턴스화될 때 반환되는 객체는 인스턴스가 아닌 프록시가됩니다. (인스턴스는 생성자 내의 `this ‘값입니다.) 인스턴스는 프록시의 대상이되고 프록시는 인스턴스인 것처럼 반환됩니다. 인스턴스는 완전히 비공개이며 직접 액세스할 수는 없지만 프록시를 통해 간접적으로 액세스할 수 있습니다. 다음은 클래스 생성자에서 프록시를 반환하는 간단한 예입니다. 12345678class Thing &#123; constructor() &#123; return new Proxy(this, &#123;&#125;); &#125;&#125;let myThing = new Thing();console.log(myThing instanceof Thing); // true 이 예제에서 Thing 클래스는 생성자에서 프록시를 반환합니다. 프록시 대상은 this이며 프록시는 생성자에서 반환됩니다. 즉, Thing 생성자를 호출하여 myThing을 만들었지만 실제로 myThing은 프록시입니다. 프록시는 자신의 동작을 대상에 전달하기 때문에 myThing은 여전히 Thing 클래스로 간주되며 프록시는 Thing 클래스를 사용하는 모든 사람에게 완전히 투명합니다. 이를 염두에두고 상대적으로 간단한 방식으로 프록시를 사용하여 맞춤 Array 클래스를 만듭니다. 코드는 “length 줄이기에 대한 요소 삭제”절의 코드와 거의 같습니다. 동일한 프록시 코드가 사용되지만 이번에는 클래스 생성자 내부에 있습니다. 전체 예제는 다음과 같습니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364function toUint32(value) &#123; return Math.floor(Math.abs(Number(value))) % Math.pow(2, 32);&#125;function isArrayIndex(key) &#123; let numericKey = toUint32(key); return String(numericKey) == key &amp;&amp; numericKey &lt; (Math.pow(2, 32) - 1);&#125;class MyArray &#123; constructor(length=0) &#123; this.length = length; return new Proxy(this, &#123; set(trapTarget, key, value) &#123; let currentLength = Reflect.get(trapTarget, \"length\"); // the special case if (isArrayIndex(key)) &#123; let numericKey = Number(key); if (numericKey &gt;= currentLength) &#123; Reflect.set(trapTarget, \"length\", numericKey + 1); &#125; &#125; else if (key === \"length\") &#123; if (value &lt; currentLength) &#123; for (let index = currentLength - 1; index &gt;= value; i\\ndex--) &#123; Reflect.deleteProperty(trapTarget, index); &#125; &#125; &#125; // always do this regardless of key type return Reflect.set(trapTarget, key, value); &#125; &#125;); &#125;&#125;let colors = new MyArray(3);console.log(colors instanceof MyArray); // trueconsole.log(colors.length); // 3colors[0] = \"red\";colors[1] = \"green\";colors[2] = \"blue\";colors[3] = \"black\";console.log(colors.length); // 4colors.length = 2;console.log(colors.length); // 2console.log(colors[3]); // undefinedconsole.log(colors[2]); // undefinedconsole.log(colors[1]); // \"green\"console.log(colors[0]); // \"red\" 이 코드는 생성자에서 프록시를 반환하는 MyArray 클래스를 만듭니다. length 프로퍼티는 생성자에 추가되고 (전달된 값이나 기본값 0으로 초기화 됨) 프록시가 생성되어 반환됩니다. 이것은 colors 변수에 MyArray의 인스턴스를 대입하는 모양이 되며 Array의 주요 동작을 구현합니다. 클래스 생성자에서 프록시를 반환하는 것은 쉽지만 모든 인스턴스에 대해 새 프록시가 만들어 짐을 의미합니다. 그러나 모든 인스턴스가 하나의 프록시를 공유하는 방법이 있습니다. 프록시를 프로토 타입으로 사용할 수 있습니다. 프로토 타입으로 프록시 사용프록시는 프로토 타입으로 사용될 수 있지만, 이장의 앞의 예제보다 약간 복잡합니다. 프록시가 프로토 타입일 때, 프록시 Trap은 기본 동작이 정상적으로 프로토 타입에 계속될 때만 호출되며, 프록시의 기능을 프로토 타입으로 제한합니다. 다음 예제를 살펴 보겠습니다. 1234567891011121314151617let target = &#123;&#125;;let newTarget = Object.create(new Proxy(target, &#123; // never called defineProperty(trapTarget, name, descriptor) &#123; // would cause an error if called return false; &#125;&#125;));Object.defineProperty(newTarget, \"name\", &#123; value: \"newTarget\"&#125;);console.log(newTarget.name); // \"newTarget\"console.log(newTarget.hasOwnProperty(\"name\")); // true newTarget 객체는 프록시를 프로토 타입으로 하여 생성됩니다. target을 프록시 타겟으로 만들면 프록시가 투명하기 때문에 효과적으로 target을newTarget의 프로토 타입으로 만듭니다. 이제, 프록시 Trap은 newTarget에 대한 연산이 target에서 일어날 연산을 통과할 때만 호출됩니다. Object.defineProperty() 메서드는 newTarget에 호출되어 name이라는 자체 프로퍼티를 생성합니다. 객체상에 프로퍼티를 정의하는 것은 일반적으로 객체의 프로토 타입으로 계속되는 연산이 아니기 때문에 프록시상의 defineProperty Trap은 결코 호출되지 않고 name 프로퍼티는 자신의 프로퍼티로 newTarget에 추가됩니다. 프로토 타입으로 사용할 경우 프록시가 심각하게 제한되지만 여전히 유용한 몇가지 Trap이 있습니다. 프로토 타입에서 get Trap 사용하기내부 [[Get]] 메서드가 호출되어 프로퍼티를 읽으면 연산은 먼저 자신의 프로퍼티를 찾습니다. 지정된 이름을 가진 자체 프로퍼티를 찾을 수 없는 경우 연산은 프로토 타입을 계속 진행하고 거기에서 프로퍼티를 찾습니다. 검사할 프로토 타입이 더이상 없을 때까지 프로세스가 계속됩니다. 이 프로세스 덕분에, get 프록시 Trap을 설정하면 주어진 이름의 자체 프로퍼티가 존재하지 않을 때마다 프로토 타입에서 Trap이 호출됩니다. get Trap을 사용하면 존재한다고 보장할 수 없는 프로퍼티에 액세스할 때 예기치 않은 동작을 방지할 수 있습니다. 단지 존재하지 않는 프로퍼티에 액세스하려고 할 때마다 오류가 발생하는 객체를 만들면 됩니다. 12345678910111213let target = &#123;&#125;;let thing = Object.create(new Proxy(target, &#123; get(trapTarget, key, receiver) &#123; throw new ReferenceError(`$&#123;key&#125; doesn't exist`); &#125;&#125;));thing.name = \"thing\";console.log(thing.name); // \"thing\"// error 발생let unknown = thing.unknown; 이 코드에서, thing 객체는 프록시를 프로토 타입으로 하여 생성됩니다. get Trap은 주어진 키가 thing 객체에 존재하지 않은 호출에 대해 에러를 발생시킵니다. thing.name을 읽을 때, 프로퍼티가 thing에 존재하기 때문에 연산은 결코 프로토 타입에서 get Trap을 호출하지 않습니다. get Trap은 존재하지 않는 thing.unknown 프로퍼티에 접근할 때에만 호출됩니다. 마지막 줄이 실행될 때 unknown은 thing의 자체 속성이 아니므로 연산은 프로토 타입으로 계속됩니다. 그리고 get Trap은 오류를 던집니다. 이러한 유형의 동작은 JavaScript에서 매우 유용할 수 있습니다. JavaScript는 알려지지 않은 프로퍼티는 오류를 발생(다른 언어에서처럼)하는 대신 undefined를 자동으로 반환합니다. 이 예제에서 trapTarget과 receiver는 다른 객체라는 것을 이해하는 것이 중요합니다. 프록시가 프로토 타입으로 사용될 때, trapTarget은 프로토 타입 객체 자체이고 receiver는 인스턴스 객체입니다. 이 경우 trapTarget은 target과 같고 receiver는 thing과 같습니다. 이렇게하면 원래 프록시 대상과 작업을 수행할 대상에 모두 액세스할 수 있습니다. 프로토 타입에서 set Trap 사용하기내부 [[Set]] 메서드는 자체 프로퍼티를 확인한 다음 필요에 따라 프로토 타입을 계속 진행합니다. 오브젝트 프로퍼티에 값을 할당하면, 같은 이름의 프로퍼티에 값이 할당됩니다. 지정된 이름의 프로퍼티가 없는 경우 연산은 프로토 타입으로 계속 진행됩니다. 까다로운 부분은 할당 작업이 프로토 타입으로 계속 되더라도 해당 프로퍼티에 값을 할당하면 해당 이름의 프로퍼티가 프로토 타입에 있는지 여부에 관계없이 기본적으로 프로토 타입이 아닌 인스턴스에 대한 프로퍼티가 만들어집니다. 프로토 타입에setTrap이 호출될 때와 그렇지 않을 때를 더 잘 이해하려면, 기본 동작을 보여주는 다음 예제를 살펴보십시오. 12345678910111213141516171819let target = &#123;&#125;;let thing = Object.create(new Proxy(target, &#123; set(trapTarget, key, value, receiver) &#123; return Reflect.set(trapTarget, key, value, receiver); &#125;&#125;));console.log(thing.hasOwnProperty(\"name\")); // false// triggers the `set` proxy trapthing.name = \"thing\";console.log(thing.name); // \"thing\"console.log(thing.hasOwnProperty(\"name\")); // true// does not trigger the `set` proxy trapthing.name = \"boo\";console.log(thing.name); // \"boo\" 이 예제에서, target은 자신의 프로퍼티가 없이 시작됩니다. thing 객체는 새로운 프로퍼티의 생성을 위한 set Trap을 정의하는 프록시를 프로토 타입으로 가지고 있습니다. thing.name에 값으로 &quot;thing&quot;이 지정되면 thing에 name이라는 자체 프로퍼티가 없으므로set 프록시 Trap이 호출됩니다. set Trap 내에서 trapTarget은 target과 같고 receiver는 thing과 같습니다. 연산은 궁극적으로 thing에 새로운 프로퍼티를 만들어야하며, 다행히 Reflect.set()는 네 번째 파라미터로 receiver를 전달하면 이 기본 동작을 구현합니다. name 프로퍼티가 thing에 생성되면 thing.name을 다른 값으로 설정해도 더이상 set 프록시 Trap을 호출하지 않습니다. 이 시점에서, name은 자체 프로퍼티이므로 [[Set]] 연산은 프로토 타입으로 계속되지 않습니다. 프로토 타입에서 has Trap 사용하기has Trap은 객체에서 in 연산자의 사용을 가로챈다는 것을 설명했습니다. in 연산자는 먼저 주어진 이름을 가진 객체 자신의 프로퍼티를 검색합니다. 이름이 같은 자체 프로퍼티가 없으면 연산이 프로토 타입으로 계속 진행됩니다. 프로토 타입에 자체 프로퍼티가 없으면 프로토 타입을 찾거나 검색할 프로토 타입이 더 이상 없을 때까지 프로토 타입 체인을 통해 검색이 계속됩니다. 따라서 has Trap은 검색이 프로토 타입 체인에서 프록시 객체에 도달할 때만 호출됩니다. 프로토 타입으로 프록시를 사용하는 경우 지정된 이름의 자체 프로퍼티가 없을 때만 발생합니다. 1234567891011121314let target = &#123;&#125;;let thing = Object.create(new Proxy(target, &#123; has(trapTarget, key) &#123; return Reflect.has(trapTarget, key); &#125;&#125;));// triggers the `has` proxy trapconsole.log(\"name\" in thing); // falsething.name = \"thing\";// does not trigger the `has` proxy trapconsole.log(\"name\" in thing); // true 이 코드는 thing 프로토 타입에 has 프록시 Trap을 만듭니다. has Trap은 in 연산자가 사용될 때 프로토 타입을 자동으로 검색하기 때문에 get 및 set Trap처럼 receiver 객체를 통과하지 않습니다. 대신, has Trap은 target과 같은 trapTarget에서만 작동해야합니다. 이 예제에서 처음으로 in 연산자가 사용되면, 프로퍼티 이름이 thing의 자체 프로퍼티로 존재하지 않기 때문에 has Trap이 호출됩니다. thing.name에 값이 주어지고 in 연산자가 다시 사용될 때 has에 자신의 프로퍼티 name을 찾은 후에 연산이 멈추기 때문에 has Trap이 호출되지 않습니다. 이 시점의 프로토 타입 예제는 Object.create() 메서드를 사용하여 생성된 객체를 중심으로 이루어졌습니다. 그러나 프록시를 프로토 타입으로 사용하는 클래스를 만들려면 프로세스가 좀 더 복잡합니다. 클래스의 프로토 타입으로서의 프록시프로토 타입 프로퍼티가 non-writable이기 때문에 클래스를 프록시 prototype으로 사용하도록 직접 수정할 수 없습니다. 그러나 상속을 사용하여 프록시를 프로토 타입으로 사용하는 클래스를 약간 다르게 사용할 수 있습니다. 시작하려면 생성자 함수를 사용하여 ECMAScript 5 스타일 형식 정의를 만들어야합니다. 그런 다음 프로토 타입을 프록시로 덮어 쓸수 있습니다. 다음은 그 예제입니다. 1234567891011121314function NoSuchProperty() &#123; // empty&#125;NoSuchProperty.prototype = new Proxy(&#123;&#125;, &#123; get(trapTarget, key, receiver) &#123; throw new ReferenceError(`$&#123;key&#125; doesn't exist`); &#125;&#125;);let thing = new NoSuchProperty();// `get` 프록시 Trap으로 인해 오류가 발생합니다.let result = thing.name; NoSuchProperty 함수는 클래스가 상속하는 기반을 나타냅니다. 함수의 프로토 타입 프로퍼티에는 제한이 없으므로 프록시로 이를 덮어 쓸 수 있습니다. get Trap은 프로퍼티가 존재하지 않을 때 오류를 던지기 위해 사용됩니다. thing 객체는 NoSuchProperty 인스턴스로 생성되고 존재하지 않는 name 프로퍼티에 접근할 때 오류를 던집니다. 다음 단계는 NoSuchProperty를 상속받은 클래스를 만드는 것입니다. 9장에서 논의된 extends 문법을 사용하여 클래스 프로토 타입 체인에 프록시를 도입 할 수 있습니다. 12345678910111213141516171819202122232425function NoSuchProperty() &#123; // empty&#125;NoSuchProperty.prototype = new Proxy(&#123;&#125;, &#123; get(trapTarget, key, receiver) &#123; throw new ReferenceError(`$&#123;key&#125; doesn't exist`); &#125;&#125;);class Square extends NoSuchProperty &#123; constructor(length, width) &#123; super(); this.length = length; this.width = width; &#125;&#125;let shape = new Square(2, 6);let area1 = shape.length * shape.width;console.log(area1); // 12// \"wdth\"가 존재하지 않기 때문에 에러가 발생합니다.let area2 = shape.length * shape.wdth; Square 클래스는 NoSuchProperty를 상속받습니다. 그래서 프록시는 Square 클래스의 프로토 타입 체인에 있습니다. shape 객체는Square의 새로운 인스턴스로 생성되고 length와 width라는 두개의 프로퍼티를 갖습니다. get 프록시 Trap이 결코 호출되지 않기 때문에 이들 프로퍼티의 값을 읽는 것은 성공합니다. shape에 존재하지 않는 프로퍼티(shape.wdth, 명백한 오타)에 접근할 때만 get 프록시 Trap 트리거가 발생하고 오류가 발생합니다. 이는 프록시가 shape의 프로토 타입 체인에 있음을 증명하지만 프록시가 shape의 직접 프로토 타입이 아니라는 점은 분명하지 않을 수 있습니다. 실제로, 프록시는 shape에서 프로토 타입 체인까지 두단계입니다. 앞의 예를 약간 변경하면 더 명확하게 알 수 있습니다. 123456789101112131415161718192021222324252627282930function NoSuchProperty() &#123; // empty&#125;// 프로토 타입이 될 프록시에 대한 참조를 저장let proxy = new Proxy(&#123;&#125;, &#123; get(trapTarget, key, receiver) &#123; throw new ReferenceError(`$&#123;key&#125; doesn't exist`); &#125;&#125;);NoSuchProperty.prototype = proxy;class Square extends NoSuchProperty &#123; constructor(length, width) &#123; super(); this.length = length; this.width = width; &#125;&#125;let shape = new Square(2, 6);let shapeProto = Object.getPrototypeOf(shape);console.log(shapeProto === proxy); // falselet secondLevelProto = Object.getPrototypeOf(shapeProto);console.log(secondLevelProto === proxy); // true 이 버전의 코드는 프록시를 proxy라는 변수에 저장하므로 나중에 쉽게 식별할 수 있습니다. shape의 프로토 타입은 Shape.prototype이고 프록시가 아닙니다. 그러나 Shape.prototype의 프로토 타입은 NoSuchProperty에서 상속된 프록시입니다. 상속은 프로토 타입 체인에 또 다른 단계를 추가합니다. 프록시에 get Trap을 호출할 때 발생할 수 있는 작업으로 인해 하나의 추가 단계가 필요하기 때문에 중요합니다. Shape.prototype에 프로퍼티가 있으면 다음과 같이 get 프록시 Trap이 호출되지 않습니다. 1234567891011121314151617181920212223242526272829303132function NoSuchProperty() &#123; // empty&#125;NoSuchProperty.prototype = new Proxy(&#123;&#125;, &#123; get(trapTarget, key, receiver) &#123; throw new ReferenceError(`$&#123;key&#125; doesn't exist`); &#125;&#125;);class Square extends NoSuchProperty &#123; constructor(length, width) &#123; super(); this.length = length; this.width = width; &#125; getArea() &#123; return this.length * this.width; &#125;&#125;let shape = new Square(2, 6);let area1 = shape.length * shape.width;console.log(area1); // 12let area2 = shape.getArea();console.log(area2); // 12// \"wdth\"가 존재하지 않기 때문에 에러가 발생됩니다.let area3 = shape.length * shape.wdth; 여기에서 Square 클래스는 getArea() 메서드를 가지고 있습니다. getArea() 메서드는 Square.prototype에 자동으로 추가되므로 shape.getArea()가 호출되면 getArea() 메서드에 대한 검색은 shape 인스턴스에서 시작한 후 프로토 타입으로 진행됩니다. 프로토 타입에 getArea ()가 있기 때문에 검색이 멈추고 프록시는 호출되지 않습니다. getArea()가 호출됐을때 오류를 잘못 던지는 것을 원하지 않기 때문에 실제로 이 상황에서 우리가 원하는 동작입니다. 프로토 타입 체인에 프록시가있는 클래스를 만드는 데 약간의 추가 코드가 필요하지만 이러한 기능이 필요한 경우에는 노력할 가치가 있습니다. 요약ECMAScript 6 이전에는 특정 객체(예 : Array)가 개발자가 복제할 수없는 비표준 동작을 표현했습니다. 프록시가 그것을 바꿉니다. 프록시를 사용하면 여러 저수준 JavaScript 작업에 대한 비표준 동작을 정의할 수 있으므로 프록시 Trap을 통해 Built-in JavaScript 객체의 모든 동작을 가로챌 수 있습니다. 이러한 Trap은 in 연산자를 사용하는 것처럼 다양한 작업이 수행되는 뒤에서 호출됩니다. 개발자가 각 프록시 Trap에 대한 기본 동작을 구현할 수 있도록 ECMAScript 6에 리플렉션 API도 도입되었습니다. 각 프록시 Trap에는 Reflect 객체에 동일한 이름의 해당 메서드가 있으며 ECMAScript 6에 추가되었습니다. 프록시 Trap 및 리플렉션 API 메서드의 조합을 사용하면 일부 동작만 필터링하여 특정 조건에서만 다르게 동작하도록 할 수 있으며 Built-in 동작을 기본값으로 사용할 수 있습니다. 취소 가능한 프록시는 revoke() 함수를 사용하여 효과적으로 비활성화 할 수있는 특수 프록시입니다. revoke() 함수는 프록시의 모든 기능을 종료하므로 revoke()가 호출된 후 프록시의 프로퍼티와 상호 작용하려는 동작은 오류가 발생합니다. 취소 가능한 프록시는 Third-party 개발자가 지정된 시간 동안 특정 객체에 액세스해야하는 응용 프로그램의 보안에 중요합니다. 프록시를 직접 사용하는 것이 가장 강력한 유스 케이스이지만 프록시를 다른 객체의 프로토 타입으로 사용할 수도 있습니다. 이 경우 효과적으로 사용할 수 있는 프록시 Trap 수가 크게 제한됩니다. 프로토 타입으로 사용될 때 프록시에서 get, set 및 has 프록시 Trap만 호출되어 사용가능 사례를 훨씬 더 좁힙니다. 이 내용은 나중에 참고하기 위해 제가 공부하며 정리한 내용입니다.의역, 오역, 직역이 있을 수 있음을 알려드립니다.This post is a translation of this original article [https://leanpub.com/understandinges6/read#leanpub-auto-proxies-and-the-reflection-api] 참고 ECMAScript 6 Block Binding ECMAScript 6 문자열과 정규 표현식 ECMAScript 6 함수 ECMAScript 6 객체의 확장된 기능 ECMAScript 6 쉬운 데이터 액세스를 위한 Destructuring ECMAScript 6 Symbol과 Symbol 프로퍼티 ECMAScript 6 Set과 Map ECMAScript 6 Iterator와 Generator ECMAScript 6 JavaScript 클래스 소개 ECMAScript 6 Array 기능 향상 ECMAScript 6 Promise와 비동기 프로그램밍 ECMAScript 6 프록시와 리플렉션 API ECMAScript 6 Module로 코드 캡슐화하기 ECMAScript 6 부록 A. 작은 변경 사항 ECMAScript 6 부록 B. ECMAScript 7(2016) 이해하기","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://infoscis.github.io/categories/JavaScript/"},{"name":"ECMAScript 2015","slug":"JavaScript/ECMAScript-2015","permalink":"http://infoscis.github.io/categories/JavaScript/ECMAScript-2015/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://infoscis.github.io/tags/JavaScript/"},{"name":"ECMAScript 2015","slug":"ECMAScript-2015","permalink":"http://infoscis.github.io/tags/ECMAScript-2015/"}]},{"title":"ECMAScript 6 Promise와 비동기 프로그램밍","slug":"ecmascript-6-promises-and-asynchronous-programming","date":"2018-02-27T13:30:33.000Z","updated":"2018-02-27T14:11:08.031Z","comments":true,"path":"2018/02/27/ecmascript-6-promises-and-asynchronous-programming/","link":"","permalink":"http://infoscis.github.io/2018/02/27/ecmascript-6-promises-and-asynchronous-programming/","excerpt":"","text":"ECMASCript 6 Promise와 비동기 프로그램밍JavaScript의 가장 강력한 부분중 하나는 비동기 프로그래밍을 쉽게 처리할 수 있다는 것입니다. 웹용으로 작성된 언어로서 JavaScript는 처음부터 클릭및 키누름과 같은 비동기 사용자 상호 작용에 응답할 수 있어야 했습니다. Node.js는 Event 대신에 Callback을 사용하여 JavaScript에서 비동기 프로그래밍을 대중화했습니다. 비동기 프로그래밍을 사용하는 프로그램이 점점 더 많아짐에 따라 Event 및 Callback은 더 이상 개발자가 원하는 모든 것을 지원할만큼 강력하지 않았습니다. Promise는 이러한 문제에 대한 해결책입니다. Promise는 비동기 프로그래밍의 또 다른 옵션이며 다른 언어의 Future와 Deferred와 같이 작동합니다. Promise는 나중에 (Event 및 Callback과 같이) 실행될 코드를 지정하고 작업에서 코드의 성공 또는 실패 여부를 명시적으로 나타냅니다. 코드를 이해하고 디버그하기 쉽게 만드는 방법으로 성공 또는 실패를 기반으로 Promise를 연결할 수 있습니다. Promise가 어떻게 작동하는지 잘 이해하려면 처음 생성되었을 때의 기본 개념을 이해하는 것이 매우 중요합니다. 비동기 프로그래밍 배경JavaScript 엔진은 단일 스레드 Event Loop 개념을 기반으로 합니다. 단일 스레드는 한번에 하나의 코드만 실행한다는 것을 의미합니다. 이것을 스레드가 여러 다른 코드를 동시에 실행할 수 있는 Java 또는 C++과 같은 언어와 비교됩니다. 여러 코드가 특정 State를 액세스하여 변경할 수 있을때 State를 유지 및 보호하는 것은 어려운 문제이며 스레드 기반 소프트웨어의 빈번한 버그의 원인이 됩니다. JavaScript 엔진은 한번에 하나의 코드만 실행할 수 있으므로 실행할 코드를 추적할 수 있어야 합니다. 이 코드는 Job Queue(작업 대기열)에 보관됩니다. 코드 조각은 실행할 준비가되면 Job Queue에 추가됩니다. JavaScript 엔진이 코드 실행을 완료하면 Event Loop는 Queue의 다음 작업을 실행합니다. Event Loop는 코드 실행을 모니터링하고 Job Queue를 관리하는 JavaScript 엔진 내부의 프로세스입니다. Queue의 작업 실행은 Queue의 첫 번째 작업에서 마지막 작업까지 실행됩니다 Event 모델사용자가 버튼을 클릭하거나 키보드의 키를 누르면 onclick과 같은 Event가 발생됩니다. 이 Event는 Job Queue 뒤쪽에 새 작업을 추가하여 상호 작용에 응답할 수 있습니다. 이것이 JavaScript의 가장 기본적인 비동기 프로그래밍 형식입니다. Event 핸들러 코드는 Event가 발생할 때까지 실행되지 않으며 작업이 실행될 때 적절한 컨텍스트를 갖습니다. 1234let button = document.getElementById(\"my-btn\");button.onclick = function(event) &#123; console.log(\"Clicked\");&#125;; 이 코드에서,console.log(&quot;Clicked&quot;)는 button이 클릭될 때까지 실행되지 않습니다. button을 클릭하면 onclick에 할당된 기능이 Job Queue의 뒤쪽에 추가되고 이전 모든 작업이 완료되면 실행됩니다. Event는 간단한 상호 작용에는 잘 작동하지만 여러 개의 개별 비동기 호출을 함께 연결해야 할때, 각 Event에 대한 Event 대상 (앞의 예제에서 button)을 추적해야하기 때문에 더 복잡합니다. 또한 Event가 처음 발생하기 전에 모든 적절한 Event 핸들러를 추가 해야합니다. 예를 들어 onclick이 지정되기 전에 button이 클릭되면 아무 일도 일어나지 않을 것입니다. Event가 사용자 상호 작용 및 이와 유사한 기능에 대한 응답에 유용하기는 하지만 보다 복잡한 요구에 대해서는 매우 유연하지 않습니다. Callback 패턴Node.js가 만들어지고 Callback 패턴 프로프래밍이 대중화하여 비동기 프로그래밍 모델을 발전 시킬수 있었습니다. 비동기 코드는 나중 시점까지 실행되지 않기 때문에 Callback 패턴은 Event 모델과 유사합니다. Callback 패턴은 다음과 같이 호출할 함수가 파라미터로 전달되기 때문에 Event 모델과 다릅니다. 12345678readFile(\"example.txt\", function(err, contents) &#123; if (err) &#123; throw err; &#125; console.log(contents);&#125;);console.log(\"Hi!\"); 이 예제는 기존 Node.js Error-first Callback 스타일을 사용합니다. readFile() 함수는 디스크의 파일 (첫 번째 파라미터로 지정된 파일)을 읽은 다음 완료될 때 Callback(두 번째 파라미터)을 실행하기 위한것입니다. 오류가 있으면 콜백의 err 파라미터는 오류 객체입니다. 그렇지 않은 경우, contents 파라미터는 파일 내용을 문자열로 포함합니다. Callback 패턴을 사용하여 readFile()은 즉시 실행을 시작하고 디스크에서 읽기를 시작할 때 일시 중지합니다. 즉, console.log(contents)가 어떤 것도 출력하기 전 readFile()이 호출된 직후에 console.log( &quot;Hi!&quot;)가 출력됩니다. readFile()이 끝나면 Callback 함수와 파라미터는 Job Queue의 끝에 추가됩니다. 그리고 그 앞에있는 다른 모든 작업이 완료되면 실행됩니다. Callback 패턴은 Event보다 융통성이 있습니다. Callback을 통해 여러개의 호출을 함께 연결하는 것이 쉬워지기 때문입니다. 12345678910111213readFile(\"example.txt\", function(err, contents) &#123; if (err) &#123; throw err; &#125; writeFile(\"example.txt\", function(err) &#123; if (err) &#123; throw err; &#125; console.log(\"File was written!\"); &#125;);&#125;); 이 코드에서 readFile()을 성공적으로 호출하면 또 다른 비동기 호출이 발생하며 이번에는 writeFile() 함수를 호출합니다. err을 검사하는 것과 같은 기본 패턴이 두 함수 모두에 존재한다는 것에 유의하십시오. readFile()이 완료되면 호출되는 Job Queue에 writeFile()을 호출하는 작업을 추가합니다 (오류가 없다고 가정). 그런 다음 writeFile()이 끝날때 Job Queue에 작업을 추가합니다. 이 패턴은 꽤 잘 작동하지만 여러분은 바로 Callback hell에 빠졌다는 것을 알게됩니다. Callback hell은 다음과 같이 너무 많은 Callback을 중첩할 때 발생합니다. 1234567891011121314151617181920212223242526272829303132method1(function(err, result) &#123; if (err) &#123; throw err; &#125; method2(function(err, result) &#123; if (err) &#123; throw err; &#125; method3(function(err, result) &#123; if (err) &#123; throw err; &#125; method4(function(err, result) &#123; if (err) &#123; throw err; &#125; method5(result); &#125;); &#125;); &#125;);&#125;); 이 예제는 여러개의 메서드 호출을 중첩하여 복잡하고, 이해 및 디버그가 어려운 웹을 만듭니다. Callback은 복잡한 기능을 구현하려는 경우에도 문제가 발생합니다. 두 개의 비동기 작업을 병렬로 실행하고 두 비동기 작업이 모두 완료될 때 알려주려면 어떻게 해야할까요? 한번에 두개의 비동기 작업을 시작하고 첫 번째 작업의 결과만 가져 오려면 어떻게 해야할까요? 이러한 경우 여러 Callback 및 Cleanup 작업을 추적해야 합니다. Promise는 이러한 상황을 크게 향상시킬 수 있습니다. Promise 기본Promise는 비동기 연산의 결과를 위한 Placeholder입니다. Event를 구독하거나 함수에 Callback을 전달하는 대신 함수는 다음과 같이 Promise을 리턴할 수 있습니다. 12// readFile은 미래의 어떤 시점에서 완료할 것을 약속합니다.let promise = readFile(\"example.txt\"); 이 코드에서 readFile()은 실제로 파일 읽기를 즉시 시작하지 않습니다. 그것은 나중에 일어날 일입니다. 대신이 함수는 비동기 읽기 작업을 나타내는 Promise 객체를 리턴하므로 향후 이 작업을 수행할 수 있습니다. 그 결과로 정확하게 일할 수 있는 때는 전적으로 Promise의 Lifecycle이 어떻게 진행되는지에 달려 있습니다. Promise 수명주기각 Promise는 Pending State에서 시작하는 짧은 Lifecycle을 거치며 비동기 작업이 아직 완료되지 않았음을 나타냅니다. Pending State의 Promise는 불안정(unsettled)한 것으로 간주됩니다. 마지막 예제의 Promise는 readFile() 함수가 리턴하는 즉시 Pending State입니다. 비동기 작업이 완료되면 Promise가 확정(settled)된 것으로 간주되어 두가지 상태중 하나가 됩니다. Fulfilled(완료됨) : Promise의 비동기 작업이 성공적으로 완료되었습니다. Rejected(거절됨) : Promise의 비동기 작업이 오류 또는 다른 원인으로 인해 성공적으로 완료되지 않았습니다. Promise State를 반영하기 위해 내부 [[PromiseState]] 프로퍼티가 &quot;pending&quot;, &quot;fulfilled&quot; 또는 &quot;rejected&quot;로 설정됩니다. 이 프로퍼티는 Promise 개체에 노출되지 않으므로 프로그래밍 방식으로 Promise State를 확인할 수 없습니다. 그러나 `then() 메서드를 사용하여 Promise의 State가 바꿀때 특정 동작을 취할 수 있습니다. then() 메서드는 모든 Promise에 존재하며 두개의 파라미터를 받습니다. 첫 번째 파라미터는 Promise가 수행될 때 호출할 함수입니다. 비동기 작업과 관련된 추가 데이터가 이 처리 함수에 전달됩니다. 두 번째 파라미터는 Promise가 거부될 때 호출할 함수입니다. 수행 기능과 마찬가지로 거부 기능에는 거부와 관련된 추가 데이터가 전달됩니다. 이런 식으로 then() 메서드를 구현하는 객체를 모두 Thenable이라고 합니다. 모든 Promise는 Thenable이지만, 모든 Thenable이 Promise인 것은 아닙니다. then()에 대한 두 파라미터는 모두 선택 사항이므로 수행 및 거부의 조합을 만들수 있습니다. 예를 들어, 다음의 then() 호출 집합을 보겠습니다. 12345678910111213141516171819let promise = readFile(\"example.txt\");promise.then(function(contents) &#123; // fulfillment console.log(contents);&#125;, function(err) &#123; // rejection console.error(err.message);&#125;);promise.then(function(contents) &#123; // fulfillment console.log(contents);&#125;);promise.then(null, function(err) &#123; // rejection console.error(err.message);&#125;); 세번 모두 then() 호출은 같은 Promise에 작동합니다. 첫 번째 호출은 수행과 거절을 모두 받습니다. 두 번째는 수행만 받고 오류는 보고되지 않습니다. 세 번째는 거절을 받고 수행을 보고하지 않습니다. 또한 Promise는 거절 처리만 전달할 때 then()과 동일한 동작을하는 catch() 메서드가 있습니다. 예를 들어 다음과 같은 catch() 및 then() 호출은 기능적으로 동일합니다. 1234567891011promise.catch(function(err) &#123; // rejection console.error(err.message);&#125;);// is the same as:promise.then(null, function(err) &#123; // rejection console.error(err.message);&#125;); then()과 catch()의 목적은 비동기 작업의 결과를 적절하게 처리하기 위해 이들을 조합하여 사용하는 것입니다. 이 시스템은 작업이 성공했는지 또는 실패했는지를 확인하기 때문에 Event와 Callback보다 낫습니다. (Event는 오류가있을 때 실행되지 않는 경향이 있고 Callback은 오류 파라미터를 항상 확인해야합니다.) Promise에 거절를 추가하지 않으면 모든 실패가 조용히 발생합니다. 핸들러가 단지 실패만을 기록하는 경우라도 항상 거절 처리가 필요합니다. 수행 또는 거절 핸들러는 Promise가 이미 완료된 후에 Job Queue에 추가 되더라도 여전히 실행됩니다. 이를 통해 언제든지 새로운 수행 처리 및 거절 처리를 추가하고 호출을 보장 할 수 있습니다. 1234567891011let promise = readFile(\"example.txt\");// 원래의 수행 처리promise.then(function(contents) &#123; console.log(contents); // 새로운 처리를 추가 promise.then(function(contents) &#123; console.log(contents); &#125;);&#125;); 이 코드에서, 수행 핸들러는 동일한 수행 Promise에 또 다른 수행 핸들러를 추가합니다. Promise는 이 시점에서 이미 완료되었으므로 새 수행 핸들러가 작업 대기열에 추가되고 준비가되면 호출됩니다. 거절 핸들러도 같은 방식으로 작동합니다. then() 또는 catch()를 호출할 때마다 Promise가 해결될 때 실행될 새 Job이 만들어집니다. 그러나 이러한 Job은 Promise을 위해 엄격하게 예약된 별도의 Job Queue에서 끝납니다. 이 두 번째 Job Queue의 정확한 세부 사항은 일반적인 Job Queue가 작동하는 방식을 이해하는 정도면 됩니다. 이 사항은 Promise 사용 방법을 이해하는 데 중요하지 않습니다. Unsettled(불확실한) Promise 생성하기새로운 Promise는 Promise 생성자를 사용하여 생성됩니다. 이 생성자는 Promise를 초기화하는 코드를 포함하는 Executor라는 함수를 파라미터로 받아들입니다. Executor에는 resolve() 및 reject()라는 두개의 함수가 파라미터로 전달됩니다. resolve() 함수는 Executor가 성공적으로 완료되면 Promise가 해결될 준비가되었음을 알리기 위해 호출되고 reject() 함수는 Executor가 실패했음을 나타냅니다. 이 장의 앞 부분에서 보여주었던 readFile() 함수를 Node.js의 Promise을 사용하여 구현하는 예제를 살펴 보겠습니다. 123456789101112131415161718192021222324252627282930313233// Node.js examplelet fs = require(\"fs\");function readFile(filename) &#123; return new Promise(function(resolve, reject) &#123; // 비동기 동작 트리거 fs.readFile(filename, &#123; encoding: \"utf8\" &#125;, function(err, contents) &#123; // check for errors if (err) &#123; reject(err); return; &#125; // the read succeeded resolve(contents); &#125;); &#125;);&#125;let promise = readFile(\"example.txt\");// 수행과 거절 모두를 처리한다.promise.then(function(contents) &#123; // 수행 console.log(contents);&#125;, function(err) &#123; // 거절 console.error(err.message);&#125;); 이 예제는 Node.js의 기본 fs.readFile() 비동기 호출이 Promise로 래핑됩니다. Executor는 error 오브젝트를 reject() 함수에 전달하거나 파일 내용을 resolve() 함수에 전달합니다. readFile()이 호출되면 Executor가 즉시 실행된다는 점에 유의하십시오. Executor resolve() 또는 reject()가 호출되면 Promise을 해결하기 위해 작업이 Job Queue에 추가됩니다. 이를 Job Scheduling이라고하며, setTimeout() 또는 setInterval() 함수를 사용한 적이 있다면 이미 익숙한 것입니다. Job Scheduling에서 새로운 작업을 Job Queue에 추가하여 “지금 당장 실행하지 말고 나중에 실행하십시오.”라고 말합니다. 예를 들어 setTimeout() 함수를 사용하면 작업이 대기열에 추가되기 전에 지연을 지정할 수 있습니다. 123456// 500ms가 지난 후에 이 함수를 작업 대기열에 추가하십시오.setTimeout(function() &#123; console.log(\"Timeout\");&#125;, 500);console.log(\"Hi!\"); 이 코드는 500ms 후에 Job Queue에 추가될 작업을 예약합니다. 두개의 console.log() 호출은 다음과 같은 내용을 출력합니다. 12Hi!Timeout 500ms 지연 덕분에 console.log( &quot;Hi!&quot;) 호출의 출력 후에 setTimeout()에 전달된 함수가 표시되었습니다. Promise도 비슷하게 작동합니다. Promise Executor는 소스 코드에서 그 이후에 나타나는 것보다 먼저 실행됩니다. 123456let promise = new Promise(function(resolve, reject) &#123; console.log(\"Promise\"); resolve();&#125;);console.log(\"Hi!\"); 이 코드의 출력은 다음과 같습니다. 12PromiseHi! resolve()를 호출하면 비동기 작업이 트리거됩니다. then() 및 catch()에 전달된 함수는 비동기적으로 실행됩니다. 이러한 함수도 Job Queue에 추가됩니다. 다음은 그 예입니다. 12345678910let promise = new Promise(function(resolve, reject) &#123; console.log(\"Promise\"); resolve();&#125;);promise.then(function() &#123; console.log(\"Resolved.\");&#125;);console.log(\"Hi!\") 이 예제의 결과는 다음과 같습니다. 123PromiseHi!Resolved then()에 대한 호출이 console.log( &quot;Hi!&quot;) 행 앞에 나타나더라도 실제로 먼저(Executor와 달리) 실행되지는 않습니다. 이는 Executor가 완료된 후 수행 및 거절 핸들러가 Job Queue의 끝에 추가되기 때문입니다. Settled(확정된) Promise 생성하기Promise 생성자는 Promise Executor의 역동적인 특성 때문에 불확실한 Promise를 만드는 가장 좋은 방법입니다. 그러나 알려진 단일 값을 나타내는 Promise를 원한다면 resolve() 함수에 값을 전달하는 Job을 스케쥴하는 것은 의미가 없습니다. 대신, 구체적인 가치를 부여한 Settled Promise를 만드는 두가지 방법이 있습니다. Promise.resolve() 사용하기Promise.resolve() 메서드는 단일 파라미터를 받아들이고 Fulfilled State의 Promise를 리턴합니다. 이는 Job Scheduling이 발생하지 않으며, 값을 검색하기 위한 Promise에 하나 이상의 수행 핸들러를 추가해야 함을 의미합니다. 12345let promise = Promise.resolve(42);promise.then(function(value) &#123; console.log(value); // 42&#125;); 이 코드는 수행 핸들러가 value로 42를 설정 하도록 수행 Promise를 작성합니다. 이 Promise는 절대 Rejected State가 되지 않기 때문에 거절 핸들러가 추가되어도 호출되지 않습니다. Promise.reject() 사용하기Promise.reject() 메서드를 사용하여 거절된 Promise를 만들수도 있습니다. Promise.resolve()와 같이 작동합니다. 단, 생성된 Promise는 다음과 같이 Rejected State입니다. 12345let promise = Promise.reject(42);promise.catch(function(value) &#123; console.log(value); // 42&#125;); 이 Promise에 추가된 모든 거절 핸들러는 호출되지만 수행 핸들러는 호출되지 않습니다. Promise를 Promise.resolve() 또는 Promise.reject() 메서드에 전달하면 변경 내용없이 Promise가 리턴됩니다. Promise가 아닌 ThenablePromise.resolve() 및 Promise.reject()는 Non-promise Thenable을 파라미터로 받을수 있습니다. Non-promise Thenable을 전달하면 이 메서드는 then() 함수 다음에 호출되는 새로운 Promise를 만듭니다. Non-promise Thenable은 객체가 다음과 같이 resolve와 reject 파라미터를 받아들이는 then() 메서드를 가질 때 생성됩니다. 12345let thenable = &#123; then: function(resolve, reject) &#123; resolve(42); &#125;&#125;; 이 예제에서 thenable 객체는 then() 메서드 이외의 Promise와 관련된 특징이 없습니다. 여러분은 Promise.resolve()를 호출하여 다음과 같이 thenable을 수행된 Promise로 변환할 수 있습니다. 12345678910let thenable = &#123; then: function(resolve, reject) &#123; resolve(42); &#125;&#125;;let p1 = Promise.resolve(thenable);p1.then(function(value) &#123; console.log(value); // 42&#125;); 이 예에서, Promise.resolve()는 Promise State를 결정할 수 있도록 thenable.then()을 호출합니다. then()메서드 내에서 resolve(42)가 호출되기 때문에 thenable에 대한 Promise State가 Fulfilled입니다. 새로운 p1 Promise는 thenable(즉, 42)에서 전달된 값으로 Fulfilled state에서 생성되고 p1의 수행 핸들러는 값으로 42를 받습니다. 같은 프로세스를 Promise.resolve()와 함께 사용하여 다음과 같은 Promise을 거절할 수 있습니다. 12345678910let thenable = &#123; then: function(resolve, reject) &#123; reject(42); &#125;&#125;;let p1 = Promise.resolve(thenable);p1.catch(function(value) &#123; console.log(value); // 42&#125;); 이 예제는 thenable이 거부된다는 것을 제외하고는 이전 예제와 유사합니다. thenable.then()이 실행되면, 값이 42 인 Rejected State에서 새로운 Promise가 생성됩니다. 그 값은 p1의 거절 처리기로 전달됩니다. Promise.resolve() 및 Promise.reject()는 이와 같이 동작하여 Non-promise Thenable에 대해 쉽게 작업할 수 있도록 합니다. 많은 라이브러리는 Promise가 ECMAScript 6에 도입되기 전에 Promise을 구현하기 위해 Thenable을 사용 했으므로, Thenable을 공식 Promise로 변환할 수 있는 이 기능은 기존 라이브러리와의 하위 호환성을 위해 중요합니다. 오브젝트가 Promise인지 확신 할 수 없을 때 Promise가 변경되지 않고 통과하기 하는 Promise.resolve() 또는 Promise.reject()(예상 결과에 따라 다름)를 통해 오브젝트를 전달하는 것이 가장 좋은 방법입니다. Executor 오류Executor 내에서 오류가 발생하면 Promise의 거절 핸들러가 호출됩니다. 1234567let promise = new Promise(function(resolve, reject) &#123; throw new Error(\"Explosion!\");&#125;);promise.catch(function(error) &#123; console.log(error.message); // \"Explosion!\"&#125;); 이 코드에서, Executor는 의도적으로 오류를 던집니다. 모든 Executor 내부에는 암묵적인 try-catch가 있어 오류가 포착된 다음 거절 처리기로 전달됩니다. 이전 예는 다음과 같습니다. 1234567891011let promise = new Promise(function(resolve, reject) &#123; try &#123; throw new Error(\"Explosion!\"); &#125; catch (ex) &#123; reject(ex); &#125;&#125;);promise.catch(function(error) &#123; console.log(error.message); // \"Explosion!\"&#125;); Executor는 던져진 오류를 잡아서 이러한 일반적인 유스 케이스를 간소화하고, Executor에서 발생한 오류는 거절 처리기가 있을때만 보고됩니다. 그렇지 않으면 오류가 표시되지 않습니다. 이것은 개발자가 Promise를 사용하는 초기 단계에서 문제가되었고, JavaScript environment는 거절된 Promise를 잡아 내기 위해 Hook을 제공함으로써 문제를 해결합니다. Global Promise 거절 처리Promise의 가장 논란이되는 측면중 하나는 거절 핸들러 없이 Promise가 거절될 때 발생하는 침묵의 실패입니다. 어떤 이들은 JavaScript 언어에서 오류를 명백히 드러내지 않는 유일한 부분이기 때문에 이것이 사양의 가장 큰 결함이라고 생각하는 사람도 있습니다. Promise 거절이 처리되었는지 여부를 결정하는 것은 Promise의 본질 때문에 간단하지 않습니다. 예를 들어 다음 예제를 살펴보겠습니다. 123456789let rejected = Promise.reject(42);// 이 시점에서 거절은 처리되지 않습니다.// 잠시 후...rejected.catch(function(value) &#123; // 이제 거절을 처리합니다. console.log(value);&#125;); 어떤 시점에서 then() 또는 catch()를 호출하여 Promise가 확정(settled) 되었는지 여부에 관계없이 올바르게 작동하게 함으로써 Promise를 처리할 때를 정확하게 알기가 어렵습니다. 이 경우 Promise는 즉시 거절되지만 나중에 처리될 때까지 처리되지 않습니다. ECMAScript의 다음 버전이 이 문제를 해결할 가능성은 있지만, 브라우저와 Node.js는 이 문제점을 해결하기 위해 변경 사항을 구현했습니다. 이는 ECMAScript 6 사양의 일부는 아니지만 Promise를 사용할 때 유용한 도구가 됩니다. Node.js의 거절 핸들링Node.js에는 Promise 거절 핸들링과 관련된 process 객체에 두개의 Event가 있습니다. unhandledRejection : Promise가 거절되고 한회의 Event Loop에서 거절 핸들러가 호출되지 않은 경우에 발생합니다. rejectionHandled : Promise가 거절되고 한회의 Event Loop 후 거절 핸들러가 호출되면 발생합니다. 이러한 Event는 거절되고 처리되지 않는 Promise를 식별하는데 도움이되도록 설계되었습니다. unhandledRejection Event 핸들러는 거절 이유 (흔히 오류 객체)와 파라미터로 거절된 Promise가 전달됩니다. 다음 코드는 실행중인 unhandledRejection을 보여줍니다. 12345678let rejected;process.on(\"unhandledRejection\", function(reason, promise) &#123; console.log(reason.message); // \"Explosion!\" console.log(rejected === promise); // true&#125;);rejected = Promise.reject(new Error(\"Explosion!\")); 이 예에서 오류 객체와 함께 거절된 Promise를 만들고 unhandledRejection Event를 수신합니다. Event 핸들러는 첫 번째 파라미터로 오류 객체를 받고 두 번째 파라미터로 Promise를 받습니다. rejectionHandled Event 핸들러에는 거절된 Promise인 하나의 파라미터만 받습니다. 1234567891011121314let rejected;process.on(\"rejectionHandled\", function(promise) &#123; console.log(rejected === promise); // true&#125;);rejected = Promise.reject(new Error(\"Explosion!\"));// 거절 핸들러를 추가 할 때까지 기다립니다.setTimeout(function() &#123; rejected.catch(function(value) &#123; console.log(value.message); // \"Explosion!\" &#125;);&#125;, 1000); 여기서 rejectionHandled Event는 거절 핸들러가 최종적으로 호출될 때 생성됩니다. 거절 핸들러가 rejected가 생성된 후 rejected에 바로 첨부된 경우 Event가 발생하지 않습니다. 거절 핸들러가 rejected를 생성한 동일한 Event Loop에서 호출 되는 것은 유용하지 않습니다. 잠재적으로 처리되지 않은 거절을 올바르게 추적하려면 rejectionHandled 및 unhandledRejection Event를 사용하여 처리되지 않은 거절 가능성이 있는 목록을 유지합니다.그리고 일정 기간 동안 목록을 검사합니다. 1234567891011121314151617181920212223let possiblyUnhandledRejections = new Map();// 거절이 처리되지 않으면 Map에 추가합니다.process.on(\"unhandledRejection\", function(reason, promise) &#123; possiblyUnhandledRejections.set(promise, reason);&#125;);process.on(\"rejectionHandled\", function(promise) &#123; possiblyUnhandledRejections.delete(promise);&#125;);setInterval(function() &#123; possiblyUnhandledRejections.forEach(function(reason, promise) &#123; console.log(reason.message ? reason.message : reason); // 이 거절을 처리하기 위해 뭔가를 합니다. handleRejection(promise, reason); &#125;); possiblyUnhandledRejections.clear();&#125;, 60000); 이코드는 처리되지 않는 거절을 추적하는 간단한 추적기입니다. 코드에서 Map을 사용하여 Promise와 거절 사유를 저장합니다. 각 Promise는 키이며, Promise의 이유는 연관된 값입니다. unhandledRejection이 발생할 때마다 Promise와 거절 이유가 Map에 추가됩니다. 그리고 rejectionHandled가 발생될 때마다 처리된 Promise가 Map에서 제거됩니다. 따라서 Event가 호출될 때 possibleUnhandledRejections가 커지고 축소됩니다. setInterval() 호출은 처리되지 않은 거절 목록을 주기적으로 검사하여 정보를 console에 출력합니다.(실제로는 로그를 남기거나 다른 방식으로 거절을 처리하기 위해 뭔가 다른 작업을 수행하려고합니다). 이 예제에서 Weak Map대신 Map을 사용합니다. Map을 주기적으로 검사하여 어떤 Promise가 있는지 확인해야 하지만 Weak Map은 가능하지 않습니다. 이 예제는 Node.js에만 해당 하고, 브라우저도 처리되지 않은 거절에 대해 개발자에게 알리는 비슷한 메커니즘을 구현했습니다. 브라우저의 거절 핸들러브라우저는 처리되지 않은 거절을 식별하는데 도움이되는 두가지 Event를 발생 시킵니다. 이러한 Event는 window 객체에 의해 발생되고 Node.js와 동일합니다. unhandledrejection : Promise가 거절되고 한회의 Event Loop에서 거절 핸들러가 호출되지 않은 경우에 발생합니다. rejectionhandled : Promise가 거절되고 한회의 Event Loop가 실행된 후 거절 핸들러가 호출되면 발생합니다. Node.js의 구현은 개별 파라미터를 Event 핸들러에 전달하는 하지만, 브라우저의 Event 핸들러는 다음과 같은 프로퍼티를 갖는 Event 객체를 받습니다. type : 이벤트 이름 ( &quot;unhandledrejection&quot; 또는 &quot;rejectionhandled&quot;). promise : 거절된 Promise 객체. reason : Promise의 거절된 값 브라우저 구현의 다른점은 두 Event 모두에서 거절값(reason)을 사용할 수 있다는 것입니다. 123456789101112131415let rejected;window.onunhandledrejection = function(event) &#123; console.log(event.type); // \"unhandledrejection\" console.log(event.reason.message); // \"Explosion!\" console.log(rejected === event.promise); // true&#125;;window.onrejectionhandled = function(event) &#123; console.log(event.type); // \"rejectionhandled\" console.log(event.reason.message); // \"Explosion!\" console.log(rejected === event.promise); // true&#125;;rejected = Promise.reject(new Error(\"Explosion!\")); 이 코드는 onunhandledrejection 및 onrejectionhandled의 DOM Level 0 표현식을 사용하여 두 Event 핸들러를 할당합니다. 원하는 경우 addEventListener( &quot;unhandledrejection&quot;) 및 addEventListener(&quot;rejectionhandled&quot;)를 사용할 수도 있습니다. 각 Event 핸들러는 거절된 Promise에 대한 정보를 포함하는 Event 객체를 받습니다. type, promise 및 reason 프로퍼티는 모두 두 Event 핸들러에서 사용할 수 있습니다. 브라우저에서 처리되지 않은 거절을 추적하는 코드는 Node.js 코드와 매우 유사합니다. 1234567891011121314151617181920212223let possiblyUnhandledRejections = new Map();// 거절이 처리되지 않으면 Map에 추가합니다.window.onunhandledrejection = function(event) &#123; possiblyUnhandledRejections.set(event.promise, event.reason);&#125;;window.onrejectionhandled = function(event) &#123; possiblyUnhandledRejections.delete(event.promise);&#125;;setInterval(function() &#123; possiblyUnhandledRejections.forEach(function(reason, promise) &#123; console.log(reason.message ? reason.message : reason); // 이 거절을 처리하기 위해 뭔가를 합니다. handleRejection(promise, reason); &#125;); possiblyUnhandledRejections.clear();&#125;, 60000); 이 구현은 Node.js 구현과 거의 동일합니다. Promise와 거절 값을 Map에 저장한 다음 나중에 검사하는 것과 같은 접근 방식을 사용합니다. 유일한 실제 차이점은 Event 핸드러에서 정보를 검색하는 위치입니다. Promise 거절을 처리하는 것은 까다로울 수 있지만, 실제로 얼마나 강력한 Promise가 될 수 있는지를 이제 알기 시작했습니다. 이제 다음 단계로 몇개의 Promise를 연결해서 처리할 때입니다. Promise 연결하기이 시점에서 Promise는 Callback과 setTimeout() 함수를 이용한 조합보다 조금더 개선된 것으로 보이지만, 눈에 보이는 것보다 훨씬더 많은 Promise가 있습니다. 보다 구체적으로, 보다 복잡한 비동기 동작을 수행하기 위해 Promise를 서로 연결하는 여러 가지 방법이 있습니다. then() 또는 catch()를 호출할 때마다 실제로 또 다른 Promise가 만들어지고 리턴됩니다. 이 두 번째 Promise는 첫 번째 Promise가 수행되거나 거절된 후에만 처리됩니다. 다음 예제를 살펴보겠습니다. 123456789let p1 = new Promise(function(resolve, reject) &#123; resolve(42);&#125;);p1.then(function(value) &#123; console.log(value);&#125;).then(function() &#123; console.log(\"Finished\");&#125;); 위 코드의 결과는 다음과 같습니다. 1242Finished p1.then()에 대한 호출은 두 번째 Promise를 리턴하고 then()이 호출됩니다. 두 번째 then() 수행 핸들러는 첫 번째 Promise가 해결된 후에만 호출됩니다. 이 예제의 연결을 해제하면 다음과 같이 보입니다. 1234567891011let p1 = new Promise(function(resolve, reject) &#123; resolve(42);&#125;);let p2 = p1.then(function(value) &#123; console.log(value);&#125;)p2.then(function() &#123; console.log(\"Finished\");&#125;); 이 연결되지 않은 코드 버전에서 p1.then()의 결과는 p2에 저장되고 p2.then()은 최종 수행 핸들러를 추가하기 위해 호출됩니다. 여러분이 짐작 했겠지만, p2.then() 호출도 Promise를 리턴하지만 그 Promise는 사용하지 않습니다. Error 포착하기Promise 체인을 사용하면 이전 Promise에서 수행 또는 거절 핸들러에서 발생할 수 있는 에러를 포착 할 수 있습니다. 123456789let p1 = new Promise(function(resolve, reject) &#123; resolve(42);&#125;);p1.then(function(value) &#123; throw new Error(\"Boom!\");&#125;).catch(function(error) &#123; console.log(error.message); // \"Boom!\"&#125;); 이 코드에서 p1의 수행 핸들러는 에러를 던집니다. 두 번째 Promise인 catch() 메서드에 대한 연결된 호출은 거절 핸들러를 통해 해당 에러를 수신할 수 있습니다. 거절 핸들러가 에러를 throw 하는 경우에도 마찬가지입니다. 12345678910let p1 = new Promise(function(resolve, reject) &#123; throw new Error(\"Explosion!\");&#125;);p1.catch(function(error) &#123; console.log(error.message); // \"Explosion!\" throw new Error(\"Boom!\");&#125;).catch(function(error) &#123; console.log(error.message); // \"Boom!\"&#125;); 여기에서 Executor가 오류를 발생시켜 다음 p1 Promise의 거절 핸들러를 트리거합니다. 그 핸들러는 두 번째 Promise의 거절 핸들러가 포착할 또 다른 에러를 발생시킵니다. 연결된 Promise 호출은 체인의 다른 Promise의 에러를 인식합니다. 에러가 발생할 때 올바르게 처리할 수 있도록 Promise 체인의 끝부분에는 항상 거절 핸들러가 있어야합니다. Promise 체인의 리턴 값Promise 체인의 또 다른 중요한 부분은 하나의 Promise에서 다음 Promise로 데이터를 전달할 수 있다는 것입니다. Executor 내에서 resolve() 핸들러로 전달된 값이 해당 Promise에 대한 수행 핸들러로 전달되는 것을 이미 보았습니다. 수행 핸들러에서 리턴값을 지정하여 체인을 따라 데이터를 계속 전달할 수 있습니다. 12345678910let p1 = new Promise(function(resolve, reject) &#123; resolve(42);&#125;);p1.then(function(value) &#123; console.log(value); // \"42\" return value + 1;&#125;).then(function(value) &#123; console.log(value); // \"43\"&#125;); p1에 대한 수행 핸들러는 실행될 때 value + 1을 리턴합니다. value는 Executor로부터 42를 입력 받고, 수행 핸들러는 43을 리턴합니다. 이 값은 두 번째 Promise의 수행 핸들러로 전달되어 콘솔로 출력됩니다. 거절 핸들러로도 똑같이 할 수 있습니다. 거절 핸들러가 호출되면 값을 리턴할 수 있습니다. 만약 그렇다면, 그 값은 다음과 같이 체인의 다음 Promise를 수행하는데 사용될수 있습니다. 123456789101112let p1 = new Promise(function(resolve, reject) &#123; reject(42);&#125;);p1.catch(function(value) &#123; // first fulfillment handler console.log(value); // \"42\" return value + 1;&#125;).then(function(value) &#123; // second fulfillment handler console.log(value); // \"43\"&#125;); 여기서 Executor는 42로 reject()를 호출합니다. 이 값은 Promise의 거절 핸들러로 전달되며 여기서 value + 1이 리턴됩니다. 이 리턴 값은 거절 핸들러에서 가져오지만 체인에서 다음 Promise의 수행 핸들러에서 계속 사용됩니다. 만약 필요하다면 한 Promise의 실패는 전체 체인에서 복구할 수 있습니다. Promise 체인에서 Promise 리턴하기수행 및 거절 핸들러에서 Primitive 값을 리턴하면 Promise 사이에 데이터를 전달할 수 있지만 객체를 리턴하려면 어떻게 해야 할까요? 객체가 Promise라면 진행 방법을 결정하기위한 추가 단계가 필요합니다. 다음 예제를 살펴보겠습니다. 12345678910111213141516let p1 = new Promise(function(resolve, reject) &#123; resolve(42);&#125;);let p2 = new Promise(function(resolve, reject) &#123; resolve(43);&#125;);p1.then(function(value) &#123; // first fulfillment handler console.log(value); // 42 return p2;&#125;).then(function(value) &#123; // second fulfillment handler console.log(value); // 43&#125;); 이 코드에서 p1은 42로 해결(Resolve)되는 작업을 스케쥴합니다. p1의 수행 핸들러는 이미 해결된 상태인 Promise인 p2를 리턴합니다. p2가 완료되었으므로 두 번째 수행 핸들러가 호출됩니다. p2가 거부되면 두 번째 수행 핸들러 대신 거절 핸들러(있는 경우)가 호출됩니다. 이 패턴에 대해 알아야 할 중요한 점은 두 번째 수행 핸들러가 p2에 추가되지 않고 오히려 세 번째 Promise에 추가된다는 것입니다. 따라서 두 번째 수행 핸들러는 세 번째 Promise에 첨부되며, 앞의 예제를 다음과 같이 만들수 있습니다. 123456789101112131415161718let p1 = new Promise(function(resolve, reject) &#123; resolve(42);&#125;);let p2 = new Promise(function(resolve, reject) &#123; resolve(43);&#125;);let p3 = p1.then(function(value) &#123; // first fulfillment handler console.log(value); // 42 return p2;&#125;);p3.then(function(value) &#123; // second fulfillment handler console.log(value); // 43&#125;); 여기에서 두 번째 수행 처리기가 p2보다는 p3에 연결되어 있음이 명확합니다. p2가 거절되는 경우 두 번째 수행 핸들러가 호출되지 않으므로 이것은 미묘하지만 중요한 차이점입니다. 12345678910111213141516let p1 = new Promise(function(resolve, reject) &#123; resolve(42);&#125;);let p2 = new Promise(function(resolve, reject) &#123; reject(43);&#125;);p1.then(function(value) &#123; // first fulfillment handler console.log(value); // 42 return p2;&#125;).then(function(value) &#123; // second fulfillment handler console.log(value); // 절대 호출되지 않음&#125;); 이 예제에서는 p2가 거절되므로 두 번째 이행 핸들러가 호출되지 않습니다. 하지만 대신 거절 핸들러를 연결할 수 있습니다. 12345678910111213141516let p1 = new Promise(function(resolve, reject) &#123; resolve(42);&#125;);let p2 = new Promise(function(resolve, reject) &#123; reject(43);&#125;);p1.then(function(value) &#123; // first fulfillment handler console.log(value); // 42 return p2;&#125;).catch(function(value) &#123; // rejection handler console.log(value); // 43&#125;); 여기서, 거절 핸들러는 p2가 거절된 결과 호출됩니다. p2에서 거절된 값 43은 해당 거절 핸들러로 전달됩니다. Promise Executor가 실행될 때 수행 또는 거절 핸들러로부터 Thenable을 리턴하는 것은 변하지 않습니다. 첫 번째 정의된 Promise는 먼저 Executor를 실행한 다음 두 번째 Promise의 Executor를 실행합니다. Thenable를 반환하면 간단하게 Promise 결과에 대한 추가 응답을 정의할 수 있습니다. 수행 핸들러 내에서 새로운 Promise를 작성하여 수행 핸들러의 실행을 연기할 수 있습니다. 12345678910111213141516let p1 = new Promise(function(resolve, reject) &#123; resolve(42);&#125;);p1.then(function(value) &#123; console.log(value); // 42 // create a new promise let p2 = new Promise(function(resolve, reject) &#123; resolve(43); &#125;); return p2&#125;).then(function(value) &#123; console.log(value); // 43&#125;); 이 예제에서 p1의 수행 핸들러에 새 Promise가 생성됩니다. 즉, 두 번째 수행 핸들러는 p2가 수행될 때까지 실행되지 않습니다. 이 패턴은 이전 Promise가 확정될 때까지 Promise가 기다리길 원할때 유용합니다. Multiple Promise에 대한 대응지금까지 이 장의 각 예제에서는 한번에 하나의 Promise에 응답하는 방법을 다루었습니다. 그러나 때로는 다음 작업을 결정하기 위해 여러 Promise의 진행 상태를 모니터링 해야할 수도 있습니다. ECMAScript 6은 Promise.all() 및 Promise.race()와 같이 여러 Promise를 모니터링하는 두가지 메서드를 제공합니다. Promise.all() 메서드Promise.all() 메서드는 모니터링 할 Promise들을 Iterable(Array와 같은)하게 만든 단일 파라미터를 받아들이고 Iterable의 모든 Promise가 해결되었을 때 해결된 Promise를 리턴합니다. 리턴된 Promise는 아래 예제처럼 Iterable의 모든 Promise가 충족될 때 수행됩니다. 1234567891011121314151617181920let p1 = new Promise(function(resolve, reject) &#123; resolve(42);&#125;);let p2 = new Promise(function(resolve, reject) &#123; resolve(43);&#125;);let p3 = new Promise(function(resolve, reject) &#123; resolve(44);&#125;);let p4 = Promise.all([p1, p2, p3]);p4.then(function(value) &#123; console.log(Array.isArray(value)); // true console.log(value[0]); // 42 console.log(value[1]); // 43 console.log(value[2]); // 44&#125;); 각각의 Promise는 숫자로 Resolve됩니다. Promise.all()에 대한 호출은 Promise p4를 생성합니다. 이것은 p1, p2 및 p3 Promise가 충족될 때 수행됩니다. p4의 수행 핸들러에 전달된 결과는 각 Resolve된 값 42, 43 및 44를 포함하는 Array입니다. 값은 Promise가 Promise.all에 전달된 순서대로 저장되므로 Promise 결과를 Resolve한 Promise와 일치시킬 수 있습니다. Promise.all()에 전달된 Promise가 거절되면 다른 Promise가 완료될 때까지 기다리지 않고 즉시 반환된 Promise는 거절됩니다. 123456789101112131415161718let p1 = new Promise(function(resolve, reject) &#123; resolve(42);&#125;);let p2 = new Promise(function(resolve, reject) &#123; reject(43);&#125;);let p3 = new Promise(function(resolve, reject) &#123; resolve(44);&#125;);let p4 = Promise.all([p1, p2, p3]);p4.catch(function(value) &#123; console.log(Array.isArray(value)) // false console.log(value); // 43&#125;); 이 예제에서 p2는 43의 값을 사용하여 거절됩니다. p4에 대한 거절 핸들러는 p1 또는 p3가 실행 완료될 때까지 기다리지 않고 즉시 호출됩니다(여전히 실행은 완료하지만, p4가 대기하지 않습니다). 거절 핸들러는 항상 Array가 아닌 단일값을 받으며 그값은 거절된 Promise의 거절값입니다. 이 경우, 거절 핸들러에는 p2로부터의 거절을 반영하기 위해 43이 입력됩니다. Promise.race() 메서드Promise.race() 메서드는 약간 다른 방법으로 여러 Promise를 모니터링하는 방법을 제공합니다. 이 메서드 또한 Promise의 Iterable을 파라미터로 받고 Promise를 리턴하지만, 리턴된 Promise는 입력된 Iterable Promise들 중 어떤 Promise가 처음으로 확정(settled) 되자마자 확정(settled) 됩니다. Promise.all() 메서드처럼 모든 Promise가 수행되기를 기다리는 대신 Promise.race() 메서드는 Iterable Promise가 수행되는 즉시 적절한 Promise를 리턴합니다. 123456789101112131415let p1 = Promise.resolve(42);let p2 = new Promise(function(resolve, reject) &#123; resolve(43);&#125;);let p3 = new Promise(function(resolve, reject) &#123; resolve(44);&#125;);let p4 = Promise.race([p1, p2, p3]);p4.then(function(value) &#123; console.log(value); // 42&#125;); 이 코드에서 p1은 수행된 Promise로 만들어지며 다른것들은 스케쥴 작업으로 생성됩니다. p4에 대한 수행 핸들러는 42라는 값으로 호출되고 다른 Promise를 무시합니다. Promise.race()에 전달된 Promise는 어느 것이 먼저 확정(settled)되는지 보기위한 경쟁입니다. 첫 번째 Promise가 확정되면 리턴된 Promise가 수행됩니다. 첫 Promise의 확정이 거절되면 리턴된 Promise는 거절됩니다. 다음은 거절 사례입니다. 123456789101112131415let p1 = new Promise(function(resolve, reject) &#123; resolve(42);&#125;);let p2 = Promise.reject(43);let p3 = new Promise(function(resolve, reject) &#123; resolve(44);&#125;);let p4 = Promise.race([p1, p2, p3]);p4.catch(function(value) &#123; console.log(value); // 43&#125;); Promise.race()가 호출될 때 이미 p2가 거절된 상태이므로 p4가 거절됩니다. p1과 p3가 수행 되더라도 p2가 거절된 후에 발생하므로 무시됩니다 Promise에서 상속 받기다른 Built-in 타입과 마찬가지로 파생 클래스의 기반으로 Promise를 사용할 수 있습니다. 이를 통해 자신만의 객체를 정의하여 Built-in Promise를 확장할 수 있습니다. 예를 들어, 일반적인 then() 및 catch() 메서드 외에도 success() 및 failure()라는 메서드를 사용할 수 있는 Promise를 만들고 싶다고 가정 해보십시오. 다음과 같이 Promise 타입을 작성할 수 있습니다. 1234567891011121314151617181920212223class MyPromise extends Promise &#123; // 기본 생성자를 사용 success(resolve, reject) &#123; return this.then(resolve, reject); &#125; failure(reject) &#123; return this.catch(reject); &#125;&#125;let promise = new MyPromise(function(resolve, reject) &#123; resolve(42);&#125;);promise.success(function(value) &#123; console.log(value); // 42&#125;).failure(function(value) &#123; console.log(value);&#125;); 이 예에서 MyPromise는 Promise에서 파생되었으며 두가지 추가 메서드가 있습니다. success() 메서드는 resolve()를 모방하고 failure()는 reject() 메서드를 모방합니다. 추가된 각 메서드는 이를 사용하여 모방하는 메서드를 호출합니다. 파생된 Promise는 Built-in Promise와 동일하게 작동하지만 원하는 경우 success() 및 failure()를 호출할 수 있습니다. 정적 메서드도 상속되므로 MyPromise.resolve(), MyPromise.reject(), MyPromise.race() 및 MyPromise.all() 메서드는 파생된 Promise에도 있습니다. 마지막 두 메서드는 기본 제공 메서드와 동일하게 동작하지만 처음 두 메서드는 약간 다릅니다. MyPromise.resolve()와 MyPromise.reject()는 전달된 값에 관계없이 MyPromise의 인스턴스를 리턴합니다. 리턴할 Promise의 타입을 결정하기 위해 Symbol.species 프로퍼티(9 장에서 다뤘습니다.)를 사용하기 때문에 전달된 값에 관계없이 MyPromise의 인스턴스를 리턴합니다. Built-in Promise가 두 메서드 중 하나에 전달되면 Promise가 수행되거나 거절되고 메서드는 새로운 MyPromise를 반환하여 수행 및 거절 핸들러를 할당할 수 있습니다. 12345678910let p1 = new Promise(function(resolve, reject) &#123; resolve(42);&#125;);let p2 = MyPromise.resolve(p1);p2.success(function(value) &#123; console.log(value); // 42&#125;);console.log(p2 instanceof MyPromise); // true 여기에서 p1은 MyPromise.resolve() 메서드로 전달되는 Built-in Promise입니다. 결과 p2는 p1의 Resolve된 값이 수행 핸들러로 전달되는 MyPromise의 인스턴스입니다. MyPromise 인스턴스가 MyPromise.resolve() 또는 MyPromise.reject() 메서드에 전달되면 Resolve되지 않고 바로 리턴됩니다. 하지만 이 두 메서드의 다른 모든 실행은 Promise.resolve() 및 Promise.reject()와 동일하게 동작합니다. 비동기 작업 실행8 장에서는 Generator를 소개하고 이를 비동기 작업 실행에 사용할 수있는 방법을 보여주었습니다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253let fs = require(\"fs\");function run(taskDef) &#123; // iterator를 만들고 다른곳에서 사용할수 있게 만든다. let task = taskDef(); // task 시작 let result = task.next(); // next() 호출을 유지하는 재귀 함수 function step() &#123; // 할일이 더 있다면 if (!result.done) &#123; if (typeof result.value === \"function\") &#123; result.value(function(err, data) &#123; if (err) &#123; result = task.throw(err); return; &#125; result = task.next(data); step(); &#125;); &#125; else &#123; result = task.next(result.value); step(); &#125; &#125; &#125; // process 시작 step();&#125;// task runner와 함께 사용할 함수를 정의function readFile(filename) &#123; return function(callback) &#123; fs.readFile(filename, callback); &#125;;&#125;// task 실행run(function*() &#123; let contents = yield readFile(\"config.json\"); doSomethingWith(contents); console.log(\"Done\");&#125;); 이 구현에는 몇가지 문제점이 있습니다. 첫째, 함수를 리턴하는 함수에서 모든 함수를 래핑하는 것은 다소 혼란 스럽습니다 (이 문장조차 혼란 스럽습니다). 둘째, Task runner의 Callback으로 의도된 함수 리턴값과 Callback이 아닌 리턴값을 구별할 수있는 방법이 없습니다. Promise를 통해 각 비동기 작업이 Promise를 반환하도록 함으로써 이 프로세스를 크게 단순화하고 일반화할 수 있습니다. 공통 인터페이스는 비동기 코드를 크게 단순화할 수 있음을 의미합니다. Task runner를 단순화 할 수있는 방법은 다음과 같습니다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950let fs = require(\"fs\");function run(taskDef) &#123; // iterator 생성 let task = taskDef(); // task 시작 let result = task.next(); // 반복하는 재귀 함수 (function step() &#123; // 할일이 더 있다면 if (!result.done) &#123; // promise를 resolve 하면 쉽게 해결됩니다. let promise = Promise.resolve(result.value); promise.then(function(value) &#123; result = task.next(value); step(); &#125;).catch(function(error) &#123; result = task.throw(error); step(); &#125;); &#125; &#125;());&#125;// task runner에서 사용할 함수를 정의function readFile(filename) &#123; return new Promise(function(resolve, reject) &#123; fs.readFile(filename, function(err, contents) &#123; if (err) &#123; reject(err); &#125; else &#123; resolve(contents); &#125; &#125;); &#125;);&#125;// task 실행run(function*() &#123; let contents = yield readFile(\"config.json\"); doSomethingWith(contents); console.log(\"Done\");&#125;); 이 버전의 코드에서 범용 run() 함수는 Generator를 실행하여 Iterator를 만듭니다. 작업을 시작하기 위해 task.next()를 호출하고 Iterator가 완료될 때까지 step()을 재귀적으로 호출합니다. step() 함수안에서 할일이 더 있다면 result.done은 false입니다. 그 시점에서 result.value는 Promise이어야합니다. 그러나 문제의 함수가 Promise를 반환하지 않은 경우 Promise.resolve()가 호출됩니다.(Promise.resolve()는 전달된 Promise는 통과시키고 Non-promise는 Promise로 래핑한다는 것을 기억하세요). 그런 다음 Promise 값을 검색하고 이 값을 Iterator에 전달하는 수행 핸들러가 추가됩니다. 그 후, result는 step() 함수가 스스로를 호출하기 전에 다음 yield 결과에 할당됩니다. 거절 핸들러는 거절 결과를 오류 객체에 저장합니다. task.throw() 메서드는 에러 객체를 Iterator로 되돌려 보내고, 만약 태스크에 에러가 잡히면 result가 다음 yield 결과에 할당됩니다. 마지막으로 step()은 catch() 내부에서 호출하여 계속 진행합니다. 이 run() 함수는 개발자에게 Promise(또는 Callback)을 노출시키지 않고 비동기 코드를 얻기 위해 yield를 사용하는 모든 Generator를 실행할 수 있습니다. 사실 함수 호출의 리턴 값은 항상 Promise로 래핑되어 있기 때문에 함수는 Promise 이외의 것을 리턴할 수도 있습니다. 즉, yield를 사용하여 호출할 때 동기및 비동기 메서드가 모두 올바르게 작동한다는 것을 의미하므로 리턴값이 Promise임을 확인할 필요가 없습니다. 유일한 관심사는 readFile()과 같은 비동기 함수가 해당 State를 올바르게 식별하는 Promise를 리턴하는지 확인하는 것입니다. Node.js Built-in 메서드의 경우 Callback을 사용하지 않고 Promise를 리턴하도록 이러한 메서드를 변환해야합니다. 미래의 비동기 Task 실행필자가 글을 쓰고있는 지금 JavaScript로 실행되는 비동기 태스크에 간단한 구문을 사용하는 작업이 진행중입니다. 이전 섹션의 Promise 기반 예제와 유사한 await구문으로 진행 중입니다. 기본적인 아이디어는 Generator 대신에 async로 표시된 함수를 사용하고 함수를 호출할 때 yield 대신에 await을 사용하는 것입니다. 12345(async function() &#123; let contents = await readFile(\"config.json\"); doSomethingWith(contents); console.log(\"Done\");&#125;); async 키워드가 function보다 먼저 나오면 함수가 비동기 방식으로 실행된다는 의미입니다. await 키워드는 readFile(&quot;config.json&quot;) 함수 호출이 Promise를 리턴해야 한다는 것을 알려주고, 그렇지 않을 경우 응답을 Promise로 감싸야합니다. 앞절에서 run()을 구현한 것과 마찬가지로, await는 Promise가 거절되면 에러를 던지고 그렇지 않을 경우 값을 반환합니다. 최종 결과는 Iterator 기반 상태 시스템을 관리하는 오버 헤드없이 동기식인 것처럼 비동기 코드를 작성하는 것입니다. await 구문은 ECMAScript 2017 (ECMAScript 8)에서 완성될 것으로 예상됩니다. 요약Promise는 JavaScript에서 비동기 프로그래밍을 개선하기 위해 설계되었습니다. Event 및 Callback보다 비동기 작업에 대한 제어력과 합성 가능성을 향상시켜줍니다. Promise 스케줄 작업은 JavaScript 엔진의 Job Queue에 추가되어 나중에 실행될 수 있습니다. 그리고 두 번째 Job Queue는 적절한 실행을 보장하기 위해 Promise 수행 및 거절 핸들러를 추적합니다. Promise에는 Pending(보류), Fulfilled(수행), Rejected(거절)이라는 세가지 상태가 있습니다. Promise는 보류중 상태에서 시작하여 성공적인 실행에서 수행되거나 실패로 인해 거부됩니다. 두경우 모두 Promise가 확정(settled)되는 시점을 나타내는 핸들러를 추가할 수 있습니다. then() 메서드를 사용하면 수행 및 거절 핸들러를 할당할 수 있으며 catch() 메서드를 사용하면 거절 핸들러만 할당할 수 있습니다. Promise를 여러 가지 방식으로 연결하여 정보를 전달할 수 있습니다. then()을 호출할 때마다 이전 Promise가 Resolve될 때 Resolve되는 새로운 Promise가 만들어지고 리턴됩니다. 이러한 체인을 사용하여 일련의 비동기 이벤트에 대한 응답을 트리거할 수 있습니다. 또한 Promise.race() 및 Promise.all()을 사용하여 여러 Promise의 진행 상황을 모니터링하고 그에 따라 응답할 수 있습니다. Promise는 비동기 작업이 리턴할 수 있는 공통 인터페이스를 제공하므로 Generator와 Promise를 결합할 때 비동기 작업 실행이 더 쉽습니다. Generator와 yield 연산자를 사용하여 비동기 응답을 기다리고 적절하게 응답할 수 있습니다. 대부분의 새로운 웹 API는 Promise를 바탕으로 구축되고 있으며 향후 더 많은 것을 기대할 수 있습니다. 이 내용은 나중에 참고하기 위해 제가 공부하며 정리한 내용입니다.의역, 오역, 직역이 있을 수 있음을 알려드립니다.This post is a translation of this original article [https://leanpub.com/understandinges6/read#leanpub-auto-promises-and-asynchronous-programming] 참고 ECMAScript 6 Block Binding ECMAScript 6 문자열과 정규 표현식 ECMAScript 6 함수 ECMAScript 6 객체의 확장된 기능 ECMAScript 6 쉬운 데이터 액세스를 위한 Destructuring ECMAScript 6 Symbol과 Symbol 프로퍼티 ECMAScript 6 Set과 Map ECMAScript 6 Iterator와 Generator ECMAScript 6 JavaScript 클래스 소개 ECMAScript 6 Array 기능 향상 ECMAScript 6 Promise와 비동기 프로그램밍 ECMAScript 6 프록시와 리플렉션 API ECMAScript 6 Module로 코드 캡슐화하기 ECMAScript 6 부록 A. 작은 변경 사항 ECMAScript 6 부록 B. ECMAScript 7(2016) 이해하기","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://infoscis.github.io/categories/JavaScript/"},{"name":"ECMAScript 2015","slug":"JavaScript/ECMAScript-2015","permalink":"http://infoscis.github.io/categories/JavaScript/ECMAScript-2015/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://infoscis.github.io/tags/JavaScript/"},{"name":"ECMAScript 2015","slug":"ECMAScript-2015","permalink":"http://infoscis.github.io/tags/ECMAScript-2015/"}]},{"title":"Array 기능 향상","slug":"ecmascript-6-improved-array-capabilities","date":"2018-02-13T14:50:12.000Z","updated":"2018-02-27T14:12:39.181Z","comments":true,"path":"2018/02/13/ecmascript-6-improved-array-capabilities/","link":"","permalink":"http://infoscis.github.io/2018/02/13/ecmascript-6-improved-array-capabilities/","excerpt":"","text":"Array 기능 향상Array는 JavaScript의 기본 객체입니다. 그러나 JavaScript의 다른 부분은 시간이 지남에 따라 진화해 왔지만 Array는 ECMAScript 5가 사용하기 쉽도록 여러 가지 메서드를 도입할 때까지 동일하게 유지되었습니다. ECMAScript 6은 새로운 생성 메서드, 몇 가지 유용하고 편리한 메서드, Typed Array 작성 기능과 같이 많은 기능을 추가하여 Array를 개선합니다. Array 생성하기ECMAScript 6 이전에 Array를 생성하는 두 가지 기본 방법인 Array 생성자와 리터럴 구문이있었습니다. 두 방법 모두 Array 항목을 개별적으로 나열 해야하며 그렇지 않으면 상당히 제한적입니다. Array와 같은 객체 (즉, 숫자 인덱스와 length 프로퍼티를 가진 객체)를 Array로 변환하는 옵션도 제한되어 있으며 종종 추가 코드가 필요했습니다. JavaScript Array를 보다 쉽게 만들기 위해 ECMAScript 6은 Array.of()와 Array.from () 메서드를 추가했습니다. Array.of() 메서드ECMAScript 6이 JavaScript에 새로운 생성 메서드를 추가한 이유중 하나는 개발자가 Array 생성자를 사용하여 Array를 생성하는 것을 방지할 수 있다는 것입니다. new Array() 생성자는 실제로 전달된 인자의 타입과 개수에 따라 다르게 동작합니다. 123456789101112131415161718let items = new Array(2);console.log(items.length); // 2console.log(items[0]); // undefinedconsole.log(items[1]); // undefineditems = new Array(\"2\");console.log(items.length); // 1console.log(items[0]); // \"2\"items = new Array(1, 2);console.log(items.length); // 2console.log(items[0]); // 1console.log(items[1]); // 2items = new Array(3, \"2\");console.log(items.length); // 2console.log(items[0]); // 3console.log(items[1]); // \"2\" Array 생성자가 하나의 숫자 값을 전달 받으면 Array의 length 프로퍼티는 그 값으로 설정됩니다. 숫자가 아닌 단일 값이 전달되면 해당 값은 Array의 유일한 항목이됩니다. 여러 값이 전달되면 (숫자 든 아니든) 해당 값은 Array의 항목이 됩니다. 전달되는 데이터의 유형을 항상 알지 못하기 때문에 이 동작은 혼란스럽고 위험합니다. ECMAScript 6은 이 문제를 해결하기 위해 Array.of()를 도입했습니다. Array.of () 메서드는 Array 생성자와 비슷하게 작동하지만 하나의 숫자 값에 대해서 특별한 경우가 없습니다. Array.of() 메서드는 파라미터의 개수나 타입에 상관없이 항상 파라미터를 포함하는 Array를 생성합니다. 다음은 Array.of() 메서드를 사용하는 예제들입니다. 123456789101112let items = Array.of(1, 2);console.log(items.length); // 2console.log(items[0]); // 1console.log(items[1]); // 2items = Array.of(2);console.log(items.length); // 1console.log(items[0]); // 2items = Array.of(\"2\");console.log(items.length); // 1console.log(items[0]); // \"2\" Array.of() 메서드로 Array를 생성하려면 Array에 원하는 값을 전달하면 됩니다. 여기서 첫 번째 예제는 두 개의 숫자를 포함하는 Array를 만들고 두 번째 Array는 한 개의 숫자를 포함하고 마지막 Array는 한 개의 문자열을 포함합니다. 이것은 Array 리터럴을 사용하는 것과 비슷하며, 대부분 네이티브 Array Array.of() 대신 Array 리터럴을 사용할 수 있습니다. 그러나 Array 생성자를 함수에 전달해야 한다면 일관된 동작을 보장하기 위해Array.of()를 대신 전달할 수 있습니다. 12345function createArray(arrayCreator, value) &#123; return arrayCreator(value);&#125;let items = createArray(Array.of, value); 이 코드에서 createArray() 함수는 Array 생성자 함수와 Array에 삽입할 값을 받아 들입니다. Array.of()를 createArray()의 첫번째 파라미터로 전달하여 새로운 Array를 만들 수 있습니다. value가 숫자가 아닐 것이라는 것을 보장할 수 없다면 Array를 직접 전달하는 것은 위험합니다. Array.of() 메서드는 반환 값의 타입을 결정하기 위해 Symbol.species 프로퍼티 (9 장에서 설명됨)를 사용하지 않습니다. 대신 현재의 생성자 (of()메서드 내에 있는 this)를 사용하여 반환할 올바른 데이터 타입을 결정합니다. Array.from() 메서드Array가 아닌 객체를 실제 Array로 변환하는 것은 JavaScript에서 항상 번거로운 작업이었습니다. 예를 들어, Array와 유사한 arguments 객체를 가지고 있고 Array처럼 사용하고 싶다면 먼저 변환해야합니다. Array와 유사한 객체를 ECMAScript 5의 Array로 변환하려고 다음 예제와 같은 함수를 작성합니다. 123456789101112131415function makeArray(arrayLike) &#123; var result = []; for (var i = 0, len = arrayLike.length; i &lt; len; i++) &#123; result.push(arrayLike[i]); &#125; return result;&#125;function doSomething() &#123; var args = makeArray(arguments); // use args&#125; 이 방법은 수동으로 result Array를 만들고 arguments의 각 항목을 새로운 Array에 복사합니다. 이 방법이 효과가 있지만 비교적 간단한 작업을 수행하기 위해서 상당한 양의 코드가 필요합니다. 결국, 개발자들은 다음과 같이 Array와 유사한 객체에 Array의 Native slice() 메서드를 호출함으로써 코드의 양을 줄일 수 있다는 것을 발견했습니다. 123456789function makeArray(arrayLike) &#123; return Array.prototype.slice.call(arrayLike);&#125;function doSomething() &#123; var args = makeArray(arguments); // use args&#125; 이 코드는 이전 예제와 기능적으로 동일하며, slice()에 대한 this 값을 Array와 유사한 객체로 설정하기 때문에 작동합니다. slice()는 숫자 인덱스와 length 프로퍼티만 있으면 올바르게 작동하기 때문에 Array와 유사한 객체가 잘 작동합니다. 이 기술은 타이핑이 덜 필요하지만 Array.prototype.slice.call(arrayLike) 호출은 분명히 arrayLike를 Array로 변환하지 않습니다. “다행히 ECMAScript 6은 Array.from() 메서드를 이용하여 객체를 Array로 변환하는 명백하고도 깨끗한 방법을 제공합니다. Iterable 또는 Array와 유사한 객체가 첫 번째 파라미터로 주어지면 Array.from() 메서드는 Array를 반환합니다. 다음은 간단한 예제입니다. 12345function doSomething() &#123; var args = Array.from(arguments); // use args&#125; Array.from() 호출은 arguments에 있는 항목을 기반으로 새로운 Array를 만듭니다. 그래서 args는 arguments와 같은 위치에 같은 값을 갖는 Array의 인스턴스입니다. Array.from() 메서드는 this를 사용하여 반환할 Array 타입을 결정합니다. 매핑 변환 (Mapping Conversion)한단계 더 나아가서 Array 변환을 원한다면 Array.from()에 매핑 함수를 두 번째 파라미터로 제공할 수 있습니다. 이 함수는 Array와 유사한 객체의 각 값에 대해 연산을 수행하고 결과를 최종 Array의 적절한 색인에 저장하기 전에 변환합니다. 1234567function translate() &#123; return Array.from(arguments, (value) =&gt; value + 1);&#125;let numbers = translate(1, 2, 3);console.log(numbers); // 2,3,4 여기서 Array.from()는 매핑 함수로 (value) =&gt; value + 1을 넘겨 주므로 항목을 저장하기 전에 Array의 각 항목에 1을 더합니다. 매핑 함수가 객체 상에 있다면, 매핑 함수를 위한 this 값을 Array.from()의 세 번째 파라미터에 선택적으로 전달할 수 있습니다. 123456789101112131415let helper = &#123; diff: 1, add(value) &#123; return value + this.diff; &#125;&#125;;function translate() &#123; return Array.from(arguments, helper.add, helper);&#125;let numbers = translate(1, 2, 3);console.log(numbers); // 2,3,4 이 예제는 변환을 위한 매핑 함수로 helper.add()를 전달합니다. helper.add()는 this.diff 프로퍼티를 사용하기 때문에, this의 값을 지정하는 Array.from()에 세 번째 파라미터를 제공해야합니다. 세번째 파라미터 덕분에, Array.from()은 bind()를 호출하지 않거나 다른 방식으로 this 값을 지정하지 않고 쉽게 데이터를 변환할 수 있습니다. Iterables에서 사용하기Array.from() 메서드는 Array와 유사한 객체와 Iterable에서 실행가능합니다. 즉, 메서드는 Symbol.iterator 프로퍼티를 가진 객체를 Array로 변환할 수 있습니다. 1234567891011let numbers = &#123; *[Symbol.iterator]() &#123; yield 1; yield 2; yield 3; &#125;&#125;;let numbers2 = Array.from(numbers, (value) =&gt; value + 1);console.log(numbers2); // 2,3,4 numbers 객체는 Iterable이기 때문에 numbers를 직접 Array.from()에 전달하여 그 값을 Array로 변환할 수 있습니다. 매핑 함수는 각 숫자에 1을 더하여 결과 Array에 1, 2, 3 대신 2, 3, 4가 포함됩니다. 객체가 Array와 유사하거나 Iterable한 경우 Array.from()에서 Iterator를 사용하여 변환할 값을 결정할 수 있습니다. 모든 Array에 대한 새로운 메서드ECMAScript 5의 추세를 이어 가면서 ECMAScript 6는 Array에 몇가지 새로운 메서드를 추가했습니다. find() 및 findIndex() 메서드는 개발자가 Array 값을 사용하는 것을 돕기위한 것이지만, fill() 및 copyWithin()은 Typed array에 대한 유스 케이스에서 영감을 얻어 ECMAScript 6에 도입된 숫자만 사용하는 Array 형식입니다. find() 및 findIndex() 메서드ECMAScript 5 이전에는 Array를 검색하는 Built-in 메서드가 없었기 때문에 번거로운 작업이었습니다. ECMAScript 5에는 indexOf() 및 lastIndexOf() 메서드가 추가되었고, 개발자가 Array 내부의 특정 값을 검색할 수 있게되었습니다. 하지만 이 두가지 메서드는 크게 개선되었지만 한번에 하나의 값만 검색할 수 있어 상당히 제한적이었습니다. 예를 들어 일련의 숫자에서 첫번째 짝수를 찾으려면 코드를 직접 작성해야합니다. ECMAScript 6에서는 find() 및 findIndex() 메서드를 도입하여 이 문제를 해결했습니다. find()와 findIndex()는 두개의 파라미터를 받습니다(콜백함수와 콜백 함수 내에서 this에 사용할 선택적 값). 콜백 함수는 Array요소, Array에있는 해당 요소의 인덱스, map()과 forEach()와 같이 Array 자신을 전달하는 동일한 파라미터를 가집니다. 주어진 값이 당신이 정의한 어떤 기준과 일치하면 콜백은 true를 리턴해야합니다. find()와 findIndex()는 콜백 함수가 처음으로 true를 반환할 때 Array 검색을 중지합니다. 두 메서드의 유일한 차이점은 find()는 값을 반환하고 findIndex()는 값이 발견된 인덱스를 반환한다는 것입니다. 다음은 그 예를 보여줍니다. 1234let numbers = [25, 30, 35, 40, 45];console.log(numbers.find(n =&gt; n &gt; 33)); // 35console.log(numbers.findIndex(n =&gt; n &gt; 33)); // 2 이 numbers Array에서 33보다 큰 첫 번째 값을 찾기 위해 find()와 findIndex()를 호출합니다. find() 호출은 35를 반환하고findIndex()는 numbers Array에서 35의 위치인 2를 반환합니다. find()와 findIndex()는 값이 아닌 조건과 일치하는 Array 요소를 찾는 데 유용합니다. 하지만 값만을 찾고 싶다면 indexOf()와 lastIndexOf()가 더좋은 선택입니다. fill() 메서드fill() 메서드는 하나 이상의 Array 요소를 특정 값으로 채웁니다. 값이 전달되면, fill()은 Array의 모든 값을 그 값으로 덮어 씁니다. 12345let numbers = [1, 2, 3, 4];numbers.fill(1);console.log(numbers.toString()); // 1,1,1,1 numbers.fill(1)을 호출하면 numbers의 모든 값이 1로 변경됩니다. 모든 요소가 아닌 일부 요소만 변경하려는 경우 시작 인덱스와 배타적 종료 인덱스(종료 인덱스는 포함되지 않음.)를 추가할 수 있습니다. 123456789let numbers = [1, 2, 3, 4];numbers.fill(1, 2);console.log(numbers.toString()); // 1,2,1,1numbers.fill(0, 1, 3);console.log(numbers.toString()); // 1,0,0,1 numbers.fill(1,2)호출에서 2는 인덱스 2의 요소부터 채우는 것을 시작한다는 것을 나타냅니다. 배타적 종료 인덱스가 세 번째 파라미터로 지정되지 않으므로 numbers.length가 종료 인덱스로 사용됩니다 numbers.fill(0, 1, 3) 연산은 인덱스 1과 2의 Array요소를 0으로 채웁니다. 두 번째와 세 번째 인자로 fill()을 호출하면 전체 Array를 덮어 쓰지 않고 한 번에 여러 Array 요소를 채울 수 있습니다. 시작 또는 끝 인덱스가 음수이면 Array의 길이에 해당 값이 추가되어 최종 위치가 결정됩니다. 예를 들어, array가 fill()이 호출되는 Array이고, 시작 인덱스가 -1이면 인덱스는 array.length - 1입니다. copyWithin() 메서드copyWithin() 메서드는 Array의 여러 요소를 동시에 변경한다는 점에서 fill()과 유사합니다. 그러나 Array 요소에 할당할 단일 값을 지정하는 대신 copyWithin()을 사용하면 Array 자체에서 Array 요소 값을 복사할 수 있습니다. 이를 수행하려면 copyWithin() 메서드에 두개의 파라미터, 즉 메서드가 값을 채우기 시작할 인덱스와 복사할 값이 시작되는 인덱스를 전달해야합니다. 예를 들어 Array의 처음 두 요소의 값을 Array의 마지막 두 항목에 복사하려면 다음 코드를 실행합니다. 123456let numbers = [1, 2, 3, 4];// 인덱스 2부터 인덱스 0에 있는 값을 붙여 넣습니다.numbers.copyWithin(2, 0);console.log(numbers.toString()); // 1,2,1,2 이 코드는 인덱스 2에서 시작하는 값을 numbers에 붙여 넣기 때문에 인덱스 2와 3이 모두 덮어 쓰여집니다. copyWithin()의 두번째 파라미터로 0을 전달하면 인덱스 0에서 값을 복사하기 시작하고 복사할 요소가 없어질 때까지 계속 진행됩니다. 기본적으로, copyWithin()은 항상 Array의 끝까지 값을 복사하지만 선택적인 세번째 파라미터를 제공하면 덮어쓸 요소의 개수를 제한할 수 있습니다. 세번째 파라미터는 값 복사가 중지되는 배타적 종료 인덱스(종료 인덱스는 포함되지 않음.)입니다. 다음은 그 예제입니다. 123456let numbers = [1, 2, 3, 4];// 인덱스 2번부터, 인덱스 0에 있는 값부터 인덱스 1번 이전 지점(0번 인덱스까지)까지의 값으로 채워 넣습니다.numbers.copyWithin(2, 0, 1);console.log(numbers.toString()); // 1,2,1,4 이 예제에서는 선택적 종료 인덱스가 1로 설정되어 있기 때문에 인덱스 0의 값만 복사됩니다. Array의 마지막 요소는 변경되지 않습니다. fill() 메서드와 마찬가지로 copyWithin() 메서드의 파라미터에 음수를 전달하면 Array의 길이가 자동으로 해당 값에 추가되어 인덱스를 결정합니다. 이 시점에서 fill()과 copyWithin() 메서드의 이용 사례는 여러분에게 명확하지 않을 수도 있습니다. 이 메서드들은 Typed array에서 유래되었고 일관성을 위해 일반 Array에 추가 되었기 때문입니다. 그러나 다음 절에서 배우 겠지만, 숫자의 비트를 조작하기 위해 Typed array를 사용하면, 이 메서드들은 훨씬 더 유용합니다. Typed ArrayTyped array는 숫자 타입 (이름에서 암시하듯이 모든 타입이 아닌)을 처리하도록 설계된 특수 용도의 Array입니다. Typed array의 기원은 OpenGL ES 2.0의 port인 WebGL이며, &lt;canvas&gt; 엘리먼트가 있는 웹 페이지에서 사용하도록 설계되었습니다. Typed array는 JavaScript에서 빠른 비트 연산을 제공하기 위해 만들어졌습니다. Native JavaScript의 대한 숫자 계산 연산은 WebGL에서 너무 느렸습니다. 왜냐하면 숫자가 64 비트 부동 소수점 포맷으로 저장되고 필요에 따라 32 비트 정수로 변환 되었기 때문입니다. 이 제한 사항을 우회하고 계산 연산에 더 나은 성능을 제공하기 위해 Typed array가 도입되었습니다. 개념은 모든 단일 숫자를 비트 Array처럼 취급할 수 있으므로 JavaScript Array에서 사용할 수있는 익숙한 메서드를 사용할 수 있다는 것입니다. ECMAScript 6는 JavaScript 엔진 전반에 걸친 더 나은 호환성과 JavaScript Array와의 상호 운용성을 보장하기 위해 Typed array를 언어의 공식적인 부분으로 채택했습니다. ECMAScript 6 버전의 Typed array는 WebGL 버전과 완전히 똑같지는 않고, ECMAScript 6 버전을 WebGL 버전의 확장 버전으로 생각할 수 있습니다. 숫자 데이터 타입(Numeric Data Types)JavaScript 숫자는 64 비트를 사용하여 숫자의 부동 소수점 표현을 저장하는 IEEE 754 형식으로 저장됩니다. 이 형식은 JavaScript에서 정수 및 부동 소수점을 모두 나타내며 두 형식 간의 변환은 숫자가 바뀌면서 자주 발생합니다. Typed array를 사용하면 아래의 8 가지 숫자 타입을 저장하고 조작할 수 있습니다. Signed 8-bit integer (int8) Unsigned 8-bit integer (uint8) Signed 16-bit integer (int16) Unsigned 16-bit integer (uint16) Signed 32-bit integer (int32) Unsigned 32-bit integer (uint32) 32-bit float (float32) 64-bit float (float64) int8에 맞는 숫자를 일반적인 JavaScript Number 타입으로 나타내면 56 비트가 낭비됩니다. 이러한 비트는 추가 int8 값 또는 56 비트 미만을 필요로하는 다른 숫자를 저장하는 데 사용하는 것이 좋습니다. 비트를 보다 효율적으로 사용하는 것은 Typed array의 사용 예중 하나입니다. Typed array와 관련된 모든 연산 및 객체는 이 8 가지 데이터 타입을 중심으로 배치됩니다. 그러나 이들을 사용하려면 Array Buffer를 만들어 데이터를 저장해야합니다. 이 책에서는 괄호 안에 보여준 약어들로 이 타입들을 언급할 것입니다. 이러한 약어는 실제 JavaScript 코드에는 나타나지 않습니다. 단지 더 긴 설명들에 대한 약어 일뿐입니다. Array Buffer모든 Typed array의 기초는 Array Buffer입니다. Array Buffer는 지정된 바이트 수를 포함할 수있는 메모리입니다. Array Buffer를 만드는 것은 C 언어에서 malloc()을 호출하여 메모리를 할당하는 것과 비슷합니다. 다음과 같이 ArrayBuffer 생성자를 사용하여 Array Buffer를 생성할 수 있습니다. 1let buffer = new ArrayBuffer(10); // 10 bytes 할당 Array Buffer가 생성자를 호출할 때 포함해야하는 바이트 수를 전달합니다. let 문장은 10 바이트 길이의 Array Buffer를 생성합니다. Array Buffer가 생성되면, byteLength 프로퍼티를 체크함으로써 바이트 수를 확인할 수 있습니다. 12let buffer = new ArrayBuffer(10); // 10 bytes 할당console.log(buffer.byteLength); // 10 또한 slice() 메서드를 사용하여 기존 Array Buffer의 일부를 포함하는 새로운 Array Buffer를 생성할 수 있습니다. slice() 메서드는 Array의 slice() 메서드와 같이 작동합니다. 여러분은 시작 인덱스와 끝 인덱스를 파라미터로 넘기고, 원래의 요소로 구성된 새로운 ArrayBuffer 인스턴스를 얻을수 있습니다. 12345let buffer = new ArrayBuffer(10); // allocate 10 byteslet buffer2 = buffer.slice(4, 6);console.log(buffer2.byteLength); // 2 위 코드에서, buffer2는 인덱스 4와 5에서 바이트를 추출하여 생성됩니다. 이 메소드의 Array 버전을 호출할 때와 마찬가지로 slice()의 두 번째 파라미터는 배타적(포함되지 않습니다.)입니다. 이렇게 저장 위치를 만들었지만 데이터를 쓸 수 없으면 별로 도움이되지 않습니다. 데이터를 쓰려면 View를 만들어야합니다. Array Buffer는 항상 생성될 때 지정된 정확한 바이트 수를 나타냅니다. Array Buffer 내에 포함된 데이터는 변경할 수 있지만 Array Buffer 자체의 크기는 변경할 수 없습니다. View를 사용하여 Array Buffer 조작하기Array Buffer는 메모리 위치를 나타내며, View는 해당 메모리를 조작하는 데 사용할 인터페이스입니다. View는 Array Buffer 또는 Array Buffer의 하위 집합에서 작동하며 숫자 데이터 타입중 하나에 데이터를 읽고 씁니다. DataView 타입은 8개의 모든 숫자 데이터 타입에 대해 조작할 수있는 Array Buffer의 일반 View입니다. DataView를 사용하려면 먼저 ArrayBuffer의 인스턴스를 생성하고 그것을 사용하여 새로운 DataView를 만듭니다. 다음 예제를 살펴보겠습니다. 12let buffer = new ArrayBuffer(10), view = new DataView(buffer); 이 예제의 view 객체는 buffer의 10 바이트 모두에 접근할 수 있습니다. 그리고 Buffer의 일부분에만 View를 생성할 수도 있습니다. 바이트의 시작 오프셋과 포함할 바이트 수를 선택적으로 입력가능합니다. 포함할 바이트 수를 입력하지 않으면, DataView는 기본적으로 시작 오프셋에서 버퍼 끝까지 선택됩니다. 12let buffer = new ArrayBuffer(10), view = new DataView(buffer, 5, 2); // 5, 6번째 바이트를 포함합니다. 여기서 view는 인덱스 5와 6의 바이트에서만 작동합니다. 이 방법을 사용하면 동일한 Array Buffer를 통해 여러 View를 만들 수 있습니다. 이는 전체 응용프로그램에서 필요에 따라 동적이 아닌 단일 메모리 위치를 사용하려는 경우 유용할 수 있습니다. View 정보 가져 오기다음과 같은 읽기 전용 속성을 가져 와서 뷰에 대한 정보를 검색할 수 있습니다. buffer - View가 연결된 Array Buffer입니다. byteOffset - 제공된 경우 DataView 생성자에 대한 두 번째 파라미터(기본값 : 0). byteLength - 제공된 경우 DataView 생성자에 대한 세 번째 파라미터(기본적으로 버퍼의 byteLength). 이러한 프로퍼티를 사용하면 다음과 같이 View가 작동중인 위치를 정확하게 검사할 수 있습니다. 12345678910let buffer = new ArrayBuffer(10), view1 = new DataView(buffer), // cover all bytes view2 = new DataView(buffer, 5, 2); // cover bytes 5 and 6console.log(view1.buffer === buffer); // trueconsole.log(view2.buffer === buffer); // trueconsole.log(view1.byteOffset); // 0console.log(view2.byteOffset); // 5console.log(view1.byteLength); // 10console.log(view2.byteLength); // 2 이 코드는 전체 Array Buffer에 대한 View인 view1과 Array Buffer의 작은 섹션에 대해 작동하는 view2를 생성합니다. 이 View는 모두 동일한 Array Buffer에서 작동하기 때문에 동일한 buffer 프로퍼티를 갖습니다. 그러나 byteOffset과 byteLength는 각 View마다 다릅니다. 각 View가 작동하는 Array Buffer 부분을 반영합니다. 물론 메모리에 대한 정보만 읽는 것은 그다지 유용하지 않습니다. 이점을 얻으려면 해당 메모리에 데이터를 쓰고 해당 메모리에서 데이터를 읽을 수 있어야합니다. 데이터 읽고 쓰기JavaScript의 8가지 숫자 데이터 타입 각각에 대해 DataView 프로토 타입에는 Array Buffer에서 데이터를 쓰는 메서드와 읽는 메서드가 있습니다. 메서드 이름은 모두 “set”또는 “get”로 시작하고 그 뒤에 데이터 타입 약어가 옵니다. 예를 들어 다음은 int8 및 uint8 값에서 작동할 수있는 읽기 및 쓰기 메서드 목록입니다. getInt8(byteOffset, littleEndian) - byteOffset에서 시작하는 int8 읽기 setInt8(byteOffset, value, littleEndian) - byteOffset에서 시작하는 int8 쓰기 getUint8(byteOffset, littleEndian) - byteOffset에서 시작하는 uint8 읽기 setUint8(byteOffset, value, littleEndian) - byteOffset에서 시작하는 uint8 쓰기 “get” 메서드는 두개의 파라미터, 즉 읽을 바이트 오프셋과 값을 리틀 엔디안으로 읽어야하는지 여부를 나타내는 선택적 값을 사용합니다. (리틀 엔디안은 최하위 바이트가 마지막 바이트 대신에 바이트 0에 있음을 의미합니다.) “set” 메서드는 3 개의 파라미터, 즉 쓸 바이트 오프셋, 쓸 값, 그리고 값이 리틀 엔디안 형식으로 저장되어야 하는지를 나타냅니다. 8 비트 값과 함께 사용할 수있는 메서드만 보여 주었지만 16 비트 값과 32 비트 값에서 동일한 메서드를 사용할 수 있습니다. 각 이름의 8을 16또는 32로 바꾸면 됩니다. 모든 정수 메서드와 함께, DataView는 또한 부동 소수점 수에 대해 다음과 같은 읽기 및 쓰기 메서드를 가지고 있습니다. getFloat32(byteOffset, littleEndian) - byteOffset에서 시작하는 float32 읽기 setFloat32(byteOffset, value, littleEndian) - byteOffset에서 시작하는 float32 쓰기 getFloat64(byteOffset, littleEndian) - byteOffset에서 시작하는 float64 읽기 setFloat64(byteOffset, value, littleEndian) - byteOffset에서 시작하는 float64 쓰기 “set”및 “get” 메서드는 다음 예제를 참고하십시오. 12345678let buffer = new ArrayBuffer(2), view = new DataView(buffer);view.setInt8(0, 5);view.setInt8(1, -1);console.log(view.getInt8(0)); // 5console.log(view.getInt8(1)); // -1 이 코드는 2바이트 Array Buffer를 사용하여 두개의 int8 값을 저장합니다. 첫번째 값은 오프셋 0에서 설정되고 두번째 값은 오프셋 1에서 각 값이 전체 바이트 (8 비트)에 걸쳐 반영됩니다. 이러한 값은 나중에 getInt8() 메서드로 위치에서 읽을 수 있습니다. 이 예제에서는 int8 값을 사용하지만 8가지 숫자 타입중 하나를 해당 메서드와 함께 사용할 수 있습니다. View는 데이터가 이전에 저장된 방식에 관계없이 언제든지 어떤 형식으로든 읽고 쓸수 있기 때문에 흥미롭습니다. 예를 들어 두개의 int8 값을 쓰고 int16 메서드로 Buffer를 읽는 다음 예제를 살펴보겠습니다. 123456789let buffer = new ArrayBuffer(2), view = new DataView(buffer);view.setInt8(0, 5);view.setInt8(1, -1);console.log(view.getInt16(0)); // 1535console.log(view.getInt8(0)); // 5console.log(view.getInt8(1)); // -1 view.getInt16(0)에 대한 호출은 View의 모든 바이트를 읽고 그 바이트를 숫자 1535로 해석합니다. 왜 이런 일이 발생하는지 이해하려면 예제에서 각 setInt8()이 Array Buffer에 어떤 작업을 하는지 살펴 보면 됩니다. 123new ArrayBuffer(2) // 0000000000000000view.setInt8(0, 5); // 0000010100000000view.setInt8(1, -1); // 0000010111111111 Array Buffer는 모두 0 인 16비트로 시작합니다. setInt8()으로 첫번째 바이트에 5를 쓰면 8 비트 표현으로 00000101 입력됩니다. 두번째 바이트에 -1을 쓰면 해당 바이트의 모든 비트가 1로 설정되며, 이는 -1의 2의 보수 표현입니다. 두번째 setInt8()호출 후에, Array Buffer는 16비트를 포함하고, getInt16()은 그 비트들을 십진수로 1535인 하나의 16비트 정수로 읽습니다. DataView 객체는 이런식으로 다른 데이터 타입을 혼합하여 사용하는 경우에 유용합니다. 그러나 하나의 특정 데이터 타입만 사용하는 경우 타입 특화 View가 더 나은 선택일 수 있습니다. Typed Array는 View입니다.ECMAScript 6 Typed Array는 실제로 Array Buffer의 타입별 View입니다. 일반 DataView 객체를 사용하여 Array Buffer를 조작하는 대신 특정 데이터 타입을 적용하는 객체를 사용할 수 있습니다. 8 개의 숫자 데이터 타입에 해당하는 8 개의 타입별 View와 uint8 값에 대한 추가 옵션이 있습니다. 아래 표에서는 ECMAScript 6 사양의 타입별 View의 전체 목록을 간략하게 보여줍니다. 생성자 이름 크기 (byte) 설명 C언어의 동일 타입 Int8Array 1 8-bit 부호있는 정수 signed char Uint8Array 1 8-bit 부호없는 정수 unsigned char Uint8ClampedArray 1 8-bit 부호없는 정수 (값 범위가 0~255로 제한됨) unsigned char Int16Array 2 16-bit 부호있는 정수 short Uint16Array 2 16-bit 부호없는 정수 unsigned short Int32Array 4 32-bit 부호있는 정수 int Uint32Array 4 32-bit 부호없는 정수 int Float32Array 4 32-bit IEEE 부동 소수점 float Float64Array 8 64-bit IEEE 부동 소수점 double 왼쪽 열은 Typed Array 생성자를 나열하고 다른 열은 Typed Array에 포함할 수있는 데이터를 설명합니다. Uint8ClampedArray는 Array Buffer의 값이 0보다 작거나 255보다 크지 않으면 Uint8Array와 같습니다. Uint8ClampedArray는 0보다 작은 값을 0으로 변환하고(-1은 0이되고) 255보다 큰 값은 255로 변환합니다(300은 255가됩니다). Typed Array 연산은 특정 타입의 데이터에서만 작동합니다. 예를 들어 Int8Array의 모든 연산은 int8 값을 사용합니다. Typed Array의 요소 크기는 Array의 타입에 따라 다릅니다. Int8Array의 요소는 한 바이트 길이이고, Float64Array 요소는 8바이트를 사용합니다. 다행스럽게도 요소는 일반 Array처럼 숫자 인덱스를 사용하여 액세스하므로 DataView의 “set”및 “get” 메서드에 대한 다소 어색한 호출을 피할 수 있습니다. 요소 크기Typed Array는 여러 요소로 구성되며 요소 크기는 각 요소가 나타내는 바이트 수입니다. 이 값은 각 생성자 및 각 인스턴스의 BYTES_PER_ELEMENT 프로퍼티에 저장되므로 요소 크기를 쉽게 확인할 수 있습니다. 12345console.log(UInt8Array.BYTES_PER_ELEMENT); // 1console.log(UInt16Array.BYTES_PER_ELEMENT); // 2let ints = new Int8Array(5);console.log(ints.BYTES_PER_ELEMENT); // 1 타입 특화 View 만들기Typed Array 생성자는 여러개의 파라미터를 허용하므로 Typed Array를 만드는 데는 몇 가지 방법이 있습니다. 먼저, DataView에서 사용하는 것과 동일한 파라미터 (Array Buffer, 선택적 바이트 오프셋 및 선택적 바이트 길이)를 전달하여 새로운 Typed Array를 만들 수 있습니다. 12345678910let buffer = new ArrayBuffer(10), view1 = new Int8Array(buffer), view2 = new Int8Array(buffer, 5, 2);console.log(view1.buffer === buffer); // trueconsole.log(view2.buffer === buffer); // trueconsole.log(view1.byteOffset); // 0console.log(view2.byteOffset); // 5console.log(view1.byteLength); // 10console.log(view2.byteLength); // 2 이 코드에서 두 개의 View는 모두 buffer를 사용하는 두 개의 Int8Array 인스턴스입니다. view1과 view2는 DataView 인스턴스 상에 존재하는buffer, byteOffset, byteLength 프로퍼티와 같습니다. 하나의 숫자 타입으로만 작업하면 DataView를 사용할 때 Typed Array를 사용하는 것으로 쉽게 전환할 수 있습니다. Typed Array를 만드는 두 번째 방법은 숫자 하나를 생성자에 전달하는 것입니다. 이 숫자는 Array에 할당할 요소 개수 (바이트가 아님)를 나타냅니다. 생성자는 Array 요소의 개수를 나타내는 올바른 바이트 수를 가진 새로운 Buffer를 만들고 length 프로퍼티를 사용하여 Array의 요소 개수를 액세스할 수 있습니다. 12345678let ints = new Int16Array(2), floats = new Float32Array(5);console.log(ints.byteLength); // 4console.log(ints.length); // 2console.log(floats.byteLength); // 20console.log(floats.length); // 5 ints Array는 두 요소를 위한 공간을 가지고 생성됩니다. 각 16 비트 정수는 값 당 2바이트를 필요로하므로 Array에는 4 바이트가 할당됩니다. floats Array는 5개의 원소를 저장하기 위해 만들어지므로 필요한 바이트 수는 20개 (요소 당 4 바이트)입니다. 두 경우 모두 새로운 Buffer가 생성되고 필요할 경우 buffer 프로퍼티를 사용하여 액세스 할 수 있습니다. Typed Array 생성자에 파라미터가 전달되지 않으면 생성자는 0이 전달된 것처럼 작동합니다. 이렇게하면 0바이트가 Buffer에 할당되므로 데이터를 저장할 수 없는 Typed Array가 만들어집니다. Typed Array을 만드는 세 번째 방법은 객체를 파라미터로 생성자에 전달하는 것입니다. 객체는 다음 중 하나일 수 있습니다. Typed Array - 각 요소는 입력된 새로운 Array의 새 요소에 복사됩니다. 예를 들어 int8을 Int16Array 생성자에 전달하면 int8 값이 int16 Array에 복사됩니다. 새 Typed Array에는 전달된 Array Buffer와 다른 Array Buffer가 사용됩니다. Iterable - 객체의 Iterator가 호출되어 입력된 Array에 삽입할 항목을 검색합니다. View 타입에 대해 유효하지 않은 요소가 있으면 생성자에서 오류가 발생합니다. Array - Array 요소가 새로운 Typed Array로 복사됩니다. 타입에 대해 유효하지 않은 요소가 있으면 생성자에서 오류가 발생합니다. 유사 Array 객체 - Array와 동일하게 작동합니다. 이 경우 각각 소스 객체의 데이터로 새로운 Typed Array가 만들어집니다. 이것은 다음과 같이 일부 값으로 입력된 Array를 초기화하려는 경우에 특히 유용할 수 있습니다. 1234567891011121314let ints1 = new Int16Array([25, 50]), ints2 = new Int32Array(ints1);console.log(ints1.buffer === ints2.buffer); // falseconsole.log(ints1.byteLength); // 4console.log(ints1.length); // 2console.log(ints1[0]); // 25console.log(ints1[1]); // 50console.log(ints2.byteLength); // 8console.log(ints2.length); // 2console.log(ints2[0]); // 25console.log(ints2[1]); // 50 이 예제는 Int16Array를 생성하고 두개의 값을 가지는 Array로 초기화합니다. 그런 다음 Int32Array가 만들어지고 Int16Array가 전달됩니다. 값 25와 50은 두 개의 Typed Array가 완전히 별도의 Buffer를 가지므로 ints1에서 ints2로 복사됩니다. 동일한 숫자는 두 입력된 Array 모두에 표시되지만 ints2는 데이터를 나타내는 데 8바이트를 사용하고 ints1는 4바이트를 사용합니다. Typed Array와 기존 Array의 유사점Typed Array와 일반 Array는 여러 가지면에서 비슷합니다. 이 장에서 이미 살펴본 것처럼 많은 경우 Typed Array를 일반 Array 처럼 사용할 수 있습니다. 예를 들어 length 프로퍼티를 사용하여 입력된 Array에 있는 요소의 수를 확인할 수 있으며 숫자 인덱스를 사용하여 입력된 Array의 요소에 직접 액세스할 수 있습니다. 1234567891011let ints = new Int16Array([25, 50]);console.log(ints.length); // 2console.log(ints[0]); // 25console.log(ints[1]); // 50ints[0] = 1;ints[1] = 2;console.log(ints[0]); // 1console.log(ints[1]); // 2 이 코드에서는 두개의 요소가 있는 새로운 Int16Array이 만들어집니다. 요소은 숫자 인덱스를 사용하여 읽고 쓰며 작업의 일부로 값이 자동으로 저장되고 int16 값으로 변환됩니다. 유사점은 거기서 끝나지 않습니다. 일반 Array와 달리 length 프로퍼티를 사용하여 입력된 Array의 크기를 변경할 수 없습니다. length 프로퍼티는 쓰기가 가능하지 않으므로 이를 변경하려는 시도는 non-strict 모드에서 무시되고 strict 모드에서 오류가 발생합니다. 공통 메서드Typed Array에는 일반 Array 메서드와 기능적으로 동일한 많은 메서드가 포함되어 있습니다. Typed Array에서도 다음 Array 메서드를 사용할 수 있습니다. copyWithin() entries() fill() filter() find() findIndex() forEach() indexOf() join() keys() lastIndexOf() map() reduce() reduceRight() reverse() slice() some() sort() values() 이 메서드들은 Array.prototype과 유사하지만 정확히 동일하지는 않습니다. Typed Array 메서드는 숫자 타입 안전성에 대한 추가 검사를 수행하며 Array가 반환되면 일반 Array 대신 Typed Array를 반환합니다 (Symbol.species 때문에). 다음은 그 차이를 보여주는 간단한 예입니다. 12345678let ints = new Int16Array([25, 50]), mapped = ints.map(v =&gt; v * 2);console.log(mapped.length); // 2console.log(mapped[0]); // 50console.log(mapped[1]); // 100console.log(mapped instanceof Int16Array); // true 이 코드는 map() 메서드를 사용하여 ints의 값을 기반으로 새로운 Array를 만듭니다. 매핑 함수는 Array의 각 값을 두 배로 늘리고 새로운 Int16Array를 반환합니다. 동일한 IteratorTyped Array에는 일반 Array와 동일한 3 개의 Iterator가 있습니다. 그것들은 entries(), keys(), values() 메서드입니다. 즉 일반 Array에서와 마찬가지로 Spread 연산자와 for-of 루프를 사용할 수 있습니다. 123456let ints = new Int16Array([25, 50]), intsArray = [...ints];console.log(intsArray instanceof Array); // trueconsole.log(intsArray[0]); // 25console.log(intsArray[1]); // 50 이 코드는 Typed Array ints와 동일한 데이터를 포함하는 새로운 Array intsArray를 만듭니다. 다른 Iterable과 마찮가지로 Spread 연산자는 Typed Array를 일반 Array로 쉽게 변환합니다. of()와 from() 메서드마지막으로, 모든 Typed Array에는 Array.of() 및 Array.from() 메서드와 같은 정적 메서드 of() 및 from()이 있습니다. 차이점은 Typed Array의 메서드는 일반 Array 대신 Typed Array를 반환한다는 것입니다. 다음은 이러한 메서드를 사용하여 Typed Array를 만드는 몇 가지 예제입니다. 12345678910111213let ints = Int16Array.of(25, 50), floats = Float32Array.from([1.5, 2.5]);console.log(ints instanceof Int16Array); // trueconsole.log(floats instanceof Float32Array); // trueconsole.log(ints.length); // 2console.log(ints[0]); // 25console.log(ints[1]); // 50console.log(floats.length); // 2console.log(floats[0]); // 1.5console.log(floats[1]); // 2.5 이 예제의 of() 및 from() 메서드는 각각 Int16Array 및 Float32Array를 만드는데 사용합니다. 이러한 방법을 통해 Typed Array를 일반 Array처럼 쉽게 만들 수 있습니다. Typed Array와 기존 Array의 차이점Typed Array와 일반 Array의 가장 중요한 차이점은 Typed Array는 일반 Array가 아니라는 것입니다. Typed Array는 Array로부터 상속받지 않으며 Array.isArray()는 Typed Array를 전달할 때 false를 반환합니다. 1234let ints = new Int16Array([25, 50]);console.log(ints instanceof Array); // falseconsole.log(Array.isArray(ints)); // false ints 변수는 Typed Array이므로 Array의 인스턴스가 아니며 그렇기 때문에 Array로 식별될 수 없습니다. Typed Array와 일반 Array는 비슷하지만 Typed Array가 다르게 동작하는 몇가지 메서드가 있기 때문에 이 구분은 매우 중요합니다. 작동 방법상의 차이점일반 Array는 상호 작용할 때 확장 및 축소될 수 있지만 Typed Array는 항상 동일한 크기를 유지합니다. 일반 Array 처럼 Typed Array의 존재하지 않는 숫자 인덱스에 값을 할당할 때 그 작업은 무시됩니다. 12345678910let ints = new Int16Array([25, 50]);console.log(ints.length); // 2console.log(ints[0]); // 25console.log(ints[1]); // 50ints[2] = 5;console.log(ints.length); // 2console.log(ints[2]); // undefined 이 예제에서 숫자 인덱스 2에 5를 할당하더라도 ints Array는 전혀 증가하지 않습니다. length는 동일하게 유지되고 값은 버려집니다. Typed Array에는 유효한 데이터 타입만 사용되는지 확인하는 검사 기능도 있습니다. 유효하지 않은 값은 대신 0이 사용됩니다. 1234let ints = new Int16Array([\"hi\"]);console.log(ints.length); // 1console.log(ints[0]); // 0 이 코드는 Int16Array에 문자열 값 &quot;hi&quot;를 사용하려고 시도합니다. 물론 문자열은 Typed Array에서 유효하지 않은 데이터 타입이므로 값은 대신 0으로 삽입됩니다. Array의 length는 여전히 하나이며, ints[0] 슬롯이 존재하더라도 0 값만 있습니다. Typed Array의 값을 수정하는 모든 메서드는 동일한 제한을 적용받습니다. 예를 들어 map()에 전달된 함수가 Typed Array에 대해 유효하지 않은 값을 반환하면 대신에 0이 사용됩니다. 123456789let ints = new Int16Array([25, 50]), mapped = ints.map(v =&gt; \"hi\");console.log(mapped.length); // 2console.log(mapped[0]); // 0console.log(mapped[1]); // 0console.log(mapped instanceof Int16Array); // trueconsole.log(mapped instanceof Array); // false 문자열 값 &quot;hi&quot;는 16 비트 정수가 아니므로 결과 Array에서 0으로 바뀝니다. 이 오류 수정 동작으로 인해 Typed Array에는 항상 잘못된 데이터가 없기 때문에 잘못된 데이터가 있을때 오류를 던지는 것에 대해 걱정할 필요가 없습니다. 누락된 메서드Typed Array에는 일반 Array와 동일한 메서드가 많이 있지만 Array 메서드중 몇개는 없습니다. Typed Array에서 다음 메서드는 사용할 수 없습니다. concat() pop() push() shift() splice() unshift() concat() 메서드를 제외하고 이 목록의 메서드는 크기를 변경할 수 있습니다. Typed Array는 크기를 변경할 수 없으므로 Typed Array에서 사용할 수 없습니다. 두 개의 Typed Array를 연결한 결과(특히 서로 다른 데이터 타입을 처리하는 경우)가 불확실할 수 있기 때문에 concat() 메서드를 사용할 수 없습니다. 이것은 처음에 Typed Array를 사용하는 이유에 반대되는 개념입니다. 추가된 메서드마지막으로 Typed Array는 set()과 subarray() 메서드와 같이 일반 Array에는 존재하지 않는 두가지 메서드를 가지고 있습니다. 이 두가지 메서드중 set()은 다른 Array를 기존의 Typed Array로 복사하는 반면 subarray()는 기존의 Typed Array의 일부를 새로운 Typed Array로 추출합니다. set() 메서드는 Array(Typed Array 또는 일반 Array)와 데이터를 선택적으로 삽입할 오프셋을 받습니다. 아무 것도 전달하지 않으면 오프셋의 기본값은 0입니다. 유효한 데이터 타입만 사용되도록 보장되며 Array 파라미터의 데이터는 대상 Typed Array에 복사됩니다. 123456let ints = new Int16Array(4);ints.set([25, 50]);ints.set([75, 100], 2);console.log(ints.toString()); // 25,50,75,100 이 코드는 네 개의 요소가있는 Int16Array를 만듭니다. set()을 처음 호출하면 Typed Array의 첫번째와 두번째 요소에 두개의 값이 복사됩니다. set()에 대한 두번째 호출은 오프셋 2를 이용하여 호출이 되고, 이것은 세번째 요소에서부터 배치되어야 함을 나타냅니다. subarray() 메서드는 선택적인 시작 및 종료 인덱스 (slice() 메서드에서와 같이 종료 인덱스는 배타적입니다.)를 받아 들여 새로운 Typed Array를 반환합니다. 그리고, 두 파라미터를 모두 생략하여 Typed Array의 복제본을 만들 수도 있습니다. 12345678let ints = new Int16Array([25, 50, 75, 100]), subints1 = ints.subarray(), subints2 = ints.subarray(2), subints3 = ints.subarray(1, 3);console.log(subints1.toString()); // 25,50,75,100console.log(subints2.toString()); // 75,100console.log(subints3.toString()); // 50,75 이 예제에서는 3 개의 Typed Array가 원래 ints에서 만들어집니다. subints1 Typed Array는 동일한 정보를 포함하는 ints의 복사본입니다. subints2 Typed Array는 인덱스 2에서 시작하는 데이터를 복사하기 때문에 ints의 마지막 두 요소만(75 및 100) 복사합니다. subints3 Typed Array는 subarray()에서 시작 인덱스와 종료 인덱스가 모두 입력되어 호출되므로 ints의 가운데 두 요소만 복사됩니다. 요약ECMAScript 6는 Array를 보다 유용하게 만드는 ECMAScript 5의 작업을 승계합니다. Array를 만드는 방법에는 Array.of() 및 Array.from() 메서드 두가지가 더 추가되었습니다. Array.from() 메서드는 Iterable 및 유사 Array 객체를 Array로 변환할 수 있습니다. 두 메서드 모두 파생 Array 클래스에 상속되며 Symbol.species 프로퍼티를 사용하여 반환할 값 타입을 결정합니다.(다른 상속된 메서드 또한 Array를 반환할 때 Symbol.species를 사용합니다.) Array에는 몇가지 새로운 메서드가 있습니다. fill() 및 copyWithin() 메서드를 사용하면 Array 요소를 현재 위치에서 변경할 수 있습니다. find() 및 findIndex() 메서드는 일부 조건과 일치하는 Array의 첫번째 요소를 찾는데 유용합니다. 전자는 기준에 맞는 첫번째 요소를 반환하고 후자는 요소의 인덱스를 반환합니다. Typed Array는 기술적으로 Array가 아니며 Array를 상속하지 않지만, Array처럼 보이고 동작합니다. Typed Array는 8 개의 다른 숫자 데이터 타입중 하나를 포함하며 숫자 또는 일련의 숫자의 기본 비트를 나타내는 ArrayBuffer 객체를 기반으로 작성됩니다. Typed Array는 JavaScript 숫자 타입의 경우처럼 타입이 앞뒤로 변환되지 않기 때문에 비트 연산을 보다 효율적으로 수행하는 방법입니다. 이 내용은 나중에 참고하기 위해 제가 공부하며 정리한 내용입니다.의역, 오역, 직역이 있을 수 있음을 알려드립니다.This post is a translation of this original article [https://leanpub.com/understandinges6/read#leanpub-auto-improved-array-capabilities] 참고 ECMAScript 6 Block Binding ECMAScript 6 문자열과 정규 표현식 ECMAScript 6 함수 ECMAScript 6 객체의 확장된 기능 ECMAScript 6 쉬운 데이터 액세스를 위한 Destructuring ECMAScript 6 Symbol과 Symbol 프로퍼티 ECMAScript 6 Set과 Map ECMAScript 6 Iterator와 Generator ECMAScript 6 JavaScript 클래스 소개 ECMAScript 6 Array 기능 향상 ECMAScript 6 Promise와 비동기 프로그램밍 ECMAScript 6 프록시와 리플렉션 API ECMAScript 6 Module로 코드 캡슐화하기 ECMAScript 6 부록 A. 작은 변경 사항 ECMAScript 6 부록 B. ECMAScript 7(2016) 이해하기","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://infoscis.github.io/categories/JavaScript/"},{"name":"ECMAScript 2015","slug":"JavaScript/ECMAScript-2015","permalink":"http://infoscis.github.io/categories/JavaScript/ECMAScript-2015/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://infoscis.github.io/tags/JavaScript/"},{"name":"ECMAScript 2015","slug":"ECMAScript-2015","permalink":"http://infoscis.github.io/tags/ECMAScript-2015/"}]},{"title":"JavaScript 클래스 소개","slug":"ecmascript-6-introducing-javascript-classes","date":"2018-02-13T14:49:26.000Z","updated":"2018-02-27T14:12:45.040Z","comments":true,"path":"2018/02/13/ecmascript-6-introducing-javascript-classes/","link":"","permalink":"http://infoscis.github.io/2018/02/13/ecmascript-6-introducing-javascript-classes/","excerpt":"","text":"JavaScript 클래스 소개대부분의 공식적인 객체 지향 프로그래밍 언어와는 달리 JavaScript는 만들어질 때 부터 유사 객체 및 관련 객체를 정의하는 주요 방법으로 클래스와 클래스 상속을 지원하지 않았습니다. 이로 인해 많은 개발자들이 혼란 스러웠고, ECMAScript 1 이전 버전부터 ECMAScript 5 까지 많은 라이브러리가 클래스를 지원하는 것처럼 보이게하는 유틸리티를 만들었습니다. 일부 JavaScript 개발자는 JavaScript에 클래스는 필요하지 않다고 강력하게 느낄수도 있지만, 클래스 지원을 목적으로 하는 많은 수의 라이브러리는 클래스를 ECMAScript 6에 포함 시키도록 했습니다. 클래스가 사용하는 기본 메커니즘을 이해하는 것이 ECMAScript 6 클래스를 공부하는데 도움이되므로 이 장에서는 ECMAScript 5 개발자가 클래스와 비슷한 동작을 하는 방법에 대해 논의함으로써 시작합니다. 그러나 나중에 보게 되겠지만, ECMAScript 6 클래스는 다른 언어의 클래스와 완전히 동일하지 않습니다. JavaScript의 동적 특성을 반영하는 독창적인 기능이 있습니다. ECMAScript 5의 클래스와 비슷한 구조ECMAScript 5 이전 버전의 JavaScript에는 클래스가 없었습니다. 클래스에 가장 가까운 방법은 생성자를 생성한 다음 생성자의 프로토 타입에 메서드를 할당하는 것으로, 일반적으로 사용자 정의 타입 생성이라고 하는 접근 방식입니다. 12345678910111213function PersonType(name) &#123; this.name = name;&#125;PersonType.prototype.sayName = function() &#123; console.log(this.name);&#125;;let person = new PersonType(\"Nicholas\");person.sayName(); // outputs \"Nicholas\"console.log(person instanceof PersonType); // trueconsole.log(person instanceof Object); // true 이 코드에서 PersonType은 name이라는 단일 프로퍼티를 생성하는 생성자 함수입니다. sayName() 메서드는 프로토 타입에 할당되어 동일한 함수가 PersonType 객체의 모든 인스턴스에 의해 공유됩니다. 그런 다음, Person의 새로운 인스턴스가 new 연산자를 통해 생성됩니다. person 객체는 프로토 타입 상속을 통해 PersonType과 Object 인스턴스로 간주됩니다. 이 기본 패턴은 클래스를 모방하는 많은 JavaScript 라이브러리의 근간을 이루며 ECMAScript 6 클래스가 시작됩니다. 클래스 선언ECMAScript 6에서 가장 간단한 클래스 형식은 다른 언어의 클래스와 비슷한 클래스 선언입니다. 클래스 선언의 기본클래스 선언은 class 키워드와 클래스의 이름으로 시작됩니다. 구문의 나머지 부분은 객체 리터럴의 간결한 메서드와 비슷하지만 쉼표가 필요하지 않습니다. 예를 들어, 다음은 간단한 클래스 선언입니다. 123456789101112131415161718192021class PersonClass &#123; // PersonType 생성자와 동일합니다. constructor(name) &#123; this.name = name; &#125; // PersonType.prototype.sayName과 동일합니다. sayName() &#123; console.log(this.name); &#125;&#125;let person = new PersonClass(\"Nicholas\");person.sayName(); // outputs \"Nicholas\"console.log(person instanceof PersonClass); // trueconsole.log(person instanceof Object); // trueconsole.log(typeof PersonClass); // \"function\"console.log(typeof PersonClass.prototype.sayName); // \"function\" PersonClass 클래스 선언은 이전 예제의 PersonType과 매우 유사하게 동작합니다. 그러나 함수를 생성자로 정의하는 대신 클래스 선언을 사용하면 특수한 constructor 메서드 이름을 사용하여 클래스 내부에 직접 생성자를 정의할 수 있습니다. 클래스 메서드는 간결한 구문을 사용하기 때문에 function 키워드를 사용할 필요가 없습니다. 그리고 다른 메서드 이름에는 특별한 의미가 없으므로 원하는 만큼 메서드를 추가할 수 있습니다. Own property는 프로토 타입이 아닌 인스턴스에서 보여지는 프로퍼티는 클래스 생성자 또는 메서드 내부에서만 만들 수 있습니다. 이 예제에서 name은 Own Property입니다. 생성자 함수 내에서 가능한 모든 프로퍼티를 만드는 것이 좋습니다. 왜냐하면 클래스의 한 장소에서 모든 프로퍼티가 표현되기 때문입니다. 흥미롭게도, 클래스 선언은 기존 사용자 정의 타입 선언의 Syntactic sugar입니다. PersonClass 선언은 실제로 constructor 메서드의 동작을 갖는 함수를 생성합니다. 이것이 typeof PersonClass가 “function“을 결과로 주는 이유입니다. sayName() 메서드는 앞의 예제에서 sayName()과 PersonType.prototype 사이의 관계와 비슷하게 이 예제에서 PersonClass.prototype에 대한 메서드로 끝납니다. 이러한 유사점을 사용하면 사용자가 사용하는 타입에 대해 너무 많이 걱정하지 않고도 사용자 정의 타입 및 클래스를 혼합할 수 있습니다. 클래스 구문을 사용해야하는 이유클래스와 사용자 정의 타입의 유사점에도 불구하고 유의해야 할 몇 가지 중요한 차이점이 있습니다. 클래스 선언은 함수 선언과 달리 Hoisting되지 않습니다. 클래스 선언은 let 선언과 같이 행동하며, 실행이 선언에 도달할 때까지 Temporal dead zone에 존재합니다. 클래스 선언의 모든 코드는 strict 모드로 자동 실행됩니다. 클래스의 strict 모드를 거부할 수있는 방법이 없습니다. 모든 메서드는 Non-enumerable 입니다. Object.defineProperty()를 사용하여 메서드를 Non-enumerable하게 만드는 사용자 지정 타입과 다른 중요한 변경 사항입니다. 모든 메서드는 내부 [[Construct]] 메서드가 없으며 new로 호출하려고 하면 에러가 발생합니다. new를 사용하지 않고 클래스 생성자를 호출하면 오류가 발생합니다. 클래스 메서드 내에서 클래스 이름을 덮어 쓰려고하면 오류가 발생합니다. 이 모든 것을 염두에 두고, 위 예제의 PersonClass 선언은 클래스 구문을 사용하지 않는 다음 코드와 동일합니다. 1234567891011121314151617181920212223242526272829303132// PersonClass와 동일합니다.let PersonType2 = (function() &#123; \"use strict\"; const PersonType2 = function(name) &#123; // new를 이용하여 호출이 되었는지 확인 if (typeof new.target === \"undefined\") &#123; throw new Error(\"Constructor must be called with new.\"); &#125; this.name = name; &#125; Object.defineProperty(PersonType2.prototype, \"sayName\", &#123; value: function() &#123; // new를 이용하여 호출하지 않도록 함. if (typeof new.target !== \"undefined\") &#123; throw new Error(\"Method cannot be called with new.\"); &#125; console.log(this.name); &#125;, enumerable: false, writable: true, configurable: true &#125;); return PersonType2;&#125;()); 먼저 두 개의 PersonType2 선언이 있음을 주목하십시오(외부 scope에 있는 let 선언과 IIFE 내부에 있는 const 선언). 이것은 클래스 메서드가 클래스 이름을 덮어 쓰는 것을 금지하는 반면 클래스 외부의 코드는 이를 허용합니다. 생성자 함수는 new.target을 검사하여 new로 호출되는지 확인합니다. 그렇지 않은 경우 오류가 발생합니다. 다음으로, sayName()메소드는 Non-enumerable으로 정의되고 메t서드는 new.target을 검사하여 new로 호출되지 않았음을 확인합니다. 마지막 단계는 생성자 함수를 반환합니다. 이 예제는 새로운 구문을 사용하지 않고 클래스가 수행할 수있는 모든 작업할 수 있지만 클래스 구문은 모든 기능을 크게 단순화한다는 것을 보여줍니다. 상수 클래스 이름클래스의 이름은 클래스 내부에서 const를 사용하는 경우에만 지정됩니다. 즉, 클래스 외부의 클래스 이름은 덮어 쓸 수 있지만 클래스 메서드 내부에서는 덮어 쓸 수 없습니다. 12345678class Foo &#123; constructor() &#123; Foo = \"bar\"; // 실행될때 에러가 발생합니다. &#125;&#125;// 클래스 선언 이후에는 가능합니다.Foo = \"baz\"; 이 코드에서 클래스 생성자 안에있는 Foo는 클래스 외부의 Foo와는 별도의 바인딩입니다. 내부의 Foo는 마치 const인 것처럼 정의되고 덮어 쓸 수 없습니다. 생성자가 Foo를 임의의 값으로 덮어 쓰려고하면 에러가 발생합니다. 그러나 외부 Foo는 let 선언처럼 정의되기 때문에 언제든지 값을 덮어 쓸 수 있습니다. 클래스 표현식클래스와 함수는 선언과 표현식이라는 두가지 형식을 가지고 있다는 점에서 비슷합니다. 함수와 클래스 선언은 적절한 키워드 (각각function 또는class)와 식별자로 시작됩니다. 함수는 function 다음에 식별자를 필요로하지 않는 표현식 형태를 가지고 있고, 비슷하게 클래스는 class 다음에 식별자를 필요로하지 않는 표현식 형태를 가지고 있습니다. 이 클래스 표현식은 변수 선언에 사용되거나 함수로 인수로 전달되도록 설계되었습니다. 기본 클래스 표현식다음은 이전 PersonClass 예제에 해당하는 클래스 표현식과 그 코드를 사용하는 코드입니다. 123456789101112131415161718192021let PersonClass = class &#123; // PersonType constructor와 같습니다. constructor(name) &#123; this.name = name; &#125; // PersonType.prototype.sayName과 같습니다. sayName() &#123; console.log(this.name); &#125;&#125;;let person = new PersonClass(\"Nicholas\");person.sayName(); // \"Nicholas\" 출력console.log(person instanceof PersonClass); // trueconsole.log(person instanceof Object); // trueconsole.log(typeof PersonClass); // \"function\"console.log(typeof PersonClass.prototype.sayName); // \"function\" 이 예제에서 알 수 있듯이, 클래스 표현식은 class 다음에 식별자를 요구하지 않습니다. 구문 외에도 클래스 표현식은 클래스 선언과 기능적으로 동일합니다. 클래스 선언 또는 클래스 표현식 사용 여부는 주로 스타일의 문제입니다. 함수 선언 및 함수 표현식과 달리 클래스 선언과 클래스 표현식은 모두 Hoisting 되지 않기 때문에 코드의 런타임 동작에 거의 영향을 미치지 않습니다. 이름이 부여된 클래스 표현식이전 섹션 예제에서 익명 클래스 표현식을 사용했지만 함수 표현식과 마찬가지로 클래스 표현식의 이름을 지정할 수도 있습니다. 이렇게 하려면 다음과 같이 class 키워드 다음에 이름(식별자)를 포함 시킵니다. 123456789101112131415let PersonClass = class PersonClass2 &#123; // PersonType constructor와 같습니다. constructor(name) &#123; this.name = name; &#125; // PersonType.prototype.sayName와 같습니다. sayName() &#123; console.log(this.name); &#125;&#125;;console.log(typeof PersonClass); // \"function\"console.log(typeof PersonClass2); // \"undefined\" 이 예제에서 클래스 표현식의 이름은 PersonClass2입니다. PersonClass2 식별자는 클래스 정의 내에서만 존재하기 때문에 (이 예제에서sayName() 메서드 처럼) 클래스 메서드 내부에서 사용될 수 있습니다. 하지만 클래스 밖에서 typeof PersonClass2는 PersonClass2 바인딩이 존재하지 않기 때문에 &quot;undefined&quot;입니다. 이러한 이유를 이해하기 위해 아래 예제처럼 클래스를 사용하지 않는 동일한 함수 선언을 살펴보겠습니다. 1234567891011121314151617181920212223242526272829303132// PersonClass에 이름이 부여된 클래스 표현식과 동일합니다.let PersonClass = (function() &#123; \"use strict\"; const PersonClass2 = function(name) &#123; // 함수가 new로 호출되었는지 확인합니다. if (typeof new.target === \"undefined\") &#123; throw new Error(\"Constructor must be called with new.\"); &#125; this.name = name; &#125; Object.defineProperty(PersonClass2.prototype, \"sayName\", &#123; value: function() &#123; // 함수가 new를 사용하지 않고 호출되었는지 확인합니다 if (typeof new.target !== \"undefined\") &#123; throw new Error(\"Method cannot be called with new.\"); &#125; console.log(this.name); &#125;, enumerable: false, writable: true, configurable: true &#125;); return PersonClass2;&#125;()); 이름이 부여된 클래스 표현식을 작성하면 JavaScript 엔진에서 일어나는 일이 약간 바뀝니다. 클래스 선언의 경우, 외부 바인딩 (let으로 정의)은 내부 바인딩 (const로 정의)과 동일한 이름을 가집니다. 이름이 부여된 클래스 표현식은 const 정의에서 그 이름을 사용하므로PersonClass2는 클래스 내부에서만 사용하도록 정의됩니다. 이름이 부여된 클래스 표현식은 이름이 부여된 함수 표현식과 다르게 동작하지만, 두 표현식 사이에는 여전히 많은 유사점이 있습니다. 둘 다 값(Value)으로 사용할 수 있으며, 이는 많은 가능성을 열어줍니다. 이것은 아래에서 다루도록 하겠습니다. 일급 시민(First-Class Citizen)으로서의 클래스 일급 시민: 컴퓨터 프로그래밍 언어 디자인에서, 특정 언어의 일급 객체 (first-class citizens, 일급 값, 일급 엔티티, 혹은 일급 시민)이라 함은 일반적으로 다른 객체들에 적용 가능한 연산을 모두 지원하는 객체를 가리킨다. 함수에 파라미터로 넘기기, 변수에 대입하기와 같은 연산들이 여기서 말하는 일반적인 연산의 예에 해당한다. 프로그래밍 언어에서 어떤것은 값(Value)으로 사용될 수 있고, 이 경우에 First-Class Citizen이라고 말합니다. 즉, 함수로 전달되고 함수에서 반환되며 변수에 할당될 수 있습니다. JavaScript 함수는 First-Class Citizen (때로는 First-Class Function이라 부름)이며, 이는 JavaScript를 고유하게 만드는 요소의 일부입니다. ECMAScript 6은 클래스를 First-Class Citizen으로 만들어 이러한 전통을 이어가고 있습니다. 이를 통해 클래스를 다양한 방식으로 사용할 수 있습니다. 예를 들어, 파라미터로 함수에 전달할 수 있습니다. 123456789101112function createObject(classDef) &#123; return new classDef();&#125;let obj = createObject(class &#123; sayHi() &#123; console.log(\"Hi!\"); &#125;&#125;);obj.sayHi(); // \"Hi!\" 이 예제에서, createObject() 함수는 익명의 클래스 표현식을 인수로하여 호출되고, new로 그 클래스의 인스턴스를 생성하여 인스턴스를 리턴합니다. 변수 obj는 반환된 인스턴스를 저장합니다. 클래스 표현식의 또 다른 흥미로운 사용법은 클래스 생성자를 즉시 호출하여 싱글톤을 생성하는 것입니다. 이렇게 하려면 클래스 표현식에 new를 사용해야 하고 마지막에 괄호를 포함해야합니다. 12345678910111213let person = new class &#123; constructor(name) &#123; this.name = name; &#125; sayName() &#123; console.log(this.name); &#125;&#125;(\"Nicholas\");person.sayName(); // \"Nicholas\" 여기서 익명의 클래스 표현식이 생성되고 즉시 실행됩니다. 이 패턴을 사용하면 클래스 참조를 검사할 수 있게하지 않고도 싱글톤을 생성하기 위한 클래스 구문을 사용할 수 있습니다(PersonClass는 바깥 쪽이 아닌 클래스 내에서만 바인딩을 생성한다는 것을 기억하십시오.). 클래스 표현식의 끝 부분에있는 괄호는 함수를 호출하는 동시에 인자를 전달할 수 있는 것을 나타냅니다. 지금까지 이 장의 예제는 메서드가 있는 클래스에 중점을 두었습니다. 그러나 객체 리터럴과 유사한 구문을 사용하여 클래스에 접근자(Accessor) 프로퍼티를 만들 수도 있습니다. 접근자(Accessor) 프로퍼티클래스 생성자 내에서 자체 프로퍼티를 만들어야 하지만 클래스를 사용하면 프로토 타입에 접근자(Accessor) 프로퍼티를 정의할 수 있습니다. Getter를 만들려면 키워드 get 다음에 공백 문자와 식별자를 사용하합니다. Setter를 만들려면 set 키워드를 사용합니다. 12345678910111213141516171819class CustomHTMLElement &#123; constructor(element) &#123; this.element = element; &#125; get html() &#123; return this.element.innerHTML; &#125; set html(value) &#123; this.element.innerHTML = value; &#125;&#125;var descriptor = Object.getOwnPropertyDescriptor(CustomHTMLElement.prototype, \"html\");console.log(\"get\" in descriptor); // trueconsole.log(\"set\" in descriptor); // trueconsole.log(descriptor.enumerable); // false 이 코드에서, CustomHTMLElement 클래스는 기존 DOM Element를 감싸는 래퍼로 만들어집니다. 그것은 Element 자체에 대한 innerHTML 메서드에 위임한 html을 위한 Getter와 Setter를 둘 다 가지고 있습니다. 이 접근자 프로퍼티는 CustomHTMLElement.prototype에서 생성되며, 다른 메서드와 마찬가지로 Non-enumerable로 생성됩니다. 클래스를 사용하지 않는 동일한 코드는 아래와 같습니다. 12345678910111213141516171819202122232425262728// 위 예제와 동일합니다.let CustomHTMLElement = (function() &#123; \"use strict\"; const CustomHTMLElement = function(element) &#123; // new를 이용한 호출인지 확인 합니다. if (typeof new.target === \"undefined\") &#123; throw new Error(\"Constructor must be called with new.\"); &#125; this.element = element; &#125; Object.defineProperty(CustomHTMLElement.prototype, \"html\", &#123; enumerable: false, configurable: true, get: function() &#123; return this.element.innerHTML; &#125;, set: function(value) &#123; this.element.innerHTML = value; &#125; &#125;); return CustomHTMLElement;&#125;()); 이전 예제와 마찬가지로 이 코드는 클래스를 이용하는 것이 동일한 기능을 하는 클래스를 사용하지 않는 코드에 비해 얼마나 코드를 줄일수 있는지 보여줍니다. html 접근자 프로퍼티 정의만이 거의 비슷한 크기입니다. 계산된 멤버 이름객체 리터럴과 클래스 간의 유사점은 아직 끝나지 않았습니다. 클래스 메서드와 접근자 프로퍼티는 계산된 이름을 가질 수도 있습니다. 식별자를 사용하는 대신 표현식 주위에 대괄호를 사용합니다. 이 표현식은 객체 리터럴의 계산된 이름에 사용되는 구문과 동일합니다. 123456789101112131415let methodName = \"sayName\";class PersonClass &#123; constructor(name) &#123; this.name = name; &#125; [methodName]() &#123; console.log(this.name); &#125;&#125;let me = new PersonClass(\"Nicholas\");me.sayName(); // \"Nicholas\" 이 버전의 PersonClass는 변수를 사용하여 정의 안에 있는 메서드에 이름을 할당합니다. 문자열 &quot;sayName&quot;은 methodName 변수에 할당되고 메서드를 선언하기 위해 methodName이 사용됩니다. sayName() 메서드는 나중에 직접 액세스됩니다. 접근자 프로퍼티는 다음과 같은 방식으로 계산된 이름을 사용할 수 있습니다. 12345678910111213141516let propertyName = \"html\";class CustomHTMLElement &#123; constructor(element) &#123; this.element = element; &#125; get [propertyName]() &#123; return this.element.innerHTML; &#125; set [propertyName](value) &#123; this.element.innerHTML = value; &#125;&#125; 여기서 html에 대한 Getter와 Setter는 propertyName 변수를 사용하여 설정됩니다. .html을 사용하여 프로퍼티에 접근하는 것은 정의에만 영향을 줍니다. 클래스와 객체 리터럴 간에는 메서드, 접근자 프로퍼티 및 계산된 이름등 많은 유사점이 있다는 것을 알았습니다. 그리고 Generator라는 유사점이 하나더 있습니다. Generator 메서드8 장에서 Generator를 소개할 때 메서드 이름에 별표 (*)를 추가하여 객체 리터럴에 Generator를 정의하는 방법을 배웠습니다. 클래스에 대해서도 동일한 구문이 적용되어 모든 메서드를 Generator로 사용할 수 있습니다. 다음은 그 예입니다. 123456789101112class MyClass &#123; *createIterator() &#123; yield 1; yield 2; yield 3; &#125;&#125;let instance = new MyClass();let iterator = instance.createIterator(); 이 코드는 createIterator() Generator 메서드를 가지는 MyClass라는 클래스를 생성합니다. 이 메서드는 값이 Generator에 하드코딩된 Iterator를 반환합니다. Generator 메서드는 값의 컬렉션을 나타내는 객체가 있고 해당 값을 쉽게 반복할 때 유용합니다. Array, Set, Map은 모두 개발자들이 아이템과 상호 작용할 필요가 있는 다양한 방법을 설명하기 위해 여러 Generator 메서드를 가지고 있습니다. 클래스에 대한 기본 Iterator를 정의하면 클래스가 값 컬렉션을 나타내는 경우 훨씬 유용합니다. Symbol.iterator를 사용하여 다음과 같이 Generator 메서드를 정의하여 클래스의 기본 Iterator를 정의할 수 있습니다. 123456789101112131415161718192021222324class Collection &#123; constructor() &#123; this.items = []; &#125; *[Symbol.iterator]() &#123; yield *this.items.values(); &#125;&#125;var collection = new Collection();collection.items.push(1);collection.items.push(2);collection.items.push(3);for (let x of collection) &#123; console.log(x);&#125;// 결과:// 1// 2// 3 이 예제는 this.items 배열의 values() Iterator에 위임한 Generator 메서드에 대해 계산된 이름을 사용합니다. 컬렉션의 값을 관리하는 모든 클래스에는 기본 Iterator가 포함되어야 합니다. 컬렉션 관련 일부 작업에는 Iterator가 필요하기 때문입니다. 이제, Collection의 어떤 인스턴스도 for-of 루프나 Spread 연산자에 직접 사용될 수 있습니다. 클래스 프로토 타입에 메서드 및 접근자 프로퍼티를 추가하면 객체 인스턴스에 해당 메서드를 표시할 때 유용합니다. 반면에 클래스 자체의 메서드 또는 접근자 프로퍼티를 원하면 정적 멤버를 사용해야합니다. 정적 멤버(Static Member)정적 멤버를 시뮬레이트하기 위해 생성자에 직접 메서드를 추가하는 것은 ECMAScript 5 및 이전 버전의 또 다른 공통 패턴입니다. 123456789101112131415function PersonType(name) &#123; this.name = name;&#125;// static methodPersonType.create = function(name) &#123; return new PersonType(name);&#125;;// instance methodPersonType.prototype.sayName = function() &#123; console.log(this.name);&#125;;var person = PersonType.create(\"Nicholas\"); 다른 프로그래밍 언어에서, PersonType.create()라고 불리는 팩토리 메소드는 정적 메소드로 간주될 것입니다. 왜냐하면 PersonType의 인스턴스에 의존하지 않기 때문입니다. ECMAScript 6 클래스는 메서드 또는 접근자 프로퍼티 이름 앞에 정식 static Annotation을 사용하여 정적 멤버 생성을 단순화합니다. 예를 들어, 다음은 이전 예제와 동일한 클래스입니다. 12345678910111213141516171819class PersonClass &#123; // PersonType constructor와 동일합니다. constructor(name) &#123; this.name = name; &#125; // PersonType.prototype.sayName와 동일합니다. sayName() &#123; console.log(this.name); &#125; // PersonType.create와 동일합니다. static create(name) &#123; return new PersonClass(name); &#125;&#125;let person = PersonClass.create(\"Nicholas\"); PersonClass 정의는 create()라고 하는 하나의 정적 메서드를 가지고 있습니다. 메서드 구문은 static 키워드를 제외하고 sayName()과 동일합니다. static 키워드는 클래스 내의 임의의 메서드 또는 접근자 프로퍼티 정의에 사용할 수 있습니다. 유일한 제약은static을 constructor 메서드 정의와 함께 사용할 수 없다는 것입니다. 정적 멤버는 인스턴스에서 액세스할 수 없습니다. 항상 클래스의 정적 멤버에 직접 액세스해야합니다. 파생 클래스를 사용한 상속ECMAScript 6 이전에는 사용자 정의 타입으로 상속을 구현할때 대규모 과정이 필요했습니다. 적절한 상속에는 여러 단계가 필요했습니다. 예를 들어 다음 예제를 살펴보겠습니다. 123456789101112131415161718192021222324252627function Rectangle(length, width) &#123; this.length = length; this.width = width;&#125;Rectangle.prototype.getArea = function() &#123; return this.length * this.width;&#125;;function Square(length) &#123; Rectangle.call(this, length, length);&#125;Square.prototype = Object.create(Rectangle.prototype, &#123; constructor: &#123; value:Square, enumerable: true, writable: true, configurable: true &#125;&#125;);var square = new Square(3);console.log(square.getArea()); // 9console.log(square instanceof Square); // trueconsole.log(square instanceof Rectangle); // true Square는 Rectangle을 상속받습니다. 그래서 Square.prototype을 Rectangle.prototype에서 생성한 새로운 객체로 덮어 쓰고Rectangle.call() 메서드를 호출해야합니다. 이 단계들은 종종 JavaScript 신참을 혼란스럽게 만들거나 경험 많은 개발자에게 오류의 원인이 되었습니다. 클래스는 익숙한 extends 키워드를 사용하여 클래스가 상속해야하는 함수를 지정함으로써 상속을 보다 쉽게 구현할 수 있도록합니다. 프로토 타입은 자동으로 조정되며 super() 메서드를 호출하여 기본 클래스 생성자에 액세스할 수 있습니다. 다음은 앞의 예제와 동일한 ECMAScript 6 코드입니다. 123456789101112131415161718192021222324class Rectangle &#123; constructor(length, width) &#123; this.length = length; this.width = width; &#125; getArea() &#123; return this.length * this.width; &#125;&#125;class Square extends Rectangle &#123; constructor(length) &#123; // Rectangle.call(this, length, length)와 같습니다. super(length, length); &#125;&#125;var square = new Square(3);console.log(square.getArea()); // 9console.log(square instanceof Square); // trueconsole.log(square instanceof Rectangle); // true 이번에 Square 클래스는 extends 키워드를 사용하여 Rectangle에서 상속받습니다. Square 생성자는 super()를 사용하여 지정된 파라미터로 Rectangle 생성자를 호출합니다. ECMAScript 5 버전의 코드와 달리 식별자 Rectangle은 클래스 선언 (extends이후)에서만 사용됩니다. 다른 클래스로부터 상속받은 클래스를 파생 클래스(derived classes)라고합니다. 파생 클래스는 생성자를 지정하는 경우 super()를 사용해야합니다. 그렇지 않으면 오류가 발생합니다. 생성자를 사용하지 않기로 결정한 경우 클래스의 새 인스턴스를 만들 때 super()가 모든 파라미터와 함께 자동으로 호출됩니다. 예를 들어, 다음 두 클래스는 동일합니다. 1234567891011class Square extends Rectangle &#123; // 생성자가 없습니다.&#125;// 위 클래스는 아래와 동일합니다.class Square extends Rectangle &#123; constructor(...args) &#123; super(...args); &#125;&#125; 이 예제의 두 번째 클래스는 모든 파생 클래스에 대한 기본 생성자와 동일합니다. 모든 파라미터는 순서대로 기본 클래스 생성자에 전달됩니다. 이전에 정의한 예제에서 Square 클래스의 생성자는 하나의 파라미터만 필요하기 때문에 super(...args)는 올바르지 않으므로 수동으로 생성자를 정의하는 것이 좋습니다. super()를 사용할 때 유의해야할 몇 가지 사항이 있습니다. 파생 클래스에서만 super()를 사용할 수 있습니다. 비 파생 클래스 (extends를 사용하지 않는 클래스) 또는 함수에서 사용하려고하면 오류가 발생합니다. 생성자에서 this에 접근하기 전에 super()를 호출해야합니다. super()는 this를 초기화할 책임이 있기 때문에 super()를 호출하기 전에 this에 접근하려고 하면 에러가 발생합니다. super()를 호출하지 않는 유일한 방법은 클래스 생성자에서 객체를 반환하는 것입니다. 클래스 메서드 숨기기파생 클래스의 메서드는 항상 기본 클래스에서 같은 이름의 메서드를 숨깁니다. 예를 들어, Square에 getArea()를 추가하면 그 기능을 재정의할 수 있습니다. 12345678910class Square extends Rectangle &#123; constructor(length) &#123; super(length, length); &#125; // Rectangle.prototype.getArea()를 숨기고 재정의 합니다. getArea() &#123; return this.length * this.length; &#125;&#125; getArea()가 Square의 일부로 정의 되었기 때문에 Rectangle.prototype.getArea() 메서드는 Square 인스턴스에 의해 더이상 호출되지 않습니다. 물론, 다음과 같이 super.getArea() 메서드를 사용하여 메서드의 기본 클래스 버전을 호출하기로 결정할 수 있습니다. 12345678910class Square extends Rectangle &#123; constructor(length) &#123; super(length, length); &#125; // Rectangle.prototype.getArea()를 숨기고 재정의 하여 호출 합니다. getArea() &#123; return super.getArea(); &#125;&#125; 이런 방식으로 super를 사용하는 것은 4 장에서 논의된 super 참조와 똑같이 작동합니다 (“Super 참조를 사용한 쉬운 프로토 타입 액세스” 참조). this 값은 자동으로 올바르게 설정되어 간단하게 메소드 호출할 수 있습니다. 정적 멤버 상속기본 클래스에 정적 멤버가 있는 경우 해당 정적 멤버는 파생 클래스에서도 사용할 수 있습니다. 상속은 다른 언어의 경우와 마찬가지로 작동하지만 이는 JavaScript에서는 새로운 개념입니다. 다음은 그 예입니다. 12345678910111213141516171819202122232425262728class Rectangle &#123; constructor(length, width) &#123; this.length = length; this.width = width; &#125; getArea() &#123; return this.length * this.width; &#125; static create(length, width) &#123; return new Rectangle(length, width); &#125;&#125;class Square extends Rectangle &#123; constructor(length) &#123; // same as Rectangle.call(this, length, length) super(length, length); &#125;&#125;var rect = Square.create(3, 4);console.log(rect instanceof Rectangle); // trueconsole.log(rect.getArea()); // 12console.log(rect instanceof Square); // false 이 코드에서는 새로운 정적 create() 메서드가 Rectangle 클래스에 추가되었습니다. 이 메서드는 상속을 통해 Square.create()로 사용할 수 있으며 Rectangle.create() 메서드와 같은 방식으로 동작합니다. 표현식에서 파생된 클래스아마도 ECMAScript 6에서 파생 클래스의 가장 강력한 부분은 표현식에서 클래스를 파생시킬 수 있는 능력입니다. 표현식이 [[Construct]]와 프로토 타입을 가진 함수로 해석되는한 어떤 표현식이라도 extends을 사용할 수 있습니다. 123456789101112131415161718function Rectangle(length, width) &#123; this.length = length; this.width = width;&#125;Rectangle.prototype.getArea = function() &#123; return this.length * this.width;&#125;;class Square extends Rectangle &#123; constructor(length) &#123; super(length, length); &#125;&#125;var x = new Square(3);console.log(x.getArea()); // 9console.log(x instanceof Rectangle); // true Rectangle은 ECMAScript 5 스타일 생성자로 정의되고 Square는 클래스입니다. Rectangle은 [[Construct]]와 프로토 타입을 가지고 있기 때문에 Square 클래스는 직접 상속받을 수 있습니다. extends 이후에 어떤 타입의 표현식이라도 받아들이면 상속받을 것을 동적으로 결정하는 것과 같은 강력한 가능성을 제공합니다. 12345678910111213141516171819202122function Rectangle(length, width) &#123; this.length = length; this.width = width;&#125;Rectangle.prototype.getArea = function() &#123; return this.length * this.width;&#125;;function getBase() &#123; return Rectangle;&#125;class Square extends getBase() &#123; constructor(length) &#123; super(length, length); &#125;&#125;var x = new Square(3);console.log(x.getArea()); // 9console.log(x instanceof Rectangle); // true getBase() 함수는 클래스 선언의 일부로서 직접 호출되어 Rectangle을 반환합니다. 이 예제는 기능적으로 이전의 것과 같습니다. 그리고 기본 클래스를 동적으로 결정할 수 있으므로 서로 다른 상속 접근법을 만들 수 있습니다. 예를 들어 mixin을 효과적으로 만들 수 있습니다. 1234567891011121314151617181920212223242526272829let SerializableMixin = &#123; serialize() &#123; return JSON.stringify(this); &#125;&#125;;let AreaMixin = &#123; getArea() &#123; return this.length * this.width; &#125;&#125;;function mixin(...mixins) &#123; var base = function() &#123;&#125;; Object.assign(base.prototype, ...mixins); return base;&#125;class Square extends mixin(AreaMixin, SerializableMixin) &#123; constructor(length) &#123; super(); this.length = length; this.width = length; &#125;&#125;var x = new Square(3);console.log(x.getArea()); // 9console.log(x.serialize()); // \"&#123;\"length\":3,\"width\":3&#125;\" 이 예에서는 클래식 상속 대신 mixin이 사용됩니다. mixin() 함수는 mixin 객체를 나타내는 파라미터를 취합니다. base라는 함수를 생성하고 각 mixin 객체의 프로퍼티를 프로토 타입에 할당합니다. mixin() 함수는 Square가 extends를 사용할 수 있도록 함수를 반환합니다. extends가 여전히 사용되기 때문에 생성자에서 super()를 호출해야 한다는 것을 명심하십시오. Square의 인스턴스는 AreaMixin의 getArea()와 SerializableMixin의 serialize()를 가지고 있습니다. 이는 프로토 타입 상속을 통해 수행됩니다. mixin() 함수는 새로운 함수의 프로토 타입을 각 mixin의 모든 프로퍼티로 동적으로 채웁니다. (여러 mixin이 동일한 속성을 갖는 경우 마지막 프로퍼티만 추가됩니다.) 모든 표현식은extends 다음에 사용될 수 있지만, 모든 표현식이 유효한 클래스가되는 것은 아닙니다. 특히 다음 표현식 유형은 오류를 유발합니다. null Generator 함수 (Chapter 8에서 설명함) 이러한 경우, 호출할 [[Construct]]가 없으므로 클래스의 새 인스턴스를 만들려고하면 오류가 발생합니다. 내장(Built-in) 상속JavaScript Array가 추가될때부터 개발자는 상속을 통해 자신만의 특별한 Array 타입을 만들고 싶어했습니다. ECMAScript 5 및 이전 버전에서는 이것이 가능하지 않았습니다. 고전적인 상속을 사용하려고 시도해도 코드가 작동하지 않았습니다. 1234567891011121314151617181920212223242526272829// built-in array 작동방법var colors = [];colors[0] = \"red\";console.log(colors.length); // 1colors.length = 0;console.log(colors[0]); // undefined// ES5에서 array를 상속하도록 시도함function MyArray() &#123; Array.apply(this, arguments);&#125;MyArray.prototype = Object.create(Array.prototype, &#123; constructor: &#123; value: MyArray, writable: true, configurable: true, enumerable: true &#125;&#125;);var colors = new MyArray();colors[0] = \"red\";console.log(colors.length); // 0colors.length = 0;console.log(colors[0]); // \"red\" 이 코드의 끝 부분에 있는 console.log() 출력은 Array에 JavaScript의 고전적인 상속 형태를 사용하여, 어떤 예기치 않은 동작을 일으키는 방법을 보여줍니다. MyArray의 인스턴스에서 length와 숫자 프로퍼티는 Array.apply() 또는 prototype을 할당해도 Built-in Array에서 처럼 동작하지 않습니다. ECMAScript 6 클래스의 목표 중 하나는 모든 Built-in 함수에서 상속을 허용하는 것입니다. 이를 달성하기 위해 클래스의 상속 모델은 ECMAScript 5 및 이전 버전에서 보여준 고전적인 상속 모델과 약간 다릅니다. ECMAScript 5 전통적인 상속에서 this의 값은 파생된 타입 (예를 들면, MyArray)에 의해 먼저 생성되고, Array.apply() 메서드와 같은 기본 타입 생성자가 호출됩니다. 즉, 이것은 MyArray 인스턴스로 시작하여 Array의 추가 프로퍼티로 꾸며져 있음을 의미합니다. ECMAScript 6 클래스 기반 상속에서, this의 값은 먼저 기본타입(Array)에 의해 생성된 다음 파생 클래스 생성자 (MyArray)에 의해 수정됩니다. 결과적으로 this는 기본타입의 모든 Built-in 기능으로 시작하여 그에 관련된 모든 기능을 올바르게 상속합니다. 다음 예제는 클래스 기반 특수 Array의 실행을 보여줍니다. 12345678910class MyArray extends Array &#123; // empty&#125;var colors = new MyArray();colors[0] = \"red\";console.log(colors.length); // 1colors.length = 0;console.log(colors[0]); // undefined MyArray는 Array에서 직접 상속되므로 Array와 같이 작동합니다. 숫자 프로퍼티와 상호 작용하면 length 프로퍼티를 업데이트하고, length 프로퍼티를 조작하면 숫자 프로퍼티를 업데이트합니다. 즉, Array를 상속 받아서 자신만의 파생 Array 클래스를 만들고 다른 Built-in 함수를 상속받을 수 있다는 것을 의미합니다. Symbol.species 프로퍼티Built-in 함수의 상속이 흥미로운 점은 Built-in 함수의 인스턴스를 반환하는 모든 메서드가 파생 클래스 인스턴스를 자동으로 반환한다는 것입니다. 그래서 Array를 상속받은 MyArray라는 파생 클래스가 있다면 slice()와 같은 메서드는 MyArray의 인스턴스를 리턴합니다. 123456789class MyArray extends Array &#123; // empty&#125;let items = new MyArray(1, 2, 3, 4), subitems = items.slice(1, 3);console.log(items instanceof MyArray); // trueconsole.log(subitems instanceof MyArray); // true 이 코드에서 slice() 메서드는 MyArray 인스턴스를 반환합니다. slice() 메서드는 Array로부터 상속 받고 Array의 인스턴스를 정상적으로 리턴합니다. 하지만 뒤에서 이 변화를 일으키는 것은 Symbol.species 프로퍼티입니다. Symbol.species Symbol은 함수를 반환하는 정적(Static) 접근자(Accessor) 프로퍼티를 정의하는데 사용됩니다. 이 함수는 클래스의 인스턴스가 인스턴스 메서드 내부에서 만들어져야 할 때마다 생성자 대신 사용하는 생성자입니다. 아래의 Built-in 타입은 Symbol.species가 정의되어 있습니다. Array ArrayBuffer (Chapter 10에서 논의 합니다.) Map Promise RegExp Set Typed Array (Chapter 10에서 논의 합니다.) 이 각각의 타입은 this를 반환하는 디폴트 Symbol.species 프로퍼티를 가지고 있습니다. 이것은 프로퍼티가 항상 생성자 함수를 반환한다는 것을 의미합니다. 커스텀 클래스에서 이 기능을 구현한다면 코드는 다음과 같이 보일 것입니다. 1234567891011121314// 몇몇 builtin 타입은 이와 유사한 방법을 사용합니다.class MyClass &#123; static get [Symbol.species]() &#123; return this; &#125; constructor(value) &#123; this.value = value; &#125; clone() &#123; return new this.constructor[Symbol.species](this.value); &#125;&#125; 이 예제에서 잘 알려진 Symbol.species Symbol은 MyClass에 정적 접근자 프로퍼티를 할당하는데 사용됩니다. 클래스의 타입 변경은 불가능하므로 setter가 없는 getter만 있습니다. this.constructor [Symbol.species]를 호출하면 MyClass가 리턴됩니다. clone() 메서드는 직접 MyClass를 사용하지 않고 클래스 정의(Class Definition)를 사용하여 새로운 인스턴스를 반환합니다. 그리고 파생 클래스가 그 값을 오버라이드(override) 할 수 있습니다. 123456789101112131415161718192021222324252627282930313233class MyClass &#123; static get [Symbol.species]() &#123; return this; &#125; constructor(value) &#123; this.value = value; &#125; clone() &#123; return new this.constructor[Symbol.species](this.value); &#125;&#125;class MyDerivedClass1 extends MyClass &#123; // empty&#125;class MyDerivedClass2 extends MyClass &#123; static get [Symbol.species]() &#123; return MyClass; &#125;&#125;let instance1 = new MyDerivedClass1(\"foo\"), clone1 = instance1.clone(), instance2 = new MyDerivedClass2(\"bar\"), clone2 = instance2.clone();console.log(clone1 instanceof MyClass); // trueconsole.log(clone1 instanceof MyDerivedClass1); // trueconsole.log(clone2 instanceof MyClass); // trueconsole.log(clone2 instanceof MyDerivedClass2); // false 여기에서 MyDerivedClass1은 MyClass를 상속 받고 Symbol.species 프로퍼티는 변경하지 않습니다. clone()이 호출되면, this.constructor [Symbol.species]가 MyDerivedClass1을 리턴하기 때문에 MyDerivedClass1의 인스턴스를 리턴합니다. MyDerivedClass2 클래스는 MyClass를 상속 받아 Symbol.species를 오버라이드하여 MyClass를 반환합니다. MyDerivedClass2의 인스턴스에서 clone()이 호출될 때, 반환 값은 MyClass의 인스턴스입니다. Symbol.species를 사용하여 파생 클래스는 메서드가 인스턴스를 리턴할 때 리턴되어야 하는 값의 타입을 판별할 수 있습니다. 예를 들어 Array는 Symbol.species를 사용하여 배열을 반환하는 메서드에 사용할 클래스를 지정합니다. Array에서 파생된 클래스에서 다음과 같이 상속된 메서드에서 반환된 객체의 타입을 결정할 수 있습니다. 123456789101112class MyArray extends Array &#123; static get [Symbol.species]() &#123; return Array; &#125;&#125;let items = new MyArray(1, 2, 3, 4), subitems = items.slice(1, 3);console.log(items instanceof MyArray); // trueconsole.log(subitems instanceof Array); // trueconsole.log(subitems instanceof MyArray); // false 이 코드는 Array를 상속받은 MyArray의 Symbol.species를 오버라이드합니다. Array를 반환하는 모든 상속된 메서드는 이제MyArray 대신 Array 인스턴스를 사용합니다. 일반적으로 클래스 메서드에서 this.constructor를 사용하려고 할 때마다 Symbol.species 프로퍼티를 사용해야합니다. 이렇게하면 파생 클래스가 반환 형식을 쉽게 재정의할 수 있습니다. 또한 Symbol.species가 정의된 클래스에서 파생 클래스를 만드는 경우에도 생성자 대신 사용해야 합니다. 클래스 생성자에서 new.target 사용3 장에서는 new.target과 함수가 호출되는 방식에 따라 값이 변경되는 방법에 대해 알게되었습니다. 클래스 생성자에서 new.target을 사용하여 클래스가 호출되는 방법을 결정할 수도 있습니다. new.target은 다음 예제와 같이 클래스 생성자 함수와 같습니다. 12345678910class Rectangle &#123; constructor(length, width) &#123; console.log(new.target === Rectangle); this.length = length; this.width = width; &#125;&#125;// new.target은 Rectangle입니다.var obj = new Rectangle(3, 4); // true 출력 이 코드의 new.target은 new Rectangle(3, 4)이 호출될 때 Rectangle과 동일하다는 것을 보여줍니다. 클래스 생성자는 new가 없으면 호출될 수 없으므로 new.target 프로퍼티는 항상 클래스 생성자 내부에서 정의됩니다. 그러나 그 값이 항상 같지는 않을 수도 있습니다. 다음 코드를 살펴보겠습니다. 12345678910111213141516class Rectangle &#123; constructor(length, width) &#123; console.log(new.target === Rectangle); this.length = length; this.width = width; &#125;&#125;class Square extends Rectangle &#123; constructor(length) &#123; super(length, length) &#125;&#125;// new.target is Squarevar obj = new Square(3); // 결과는 false Square는 Rectangle 생성자를 호출하고 Rectangle 생성자가 호출될 때 new.target은 Square와 같습니다. 이는 각 생성자에게 호출되는 방식에 따라 동작을 변경할 수있는 기능을 제공하므로 중요합니다. 예를 들어, 다음과 같이 new.target을 사용하여 추상적인 기본 클래스 (직접적으로 인스턴스화할 수없는 클래스)를 생성할 수 있습니다. 123456789101112131415161718192021// abstract base classclass Shape &#123; constructor() &#123; if (new.target === Shape) &#123; throw new Error(\"This class cannot be instantiated directly.\") &#125; &#125;&#125;class Rectangle extends Shape &#123; constructor(length, width) &#123; super(); this.length = length; this.width = width; &#125;&#125;var x = new Shape(); // throws errorvar y = new Rectangle(3, 4); // no errorconsole.log(y instanceof Shape); // true 이 예제에서 Shape 클래스 생성자는 new.target이 Shape 일 때마다 에러를 던집니다. 즉, new Shape ()는 항상 에러를 던집니다. 그러나 여전히 Rectangle에서 사용하는 것처럼 Shape을 기본 클래스로 사용할 수 있습니다. super() 호출은 Shape 생성자를 실행하고 new.target은 Rectangle과 같습니다. 그래서 생성자는 오류없이 계속됩니다. new가 없으면 클래스를 호출할 수 없으므로 new.target 프로퍼티는 결코 클래스 생성자 내부에서 정의되지 않습니다. 요약ECMAScript 6 클래스는 JavaScript에서 상속을 사용하기 쉽게하기 때문에 다른 언어에서 상속에 대한 기존의 이해를 버릴 필요가 없습니다. ECMAScript 6 클래스는 ECMAScript 5의 클래식 상속 모델에 대한 Syntactic sugar로 시작하지만 실수를 줄이기위한 많은 기능을 추가합니다. ECMAScript 6 클래스는 클래스 프로토 타입에 비 정적 메서드를 정의하여 프로토 타입 상속과 함께 작동하고, 정적 메서드는 생성자 자체에서 끝납니다. 클래스의 모든 메소드는 Non-enumerable이며, 기본적으로 Non-enumerable인 Built-in 객체의 동작과 더 잘 일치하는 기능입니다. 또한 클래스 생성자는 new가 없으면 호출할 수 없으므로 실수로 클래스를 함수로 호출할 수 없습니다. 클래스 기반 상속을 사용하면 다른 클래스, 함수 또는 표현식에서 클래스를 파생시킬 수 있습니다. 이 기능을 사용하여 상속할 올바른 기준을 결정하는 함수를 호출할 수 있으므로 mixin 및 다른 여러 구성 패턴을 사용하여 새 클래스를 만들 수 있습니다. 상속은 Array와 같은 Built-in 객체를 상속하는 것이 가능합니다. 클래스 생성자에서 new.target을 사용하여 클래스가 어떻게 호출되는지에 따라 다르게 행동할 수 있습니다. 가장 보편적인 사용은 직접적으로 인스턴스화 될 때 오류를 던지지만 다른 클래스를 통해 상속을 허용하는 추상 기본 클래스를 만드는 것입니다. 전반적으로 클래스는 JavaScript에 중요한 추가 요소입니다. 보다 간결한 구문과 사용자 정의 객체 타입을 안전하고 일관된 방식으로 정의하기 위한 더 나은 기능을 제공합니다. 이 내용은 나중에 참고하기 위해 제가 공부하며 정리한 내용입니다.의역, 오역, 직역이 있을 수 있음을 알려드립니다.This post is a translation of this original article [https://leanpub.com/understandinges6/read#leanpub-auto-introducing-javascript-classes] 참고 ECMAScript 6 Block Binding ECMAScript 6 문자열과 정규 표현식 ECMAScript 6 함수 ECMAScript 6 객체의 확장된 기능 ECMAScript 6 쉬운 데이터 액세스를 위한 Destructuring ECMAScript 6 Symbol과 Symbol 프로퍼티 ECMAScript 6 Set과 Map ECMAScript 6 Iterator와 Generator ECMAScript 6 JavaScript 클래스 소개 ECMAScript 6 Array 기능 향상 ECMAScript 6 Promise와 비동기 프로그램밍 ECMAScript 6 프록시와 리플렉션 API ECMAScript 6 Module로 코드 캡슐화하기 ECMAScript 6 부록 A. 작은 변경 사항 ECMAScript 6 부록 B. ECMAScript 7(2016) 이해하기","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://infoscis.github.io/categories/JavaScript/"},{"name":"ECMAScript 2015","slug":"JavaScript/ECMAScript-2015","permalink":"http://infoscis.github.io/categories/JavaScript/ECMAScript-2015/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://infoscis.github.io/tags/JavaScript/"},{"name":"ECMAScript 2015","slug":"ECMAScript-2015","permalink":"http://infoscis.github.io/tags/ECMAScript-2015/"}]},{"title":"Angular에서 ViewChildren, ContentChildren, 그리고 QueryList 이해하기","slug":"understanding-viewchildren-contentchildren-and-querylist-in-angular","date":"2018-02-13T14:43:23.000Z","updated":"2018-02-13T15:10:21.970Z","comments":true,"path":"2018/02/13/understanding-viewchildren-contentchildren-and-querylist-in-angular/","link":"","permalink":"http://infoscis.github.io/2018/02/13/understanding-viewchildren-contentchildren-and-querylist-in-angular/","excerpt":"","text":"Angular에서 ViewChildren, ContentChildren, 그리고 QueryList 이해하기부모 Component에서 자녀에게 액세스 해야하는 경우가 있습니다. Angular로 어떻게 처리 할 수 있는지 보도록 하겠습니다. ViewChildren View DOM에서 지정된 Component 또는 Directive를 QueryList로 반환합니다. 예를 들어 간단한 alert Component를 작성해 보겠습니다. 12345678910111213@Component(&#123; selector: 'alert', template: ` &lt;h1 (click)=\"alert()\"&gt;&#123;&#123;type&#125;&#125;&lt;/h1&gt; `,&#125;)export class AlertComponent &#123; @Input() type: string = \"success\"; alert() &#123; console.log(\"alert\"); &#125;&#125; 이제 우리의 app Component에서 이 Component를 여러번 사용하고 @ViewChildren 데코레이터를 사용합시다. 123456789101112131415@Component(&#123; selector: 'my-app', template: ` &lt;alert&gt;&lt;/alert&gt; &lt;alert type=\"danger\"&gt;&lt;/alert&gt; &lt;alert type=\"info\"&gt;&lt;/alert&gt; `,&#125;)export class App &#123; @ViewChildren(AlertComponent) alerts: QueryList&lt;AlertComponent&gt; ngAfterViewInit() &#123; this.alerts.forEach(alertInstance =&gt; console.log(alertInstance)); &#125;&#125; 우리는 @ViewChildren 데코레이터를 사용하여 호스트 뷰에서 요소를 가져올 수 있습니다. @ViewChildren 데코레이터는 파라미터 타입으로 Component / Directive 타입 또는 템플릿 변수 이름을 지원합니다. 파라미터가 Component / Directive 일 경우 반환 값은 Component / Directive의 인스턴스가 됩니다. 파라미터가 템플릿 변수 이름인 경우 반환 값은 Native Element에 대한 참조가 됩니다. 12345678910111213@Component(&#123; selector: 'my-app', template: ` &lt;div #div&gt;#div is a template variable&lt;/div&gt; `,&#125;)export class App &#123; @ViewChildren(\"div\") divs: QueryList&lt;any&gt; ngAfterViewInit() &#123; this.divs.forEach(div =&gt; console.log(div)); &#125;&#125; 참고: 이 경우 하나의 요소이므로 @ViewChild 데코레이터를 사용하는 것이 더 좋습니다. read 파라미터기본적으로 @ViewChildren 데코레이터는 Component 인스턴스를 반환하지만 다른 토큰을 요청할 수 있습니다. native DOM Element 1@ViewChildren(AlertComponent, &#123; read: ElementRef &#125;) alerts: QueryList&lt;AlertComponent&gt; ViewContainerRef - 템플릿이나 Component를 동적으로 만들어야 할 때 이 토큰이 필요합니다. 1@ViewChildren(AlertComponent, &#123; read: ViewContainerRef &#125;) alerts: QueryList&lt;AlertComponent&gt; QueryList@ViewChildren의 반환 타입은 QueryList입니다. QueryList는 항목 목록을 저장하는 객체의 이름입니다. 이 객체의 특별한 점은 응용 프로그램의 상태가 변경되면 Angular가 자동으로 객체 항목을 업데이트한다는 것입니다. QueryList는 Iterable 인터페이스를 구현하므로 ngFor Directive를 사용하여 Angular 템플릿에서 사용할 수 있습니다. QueryList APIGetter first - 첫 번째 항목 가져 오기 last - 마지막 항목 가져 오기 length - 아이템 길이를 얻는다. Methodmap(), filter() , find(), reduce(), forEach(), some() toArray() - JavaScript 배열로 항목을 반환합니다. changes () - 값의 변경을 changes Observable을 구독 (subscribe)하여 인지할 수 있습니다. 하위 요소가 추가, 제거 또는 이동될 때마다 쿼리 목록이 업데이트되고 쿼리 목록의 changes Observable이 새로운 값을 emit 합니다. 기억하세요QueryList는 ngAfterViewInit 라이프 사이클 훅 전에만 초기화되며, 따라서 이 시점에만 사용할 수 있습니다. @ViewChildren vs @ContentChildren@ViewChildren은 ng-content 태그 내에 존재하는 요소를 포함하지 않습니다. @ContentChildren은 ng-content 태그 내에 존재하는 요소만 포함됩니다. @ContentChildren Content DOM에서 지정된 요소 또는 Directive를 QueryList로 반환합니다. 12345678910111213141516171819202122232425262728293031323334@Component(&#123; selector: 'tab', template: ` &lt;p&gt;&#123;&#123;title&#125;&#125;&lt;/p&gt; `,&#125;)export class TabComponent &#123; @Input() title;&#125;@Component(&#123; selector: 'tabs', template: ` &lt;ng-content&gt;&lt;/ng-content&gt; `,&#125;)export class TabsComponent &#123; @ContentChildren(TabComponent) tabs: QueryList&lt;TabComponent&gt; ngAfterContentInit() &#123; this.tabs.forEach(tabInstance =&gt; console.log(tabInstance)) &#125;&#125;@Component(&#123; selector: 'my-app', template: ` &lt;tabs&gt; &lt;tab title=\"One\"&gt;&lt;/tab&gt; &lt;tab title=\"Two\"&gt;&lt;/tab&gt; &lt;/tabs&gt; `,&#125;)export class App &#123;&#125; 기억하세요QueryList는 ngAfterContentInit 라이프 사이클 훅 전에만 초기화되며, 따라서 이 시점에서만 사용할 수 있습니다. 이 내용은 나중에 참고하기 위해 제가 공부하며 정리한 내용입니다.의역, 오역, 직역이 있을 수 있음을 알려드립니다.This post is a translation of this original article [https://netbasal.com/understanding-viewchildren-contentchildren-and-querylist-in-angular-896b0c689f6e] 참고 Angular 튜토리얼 - 소개 Angular 튜터리얼 - Hero 에디터 Angular 튜터리얼 - Master/Detail Angular 튜터리얼 - 다중 콤포넌트 Angular 튜터리얼 - 서비스 Angular 튜터리얼 - 라우팅 Angular 튜터리얼 - HTTP Angular HttpClient Angular Webpack 설정 Angular에서 간단하게 번역기능 구현하기 Angular 동적 컴포넌트 로딩 Angular에서 동적 컨텐츠 생성 Angular에서 ViewChildren, ContentChildren, 그리고 QueryList 이해하기","categories":[{"name":"Angular","slug":"Angular","permalink":"http://infoscis.github.io/categories/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://infoscis.github.io/tags/Angular/"}]},{"title":"Angular에서 동적 컨텐츠 생성","slug":"dynamic-content-in-angular","date":"2018-02-13T14:42:55.000Z","updated":"2018-02-13T15:10:29.661Z","comments":true,"path":"2018/02/13/dynamic-content-in-angular/","link":"","permalink":"http://infoscis.github.io/2018/02/13/dynamic-content-in-angular/","excerpt":"","text":"Angular에서 동적 컨텐츠 생성이 글에서 Angular로 동적 컨텐츠를 만드는 몇가지 방법을 보여 드리겠습니다. 사용자 지정 리스트 템플릿, 동적 Component 생성, 런타임 Component 및 모듈 컴파일의 예제를 보여줍니다. 전체 소스 코드는 이 글의 끝부분에서 보실수 있습니다. 제가 작업하고 있는 Developing with Angular에서 Angular 개발에 대한 더 많은 정보를 얻을 수 있습니다. List item templates사용자 정의 템플릿을 제공하여 Angular Component를 풍성하게 만드는 방법을 살펴 보겠습니다. 개발자가 선언한 외부 Row(행) 템플릿을 지원하는 간단한 리스트 Component를 작성하며 시작하겠습니다. List component먼저 바인딩된 항목 컬렉션을 표시하는 간단한 리스트 Component를 만듭니다. 12345678910111213141516@Component(&#123; selector: 'tlist', template: ` &lt;ul&gt; &lt;li *ngFor=\"let item of items\"&gt; &#123;&#123; item.title &#125;&#125; &lt;/li&gt; &lt;/ul&gt; `&#125;)export class TListComponent &#123; @Input() items: any[] = [];&#125; 이제 메인 응용 프로그램 Component를 업데이트 하거나 다음 예제와 같이 별도의 데모 Component를 만듭니다. 12345678910111213141516@Component(&#123; selector: 'tlist-demo', template: ` &lt;h1&gt;Templated list&lt;/h1&gt; &lt;tlist [items]=\"items\"&gt;&lt;/tlist&gt; `&#125;)export class AppComponent &#123; items: any[] = [ &#123; title: 'Item 1' &#125;, &#123; title: 'Item 2' &#125;, &#123; title: 'Item 3' &#125; ];&#125; 그러면 다음과 같이 정렬되지 않은 HTML 목록이 렌더링됩니다. Row templates우리는 객체의 배열에 바인딩하고 정렬되지 않은 표준 HTML리스트를 렌더링하는 간단한 리스트 컴포넌트를 만들었습니다. 그리고 모든 리스트 항목은 title 프로퍼티 값에 바인딩됩니다. 이제 외부 템플릿을 지원하도록 코드를 변경해 보겠습니다. 아래 그림과 같이 코드를 업데이트 합니다. 1234567891011121314151617181920import &#123; Component, Input, ContentChild, TemplateRef &#125; from '@angular/core';@Component(&#123; selector: 'tlist', template: ` &lt;ul&gt; &lt;template ngFor [ngForOf]=\"items\" [ngForTemplate]=\"template\"&gt; &lt;/template&gt; &lt;/ul&gt; `&#125;)export class TListComponent &#123; @ContentChild(TemplateRef) template: TemplateRef&lt;any&gt;; @Input() items: any[] = [];&#125; 이제 TListComponent는 자식 컨텐츠에서 정의될 템플릿을 참조합니다. 그리고 템플릿 내용을 받아 각 *ngFor 항목에 적용합니다. 따라서 이 Component를 사용하는 응용 프로그램 개발자는 다음과 같이 전체 Row 템플릿을 정의할 수 있습니다. 1234567&lt;tlist [items]=\"items\"&gt; &lt;template&gt; &lt;li&gt; Row template content &lt;/li&gt; &lt;/template&gt;&lt;/tlist&gt; 이제 아래 예제와 같이 업데이트합니다. 12345678910111213141516171819202122import &#123; Component &#125; from '@angular/core';@Component(&#123; selector: 'tlist-demo', template: ` &lt;div&gt; &lt;h2&gt;Templated list&lt;/h2&gt; &lt;tlist [items]=\"items\"&gt; &lt;template let-item=\"$implicit\" let-i=\"index\"&gt; &lt;li&gt;[&#123;&#123;i&#125;&#125;] Hello: &#123;&#123;item.title&#125;&#125;&lt;/li&gt; &lt;/template&gt; &lt;/tlist&gt; &lt;/div&gt; `&#125;)export class TListComponentDemo &#123; items: any[] = [ &#123; title: 'Item 1' &#125;, &#123; title: 'Item 2' &#125;, &#123; title: 'Item 3' &#125; ];&#125; 각 Row에 대한 기본 데이터 바인딩 컨텍스트에 액세스하기 위해 let-item = &quot;$implicit&quot; 프로퍼티를 사용하여 item 변수에 매핑합니다. 따라서 item은 TListComponentDemo의 items 컬렉션에 있는 항목을 가리키며 title 프로퍼티에 바인딩할 수 있습니다. 또한 let-i = &quot;index&quot;를 통해 i 변수에 Row 인덱스 프로퍼티 값을 할당합니다. 또 다른 개선점은 TListComponent가 더 이상 모든 바인딩된 객체가 title 프로퍼티를 갖도록 강요하지 않는다는 것입니다. 이제 템플릿과 기본 컨텍스트가 모두 응용 프로그램 수준에서 정의됩니다. 변경 사항이 렌더링된 결과는 다음과 같습니다. 동적 Component또 다른 일반적인 시나리오는 일부 조건에 따라 Component의 내용을 변경하는 것입니다. 예를 들어 아래와 같이 type 프로퍼티 값을 기반으로 다른 하위 Component를 렌더링하는 경우입니다. 12&lt;component type=\"my-type-1\"&gt;&lt;/component&gt;&lt;component type=\"my-type-2\"&gt;&lt;/component&gt; 기본 Component 구조부터 살펴 보겠습니다. 1234567891011121314151617@Component(&#123; selector: 'dynamic-content', template: ` &lt;div&gt; &lt;div #container&gt;&lt;/div&gt; &lt;/div&gt; `&#125;)export class DynamicContentComponent &#123; @ViewChild('container', &#123; read: ViewContainerRef &#125;) container: ViewContainerRef; @Input() type: string;&#125; container 사용법에 유의하십시오. 주입 지점으로 사용되며, 모든 동적 컨텐츠가 이 요소 아래의 DOM에 삽입됩니다. 또한 ViewContainerRef 유형의 프로퍼티를 사용하면 코드에서 container에 액세스할 수 있습니다. 이 Component는 나중에 다음과 같이 사용할 수 있습니다. 1&lt;dynamic-content type=\"some-value\"&gt;&lt;/dynamic-type&gt; 이제 “type” 값을 기반으로 표시할 두 가지 간단한 Component와 추가적으로 “unknown” 타입에 대한 하나의 대체 Component를 소개합니다. 1234567891011121314151617@Component(&#123; selector: 'dynamic-sample-1', template: `&lt;div&gt;Dynamic sample 1&lt;/div&gt;`&#125;)export class DynamicSample1Component &#123;&#125;@Component(&#123; selector: 'dynamic-sample-2', template: `&lt;div&gt;Dynamic sample 2&lt;/div&gt;`&#125;)export class DynamicSample2Component &#123;&#125;@Component(&#123; selector: 'unknown-component', template: `&lt;div&gt;Unknown component&lt;/div&gt;`&#125;)export class UnknownDynamicComponent &#123;&#125; 또한 해당 문자열을 Component로 변환할 수 있도록 “string” - “type” 매핑이 필요합니다. 별도의 Injectable 서비스 (권장) 또는 Component 구현의 일부일 수 있습니다. 12345678private mappings = &#123; 'sample1': DynamicSample1Component, 'sample2': DynamicSample2Component&#125;;getComponentType(typeName: string) &#123; let type = this.mappings[typeName]; return type || UnknownDynamicComponent;&#125; 그리고 type 이름이 없을 경우 UnknownDynamicComponent가 자동으로 반환됩니다. 이제 Component를 동적으로 만들 준비가 되었습니다. 다음은 동적 Component 생성에 관심이 있는 주요 블록이 있는 Component의 단순 버전입니다. 123456789101112131415161718192021222324export class DynamicContentComponent implements OnInit, OnDestroy &#123; private componentRef: ComponentRef&lt;&#123;&#125;&gt;; constructor( private componentFactoryResolver: ComponentFactoryResolver) &#123; &#125; ngOnInit() &#123; if (this.type) &#123; let componentType = this.getComponentType(this.type); let factory = this.componentFactoryResolver.resolveComponentFactory(componentType); this.componentRef = this.container.createComponent(factory); &#125; &#125; ngOnDestroy() &#123; if (this.componentRef) &#123; this.componentRef.destroy(); this.componentRef = null; &#125; &#125;&#125; 동적으로 생성하려는 모든 Component는 모듈의 entryComponents 섹션에 등록해야합니다. 1234567891011@NgModule(&#123; imports: [...], declarations: [...], entryComponents: [ DynamicSample1Component, DynamicSample2Component, UnknownDynamicComponent ], bootstrap: [ AppComponent ]&#125;)export class AppModule &#123; &#125; 이제 세 가지 모든 경우를 테스트 할 수 있습니다. 123&lt;dynamic-content type=\"sample1\"&gt;&lt;/dynamic-content&gt;&lt;dynamic-content type=\"sample2\"&gt;&lt;/dynamic-content&gt;&lt;dynamic-content type=\"some-other-type\"&gt;&lt;/dynamic-content&gt; 아마도 대부분의 경우 새로 작성된 하위 Component에 런타임 컨텍스트를 전달하려고 할 것입니다. 서로 다른 타입의 동적 Component를 유지하는 가장 쉬운 방법은 공통 인터페이스 또는 추상 클래스를 작성하는 것입니다. 123abstract class DynamicComponent &#123; context: any;&#125; 간단히 하기 위해, context에 any 타입을 사용했습니다. 실제 시나리오에서는 정적 검사의 이점을 얻기위해 타입을 선언할 수 있습니다. context를 고려하여 이전에 생성된 모든 Component를 업데이트 할 수 있습니다. 123456789101112131415161718192021export abstract class DynamicComponent &#123; context: any;&#125;@Component(&#123; selector: 'dynamic-sample-1', template: `&lt;div&gt;Dynamic sample 1 (&#123;&#123;context?.text&#125;&#125;)&lt;/div&gt;`&#125;)export class DynamicSample1Component extends DynamicComponent &#123;&#125;@Component(&#123; selector: 'dynamic-sample-2', template: `&lt;div&gt;Dynamic sample 2 (&#123;&#123;context?.text&#125;&#125;)&lt;/div&gt;`&#125;)export class DynamicSample2Component extends DynamicComponent &#123;&#125;@Component(&#123; selector: 'unknown-component', template: `&lt;div&gt;Unknown component (&#123;&#123;context?.text&#125;&#125;)&lt;/div&gt;`&#125;)export class UnknownDynamicComponent extends DynamicComponent &#123;&#125; 그리고 동적 Component도 업데이트 해야합니다. 123456789101112131415export class DynamicContentComponent implements OnInit, OnDestroy &#123; ... @Input() context: any; ... ngOnInit() &#123; if (this.type) &#123; ... let instance = &lt;DynamicComponent&gt; this.componentRef.instance; instance.context = this.context; &#125; &#125;&#125; 위의 변경 사항으로 이제 부모 Component 내에서 context 객체를 바인딩 할 수 있습니다. 다음은 간단한 데모입니다. 12345678910111213141516171819@Component(&#123; selector: 'dynamic-component-demo', template: ` &lt;div&gt; &lt;h2&gt;Dynamic content&lt;/h2&gt; &lt;h3&gt;Context: &lt;input type=\"text\" [(ngModel)]=\"context.text\"&gt;&lt;/h3&gt; &lt;dynamic-content type=\"sample1\" [context]=\"context\"&gt;&lt;/dynamic-content&gt; &lt;dynamic-content type=\"sample2\" [context]=\"context\"&gt;&lt;/dynamic-content&gt; &lt;dynamic-content type=\"some-other-type\" [context]=\"context\"&gt;&lt;/dynamic-content&gt; &lt;/div&gt; `&#125;)export class DynamicContentComponentDemo &#123; context: any = &#123; text: 'test' &#125;&#125; 런타임에는 세 가지 Component(Fallback된 UnknownDynamicComponent 포함)를 볼 수 있어야합니다. Context 입력란의 텍스트를 변경하면 모든 위젯이 자동으로 업데이트됩니다. 일반적인 사용 사례정의 파일 (JSON, XML 등)을 기반으로 Form(또는 복합 Component)을 표시해야하는 경우 스키마 또는 상태를 기반으로 최종 컨텐츠를 빌드하는 동적 Component와 여러 동적 컨텐츠 컨테이너에서 빌드된 Form Component를 갖게 될 수 있습니다. 런타임 컴파일일부 고급 시나리오의 경우 Angular Component 또는 템플릿 편집을 완전히 제어 할 필요가 있을 수 있습니다. 이 장에서는 다음 기능을 구현합니다. 사용자에게 Component 템플릿을 정의하도록 합니다. Component를 즉석에서 컴파일(사용자 정의 템플릿 + 클래스)합니다. 컴포넌트를 생성하면서 NgModule을 즉시 컴파일합니다. 새로 생성된 Component 표시합니다. 구현은 이전 장의 동적 Component를 기반으로 합니다. 그리고 콘텐츠를 삽입하기위한 전용 자리 표시자가있는 기본 Component가 필요합니다. 1234567891011121314@Component(&#123; selector: 'runtime-content', template: ` &lt;div&gt; &lt;div #container&gt;&lt;/div&gt; &lt;/div&gt; `&#125;)export class RuntimeContentComponent &#123; @ViewChild('container', &#123; read: ViewContainerRef &#125;) container: ViewContainerRef;&#125; 사용자가 Component 템플릿을 편집 할 수 있도록 기본 UI를 수정합니다. 1234567891011121314151617181920@Component(&#123; selector: 'runtime-content', template: ` &lt;div&gt; &lt;h3&gt;Template&lt;/h3&gt; &lt;div&gt; &lt;textarea rows=\"5\" [(ngModel)]=\"template\"&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;button (click)=\"compileTemplate()\"&gt;Compile&lt;/button&gt; &lt;h3&gt;Output&lt;/h3&gt; &lt;div #container&gt;&lt;/div&gt; &lt;/div&gt; `&#125;)export class RuntimeContentComponent &#123; template: string = '&lt;div&gt;\\nHello, &#123;&#123;name&#125;&#125;\\n&lt;/div&gt;'; // ...&#125; ngModel을 사용하려면 AppModule 내에서 FormsModule을 가져 와서 참조해야합니다. 123456789import &#123; NgModule &#125; from '@angular/core';import &#123; BrowserModule &#125; from '@angular/platform-browser';import &#123; FormsModule &#125; from '@angular/forms';@NgModule(&#123; imports: [BrowserModule, FormsModule], declarations: [...], bootstrap: [ AppComponent ]&#125;)export class AppModule &#123; &#125; 렌더링될 때 다음과 같이 보일 것입니다. 이제 Component 구현의 가장 중요한 부분인 런타임 컴파일입니다. 1234567891011121314export class RuntimeContentComponent &#123; private createComponentFactorySync(compiler: Compiler, metadata: Component, componentClass: any): ComponentFactory&lt;any&gt; &#123; const cmpClass = componentClass || class RuntimeComponent &#123; name: string = 'Denys' &#125;; const decoratedCmp = Component(metadata)(cmpClass); @NgModule(&#123; imports: [CommonModule], declarations: [decoratedCmp] &#125;) class RuntimeComponentModule &#123; &#125; let module: ModuleWithComponentFactories&lt;any&gt; = compiler.compileModuleAndAllComponentsSync(RuntimeComponentModule); return module.componentFactories.find(f =&gt; f.componentType === decoratedCmp); &#125;&#125; 위 코드는 사용자 지정 메타 데이터와 선택적으로 Component 클래스를 받습니다. 클래스가 제공되어 있지 않은 경우, 대신 RuntimeComponent를 미리 정의된 name 프로퍼티와 함께 사용됩니다. 이것은 우리가 테스트를 위해 사용할 것입니다. 그런 다음 결과 Component는 제공된 메타 데이터로 장식(Decorate)됩니다. 다음으로, RuntimeComponentModule 모듈은 미리 정의된 CommonModule을 import(필요한 경우 목록을 확장 할 수 있음)하고, declarations 섹션의 일부로 이전에 생성되어 장식(Decorate)된 Component로 만들어집니다. 마지막으로 이 함수는 Angular의 Compiler 서비스를 사용하여 모듈과 포함된 Component를 컴파일합니다. 컴파일된 모듈은 기본 Component 팩토리에 대한 액세스를 제공하며 이는 정확히 우리가 필요로하는 것입니다. 마지막 단계에서는 다음 코드로 Compile 버튼을 연결합니다. 12345678910111213141516171819export class RuntimeContentComponent &#123; compileTemplate() &#123; let metadata = &#123; selector: `runtime-component-sample`, template: this.template &#125;; let factory = this.createComponentFactorySync(this.compiler, metadata, null); if (this.componentRef) &#123; this.componentRef.destroy(); this.componentRef = null; &#125; this.componentRef = this.container.createComponent(factory); &#125;&#125; 사용자가 Compile 버튼을 클릭할 때 마다 템플릿을 가져 와서 (RuntimeComponent 클래스가 미리 정의된 name 프로퍼티를 사용하여) 새 Component를 컴파일하고 렌더링합니다. 어디에서든 Component 템플릿을 저장하고 즉시 Component를 생성하려는 경우 가장 좋은 옵션입니다. 소스코드이 GitHub 저장소에서 모든 소스 코드와 실제 예제 프로젝트를 얻을 수 있습니다. 이 내용은 나중에 참고하기 위해 제가 공부하며 정리한 내용입니다.의역, 오역, 직역이 있을 수 있음을 알려드립니다.This post is a translation of this original article [https://denysvuika.blog/2017/10/07/dynamic-content-in-angular/] 참고 Angular 튜토리얼 - 소개 Angular 튜터리얼 - Hero 에디터 Angular 튜터리얼 - Master/Detail Angular 튜터리얼 - 다중 콤포넌트 Angular 튜터리얼 - 서비스 Angular 튜터리얼 - 라우팅 Angular 튜터리얼 - HTTP Angular HttpClient Angular Webpack 설정 Angular에서 간단하게 번역기능 구현하기 Angular 동적 컴포넌트 로딩 Angular에서 동적 컨텐츠 생성 Angular에서 ViewChildren, ContentChildren, 그리고 QueryList 이해하기","categories":[{"name":"Angular","slug":"Angular","permalink":"http://infoscis.github.io/categories/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://infoscis.github.io/tags/Angular/"}]},{"title":"ECMAScript 6 Iterator와 Generator","slug":"ecmascript-6-iterators-and-generators","date":"2018-01-31T14:24:43.000Z","updated":"2018-02-27T14:12:31.782Z","comments":true,"path":"2018/01/31/ecmascript-6-iterators-and-generators/","link":"","permalink":"http://infoscis.github.io/2018/01/31/ecmascript-6-iterators-and-generators/","excerpt":"","text":"Iterator와 Generator많은 프로그래밍 언어는 컬렉션에서 위치를 추적하기 위해 변수가 필요한 for 루프를 사용하여 데이터를 반복하는 것에서 컬렉션의 다음 항목을 반환하는 Interator 객체를 사용하는 방식으로 전환했습니다. Iterator를 사용하면 데이터 컬렉션을 쉽게 처리할 수 있어 ECMAScript 6에서는 Iterator를 JavaScript에 추가했습니다. Iterator는 새로운 Array 메서드 및 새로운 타입의 컬렉션 (Set 및 Map)과 결합하여 데이터를 효율적으로 처리할수 있는 핵심 요소이며, 이러한 부분은 JavaScript의 여러곳에서 찾아볼 수 있습니다. 또한 Iterator와 함께 작동하는 새로운 for-of 루프가 있으며, Spread (...) 연산자에서도 Iterator를 사용할 수 있습니다. 그리고 Iterator는 비동기 프로그래밍을 더 쉽게 만들수 있게 합니다. 이 장에서는 Iterator의 많은 용도에 대해 다루지만, 먼저 Iterator가 JavaScript에 추가된 이유에 대한 역사를 이해하는 것이 중요합니다. 루프(Loop) 문제점JavaScript로 프로그래밍한 적이 있다면 아마도 다음 코드가 익숙할 것입니다. 12345var colors = [\"red\", \"green\", \"blue\"];for (var i = 0, len = colors.length; i &lt; len; i++) &#123; console.log(colors[i]);&#125; 이 표준 for 루프는 인덱스를 colors Array에 대해 i 변수로 추적합니다. i의 값은 i가 (len에 저장된) Array의 길이보다 크지 않다면 루프가 실행될 때마다 증가합니다. 이 예제의 루프는 매우 간단하지만 루프를 중첩하여 여러 변수를 추적해야 할 때 매우 복잡해집니다. 추가적인 복잡성으로 인해 오류가 발생할 수 있으며, for 루프의 상용구는 유사한 코드가 여러 위치에 작성되어 더 많은 오류를 발생시킬 수 있습니다. Iterator는 이 문제를 해결하기 위한 것입니다. Iterator는 무엇일까요?Iterator는 반복을 위해 설계된 특정 인터페이스가 있는 객체입니다. 모든 Iterator 객체는 결과 객체를 반환하는 next() 메서드를 가지고 있습니다. 결과 객체에는 두 가지 프로퍼티, 즉 다음 값인 value와 반환할 값이 더 이상 없을 때 true 인 부울 값인 done 프로퍼티입니다. Iterator는 값 컬렉션 내의 위치에 대한 내부 포인터를 유지하고 next() 메서드를 호출할 때마다 다음 적절한 값을 반환합니다. 마지막 값이 반환된 후에 next()를 호출하면 메서드는 done을 true로 리턴하고 value는 Iterator의 리턴 값을 포함합니다. 이 리턴 값은 데이터의 일부가 아니며 관련 데이터의 마지막 부분이거나 그러한 데이터가 없으면 undefined입니다. Iterator의 리턴 값은 정보를 호출자에게 전달하는 마지막 방법이라는 점에서 함수의 리턴 값과 유사합니다. 이를 염두에 두고 ECMAScript 5에서 Iterator를 만드는 것은 아래와 같이 간단합니다. 12345678910111213141516171819202122232425262728function createIterator(items) &#123; var i = 0; return &#123; next: function() &#123; var done = (i &gt;= items.length); var value = !done ? items[i++] : undefined; return &#123; done: done, value: value &#125;; &#125; &#125;;&#125;var iterator = createIterator([1, 2, 3]);console.log(iterator.next()); // \"&#123; value: 1, done: false &#125;\"console.log(iterator.next()); // \"&#123; value: 2, done: false &#125;\"console.log(iterator.next()); // \"&#123; value: 3, done: false &#125;\"console.log(iterator.next()); // \"&#123; value: undefined, done: true &#125;\"// for all further callsconsole.log(iterator.next()); // \"&#123; value: undefined, done: true &#125;\" createIterator() 함수는 next() 메서드를 가진 객체를 반환합니다. 메서드가 호출될 때마다 items Array의 다음 값은 value로 리턴됩니다. i가 3 일 때 done은 true가 되고 value를 설정하는 삼항 조건 연산자는 undefined로 평가됩니다. 이 결과는 ECMAScript 6에서는 마지막 데이터가 사용된 후 next()가 호출될 때와 같은 특수한 역할을 합니다. 이 예제에서 보듯이, ECMAScript 6에 규정된 규칙에 따라 동작하는 Iterator 작성은 약간 복잡합니다. 다행히도 ECMAScript 6은 Iterator 생성자를 제공하여 Iterator 객체를 훨씬 쉽게 만들 수 있습니다. Generator는 무엇일까요?Generator는 Iterator를 반환하는 함수입니다. Generator 함수는 function 키워드 다음에 별표 (*)가 추가되고 새로운 yield 키워드를 사용합니다. 별표가 function 바로 앞에 있는지 또는 *와 function 사이에 공백이 있는지는 중요하지 않습니다. 아래 예제를 보겠습니다. 12345678910111213// generatorfunction *createIterator() &#123; yield 1; yield 2; yield 3;&#125;// generator는 일반 함수처럼 호출되지만 iterator를 반환합니다.let iterator = createIterator();console.log(iterator.next().value); // 1console.log(iterator.next().value); // 2console.log(iterator.next().value); // 3 createIterator() 이전의 *는 함수를 Generator로 만듭니다. ECMAScript 6에 새로 도입된 yield 키워드는 next()가 호출될 때 결과 Iterator가 리턴 해야하는 값을 리턴될 순서대로 지정합니다. 이 예제에서 생성된 Iterator는 next() 메서드를 연속적으로 호출할 때 세가지 다른 값을 리턴합니다. : 1, 2 그리고 마지막으로 3. Generator는 iterator를 생성할 때 본 것처럼 다른 함수와 똑같이 호출할 수 있습니다. 아마도 Generator 함수 중 가장 흥미로운 부분은 각 yield 문 다음에 실행을 멈추는 것입니다. 예를 들어, 이 코드에서 yield 1을 실행 한 후에, 함수는 Iterator의 next() 메서드가 호출될 때까지 다른 것을 실행하지 않고, next()가 호출 되는 시점에 yield 2가 실행됩니다. 함수 중간에 실행을 중지하는 이 기능은 매우 강력하며 Generator 함수의 사용을 흥미롭게 합니다. (“Iterator의 고급기능”섹션에서 논의 함). yield 키워드는 모든 값이나 표현식과 함께 사용할 수 있으므로 항목을 하나씩 나열하지 않고 Iterator에 항목을 추가하는 Generator 함수를 작성할 수 있습니다. 예를 들어, for 루프에서 yield를 사용할 수있는 방법은 다음과 같습니다. 123456789101112131415function *createIterator(items) &#123; for (let i = 0; i &lt; items.length; i++) &#123; yield items[i]; &#125;&#125;let iterator = createIterator([1, 2, 3]);console.log(iterator.next()); // \"&#123; value: 1, done: false &#125;\"console.log(iterator.next()); // \"&#123; value: 2, done: false &#125;\"console.log(iterator.next()); // \"&#123; value: 3, done: false &#125;\"console.log(iterator.next()); // \"&#123; value: undefined, done: true &#125;\"// for all further callsconsole.log(iterator.next()); // \"&#123; value: undefined, done: true &#125;\" 이 예제는 items라는 Array를 createIterator() Generator 함수에 전달합니다. 함수 내에서 for 루프가 진행됨에 따라 Array에서 Iterator 요소를 생성합니다. yield가 발생할 때마다 루프가 멈추고 iterator의 next()가 호출될 때마다 루프의 다음 yield 문이 실행 됩니다. Generator는 ECMAScript 6의 중요한 기능이며, 함수이기 때문에 모든 곳에서 사용할 수 있습니다. 이 섹션의 나머지 부분에서는 Generator를 작성하는 다른 유용한 방법에 중점을 둡니다. yield 키워드는 Generator 내부에서만 사용할 수 있습니다. 예를 들면 다음과 같이 Generator 내부 함수에서 사용하는 것을 포함하여 다른 곳에서 yield를 사용하는 것은 구문 오류입니다. 12345678function *createIterator(items) &#123; items.forEach(function(item) &#123; // syntax error yield item + 1; &#125;);&#125; yield는 기술적으로 createIterator() 내부에 있지만, yield는 함수의 경계를 넘을 수 없으므로 이 코드는 구문 오류입니다. yield가 return과 비슷한 방식으로 사용되었지만 중첩된 함수는 그 함수를 포함하는 값을 리턴할 수 없습니다. Generator 함수 표현식함수 표현식을 사용하여 function 키워드와 여는 괄호 사이에 별표 (*) 문자를 포함시킴으로써 Generator를 생성할 수 있습니다. 123456789101112131415let createIterator = function *(items) &#123; for (let i = 0; i &lt; items.length; i++) &#123; yield items[i]; &#125;&#125;;let iterator = createIterator([1, 2, 3]);console.log(iterator.next()); // \"&#123; value: 1, done: false &#125;\"console.log(iterator.next()); // \"&#123; value: 2, done: false &#125;\"console.log(iterator.next()); // \"&#123; value: 3, done: false &#125;\"console.log(iterator.next()); // \"&#123; value: undefined, done: true &#125;\"// for all further callsconsole.log(iterator.next()); // \"&#123; value: undefined, done: true &#125;\" 이 코드에서, createIterator()는 함수 선언 대신에 Generator 함수 표현식입니다. 함수 표현식이 익명이므로 별표는 function 키워드와 여는 괄호 사이에 옵니다. 그 외에 이 예제는 for 루프를 사용했던 createIterator() 함수의 이전 버전과 동일합니다. Arrow 함수를 이용해 Generator를 만들수 없습니다. Generator 객체 메서드Generator는 함수이기 때문에 객체에도 추가할 수 있습니다. 예를 들어, 함수 표현식을 사용하여 ECMAScript 5 스타일 객체 리터럴에서 Generator를 만들 수 있습니다. 12345678910var o = &#123; createIterator: function *(items) &#123; for (let i = 0; i &lt; items.length; i++) &#123; yield items[i]; &#125; &#125;&#125;;let iterator = o.createIterator([1, 2, 3]); 메서드 이름 앞에 별표(*)를 붙임으로써 ECMAScript 6 단축 메서드를 바로 사용할 수도 있습니다. 12345678910var o = &#123; *createIterator(items) &#123; for (let i = 0; i &lt; items.length; i++) &#123; yield items[i]; &#125; &#125;&#125;;let iterator = o.createIterator([1, 2, 3]); 이 예제는 “Generator 함수 표현식” 섹션의 예제와 기능적으로 동일합니다. 단지 다른 구문을 사용했을 뿐입니다. 단축 버전에서는 createIterator() 메서드가 function 키워드 없이 정의되었고 별표와 메서드 이름 사이에 공백을 둘 수 있지만 별표는 메서드 이름 바로 앞에 위치해야 합니다. Iterables 과 for-ofIterator와 밀접하게 관련된 Iterable 은 Symbol.iterator 프로퍼티를 가진 객체입니다. 잘 알려진 Symbol.iterator Symbol은 주어진 객체에 대한 Iterator를 반환하는 함수를 지정합니다. ECMAScript 6에서는 모든 컬렉션 객체 (Array, Set 및 Map) 및 문자열이 Iterable이므로 기본 Iterator가 지정되어 있습니다. Iterable은 ECMAScript에 새로 추가된 for-of 루프와 함께 사용하도록 설계되었습니다. Generator가 기본적으로 Symbol.iterator 프로퍼티를 할당하므로 Generator가 만든 모든 Iterator도 Iterable입니다. 이 장의 시작 부분에서, for 루프 내에서 인덱스를 추적하는 문제에 대해 언급했습니다. 이 문제를 해결하는 첫 번째는 Iterator입니다. 그리고 두 번째는 for-of 루프입니다. 컬렉션에 대한 인덱스를 추적할 필요가 없기 때문에 컬렉션의 내용에 대한 작업에 집중할 수 있습니다. for-of 루프는 루프가 실행될 때마다 Iterable에서 next()를 호출하고 결과 객체의 value를 변수에 저장합니다. 루프는 반환된 객체의 done 프로퍼티 값이 true가 될 때까지 이 과정을 계속합니다. 다음은 그 예제를 살펴 보겠습니다. 12345let values = [1, 2, 3];for (let num of values) &#123; console.log(num);&#125; 이 코드는 다음을 출력합니다. 123123 이 for-of 루프는 values Array에 Symbol.iterator 메서드를 먼저 호출하여 Iterator를 검색합니다. (Symbol.iterator에 대한 호출은 JavaScript 엔진 자체에서 발생합니다.) 그러면 iterator.next()가 호출되고 Iterator의 결과 객체에있는 value 프로퍼티가 num으로 읽혀집니다. num 변수는 1, 2, 그리고 마지막으로 3입니다. 결과 객체에서 done이 true 일 때, 루프는 끝나기 때문에 num은 결코 undefined의 값으로 지정되지 않습니다. 단순히 Array이나 컬렉션의 값을 반복한다면 for 루프 대신에 for-of 루프를 사용하는 것이 좋습니다. for-of 루프는 일반적으로 추적하기 위한 조건이 적기 때문에 에러 발생이 전통적인 for 루프보다 적습니다. 보다 복잡한 제어 조건이 필요한 경우 전통적인for 루프를 사용 하십시오. for-of 문은 Non-iterable 객체, null 또는 undefined에서 사용될 때 에러를 던집니다. Default Iterator 액세스 하기Symbol.iterator를 사용하여 다음과 같이 객체의 Default Iterator를 액세스할 수 있습니다. 1234567let values = [1, 2, 3];let iterator = values[Symbol.iterator]();console.log(iterator.next()); // \"&#123; value: 1, done: false &#125;\"console.log(iterator.next()); // \"&#123; value: 2, done: false &#125;\"console.log(iterator.next()); // \"&#123; value: 3, done: false &#125;\"console.log(iterator.next()); // \"&#123; value: undefined, done: true &#125;\" 이 코드는 values에 대한 Default Iterator를 가져오고 이를 사용하여 Array의 각항목을 반복합니다. 이것은 for-of 루프를 사용할 때 배후에서 일어나는 것과 같은 방식입니다. Symbol.iterator는 Default Iterator를 지정하므로 이를 사용하여 객체가 다음과 같이 반복 가능한지 여부를 확인할 수 있습니다. 12345678910function isIterable(object) &#123; return typeof object[Symbol.iterator] === \"function\";&#125;console.log(isIterable([1, 2, 3])); // trueconsole.log(isIterable(\"Hello\")); // trueconsole.log(isIterable(new Map())); // trueconsole.log(isIterable(new Set())); // trueconsole.log(isIterable(new WeakMap())); // falseconsole.log(isIterable(new WeakSet())); // false isIterable() 함수는 객체에 Default Iterator가 존재 하는지를 확인하는 함수입니다. for-of 루프는 실행 전에 비슷한 검사를 수행합니다. 지금까지 이 섹션의 예제에서는 내장 Iterable이 있는 Symbol.iterator를 사용하는 방법을 알아 봤지만 Symbol.iterator 프로퍼티를 사용하여 고유한 Iterable을 만들수도 있습니다. Iterable 만들기개발자가 정의한 객체는 기본적으로 반복 가능하지 않지만 Generator가 포함된 Symbol.iterator 프로퍼티를 만들어 반복 가능하게 만들 수 있습니다. 1234567891011121314151617let collection = &#123; items: [], *[Symbol.iterator]() &#123; for (let item of this.items) &#123; yield item; &#125; &#125;&#125;;collection.items.push(1);collection.items.push(2);collection.items.push(3);for (let x of collection) &#123; console.log(x);&#125; 위 코드는 다음을 출력합니다.123123 먼저, 이 예제는 collection이라는 객체의 Default Iterator를 정의합니다. Default Iterator는 Generator인 Symbol.iterator 메서드에 의해 생성됩니다 (별표시는 여전히 이름 앞에 옵니다). Generator는 for-of 루프를 사용하여 this.items의 값을 반복하고 yield를 사용하여 각각을 리턴합니다. collection 객체는 수동으로 반복하여 collection의 Default Iterator에 대한 값을 정의하는 대신, this.items의 Default Iterator를 사용하여 작업을 수행합니다. 이 장의 뒷부분에 나오는 “Generator 위임”에서는 다른 객체의 Iterator를 사용하는 방법에 대해 설명합니다. 이제까지 Array의 Default Iterator에 대한 사용법을 살펴 보았지만 ECMAScript 6에는 더 많은 Iterator가 내장되어 있어 데이터 수집 작업을 쉽게 수행할 수 있습니다. 내장 Iterator들Iterator는 ECMAScript 6의 중요한 부분이므로 많은 빌트인 타입에 대해 자체적으로 Iterator를 만들 필요가 없습니다. 언어 레벨에서 기본적으로 포함하고 있습니다. 기본 제공되는 Iterator가 목적에 부합하지 않을 때만 Iterator를 만들어야 하며, 이는 자신만의 객체 나 클래스를 정의할 때 자주 발생합니다. 그 외에는 내장된 Iterator를 사용하여 작업을 수행할 수 있습니다. 아마도 가장 일반적인 Iterator는 컬렉션에서 작동하는 Iterator일 것입니다. 컬렉션 Iterator들ECMAScript 6에는 Array, Map 및 Set 세가지 타입의 컬렉션 객체가 있습니다. 세가지 모두에는 내용을 탐색하는데 도움이되는 다음과 같은 기본 제공 Iterator가 있습니다. entries() - 값이 키 - 값 쌍인 Iterator를 반환합니다. values() - 값이 컬렉션의 value인 Iterator를 반환합니다. keys() - 값이 컬렉션에 포함된 key인 Iterator를 반환합니다. 이 메서드 중 하나를 호출하여 컬렉션을 검색할 수 있습니다. entries() Iteratorentries() Iterator는 next()가 호출될 때마다 두개의 아이템 Array을 반환합니다. 두개의 아이템 Array는 컬렉션의 각 항목에 대한 키와 값을 나타냅니다. Array의 경우 첫 번째 항목은 숫자 인덱스입니다. Set의 경우 첫 번째 항목은 값이기도합니다 (값은 Set의 키와 동일하므로). Map의 경우 첫 번째 항목은 키입니다. 다음은이 Iterator를 사용하는 몇 가지 예제입니다. 123456789101112131415161718let colors = [ \"red\", \"green\", \"blue\" ];let tracking = new Set([1234, 5678, 9012]);let data = new Map();data.set(\"title\", \"Understanding ECMAScript 6\");data.set(\"format\", \"ebook\");for (let entry of colors.entries()) &#123; console.log(entry);&#125;for (let entry of tracking.entries()) &#123; console.log(entry);&#125;for (let entry of data.entries()) &#123; console.log(entry);&#125; console.log() 호출은 다음과 같은 결과를냅니다. 12345678[0, &quot;red&quot;][1, &quot;green&quot;][2, &quot;blue&quot;][1234, 1234][5678, 5678][9012, 9012][&quot;title&quot;, &quot;Understanding ECMAScript 6&quot;][&quot;format&quot;, &quot;ebook&quot;] 위 예제는 각 컬렉션 타입에 대해 entries() 메서드를 사용하여 Iterator를 검색하고 for-of 루프를 사용하여 반복합니다. console 출력은 각 객체에 대해 어떻게 키와 값이 쌍으로 리턴되는지 보여줍니다. values() Iteratorvalues() Iterator는 컬렉션에 저장된 값을 반환합니다. 123456789101112131415161718let colors = [ \"red\", \"green\", \"blue\" ];let tracking = new Set([1234, 5678, 9012]);let data = new Map();data.set(\"title\", \"Understanding ECMAScript 6\");data.set(\"format\", \"ebook\");for (let value of colors.values()) &#123; console.log(value);&#125;for (let value of tracking.values()) &#123; console.log(value);&#125;for (let value of data.values()) &#123; console.log(value);&#125; 이 코드는 다음을 출력합니다. 12345678&quot;red&quot;&quot;green&quot;&quot;blue&quot;123456789012&quot;Understanding ECMAScript 6&quot;&quot;ebook&quot; 이 예제에서와 같이 values() Iterator를 호출하면 컬렉션의 해당 데이터 위치에 대한 정보없이 각 컬렉션에 포함된 정확한 데이터가 반환됩니다. keys() Iteratorkeys() Iterator는 컬렉션에 있는 각 키를 반환합니다. Array의 경우 숫자 키만 반환하며 Array의 다른 프로퍼티는 반환하지 않습니다. Set의 경우 키는 값과 동일하므로 keys() 및 values()는 동일한 Iterator를 반환합니다. Map의 경우, keys() Iterator는 각 고유 키를 리턴합니다. 다음은 이 세가지를 모두 보여주는 예제입니다. 123456789101112131415161718let colors = [ \"red\", \"green\", \"blue\" ];let tracking = new Set([1234, 5678, 9012]);let data = new Map();data.set(\"title\", \"Understanding ECMAScript 6\");data.set(\"format\", \"ebook\");for (let key of colors.keys()) &#123; console.log(key);&#125;for (let key of tracking.keys()) &#123; console.log(key);&#125;for (let key of data.keys()) &#123; console.log(key);&#125; 이 예제는 다음을 출력합니다. 12345678012123456789012&quot;title&quot;&quot;format&quot; keys() Iterator는 colors, tracking 및 data에서 각 키를 가져 오며, 이 키들은 세개의 for-of 루프 내부에서 출력됩니다. Array의 경우 숫자 색인만 출력되며 Array에 명명된(named) 프로퍼티를 추가 한 경우에도 숫자 색인만 출력합니다. 이것은 for-in 루프는 숫자 인덱스가 아닌 프로퍼티를 반복하기 때문에 for-in에서 Array를 이용하는 방식과 다릅니다. 컬렉션 타입에 대한 Default Iterator각 컬렉션 타입에는 Iterator가 명시적으로 지정되지 않은 경우 for-of에 의해 사용되는 Default Iterator가 있습니다. values() 메서드는 Array와 Set의 Default Iterator이며, entries() 메서드는 Map의 Default Iterator입니다. 이러한 기본값은 for-of 루프에서 컬렉션 객체를 사용하는 것을 좀더 쉽게 만듭니다. 다음 예제를 살펴보겠습니다. 123456789101112131415161718192021let colors = [ \"red\", \"green\", \"blue\" ];let tracking = new Set([1234, 5678, 9012]);let data = new Map();data.set(\"title\", \"Understanding ECMAScript 6\");data.set(\"format\", \"print\");// colors.values()를 사용하는 것과 같습니다.for (let value of colors) &#123; console.log(value);&#125;// tracking.values()를 사용하는 것과 같습니다.for (let num of tracking) &#123; console.log(num);&#125;// data.entries()를 사용하는 것과 같습니다.for (let entry of data) &#123; console.log(entry);&#125; Iterator가 지정되지 않았기 때문에 Default Iterator가 사용됩니다. Array, Set 및 Map의 Default Iterator는 이러한 객체가 초기화되는 방식을 반영하도록 설계되었으므로 이 코드는 다음을 출력합니다. 12345678&quot;red&quot;&quot;green&quot;&quot;blue&quot;123456789012[&quot;title&quot;, &quot;Understanding ECMAScript 6&quot;][&quot;format&quot;, &quot;print&quot;] Array와 Set은 기본적으로 값을 반환하고, Map은 Map 생성자에 전달할 수 있는 것과 동일한 Array 형태를 반환합니다. 반대로 Weak Set과 Weak Map에는 Built-in Iterator가 없습니다. 약한 참조를 관리한다는 것은 이러한 컬렉션에 정확히 얼마나 많은 값이 있는지를 알 수있는 방법이 없다는 것을 의미합니다. 또한 이들을 반복할 방법이 없다는 것을 의미합니다. Destructuring과 for-of 루프Map에 대한 Default Iterator의 동작은 다음 예와 같이 Destructuring이 있는 for-of 루프에서 사용될 때도 유용합니다. 123456789let data = new Map();data.set(\"title\", \"Understanding ECMAScript 6\");data.set(\"format\", \"ebook\");// data.entries()을 사용하는 것과 같습니다.for (let [key, value] of data) &#123; console.log(key + \"=\" + value);&#125; 이 코드의 for-of 루프는 Destructured Array을 사용하여 Map의 각 항목에 대해 key와 value를 지정합니다. 이 방법으로 두 항목 Array에 액세스하거나 Map에서 키 또는 값을 가져 오지 않고도 키와 값을 사용하여 쉽게 작업할 수 있습니다. Map에 대해 Destructured Array를 사용하여 for-of 루프가 Set과 Array의 경우와 마찬가지로 Map에 똑같이 유용할 수 있습니다. 문자열 IteratorJavaScript 문자열은 ECMAScript 5가 출시된 이후 천천히 배열과 비슷해졌습니다. 예를 들어, ECMAScript 5는 문자열의 문자에 액세스하기위한 대괄호 표기법을 사용합니다 (즉, 첫 번째 문자를 가져 오기 위해 text[0] 사용). 그러나 대괄호 표기법은 문자가 아닌 Code Unit에서 작동하므로 아래 예제에서 보여주는 것처럼 2 바이트 문자를 올바르게 액세스하는데 사용할 수 없습니다. 12345var message = \"A ð ®· B\";for (let i=0; i &lt; message.length; i++) &#123; console.log(message[i]);&#125; 이 코드는 괄호 표기법과 length 프로퍼티를 사용하여 반복하고 유니 코드 문자가 포함된 문자열을 출력합니다. 결과는 예상과 다릅니다. 123456A(blank)(blank)(blank)(blank)B 두개의 바이는 두 개의 개별 Code Unit으로 취급되기 때문에 A와 B 사이에 4 개의 비어있는 행이 출력됩니다. 다행스럽게도 ECMAScript 6은 유니 코드를 완벽하게 지원하고 (2 장 참조) 기본 문자열 Iterator는 문자열 반복 문제를 해결하기 위한 시도입니다. 따라서 문자열의 기본 Iterator는 Code Unit이 아닌 문자단위로 작동합니다. 이 예제를 for-of 루프와 함께 기본 문자열 Iterator를 사용하도록 변경하면 보다 적절한 결과가 출력됩니다. 다음은 수정된 코드입니다. 12345var message = \"A ð ®· B\";for (let c of message) &#123; console.log(c);&#125; 출력 결과는 다음과 같습니다. 12345A(blank)ð ®·(blank)B 이 결과는 문자로 작업할 때 기대했던 것과 더 비슷합니다. 루프는 유니 코드 문자뿐 아니라 나머지 문자도 모두 성공적으로 출력합니다. NodeList IteratorDOM (Document Object Model)에는 문서의 요소 컬렉션을 나타내는 NodeList 타입이 있습니다. JavaScript를 웹 브라우저에서 실행하는 사람들에게는 NodeList 객체와 Array의 차이점을 이해하는 것이 항상 약간 어려웠습니다. NodeList 객체와 Array는 항목의 수를 나타 내기 위해 length 프로퍼티를 사용하며, 둘 다 괄호 표기법을 사용하여 개별 항목에 액세스합니다. 그러나 내부적으로 NodeList와 Array는 완전히 다르게 작동하므로 많은 혼란을 겪습니다. ECMAScript 6에 Default Iterator가 추가된 NodeList (ECMAScript 6 자체가 아닌 HTML 사양에 포함됨)의 DOM 정의에는 Array Default Iterator와 같은 방식으로 작동하는 Default Iterator가 포함되어 있습니다. 즉, for-of 루프 또는 객체의 Default Iterator를 사용하는 다른 부분에서 아래와같이 NodeList를 사용할 수 있습니다. 12345var divs = document.getElementsByTagName(\"div\");for (let div of divs) &#123; console.log(div.id);&#125; 이 코드는 getElementsByTagName()을 호출하여 document 객체의 모든 &lt;div&gt; 요소를 나타내는 NodeList를 검색합니다. for-of 루프는 각 요소를 반복하고 엘리먼트 ID를 출력하므로 표준 Array의 코드와 동일합니다. Spread 연산자와 Non-Array Iterables7 장에서 아래와 같이 Set을 Array로 변환하는 데 Spread 연산자 (...)를 사용할 수 있다는 점을 설명했습니다. 1234let set = new Set([1, 2, 3, 3, 3, 4, 5]), array = [...set];console.log(array); // [1,2,3,4,5] 이 코드는 Array 리터럴의 Spread 연산자를 사용하여 해당 Array을 set의 값으로 채웁니다. Spread 연산자는 모든 Iterable에서 작동하고 Default Iterator를 사용하여 포함할 값을 결정합니다. 모든 값은 Iterator에서 읽혀지고 Iterator에서 값이 리턴된 순서대로 Array에 삽입됩니다. 이 예제는 Set이 Iterable이기 때문에 작동했습니다. 그리고 모든 Iterable에서 똑같이 작동 합니다. 다른 예를 살펴 보겠습니다. 1234let map = new Map([ [\"name\", \"Nicholas\"], [\"age\", 25]]), array = [...map];console.log(array); // [ [\"name\", \"Nicholas\"], [\"age\", 25]] 여기에서 Spread 연산자는 map을 Array의 Array로 변환합니다. Map에 대한 Default Iterator는 키-값 쌍을 반환하기 때문에 결과 Array는 new Map()호출 중에 전달된 Array처럼 보입니다. Array 리터럴에서 원하는 만큼 여러번 Spread 연산자를 사용할 수 있으며 Iterable에서 여러 항목을 삽입하려는 곳이면 어디에서나 사용할 수 있습니다. 이러한 항목은 Spread 연산자의 위치에 있는 새로운 Array에 순서대로 나타납니다. 123456let smallNumbers = [1, 2, 3], bigNumbers = [100, 101, 102], allNumbers = [0, ...smallNumbers, ...bigNumbers];console.log(allNumbers.length); // 7console.log(allNumbers); // [0, 1, 2, 3, 100, 101, 102] Spread 연산자는 smallNumbers 및 bigNumbers의 값에서 allNumbers를 만드는 데 사용됩니다. 값은 allNumbers가 만들어질 때 Array가 추가되는 순서와 동일한 순서로 allNumbers에 배치됩니다. 먼저 0이오고 smallNumbers의 값이 뒤 따르고 bigNumbers의 값이옵니다. 그러나 원래 배열은 값이 allNumbers로 복사되었으므로 변경되지 않습니다. Spread 연산자는 어떤 Iterable에서도 사용할 수 있기 때문에, Iterable을 Array로 변환하는 가장 쉬운 방법입니다. 문자열을 문자 Array(Code Unit 아님) 및 브라우저의 NodeList 객체를 Node Array로 변환할 수 있습니다. for-of 연산자와 Spread 연산자를 포함하여 Iterator가 작동하는 기본 사항을 이해 했으므로 이제는 Iterator를 좀 더 복잡한 용도로 살펴볼 차례입니다. Iterator 고급 기능Iterator는 Genertor를 이용하여 쉽게 만들고 기본 기능을 이용하여 Iterator를 쉽게 사용할수 있습니다. 그러나 Iterator는 단순히 값의 모음을 반복하는것 이외의 작업에 사용될 때 훨씬 강력합니다. ECMAScript 6을 개발하는 동안 제작자가 더 많은 기능을 추가하도록 독창적인 아이디어와 패턴이 많이 나타났습니다. 이러한 추가 기능중 일부는 함께 사용하면 흥미로운 상호 작용을 수행할 수 있습니다. Iterator에 파라미터 넘기기이 장 전반의 예제에서는 Iterator의 next() 메서드를 통해 값을 전달받거나 Generator의 yield를 사용하는 모습을 보여줬습습니다. 그러나 next() 메서드를 통해 Iterator에 파라미터를 전달할 수도 있습니다. 파라미터가 next() 메서드에 전달되면, 그 파라미터는 Generator 내부의 yield 문의 값이 됩니다. 이 기능은 비동기 프로그래밍과 같은 고급 기능에 중요합니다. 다음은 기본적인 예입니다. 123456789101112function *createIterator() &#123; let first = yield 1; let second = yield first + 2; // 4 + 2 yield second + 3; // 5 + 3&#125;let iterator = createIterator();console.log(iterator.next()); // \"&#123; value: 1, done: false &#125;\"console.log(iterator.next(4)); // \"&#123; value: 6, done: false &#125;\"console.log(iterator.next(5)); // \"&#123; value: 8, done: false &#125;\"console.log(iterator.next()); // \"&#123; value: undefined, done: true &#125;\" next()의 첫 번째 호출은 전달된 파라미터가 사라지는 특별한 경우입니다. yield 문 앞에 접근할 수 있다면 next()에 전달된 파라미터가 yield에 의해 리턴된 값이되기 때문에, next()에 대한 첫 번째 호출의 파라미터는 Generator 함수의 첫 번째 yield 문장을 대체할 수 있습니다. 하지만 그건 불가능합니다. 그래서 next()가 처음 호출되었을 때 파라미터를 넘길 이유가 없습니다. next()의 두 번째 호출에서 4값이 파라미터로 전달됩니다. 4는 Generator 함수 내에서 first 변수에 할당됩니다. 할당을 포함하는 yield 문에서 표현식의 오른쪽은 next()의 첫 번째 호출에서 평가되고 왼쪽은 함수가 계속 실행되기 전에 next()의 두 번째 호출에서 평가됩니다. next()의 두 번째 호출이 4로 전달되기 때문에, 그 값은 first에 할당되고 실행이 계속됩니다. 두 번째 yield는 첫 번째 yield의 결과를 사용하고 두개를 더합니다. 즉, 6의 값을 반환합니다. next()가 세번째로 호출될 때, 값 5가 파라미터로 전달됩니다. 이 값은 변수 second에 할당된 다음 yield 문에서 8을 반환하는데 사용됩니다. 실행이 Generator 함수 내에서 계속될 때마다 어떤 코드가 실행되고 있는지 고려하여 어떤 일이 일어나고 있는지 생각하는 것이 쉽습니다. 그림 8-1은 색상을 사용하여 실행중인 코드를 보여줍니다. [그림 8-1]Generator 내부에서 코드 실행 노란색은 next()에 대한 첫 번째 호출과 Generator 내부에서 실행된 코드를 나타냅니다. 아쿠아색은 next(4)의 호출과 그 호출로 실행된 코드를 나타냅니다. 그리고 자주색은 next(5) 호출과 그 결과로 실행되는 코드를 나타냅니다. 까다로운 부분은 왼쪽면이 실행되기 전에 각 표현식의 오른쪽에있는 코드가 어떻게 실행되고 중지되는지 입니다. 이것은 일반 함수를 디버깅하는 것보다 Generator를 디버깅하는 것을 더 복잡하게 만드는 원인입니다. 지금까지 next() 메서드에 값이 전달될 때 yield가 return처럼 작동할 수 있다는 것을 보았습니다. 그러나 이것만이 Generator 내부에서 수행할 수있는 유일한 실행이 아닙니다. Iterator로 인해 오류가 발생할 수도 있습니다. Iterator에서 에러 던지기Iterator에 데이터뿐만 아니라 오류 조건도 전달할 수 있습니다. Iterator는 Iterator가 다시 시작할 때 오류를 발생 시키도록 지시하는 throw() 메서드를 구현하도록 선택할 수 있습니다. 이것은 비동기 프로그래밍을 위한 중요한 기능이고, 함수를 종료하는 두가지 방법인 리턴과 오류를 던지는 기능을 모방할 수 있어 Generator 내부의 유연성에도 중요합니다. Iterator가 처리를 계속할 때 던져 져야하는 throw()에 에러 객체를 전달할 수 있습니다. 1234567891011function *createIterator() &#123; let first = yield 1; let second = yield first + 2; // yield 4 + 2, then throw yield second + 3; // never is executed&#125;let iterator = createIterator();console.log(iterator.next()); // \"&#123; value: 1, done: false &#125;\"console.log(iterator.next(4)); // \"&#123; value: 6, done: false &#125;\"console.log(iterator.throw(new Error(\"Boom\"))); // generator에서 에러를 던집니다. 이 예제에서 처음 두개의 yield 표현식은 평범한 것으로 평가되지만 throw()가 호출되면 let second가 평가되기 전에 에러가 발생합니다. 이로 인해 코드 실행이 오류를 직접 throw 하는 것과 비슷한 효과로 중지됩니다. 유일한 차이점은 오류가 발생하는 위치입니다. [그림 8-2]는 각 단계에서 어떤 코드가 실행되는지 보여줍니다. [그림 8-2] Generator 내부에서 에러를 던집니다 이 그림에서 붉은색은 throw()가 호출될 때 실행되는 코드를 나타내며 빨간색 별은 오류가 Generator 내부로 던져지는 부분을 대략 나타냅니다. 처음 두개의 yield 문이 실행되고 throw()가 호출되면 다른 코드가 실행되기 전에 오류가 발생합니다. 이것을 알고있다면, try-catch 블록을 사용하여 Generator 내에서 에러를 잡을 수 있습니다. 123456789101112131415161718function *createIterator() &#123; let first = yield 1; let second; try &#123; second = yield first + 2; // yield 4 + 2, then throw &#125; catch (ex) &#123; second = 6; // 에러시 다른 값을 할당함. &#125; yield second + 3;&#125;let iterator = createIterator();console.log(iterator.next()); // \"&#123; value: 1, done: false &#125;\"console.log(iterator.next(4)); // \"&#123; value: 6, done: false &#125;\"console.log(iterator.throw(new Error(\"Boom\"))); // \"&#123; value: 9, done: false &#125;\"console.log(iterator.next()); // \"&#123; value: undefined, done: true &#125;\" 이 예제에서, 두 번째 yield 문은 try-catch 블록이 감싸고 있습니다. 이 yield는 에러 없이 실행되고, 다음 실행에서 어떤한 값이 second에 할당되기 전에 에러가 던져 지므로 catch 블록은 6의 값을 할당합니다. 그리고 실행은 다음 yield로 이동하여 9를 반환합니다. 흥미로운 일이 발생합니다. throw() 메서드는 next() 메서드와 마찬가지로 결과 객체를 리턴합니다. 오류가 Generator 내부에서 발견 되었기 때문에 코드 실행은 다음 yield로 이어지고 다음 값인 9가 반환됩니다. Iterator에 대한 지시사항인 next()와 throw()를 생각하는 것이 도움이됩니다. next() 메서드는 Iterator에게 (주어진 값으로) 실행을 계속하도록 지시하고 throw()는 Iterator에게 오류를 던져 실행을 계속하도록 지시합니다. 그 시점 이후에 일어나는 일은 Generator 내부의 코드에 달려 있습니다. next()와 throw() 메서드는 yield를 사용할 때 Iterator 안에서 실행을 제어하지만 return 문도 사용할 수 있습니다. 그러나return은 다음 절에서 보듯이 정규 함수와 약간 다르게 작동합니다. Generator의 Return 문Generator는 함수이기 때문에 return 문을 사용하여 일찍 종료하고 next() 메서드에 대한 마지막 호출의 반환 값을 지정할 수 있습니다. 이 장의 대부분의 예제에서, Iterator에서 next()를 마지막으로 호출하면 undefined가 반환되지만 다른 함수에서와 같이 return을 사용하여 값을 지정할 수 있습니다. Generator에서 return은 모든 처리가 완료되었음을 나타내므로 done 프로퍼티는true로 설정되고 값이 제공되면 value가 됩니다. 다음은 return을 사용하여 일찍 종료하는 예제입니다. 1234567891011function *createIterator() &#123; yield 1; return; yield 2; yield 3;&#125;let iterator = createIterator();console.log(iterator.next()); // \"&#123; value: 1, done: false &#125;\"console.log(iterator.next()); // \"&#123; value: undefined, done: true &#125;\" 이 코드의 Generator에는 yield문 다음에 return 문장이 옵니다. return은 더 이상의 값이 없다는 것을 나타내므로 나머지 yield 문은 실행되지 않습니다 (도달할 수 없습니다). 리턴된 오브젝트의 value 필드에 값을 지정할 수도 있습니다. 12345678910function *createIterator() &#123; yield 1; return 42;&#125;let iterator = createIterator();console.log(iterator.next()); // \"&#123; value: 1, done: false &#125;\"console.log(iterator.next()); // \"&#123; value: 42, done: true &#125;\"console.log(iterator.next()); // \"&#123; value: undefined, done: true &#125;\" 두 번째 next() 메서드 호출에서 value 프로퍼티에 값 42가 리턴됩니다.(done이 처음으로 true인 지점입니다.)next()의 세번째 호출에 value 프로퍼티가 다시 undefined인 객체를 반환합니다. return으로 지정한 값은 value 프로퍼티가undefined로 재설정되기 전에 반환된 객체에서만 한번 사용할 수 있습니다. Spread 연산자와 for-of는 return 문에 의해 지정된 값을 무시합니다. done이 true이면 바로value를 읽지 않고 멈춥니다. 그러나 Generator를 위임할 때는 Iterator 리턴 값이 유용합니다. Generator 위임경우에 따라 두 개의 Iterator 값을 하나로 결합하는 것이 유용할 수 있습니다. Generator는 별표 (*) 문자로 yield라는 특수 형식을 사용하여 다른 Iterator에 위임할 수 있습니다. Generator 정의에서와 같이 *가 나타나는 위치는 *이 yield 키워드와 Generator 함수 이름 사이에있는 한 중요하지 않습니다. 다음은 그 예입니다. 123456789101112131415161718192021222324function *createNumberIterator() &#123; yield 1; yield 2;&#125;function *createColorIterator() &#123; yield \"red\"; yield \"green\";&#125;function *createCombinedIterator() &#123; yield *createNumberIterator(); yield *createColorIterator(); yield true;&#125;var iterator = createCombinedIterator();console.log(iterator.next()); // \"&#123; value: 1, done: false &#125;\"console.log(iterator.next()); // \"&#123; value: 2, done: false &#125;\"console.log(iterator.next()); // \"&#123; value: \"red\", done: false &#125;\"console.log(iterator.next()); // \"&#123; value: \"green\", done: false &#125;\"console.log(iterator.next()); // \"&#123; value: true, done: false &#125;\"console.log(iterator.next()); // \"&#123; value: undefined, done: true &#125;\" 위 예제에서, createCombinedIterator() Generator는 createNumberIterator()에서 리턴된 Iterator에 먼저 위임한 다음createColorIterator()에서 리턴된 Iterator에 위임합니다. createCombinedIterator()에서 반환된 Iterator는 바깥쪽에서 보기에 일관된 Iterator로 보여집니다. next()에 대한 각각의 호출은 createNumberIterator()와 createColorIterator()에 의해 생성된 Iterator가 비게 될 때까지 적절한 Iterator에 위임됩니다. 그런 다음 최종 yield가 실행되어 true를 반환합니다. Generator 위임을 통해 Generator 리턴값을 더 많이 사용할 수도 있습니다. 이것은 반환된 값을 액세스하는 가장 쉬운 방법이며 복잡한 작업을 수행하는데 매우 유용할 수 있습니다. 12345678910111213141516171819202122232425function *createNumberIterator() &#123; yield 1; yield 2; return 3;&#125;function *createRepeatingIterator(count) &#123; for (let i=0; i &lt; count; i++) &#123; yield \"repeat\"; &#125;&#125;function *createCombinedIterator() &#123; let result = yield *createNumberIterator(); yield *createRepeatingIterator(result);&#125;var iterator = createCombinedIterator();console.log(iterator.next()); // \"&#123; value: 1, done: false &#125;\"console.log(iterator.next()); // \"&#123; value: 2, done: false &#125;\"console.log(iterator.next()); // \"&#123; value: \"repeat\", done: false &#125;\"console.log(iterator.next()); // \"&#123; value: \"repeat\", done: false &#125;\"console.log(iterator.next()); // \"&#123; value: \"repeat\", done: false &#125;\"console.log(iterator.next()); // \"&#123; value: undefined, done: true &#125;\" 여기서 createCombinedIterator() Generator createNumberIterator()에 위임하고 result에 리턴값을 할당합니다. createNumberIterator()는 return 3을 포함하기 때문에 리턴값은 3입니다. result 변수는 createRepeatingIterator()에 같은 문자열을 yield 하는 횟수(이 경우에는 3 번)를 나타내는 인자로 전달됩니다. next() 메서드에 대한 호출에서 3 값은 절대로 출력되지 않았습니다. 지금은 createCombinedIterator() Generator 안에만 존재합니다. 그러나 다음과 같이 또 다른 yield 문을 추가하여 그 값을 출력할 수 있습니다. 123456789101112131415161718192021222324252627function *createNumberIterator() &#123; yield 1; yield 2; return 3;&#125;function *createRepeatingIterator(count) &#123; for (let i=0; i &lt; count; i++) &#123; yield \"repeat\"; &#125;&#125;function *createCombinedIterator() &#123; let result = yield *createNumberIterator(); yield result; yield *createRepeatingIterator(result);&#125;var iterator = createCombinedIterator();console.log(iterator.next()); // \"&#123; value: 1, done: false &#125;\"console.log(iterator.next()); // \"&#123; value: 2, done: false &#125;\"console.log(iterator.next()); // \"&#123; value: 3, done: false &#125;\"console.log(iterator.next()); // \"&#123; value: \"repeat\", done: false &#125;\"console.log(iterator.next()); // \"&#123; value: \"repeat\", done: false &#125;\"console.log(iterator.next()); // \"&#123; value: \"repeat\", done: false &#125;\"console.log(iterator.next()); // \"&#123; value: undefined, done: true &#125;\" 이 코드에서 여분의 yield 문은 리턴된 값을 createNumberIterator() Generator에서 명시적으로 출력합니다. 리턴값을 사용하는 Generator 위임은 특히 비동기 작업과 함께 사용할 때 매우 흥미로운 가능성을 가지는 매우 강력한 패러다임입니다. 문자열에 yield *를 직접 사용할 수 있습니다 (예 :yield * &quot;hello&quot;). 이 경우 문자열의 기본 Iterator가 사용됩니다. 비동기(Asynchronous) 작업 실행Generator의 흥미로운 점은 비동기 프로그래밍과 직접 관련이 있습니다. JavaScript의 비동기 프로그래밍은 양날의 칼입니다. 간단한 작업은 비동기식으로 수행하기 쉽고 복잡한 작업은 코드에서 내용 역할을 하게됩니다. Generator는 실행 중간에 코드를 효과적으로 일시 중지할 수 있으므로 비동기 처리와 관련된 많은 가능성을 가지고 있습니다. 비동기 작업을 수행하는 전통적인 방법은 콜백이 있는 함수를 호출하는 것입니다. 예를 들어, Node.js의 디스크에서 파일을 읽는 것을 생각해 보겠습니다. 12345678910let fs = require(\"fs\");fs.readFile(\"config.json\", function(err, contents) &#123; if (err) &#123; throw err; &#125; doSomethingWith(contents); console.log(\"Done\");&#125;); fs.readFile() 메서드는 읽을 파일 이름과 콜백 함수를 가지고 호출됩니다. 작업이 끝나면 콜백 함수가 호출됩니다. 콜백은 오류가 있는지 검사하고 그렇지 않은 경우 반환된 contents을 처리합니다. 이 작업은 작거나, 유한한 수의 비동기 작업을 완료하는데는 괜찮지만 콜백을 중첩하거나 일련의 비동기 작업을 순서대로 수행해야하는 경우에는 복잡해집니다. 이부분이 Generator와 yield가 도움이되는 곳입니다. 간단한 작업 실행yield는 실행을 멈추고 다시 시작하기 전에 next() 메서드가 호출되기를 기다리기 때문에 콜백을 관리하지 않고 비동기 호출을 구현할 수 있습니다. 시작하려면 Generator를 호출하고 다음과 같이 Iterator를 시작할 수있는 함수가 필요합니다. 12345678910111213141516171819202122function run(taskDef) &#123; // iterator를 만들고 다른곳에서 사용할 수 있게 합니다. let task = taskDef(); // 태스크 시작 let result = task.next(); // next() 호출을 계속하는 재귀 함수 function step() &#123; // 더해야 할 일이 있다면 if (!result.done) &#123; result = task.next(); step(); &#125; &#125; // process를 시작 step();&#125; run() 함수는 태스크의 정의 (Generator 함수)를 파라미터로 받아들입니다. Generator를 호출하여 Iterator를 만들고 Iterator를task에 저장합니다. task 변수는 함수 외부에 있으므로 다른 함수가 접근할 수 있습니다(뒷부분에서 설명 합니다.). next()에 대한 첫 번째 호출은 Iterator를 시작하고 결과는 나중에 사용하기 위해 저장됩니다. step() 함수는 result.done이 false인지 검사하고, 만약 그렇다면 재귀적으로 자신을 호출하기 전에 next()를 호출합니다. next()를 호출할 때마다 결과 값이 result에 저장됩니다.이 값은 항상 최신 정보를 포함하도록 덮어 쓰여집니다. 처음 step()의 호출은 더 수행할 태스크가 있는지를 알기 위해 result.done 변수를 확인 합니다. 위에 구현한 run()을 다음과 같이 여러 yield 문이 포함된 Generator로 실행할 수 있습니다. 1234567run(function*() &#123; console.log(1); yield; console.log(2); yield; console.log(3);&#125;); 이 예제는 단순히 콘솔에 세 개의 숫자를 출력하는데, 간단히 next()에 대한 모든 호출이 이루어지는 것을 보여줍니다. 그러나 단지 두 번 yield하는 것은 별로 유용하지 않습니다. 다음 단계는 Iterator 안팎으로 값을 전달하는 것입니다. 데이터를 가진 태스크 실행하기태스크 실행에 데이터를 전달하는 가장 쉬운 방법은 yield에 의해 지정된 값을 next() 메서드에 대한 호출에 전달하는 것입니다. 이렇게하려면 이 코드에서와 같이 result.value 만 전달하면됩니다. 12345678910111213141516171819202122function run(taskDef) &#123; // iterator를 만들고 다른곳에서 사용할 수 있게 합니다. let task = taskDef(); // 태스크 시작 let result = task.next(); // next() 호출을 계속하는 재귀 함수 function step() &#123; // 더해야 할 일이 있다면 if (!result.done) &#123; result = task.next(result.value); step(); &#125; &#125; // process 시작 step();&#125; 이제 result.value가 파라미터로 next()에 전달되었으므로 다음과 같이 yield 호출간에 데이터를 전달할 수 있습니다. 1234567run(function*() &#123; let value = yield 1; console.log(value); // 1 value = yield value + 3; console.log(value); // 4&#125;); 이 예제는 콘솔에 두 개의 값을 출력합니다(1과 4). 값 1은 yield 1에서 나오는데, 1은 value 변수로 바로 전달됩니다. 4는 value에 3을 더하고 그 결과를 value에 전달함으로써 계산됩니다. 데이터가 yield호출 사이에서 흐르고 있으므로 비동기 호출을 허용하려면 작은 변경만 하면됩니다. 비동기 태스크 실행앞의 예제는 정적 데이터가 yield 호출 사이에서 왔다 갔다했지만 비동기 프로세스를 기다리는 것은 약간 다릅니다. 태스크 러너는 콜백 및 그 사용 방법을 알아야합니다. 그리고 yield 표현식은 값을 태스크 러너로 전달하기 때문에 어떤 함수 호출이라도 호출이 태스크 러너가 기다려야하는 비동기 연산임을 나타내는 값을 리턴해야 함을 의미합니다. 다음은 값이 비동기 작업임을 알리는 한 가지 방법입니다. 12345function fetchData() &#123; return function(callback) &#123; callback(null, \"Hi!\"); &#125;;&#125; 이 예제의 목적을 위해, 태스크 러너에 의해 호출되는 모든 함수는 callback을 실행하는 함수를 리턴할 것이다. fetchData() 함수는 콜백 함수를 파라미터로 받아들이는 함수를 리턴한다. 반환된 함수가 호출되면, 단일 데이터 ( &quot;Hi!&quot;문자열)로 콜백 함수를 실행합니다. callback 파라미터는 콜백을 실행하는 것이 기본 Iterator와 정확하게 상호 작용 하는지를 확인하기 위해 태스크 러너로부터 올 필요가있습니다. fetchData() 함수는 동기식이지만, 다음과 같이 약간의 지연만으로 콜백을 호출하여 쉽게 비동기식으로 확장할 수 있습니다. 1234567function fetchData() &#123; return function(callback) &#123; setTimeout(function() &#123; callback(null, \"Hi!\"); &#125;, 50); &#125;;&#125; 이 버전의 fetchData()는 콜백을 호출하기 전에 50ms의 지연을 가져와 이 패턴이 동기 및 비동기 코드에서 똑같이 잘 작동 함을 보여줍니다. yield를 사용하여 호출하려는 각 함수가 동일한 패턴을 따르는지 확인해야 합니다. 함수가 비동기 프로세스라는 신호를 보내는 방법을 잘 이해하면 태스크 러너를 수정하여 해당 사실을 고려할 수 있습니다. result.value가 함수 일 때마다, 태스크 러너는 그 값을 next() 메서드로 전달하는 대신에 실행할 것입니다. 다음은 업데이트된 코드입니다. 1234567891011121314151617181920212223242526272829303132333435function run(taskDef) &#123; // iterator를 만들고 다른곳에서 사용할 수 있게 합니다. let task = taskDef(); // 태스크 시작 let result = task.next(); // next() 호출을 계속하는 재귀 함수 function step() &#123; // 더해야 할 일이 있다면 if (!result.done) &#123; if (typeof result.value === \"function\") &#123; result.value(function(err, data) &#123; if (err) &#123; result = task.throw(err); return; &#125; result = task.next(data); step(); &#125;); &#125; else &#123; result = task.next(result.value); step(); &#125; &#125; &#125; // 프로세스 시작 step();&#125; result.value가 (===연산자로 검사된) 함수이면 콜백 함수가 호출됩니다. 이 콜백 함수는 가능한 오류를 첫 번째 인수 (err)로 전달하고 결과를 두 번째 인수로 전달하는 Node.js 규칙을 따릅니다. err가 있어 오류가 발생하면 task.throw()가 task.next()대신에 오류 객체와 함께 호출되므로 정확한 위치에 오류가 발생합니다. 오류가 없으면 data가 task.next()에 전달되고 그 결과가 저장됩니다. 그런 다음 step()이 호출되어 프로세스가 계속 진행됩니다. result.value가 함수가 아니라면 next() 메서드에 직접 전달됩니다. 이 새로운 버전의 태스크 러너는 모든 비동기 태스크에 대한 준비가 되어 있습니다. Node.js에서 파일로부터 데이터를 읽으려면, 이 섹션의 시작 부분에서 fetchData() 함수와 유사한 함수를 반환하는 fs.readFile()을 감싸는 래퍼를 생성해야합니다. 1234567let fs = require(\"fs\");function readFile(filename) &#123; return function(callback) &#123; fs.readFile(filename, callback); &#125;;&#125; readFile() 메서드는 파라미터인 파일명을 받아들이고 콜백을 호출하는 함수를 반환합니다. 콜백은 fs.readFile() 메서드에 직접 전달되며, 메서드는 완료시 콜백을 실행합니다. 다음과 같이 yield를 사용하여 이 작업을 실행할 수 있습니다. 12345run(function*() &#123; let contents = yield readFile(\"config.json\"); doSomethingWith(contents); console.log(\"Done\");&#125;); 이 예제는 주 코드에 콜백을 표시하지 않고 비동기 readFile() 연산을 수행합니다. yield와는 별도로, 코드는 동기 코드와 동일하게 보입니다. 비동기 작업을 수행하는 함수가 모두 동일한 인터페이스를 준수하는 한 동기 코드와 같은 로직을 작성할 수 있습니다. 물론,이 예제에서 사용된 패턴에는 단점이 있습니다. 즉, 함수를 반환하는 함수가 비동기인지 항상 확신할 수는 없습니다. 지금 당장은 실행중인 태스크 뒤에있는 이론을 이해하는 것이 중요합니다. Promise를 사용하면 비동기 작업을 예약하는 보다 강력한 방법이 제공되며 11 장에서는 이 주제에 대해 자세히 설명합니다. 요약Iterator는 ECMAScript 6의 중요한 부분이며 언어의 몇 가지 핵심 요소에 존재합니다. 표면적으로 Iterator는 간단한 API를 사용하여 일련의 값을 반환하는 방법을 제공합니다. 그러나 ECMAScript 6에서 Iterator를 사용하는 훨씬 더 복잡한 방법이 있습니다. Symbol.iterator Symbol은 객체의 기본 Iterator를 정의하는데 사용됩니다. Built-in 객체와 개발자 정의 객체는 모두 이 Symbol을 사용하여 Iterator를 반환하는 메서드를 제공할 수 있습니다. Symbol.iterator가 객체에 제공되면 객체는 Iterable한 것으로 간주됩니다. for-of 루프는 Iterable를 사용하여 루프에서 일련의 값을 반환합니다. for-of를 사용하면 더 이상 값을 추적할 필요가 없고 루프가 끝나는 시점을 제어할 필요가 없으므로 전통적인 for 루프를 반복하는 것보다 쉽습니다. for-of 루프는 Iterator에서 더 이상 값이 없을 때까지 모든 값을 자동으로 읽은 다음 종료합니다. for-of를 더 쉽게 사용하기 위해 ECMAScript 6의 많은 타입에는 기본 Iterator가 있습니다. 컬렉션, 즉 Array, Map 및 Set과 같은 모든 컬렉션 유형에는 내용에 쉽게 액세스할 수 있도록 설계된 Iterator가 있습니다. 문자열에는 기본 Iterator가 있어 Code unit이 아닌 문자열의 문자를 쉽게 반복할 수 있습니다. Spread 연산자는 모든 Iterable 함수에서 작동하며 Iterable를 Array로 쉽게 변환합니다. 변환은 Iterator에서 값을 읽어 Array에 개별적으로 삽입하여 작동합니다. Generator는 호출될 때 Iterator를 자동으로 생성하는 특수 함수입니다. Generator 정의는 별표(*) 문자로 표시되고 yield 키워드를 사용하여 next() 메서드를 연속적으로 호출할 때 반환할 값을 나타냅니다. Generator 위임은 새로운 Generator에서 기존 Generator를 재사용 하도록 함으로써 Iterator 동작을 잘 캡슐화하도록 합니다. yield 대신 yield *를 호출하여 다른 Generator의 기존 Generator를 사용할 수 있습니다. 이 프로세스를 통해 여러 Iterator의 값을 반환하는 Iterator를 만들 수 있습니다. 아마도 Generator와 Iterator 중 가장 흥미로운 부분은 보다 깨끗한 비동기 코드를 생성할 수 있다는 것입니다. 콜백을 사용하는 대신 동기식으로 보이는 코드가 실제로 yield를 사용하면 비동기 작업으로 완료될 때까지 대기합니다. 이 내용은 나중에 참고하기 위해 제가 공부하며 정리한 내용입니다.의역, 오역, 직역이 있을 수 있음을 알려드립니다.This post is a translation of this original article [https://leanpub.com/understandinges6/read#leanpub-auto-iterators-and-generators] 참고 ECMAScript 6 Block Binding ECMAScript 6 문자열과 정규 표현식 ECMAScript 6 함수 ECMAScript 6 객체의 확장된 기능 ECMAScript 6 쉬운 데이터 액세스를 위한 Destructuring ECMAScript 6 Symbol과 Symbol 프로퍼티 ECMAScript 6 Set과 Map ECMAScript 6 Iterator와 Generator ECMAScript 6 JavaScript 클래스 소개 ECMAScript 6 Array 기능 향상 ECMAScript 6 Promise와 비동기 프로그램밍 ECMAScript 6 프록시와 리플렉션 API ECMAScript 6 Module로 코드 캡슐화하기 ECMAScript 6 부록 A. 작은 변경 사항 ECMAScript 6 부록 B. ECMAScript 7(2016) 이해하기","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://infoscis.github.io/categories/JavaScript/"},{"name":"ECMAScript 2015","slug":"JavaScript/ECMAScript-2015","permalink":"http://infoscis.github.io/categories/JavaScript/ECMAScript-2015/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://infoscis.github.io/tags/JavaScript/"},{"name":"ECMAScript 2015","slug":"ECMAScript-2015","permalink":"http://infoscis.github.io/tags/ECMAScript-2015/"}]},{"title":"ECMAScript 6 Set과 Map","slug":"ecmascript-6-sets-and-maps","date":"2018-01-27T14:19:03.000Z","updated":"2018-02-27T14:12:22.502Z","comments":true,"path":"2018/01/27/ecmascript-6-sets-and-maps/","link":"","permalink":"http://infoscis.github.io/2018/01/27/ecmascript-6-sets-and-maps/","excerpt":"","text":"Set과 MapJavaScript의 역사에서 컬렉션 타입은 Array 타입 하나만 가지고 있었습니다. (Array가 아닌 모든 객체는 키 - 값 쌍의 집합이므로 Array와 원래 의도된 용도는 다릅니다). Array는 다른 언어와 마찬가지로 JavaScript에서도 사용되지만 다른 컬렉션이 없기 때문에 대개 Queue 및 Stack으로 Array를 사용합니다. Array는 숫자 인덱스만 사용하기 때문에 개발자는 숫자가 아닌 인덱스가 필요할 때마다 Array가 아닌 객체를 사용했습니다. 아래에서 설명한 기술을 사용하면 Array가 아닌 객체를 사용하여 Set 및 Map을 사용자 정의로 구현할 수 있습니다. Set은 중복을 포함할 수 없는 값의 목록입니다. 일반적인 Array의 항목처럼 Set은 개별 항목에 액세스하지 않습니다. 대신 값이 있는지 확인하기 위해 Set를 확인하는 것이 훨씬 더 일반적입니다. Map은 특정 값에 해당하는 키의 모음입니다. 따라서 Map의 각 항목에는 두 개의 데이터가 저장되고 값은 읽을 키를 지정하여 검색됩니다. Map은 캐시로 자주 사용되어 나중에 빠르게 검색할 데이터를 저장하기도 합니다. ECMAScript 5에는 공식적으로 Set과 Map이 없었지만 개발자는 Array가 아닌 오브젝트를 사용하여 이 제한을 풀었습니다. ECMAScript 6은 JavaScript에 Set과 Map을 추가했으며 이 장에서는 이 두 가지 컬렉션 유형에 대해 알아야할 모든 내용에 대해 설명합니다. 먼저 ECMAScript 6 이전에 Set과 Map을 구현하는데 사용된 방법과 그 구현이 왜 문제가되는지 설명합니다. 중요한 배경 지식을 얻은 후에 ECMAScript 6에서 Set과 Map의 작동 방법을 설명하겠습니다. ECMAScript 5에서의 Set과 MapECMAScript 5에서 개발자는 다음과 같이 객체 프로퍼티를 사용하여 Set 및 Map을 모방했습니다. 123456789let set = Object.create(null);set.foo = true;// 존재 확인하기if (set.foo) &#123; // do something&#125; 이 예제에서 set 변수는 객체 상에 상속된 프로퍼티가 없음을 보장하는 null 프로토 타입을 가진 객체입니다. 객체 프로퍼티를 검사할 고유 값으로 사용하는 것은 ECMAScript 5에서 일반적인 접근법입니다. 프로퍼티가 set 객체에 추가되면, 이 객체는 true로 설정되어 조건문 (이 예에서 if 문)에서 값이 존재하는지 쉽게 확인할 수 있습니다. Set으로 사용된 객체와 Map으로 사용되는 객체 사이의 차이점은 저장되는 값뿐입니다. 예를 들어, 아래 예제는 객체를 Map으로 사용합니다. 12345678let map = Object.create(null);map.foo = \"bar\";// 값을 추출let value = map.foo;console.log(value); // \"bar\" 이 코드는 foo 키 아래에 문자열 값 &quot;bar&quot;를 저장합니다. Set과 달리, Map은 키의 존재를 확인하기 보다는 정보를 검색하는 데 주로 사용됩니다. 해결 방법의 문제점객체를 Set 및 Map으로 사용하는 것은 간단한 상황에서 문제 없이 작동하지만 객체 프로퍼티의 한계를 뛰어 넘으면 접근법이 더 복잡해질 수 있습니다. 예를 들어 모든 객체 프로퍼티는 문자열이어야 하므로 동일한 문자열로 평가되는 두 개의 키가 없어야합니다. 다음 사항을 생각해 보겠습니다. 12345let map = Object.create(null);map[5] = \"foo\";console.log(map[\"5\"]); // \"foo\" 이 예제에서는 문자열 값 &quot;foo&quot;를 숫자 키 5에 할당합니다. 내부적으로 숫자 값은 문자열로 변환되므로 map[&quot;5&quot;] 및 map[5]는 실제로 동일한 프로퍼티를 참조합니다. 내부 변환은 숫자와 문자열을 키로 사용하려는 경우 문제를 일으킬 수 있습니다. 다음과 같이 객체를 키로 사용할 때 또 다른 문제가 발생합니다. 1234567let map = Object.create(null), key1 = &#123;&#125;, key2 = &#123;&#125;;map[key1] = \"foo\";console.log(map[key2]); // \"foo\" 여기서 map[key2]와 map[key1]은 같은 값을 참조합니다. 객체 프로퍼티는 문자열이어야 하므로 객체 key1 및 key2는 문자열로 변환됩니다. &quot;[object Object]&quot;는 객체의 기본 문자열 표현이기 때문에 key1과 key2가 모두 해당 문자열로 변환됩니다. 이는 사실상 다른 객체의 키가 같은 값으로 가정되는 것이 논리적의로 명백하지 않을 수있는 오류를 유발할 수 있습니다. 기본 문자열 표현으로 변환하면 객체를 키로 사용하기가 어렵습니다. (객체를 Set으로 사용하려고할 때도 같은 문제가 발생합니다.) 거짓으로 표현되는 값을 가지는 키가 있는 Map은 특정 문제를 발생시킵니다. 거짓 값은 if 문과 같은 부울 값이 필요한 상황에서 사용될 때 자동으로 false로 변환됩니다. 이 변환만으로는 문제가되지 않습니다. 값을 사용하는 방법에 대해 신중해야합니다. 예를 들어 다음 코드를 살펴보십시오. 12345678let map = Object.create(null);map.count = 1;// \"count\"값이 존재하는지 또는 0이 아닌지 어떤걸 체크 하나요?if (map.count) &#123; // ...&#125; 이 예제는 map.count가 어떻게 사용되어야하는지 모호합니다. if 문은 map.count의 존재를 검사할지 아니면 값이 0이 아닌 것을 검사할지 모호합니다. 그래서 숫자 1은 true로 표현되어 if문 안의 코드가 실행됩니다. 그러나 map.count가 0이거나 map.count가 없으면 if 문 안의 코드는 실행되지 않습니다. ECMAScript 6가 Set과 Map 모두를 언어에 추가하는 가장 큰 이유는 대규모 응용 프로그램에서 발생하는 문제를 식별하고 디버그하는 것이 어렵기 때문입니다. JavaScript는 객체의 값을 읽지 않고 객체에 프로퍼티가 있으면 true를 반환하는 in 연산자를 가지고 있습니다. 그러나 in 연산자는 객체의 프로토 타입을 검색하기 때문에 객체가 null 프로토 타입을 가지고있을 때만 안전하게 사용할 수 있습니다. 그럼에도 불구하고, 많은 개발자들은 여전히 in을 사용하는 대신 마지막 예제 에서처럼 코드를 잘못 사용합니다. ECMAScript 6에서 SetECMAScript 6이 중복되지 않은 값의 정렬된 목록인 Set 타입을 추가 했습니다. Set을 사용하면 포함된 데이터에 빠르게 액세스할 수 있으므로 불연속 값을 보다 효율적으로 추적할 수 있습니다. Set 만들기와 아이템 추가하기Set은 new Set()를 사용하여 생성할수 있고, 항목은 add() 메서드를 호출하여 추가할 수 있습니다. size 프로퍼티를 확인하여 Set에 포함된 항목 수를 확인할 수 있습니다. 12345let set = new Set();set.add(5);set.add(\"5\");console.log(set.size); // 2 Set은 값이 동일한지 확인하기 위해 값을 강제 변환하지 않습니다. 이는 Set이 숫자 5와 문자열 &quot;5&quot;를 두 개의 개별 항목을 포함할 수 있음을 의미합니다. 유일한 예외는 -0과 +0은 같은 것으로 간주된다는 것입니다. 또한 Set에 여러 객체를 추가할 수 있으며 이러한 객체는 구별됩니다. 12345678let set = new Set(), key1 = &#123;&#125;, key2 = &#123;&#125;;set.add(key1);set.add(key2);console.log(set.size); // 2 key1과 key2는 문자열로 변환되지 않으므로 Set에서 두 개의 고유 항목으로 간주됩니다. (문자열로 변환하면 &quot;[Object object]&quot;와 같이 둘은 서로 같습니다.) add() 메서드가 같은 값으로 두 번 이상 호출되면 첫 번째 호출 이후의 모든 호출은 무시됩니다. 123456let set = new Set();set.add(5);set.add(\"5\");set.add(5); // duplicate - this is ignoredconsole.log(set.size); // 2 Array를 사용하여 Set을 초기화할 수 있으며 Set 생성자는 고유 한 값만 사용합니다. 예를 들어 아래와 같습니다. 12let set = new Set([1, 2, 3, 4, 5, 5, 5, 5]);console.log(set.size); // 5 이 예제에서는 중복 값이 있는 Array를 사용하여 Set을 초기화합니다. 숫자 5는 Array에 네 번 나타나지만 Set에 한 번만 입력됩니다. 이 기능을 사용하여 기존 코드 또는 JSON을 쉽게 Set으로 사용할 수 있습니다. Set 생성자는 실제로 모든 반복 가능한 객체를 인수로 받습니다. Array는 Set과 Map처럼 기본적으로 반복 가능하기 때문입니다. Set 생성자는 Iterator를 사용하여 인수에서 값을 추출합니다. (Iterables과 Iterator는 8 장에서 자세히 논의됩니다.) 다음과 같이 has() 메서드를 사용하여 어떤 값이 Set에 있는지 테스트할 수 있습니다. 123456let set = new Set();set.add(5);set.add(\"5\");console.log(set.has(5)); // trueconsole.log(set.has(6)); // false Set에는 값이 없기 때문에 set.has(6)는 false를 반환합니다. 값 지우기Set에서 값을 제거할 수도 있습니다. delete() 메서드를 사용하여 단일 값을 제거하거나 clear() 메서드를 호출하여 Set에서 모든 값을 제거할 수 있습니다. 아래 코드는 두 가지를 모두 보여줍니다. 123456789101112131415let set = new Set();set.add(5);set.add(\"5\");console.log(set.has(5)); // trueset.delete(5);console.log(set.has(5)); // falseconsole.log(set.size); // 1set.clear();console.log(set.has(\"5\")); // falseconsole.log(set.size); // 0 delete() 호출 후 5가 삭제되었습니다. clear() 메서드가 실행된 후 set은 모두 비어 있습니다. 이 모든 것이 정렬된 값을 추적하기 위한 매우 쉬운 메커니즘입니다. 그리고 Set에 항목을 추가한 다음 각 항목에 대해 일부 작업을 수행하려면 forEach() 메소드를 이용합니다. Set의 forEach 메서드Array 작업에 익숙하다면 이미 forEach() 메서드에 익숙할 것입니다. ECMAScript 5는 forEach()를 Array에 추가하여 Array의 각 항목에서 for 루프를 설정하지 않고 작업을 쉽게할 수 있게했습니다. 이 방법은 개발자들 사이에서 인기가 높으며 동일한 방법이 Set에서 사용 가능하고 동일한 방식으로 실행됩니다. forEach() 메서드는 세 개의 파라미터를 받는 콜백 함수가 전달됩니다. Set 내의 다음의 위치 값입니다. 첫 번째 파라미터와 같은 값 값을 읽는 Set Set의 forEach()가 Array의 forEach()와 특이한 차이점은 콜백 함수에 대한 첫 번째 및 두 번째 파라미터가 동일하다는 것입니다. 이것은 실수처럼 보일 수 있지만 타당한 이유가 있습니다. forEach() 메서드 (Array 및 Map)가 있는 다른 객체는 콜백 함수에 세 개의 파라미터를 전달합니다. Array와 Map의 최초의 2 개의 파라미터는, 값과 키 (Array의 인덱스 숫자)입니다. 그러나 Set에는 키가 없습니다. ECMAScript 6 표준을 작성한 사람들은 forEach()의 Set 버전에서 콜백 함수에 두 개의 파라미터를 허용하지만, Array와 Map의 파라미터와 다르게 만들었습니다. 대신 콜백 함수를 동일하게 유지하고 세 개의 파라미터를 허용하는 방법을 찾았습니다. Set의 첫 번째, 두 번째 파라미터는 키와 값으로 간주됩니다. 따라서 첫 번째와 두 번째 파라미터는 Array와 Map의 forEach() 메서드와 일관된 기능을 유지합니다. 파라미터의 차이 이외에, forEach()를 사용하는 것은 기본적으로 Array와 같습니다. 다음은 메서드가 실행되는 방식을 보여주는 코드입니다. 123456let set = new Set([1, 2]);set.forEach(function(value, key, ownerSet) &#123; console.log(key + \" \" + value); console.log(ownerSet === set);&#125;); 이 코드는 Set의 각 항목을 반복하여 forEach() 콜백 함수에 전달된 값을 출력합니다. 콜백 함수가 실행될 때마다 key와 value는 같고 ownerSet는 항상 set과 같습니다. 이 코드의 출력 결과는 아래와 같습니다. 12341 1true2 2true 콜백 함수에서 this를 사용해야한다면 forEach()의 두 번째 파라미터로 this 값을 전달할 수 있습니다. 1234567891011121314let set = new Set([1, 2]);let processor = &#123; output(value) &#123; console.log(value); &#125;, process(dataSet) &#123; dataSet.forEach(function(value) &#123; this.output(value); &#125;, this); &#125;&#125;;processor.process(set); 이 예제에서 processor.process() 메서드는 Set에서 forEach()를 호출하고 this를 콜백을 위한 this 값으로 전달합니다. 그래서 this.output()은 processor.output() 메서드로 올바르게 해석됩니다. forEach() 콜백 함수는 첫 번째 파라미터인 value만을 사용하므로 나머지는 생략합니다. Arrow 함수를 사용하여 두 번째 파라미터를 전달하지 않고 동일한 효과를 얻을 수도 있습니다. 123456789101112let set = new Set([1, 2]);let processor = &#123; output(value) &#123; console.log(value); &#125;, process(dataSet) &#123; dataSet.forEach((value) =&gt; this.output(value)); &#125;&#125;;processor.process(set); 위 예제의 Arrow 함수는 process() 함수에서 this를 읽어서 this.output()을 processor.output()호출로 올바르게 해석합니다. Set은 값을 추적하는데 적합하고 forEach()를 사용하여 순차적으로 각 값을 처리할 수 있지만, Array 처럼 인덱스를 사용하여 값에 직접 액세스할 수는 없습니다. 그렇게해야 할 경우, 가장 좋은 방법은 Set을 Array로 변환하는 것입니다. Set을 Array로 변환Array를 Set 생성자에 전달할 수 있기 때문에 Array를 Set으로 쉽게 변환할 수 있습니다. Spread 연산자를 사용하여 Set을 다시 Array로 변환하는 것도 쉽습니다. 3 장에서는 Array의 항목을 별도의 함수 매개 변수로 분할하는 방법으로 Spread 연산자 (...)를 설명했습니다. 또한 Spread 연산자를 사용하여 Set과 같은 반복 가능한 객체를 Array로 변환할 수 있습니다. 1234let set = new Set([1, 2, 3, 3, 3, 4, 5]), array = [...set];console.log(array); // [1,2,3,4,5] 여기서, Set은 초기에 중복을 포함하는 Array로 로드됩니다. Set은 중복을 제거한 다음 Spread 연산자를 사용하여 항목을 새로운 Array에 배치합니다. Set 자체에는 생성될 때받은 것과 동일한 항목 (1, 2, 3, 4 및 5)이 여전히 포함되어 새로운 Array로 복사됩니다. 이 방법은 이미 Array가 있지만 새로운 중복값 없이 Array를 만들려는 경우에 유용합니다. 12345678function eliminateDuplicates(items) &#123; return [...new Set(items)];&#125;let numbers = [1, 2, 3, 3, 3, 4, 5], noDuplicates = eliminateDuplicates(numbers);console.log(noDuplicates); // [1,2,3,4,5] eliminateDuplicates() 함수에서 Set은 중복이 없는 새로운 Array를 만들기 전에 중복 값을 필터링하는데 사용되는 임시 매개체 일뿐입니다. Weak SetSet 타입은 오브젝트 참조를 저장하는 방식 때문에 Strong Set이 라고 부를 수 있습니다. Set의 인스턴스에 저장된 객체는 그 객체를 변수 안에 저장하는 것과 실질적으로 동일합니다. 해당 Set 인스턴스에 대한 참조가 존재하는 한, 객체는 가비지 컬랙트되어 메모리를 비울 수 없습니다. 12345678910111213let set = new Set(), key = &#123;&#125;;set.add(key);console.log(set.size); // 1// 원래의 참조 삭제key = null;console.log(set.size); // 1// 원래의 참조를 되찾습니다.key = [...set][0]; 이 예제에서 key를 null로 설정하면 key 객체의 참조를 지우지만 다른 참조는 set 안에 남아 있습니다. 집합을 Spread 연산자로 Array로 변환하고 첫 번째 항목에 액세스하면 여전히 key를 검색할 수 있습니다. 대부분의 프로그램에서는 괜찮지만 때때로 다른 모든 참조가 사라지면 Set의 참조가 사라지는 것이 좋을 때도 있습니다. 예를 들어 웹 페이지에서 JavaScript 코드가 실행 중이고 다른 스크립트에 의해 제거 될 수있는 DOM 요소를 추적하려는 경우 코드가 DOM 요소에 대한 마지막 참조를 유지하지 못하게해야 합니다. (이 상황을 메모리 누수(memory leak)라고합니다.) 이러한 문제를 줄이기 위해 ECMAScript 6에는 약한 객체 참조만 저장하고 원시 값을 저장할 수없는 Weak Set도 포함하고 있습니다. 객체에 대한 약한 참조가 유일하게 남아있는 참조인 경우 가비지 컬렉션 대상이 됩니다. Weak Set 생성하기Weak Set은 WeakSet 생성자를 사용하여 생성되며 add(), has() 및 delete() 메서드를 포함합니다. 다음은이 세 가지를 모두 사용하는 예제입니다. 1234567891011let set = new WeakSet(), key = &#123;&#125;;// add the object to the setset.add(key);console.log(set.has(key)); // trueset.delete(key);console.log(set.has(key)); // false Weak Set을 사용하는 것은 보통 Set을 사용하는 것과 같습니다. Weak Set에서 참조를 추가, 제거 및 확인할 수 있습니다. Iterable을 생성자에 전달하여 값이 있는 Weak Set를 생성할 수도 있습니다. 123456let key1 = &#123;&#125;, key2 = &#123;&#125;, set = new WeakSet([key1, key2]);console.log(set.has(key1)); // trueconsole.log(set.has(key2)); // true 이 예제에서 Array는 WeakSet 생성자에 전달됩니다. 이 Array에는 두 개의 객체가 포함되어 있으므로 해당 객체가 Weak Set에 추가됩니다. WeakSet은 Primitive 값을 받아 들일 수 없으므로 Array에 객체가 아닌 값이 포함되어 있으면 오류가 발생합니다. Set 타입 간의 주요 차이점Weak Set와 정규 Set의 가장 큰 차이점은 객체 값에 약한 참조를 보유한다는 것입니다. 다음은 그 차이를 보여주는 예입니다. 12345678910let set = new WeakSet(), key = &#123;&#125;;// add the object to the setset.add(key);console.log(set.has(key)); // true// 키에 대한 마지막 strong reference를 제거하고 Weak Set에서 제거합니다.key = null; 이 코드가 실행된 후에, Weak Set의 key에 대한 참조는 더 이상 접근 가능하지 않습니다. 하지만 has() 메서드에 전달할 객체에 대한 참조가 필요하기 때문에 객체의 제거를 확인할 수 없습니다. 이렇게하면 Weak Set 테스트가 다소 혼란스럽지만, JavaScript 엔진이 참조를 제대로 제거했다는 것을 신뢰해야 합니다. 이 예제는 Weak Set이 일반 Set과 몇 가지 특성은 공유하지만 또한 몇 가지 중요한 차이점이 있음을 알려줍니다. WeakSet 인스턴스에서, 비 객체 add() 메서드는 오류를 throw합니다.(has() 및 delete()는 객체가 아닌 파라미터에 대해 항상 false를 반환) Weak Set은 Iterable이 아니므로 for-of 루프에서 사용할 수 없습니다. Weak Set은 Iterator(keys() 및 values() 메소드와 같은)를 노출시키지 않으므로 프로그래밍 방식으로 Weak Set의 내용을 판별할 수는 없습니다. Weak Set에는 forEach() 메서드가 없습니다. Weak Set에는 size 프로퍼티가 없습니다. 메모리를 적절히 처리하려면 Weak Set의 기능을 제한적으로 사용하는 것이 필요합니다. 객체 참조 추적을 한다면 일반 Set 대신 Weak Set를 사용합니다. Set은 값 목록을 처리하는 새로운 방법을 제공하지만 추가 정보를 해당 값과 연결해야하는 경우 유용하지 않습니다. 그래서 ECMAScript 6은 Map을 추가했습니다. ECMAScript 6의 MapECMAScript 6 Map 타입은 키-값 쌍의 정렬된 목록입니다. 여기서 키와 값은 어떤 타입도 가질 수 있습니다. 키는 Set 객체와 같은 접근법을 사용하여 결정됩니다. 그래서 5키와 &#39;5&#39;키를 가질 수 있습니다. 객체에서 프로퍼티를 키로 사용하는 것과 매우 다릅니다. 왜냐하면 객체의 프로퍼티는 항상 문자열로 강제 변환합니다. set() 메서드를 호출하고 키와 값을 전달하여 Map에 항목을 추가할 수 있습니다. 나중에 get() 메서드에 키를 전달하여 값을 검색할 수 있습니다. 123456let map = new Map();map.set(\"title\", \"Understanding ES6\");map.set(\"year\", 2016);console.log(map.get(\"title\")); // \"Understanding ES6\"console.log(map.get(\"year\")); // 2016 이 예에서는 두 개의 키-값 쌍이 저장됩니다. &quot;title&quot;키에는 문자열이 저장되고 &quot;year&quot;키에는 숫자가 저장됩니다. get() 메서드는 나중에 호출되어 두 키의 값을 검색합니다. Map에 키가 하나도 없으면 get()은 값 대신에 undefined라는 특수 값을 반환했을 것입니다. 객체를 키로 사용할 수도 있습니다. 이 방법은 이전에 객체 프로퍼티를 사용하여 Map을 만들던 방법으로는 불가능 했던걸 가능하게 합니다. 123456789let map = new Map(), key1 = &#123;&#125;, key2 = &#123;&#125;;map.set(key1, 5);map.set(key2, 42);console.log(map.get(key1)); // 5console.log(map.get(key2)); // 42 이 코드는 key1과 key2 객체를 Map의 키로 사용하여 두 개의 다른 값을 저장합니다. 이러한 키는 다른 형태로 강제 변환되지 않으므로 각 객체는 고유 한 것으로 간주됩니다. 이렇게하면 객체 자체를 수정하지 않고도 객체에 추가 데이터를 연결할 수 있습니다. Map 메서드Map은 여러 메서드를 Set과 공유합니다. 이는 의도적인 것이며, 비슷한 방식으로 Map 및 Set과 상호 작용할 수 있습니다. 아래의 세 가지 메서드는 Map과 Set에서 사용할 수 있습니다. has(key) - 지정된 키가 Map에 있는지 확인합니다. delete(key) - Map에서 키와 관련 값을 제거합니다. clear() - Map에서 모든 키와 값을 제거합니다. 또한 Map에는 키-값 쌍이 얼마나 많은지 나타내는 size 프로퍼티가 있습니다. 아래 코드는 세 가지 메서드와 사이즈를 모두 다른 방식으로 사용합니다. 1234567891011121314151617181920212223let map = new Map();map.set(\"name\", \"Nicholas\");map.set(\"age\", 25);console.log(map.size); // 2console.log(map.has(\"name\")); // trueconsole.log(map.get(\"name\")); // \"Nicholas\"console.log(map.has(\"age\")); // trueconsole.log(map.get(\"age\")); // 25map.delete(\"name\");console.log(map.has(\"name\")); // falseconsole.log(map.get(\"name\")); // undefinedconsole.log(map.size); // 1map.clear();console.log(map.has(\"name\")); // falseconsole.log(map.get(\"name\")); // undefinedconsole.log(map.has(\"age\")); // falseconsole.log(map.get(\"age\")); // undefinedconsole.log(map.size); // 0 Set과 마찬가지로 size 프로퍼티는 항상 키-값 쌍의 수를 Map에 포함합니다. 이 예제에서 Map 인스턴스는 &quot;name&quot;과 &quot;age&quot;키들로 시작합니다. 그래서 has() 메서드는 true를 리턴합니다. &quot;name&quot; 키가 delete() 메서드에 의해 제거된 후에 has() 메서드는 false를 리턴하고 size 프로퍼티는 1을 나타냅니다. 그런 다음 clear() 메서드는 나머지 키를 제거하고, size프로퍼티는 0, has()는 false를 반환합니다. clear() 메서드는 Map에서 많은 데이터를 빠르게 제거하는 방법이지만 한 번에 많은 데이터를 Map에 추가하는 방법도 있습니다. Map 초기화또한 Set과 유사하게 Array를 Map 생성자에 전달하여 데이터로 Map을 초기화할 수 있습니다. Array의 각 항목은 첫 번째 항목이 키이고 두 번째 항목이 키의 값인 Array이어야합니다. 따라서 전체 Map은 다음과 같은 Array의 Array입니다. 1234567let map = new Map([[\"name\", \"Nicholas\"], [\"age\", 25]]);console.log(map.has(\"name\")); // trueconsole.log(map.get(\"name\")); // \"Nicholas\"console.log(map.has(\"age\")); // trueconsole.log(map.get(\"age\")); // 25console.log(map.size); // 2 키 &quot;name&quot;과 &quot;age&quot;는 생성자의 초기화를 통해 map에 추가됩니다. Array의 Array가 조금 이상하게 보일 수도 있지만 키는 모든 데이터 타입이 될 수 있으므로 키를 정확하게 나타내야합니다. 키를 Array에 저장하는 것이 Map에 저장되기 전에 다른 데이터 타입으로 강제 변환되지 않도록하는 유일한 방법입니다. Map에서의 forEach 메서드Map에 대한 forEach() 메서드는 세 개의 파라미터를 받는 콜백 함수를 허용한다는 점에서 Set 및 Array의 forEach()와 유사합니다. Map의 다음 위치 값 그 값의 키 값을 읽는 Map 이러한 콜백 파라미터는 첫 번째 파라미터가 값이고 두 번째 파라미터가 키 (Array의 숫자 인덱스에 해당) 인 Array의 forEach () 동작과 비슷합니다. 다음은 그 예입니다. 123456let map = new Map([ [\"name\", \"Nicholas\"], [\"age\", 25]]);map.forEach(function(value, key, ownerMap) &#123; console.log(key + \" \" + value); console.log(ownerMap === map);&#125;); forEach() 콜백 함수는 전달된 정보를 출력합니다. value와 key는 직접 출력되고, ownerMap은 map과 비교되어 값이 동일 함을 보여줍니다. 결과는 다음과 같습니다. 1234name Nicholastrueage 25true forEach()에 전달된 콜백은 Map에 삽입된 순서대로 각 키-값 쌍을 받습니다. 이 동작은 콜백이 숫자 인덱스 순서대로 각 항목을 받는 Array의 forEach()가 호출되는 것과 약간 다릅니다. forEach()에 두 번째 파라미터를 제공하여 콜백 함수 내에서 this 값을 지정할 수도 있습니다. 이와 같은 호출은 Set 버전의 forEach() 메서드와 동일하게 작동합니다. Weak MapWeak Map은 약한 객체 참조를 저장하는 방법입니다. Weak Map에서는 모든 키가 객체여야 하며 (객체가 아닌 키를 사용하려고하면 오류가 발생 함) 이러한 객체 참조는 가비지 컬랙트를 방해하지 않도록 약하게 유지됩니다. Weak Map 외부의 키에 대한 참조가 없으면 Weak Map에서 키-값 쌍이 제거됩니다. Weak Map을 사용하는 가장 유용한 장소는 웹 페이지의 특정 DOM 엘리먼트와 관련된 객체를 만드는 경우입니다. 예를 들어 웹 페이지용 JavaScript 라이브러리 중 일부는 라이브러리에서 참조하는 모든 DOM 엘리먼트에 대해 특정 사용자 정의 객체를 유지하고 해당 매핑은 내부적으로 객체 캐시에 저장됩니다. 이 접근법의 어려운 부분은 DOM 엘리먼트가 웹 페이지에 더 이상 존재하지 않아 라이브러리가 관련 객체를 제거할 수 없을 때를 결정하는 것입니다. 그렇지 않으면 라이브러리가 참조 엘리먼트의 유용성을 넘어 DOM 엘리먼트 참조를 유지하고 메모리 누수가 발생합니다. Weak Map으로 DOM 엘리먼트를 추적하면 라이브러리가 모든 DOM 엘리먼트와 객체를 연결할 수 있으며 해당 객체의 DOM 엘러먼트가 더 이상 존재하지 않으면 Map의 객체를 자동으로 삭제할 수 있습니다. Weak Map 값이 아닌 Weak Map 키만 약한 참조임을 유의해야합니다. Weak Map 값으로 저장된 오브젝트는 다른 모든 참조가 제거되어도 가비지 콜렉션 대상이 아닙니다. Weak Map 사용하기ECMAScript 6 WeakMap 타입은 키와 값 쌍의 정렬되지 않은 목록입니다. 여기서 키는 null이 아닌 객체여야 하며 값은 모든 타입이 될 수 있습니다. WeakMap은 set()과 get()이 각각 데이터를 추가하고 검색하는 데 사용된다는 점에서 Map의 인터페이스와 매우 유사합니다. 12345678910111213let map = new WeakMap(), element = document.querySelector(\".element\");map.set(element, \"Original\");let value = map.get(element);console.log(value); // \"Original\"// remove the elementelement.parentNode.removeChild(element);element = null;// the weak map is empty at this point 이 예제는 키-값 쌍 하나가 저장됩니다. element 키는 해당 문자열 값을 저장하는 데 사용되는 DOM 엘리먼트입니다. 그 값은 DOM 엘레멘트를 get() 메서드에 전달해서 얻습니다. 나중에 DOM 엘리먼트가 Document에서 제거되고 이를 참조하는 변수가 null로 설정되면 데이터도 Weak Map에서 제거됩니다. Weak Set과 마찬가지로 size 프로퍼티가 없기 때문에 Weak Map이 비어 있는지 확인할 방법이 없습니다. 키에 대한 참조가 남아 있지 않으므로 get() 메서드를 호출하여 값을 검색할 수 없습니다. Weak Map은 그 키에 대한 값의 액세스를 차단하고, 가비지 컬렉터가 실행될 때 값으로 점유된 메모리는 해제됩니다. Weak Map 초기화Weak Map을 초기화하려면 WeakMap 생성자에 Array의 Array를 전달합니다. 일반 Map을 초기화하는 것처럼 포함하는 Array의 각 Array에는 두 개의 항목이 있어야합니다. 첫 번째 항목은 null이 아닌 객체 키이고 두 번째 항목은 값 (모든 데이터 유형)입니다. 12345678let key1 = &#123;&#125;, key2 = &#123;&#125;, map = new WeakMap([[key1, \"Hello\"], [key2, 42]]);console.log(map.has(key1)); // trueconsole.log(map.get(key1)); // \"Hello\"console.log(map.has(key2)); // trueconsole.log(map.get(key2)); // 42 key1 및 key2 객체는 Weak Map에서 키로 사용되며 get() 및 has() 메서드를 통해 해당 객체에 액세스할 수 있습니다. WeakMap 생성자가 어떤 키-값 쌍에서 객체가 아닌 키를 받으면 오류가 발생합니다. Weak Map 메서드Weak Map에는 키-값 쌍과 상호 작용할 수있는 두 가지 추가 방법이 있습니다. 특정 키가 Map에 있는지 확인하는 has() 메소드와 특정 키-값 쌍을 제거하는 delete() 메소드가 있습니다. Weak Map에서는 Weak Set 처럼 키를 열거하는 것이 불가능 하기 때문에 clear() 메서드가 없습니다. 아래 예제에서는 has() 및 delete() 메서드를 모두 사용합니다. 1234567891011let map = new WeakMap(), element = document.querySelector(\".element\");map.set(element, \"Original\");console.log(map.has(element)); // trueconsole.log(map.get(element)); // \"Original\"map.delete(element);console.log(map.has(element)); // falseconsole.log(map.get(element)); // undefined 위 예제에서 DOM 엘리먼트를 Weak Map에서 키로 사용됩니다. has() 메서드는 참조가 현재 Weak Map에서 키로 사용되고 있는지 확인하는 데 유용합니다. 이것은 키에 대한 null이 아닌 참조가 있는 경우에만 작동한다는 점에 유의하십시오. 키는 delete() 메서드에 의해 Weak Map에서 강제로 제거됩니다. 그리고 has()는 false를 반환하고 get()은 undefined를 반환합니다. Private Object Data대부분의 개발자는 Weak Map의 주요 유스 케이스가 DOM 엘리먼트와 관련된 데이터라고 생각하지만 다른 많은 용도가 있습니다 (의심의 여지가 있지만 아직 발견되지 않은 것). Weak Map을 실제로 사용하는 한 가지 방법은 객체 인스턴스에 Private 데이터를 저장하는 것입니다. ECMAScript 6에서는 모든 객체 프로퍼티가 public이므로 객체에 액세스할 수있는 데이터를 만들려면 창의력을 사용해야하지만 모든 객체에 액세스할 수는 없습니다 다음 예제를 살펴 보겠습니다. 1234567function Person(name) &#123; this._name = name;&#125;Person.prototype.getName = function() &#123; return this._name;&#125;; 이 코드는 일반적인 규칙인 선행 밑줄을 사용하였기 때문에 프로퍼티가 Private으로 간주되므로 객체 인스턴스 외부에서 수정하면 안됩니다. 의도는 getName()을 사용하여 this._name을 읽고 _name 값을 변경하지 못하게하는 것입니다. 그러나 _name 프로퍼티를 작성하는 사람은 의도적으로 또는 실수로 덮어 쓸 수 있습니다. ECMAScript 5에서는 다음과 같은 패턴을 사용하여 객체를 생성하여 진정한 Private 데이터를 가질 수 있습니다. 12345678910111213141516171819var Person = (function() &#123; var privateData = &#123;&#125;, privateId = 0; function Person(name) &#123; Object.defineProperty(this, \"_id\", &#123; value: privateId++ &#125;); privateData[this._id] = &#123; name: name &#125;; &#125; Person.prototype.getName = function() &#123; return privateData[this._id].name; &#125;; return Person;&#125;()); 이 예제는 두 개의 Private 변수 인 privateData와 privateId를 포함하는 IIFE에 Person의 정의를 래핑합니다. privateData 객체는 각 인스턴스에 대한 개인 정보를 저장하는 반면 privateId는 각 인스턴스에 대해 고유 한 ID를 생성하는데 사용됩니다. Person 생성자가 호출 될 때, nonumerable, nonconfigurable, 그리고 nonwritable _id 프로퍼티가 추가됩니다. 그런 다음 객체 인스턴스의 ID에 해당하는 privateData 객체에 항목이 만들어지고 그 이름이 저장됩니다. 나중에 getName() 함수에서 this._id를 privateData의 키로 사용하여 이름을 검색할 수 있습니다. privateData는 IIFE 외부에서 접근할 수 없으므로 this._id가 공개 되어도 실제 데이터는 안전합니다. 이 접근법의 가장 큰 문제점은 객체 인스턴스가 언제 파괴되는지를 알 수 없기 때문에 privateData의 데이터가 사라지지 않는다는 것입니다. privateData 객체는 항상 여분의 데이터를 포함합니다. 이 문제는 다음과 같이 Weak Map을 대신 사용하여 해결할 수 있습니다. 1234567891011121314let Person = (function() &#123; let privateData = new WeakMap(); function Person(name) &#123; privateData.set(this, &#123; name: name &#125;); &#125; Person.prototype.getName = function() &#123; return privateData.get(this).name; &#125;; return Person;&#125;()); 이 버전의 Person 예제는 객체가 아닌 Private 데이터용 Weak Map을 사용합니다. Person 객체 인스턴스 자체를 키로 사용할 수 있기 때문에 별도의 ID를 추적할 필요가 없습니다. Person 생성자가 호출되면 weak 필드에 this키와 개인 정보가 들어있는 객체의 값을 가진 새로운 항목이 만들어집니다. 이 경우 값은 name만 포함하는 객체입니다. getName() 함수는 privateData.get() 메소드에 this를 전달하여 해당 개인 정보를 검색합니다. privateData.get() 메소드는 값 객체를 입력받아 name 프로퍼티에 액세스합니다. 이 기법은 개인 정보를 비공개로 유지하고, 관련 정보가 파괴될 때마다 정보도 파괴됩니다. Weak Map 사용 및 제한 사항Weak Map 또는 일반 Map을 사용할지 여부를 결정할 때 고려해야 할 기본 결정은 객체 키만 사용할지 여부입니다. 언제든지 객체 키만 사용하려고 할 때 가장 좋은 선택은 Weak map입니다. 이렇게하면 여분의 데이터는 더이상 유지되지 않고 액세스할 수 없어 메모리 사용을 최적화하고 메모리 누수를 피할 수 있습니다. Weak Map은 내용을 거의 볼 수 없으므로 forEach() 메서드, size 프로퍼티 또는 clear() 메서드를 사용하여 항목을 관리할 수 없습니다. 몇 가지 검사 기능이 필요한 경우 일반 Map을 사용하는 것이 좋습니다. 메모리 사용을 주시하십시오. 물론 객체가 아닌 키만 사용하려는 경우 일반 Map만 선택할 수 있습니다. 요약ECMAScript 6은 정식으로 Set과 Map을 JavaScript에 도입했습니다. 이전에는 개발자가 객체를 사용하여 Set과 Map을 모방하는 경우가 많았습니다. 하지만 객체 프로퍼티와 관련된 제한으로 인해 종종 문제가 발생했습니다. Set은 고유한 값의 정렬된 목록입니다. 같은지 여부를 판별하는 값을 가지고 있지 않습니다. Set는 중복값을 자동으로 제거하므로 Set을 사용하여 Array의 중복된 값을 필터링하고 결과를 반환할 수 있습니다. Set은 Array의 하위 클래스가 아니므로 Set의 값에 임의로 액세스할 수는 없습니다. 대신 has() 메서드를 사용하여 값이 Set에 포함되어 있는지 확인하고 Set의 개수를 알려주는 size 프로퍼티를 사용할 수 있습니다. Set 타입은 각 값을 처리하기 위한 forEach() 메서드를 가지고 있습니다. Weak Set은 객체만 포함할 수있는 특수 Set입니다. 해당 객체는 약한 참조로 저장됩니다. 즉, Weak Set의 항목은 해당 항목이 객체에 대한 유일한 참조인 경우 가비지 컬렉트 대상이 됩니다. Weak Set 내용은 메모리 관리의 복잡성 때문에 검사할 수 없으므로 함께 그룹화 해야하는 객체 추적에만 Weak Set를 사용하는 것이 가장 좋습니다. Map은 정렬된 키-값 쌍입니다. 여기서 키는 모든 데이터 타입이 될 수 있습니다. Set과 마찬가지로 키는 같음여부를 판별하기 위해 강제변환이 실행되지 않으므로 숫자 키 5와 문자열 &quot;5&quot;를 별개의 두 개의 키로 가질 수 있습니다. 모든 데이터 타입의 값은 set() 메서드를 사용하여 키의 값이 될수 있으며, 그 값은 나중에 get() 메소드를 사용하여 검색할 수 있습니다. Map에는 size 프로퍼티와 forEach() 메서드가 있어 보다 쉽게 항목에 액세스할 수 있습니다. Weak Map은 객체 키만 가질 수있는 특별한 타입의 Map입니다. Weak Set과 마찬가지로 객체 키 참조는 약하며 객체에 대한 유일하게 남아있는 참조인 경우 가비지 컬렉트 대상이 됩니다. 키가 가비지 컬렉트되면 키와 연관된 값도 Weak Map에서 제거됩니다. 이 메모리 관리 측면은 추가 정보를 액세스하는 코드 외부에서 라이프사이클이 관리되는 구조에 Weak Map이 적합합니다. 이 내용은 나중에 참고하기 위해 제가 공부하며 정리한 내용입니다.의역, 오역, 직역이 있을 수 있음을 알려드립니다.This post is a translation of this original article [https://leanpub.com/understandinges6/read#leanpub-auto-sets-and-maps] 참고 ECMAScript 6 Block Binding ECMAScript 6 문자열과 정규 표현식 ECMAScript 6 함수 ECMAScript 6 객체의 확장된 기능 ECMAScript 6 쉬운 데이터 액세스를 위한 Destructuring ECMAScript 6 Symbol과 Symbol 프로퍼티 ECMAScript 6 Set과 Map ECMAScript 6 Iterator와 Generator ECMAScript 6 JavaScript 클래스 소개 ECMAScript 6 Array 기능 향상 ECMAScript 6 Promise와 비동기 프로그램밍 ECMAScript 6 프록시와 리플렉션 API ECMAScript 6 Module로 코드 캡슐화하기 ECMAScript 6 부록 A. 작은 변경 사항 ECMAScript 6 부록 B. ECMAScript 7(2016) 이해하기","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://infoscis.github.io/categories/JavaScript/"},{"name":"ECMAScript 2015","slug":"JavaScript/ECMAScript-2015","permalink":"http://infoscis.github.io/categories/JavaScript/ECMAScript-2015/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://infoscis.github.io/tags/JavaScript/"},{"name":"ECMAScript 2015","slug":"ECMAScript-2015","permalink":"http://infoscis.github.io/tags/ECMAScript-2015/"}]},{"title":"ECMAScript 6 Symbol과 Symbol 프로퍼티","slug":"ecmascript-6-symbols-and-symbol-properties","date":"2018-01-27T14:08:05.000Z","updated":"2018-02-27T14:12:27.117Z","comments":true,"path":"2018/01/27/ecmascript-6-symbols-and-symbol-properties/","link":"","permalink":"http://infoscis.github.io/2018/01/27/ecmascript-6-symbols-and-symbol-properties/","excerpt":"","text":"Symbols과 Symbol 프로퍼티Symbol은 ECMAScript 6에서 도입된 Primitive 타입으로, 기존의 string, number, boolean, null, undefined와 같은 타입입니다. Symbol은 객체의 Private 멤버를 생성하는 방법으로 시작되었는데, JavaScript 개발자들이 오랫동안 원했던 기능입니다. Symbol 이전에는 이름이 있는 프로퍼티는 이름의 모호함에 관계없이 쉽게 액세스할 수 있었고 Private name 기능은 개발자가 문자열이 아닌 프로퍼티 이름을 만들 수 있도록 하기위한 것입니다. 그리고 일반적인 방법으로 Private name에 대한 탐지는 작동하지 않습니다. Private name에 대한 제안은 마침내 ECMAScript 6 Symbol로 진화했습니다. 이장에서는 Symbol을 효과적으로 사용하는 법을 가르쳐줄 것입니다. 구현 세부 사항은 동일하게 유지되었지만 (즉, 프로퍼티 이름에 문자열이 아닌 값을 추가 한 경우) Privacy에 대한 부분은 삭제되었습니다. 대신 Symbol 프로퍼티는 다른 객체 프로퍼티와 구분되어 분류됩니다. Symbol 생성하기Symbol은 JavaScript Primitive 중, boolean은 true, number는 42와 같은 리터럴이 없는 유일한 타입니다. 아래 예제와 같이 전역Symbol 함수를 사용하여 Symbol을 만들 수 있습니다. 12345let firstName = Symbol();let person = &#123;&#125;;person[firstName] = \"Nicholas\";console.log(person[firstName]); // \"Nicholas\" 위 예제의 Symbol firstName은 person 객체에 새로운 프로퍼티를 할당하기 위해 만들어지고 사용됩니다. 이 Symbol은 동일한 프로퍼티에 액세스할 때마다 사용 해야합니다. Symbol 변수에 적절한 이름을 부여하는 것은 좋은 생각입니다. Symbol이 무엇을 나타내는지 쉽게 알 수 있기 때문입니다. Symbol은 Primitive이기 때문에 new Symbol()을 호출하면 오류가 발생합니다. Symbol의 인스턴스를 new Object (yourSymbol)을 통해서 만들 수도 있습니다. 하지만 이 기능이 그렇게 유용하지 않습니다. Symbol 함수는 Symbol에 대한 설명을 위해 Optional 파라미터도 받아들입니다. 설명 자체는 프로퍼티에 액세스하는데 사용할 수 없지만 디버깅 목적으로 사용될 수 있습니다. 12345678let firstName = Symbol(\"first name\");let person = &#123;&#125;;person[firstName] = \"Nicholas\";console.log(\"first name\" in person); // falseconsole.log(person[firstName]); // \"Nicholas\"console.log(firstName); // \"Symbol(first name)\" Symbol의 설명은 내부적으로 [[Description]] 프로퍼티에 저장됩니다. 이 프로퍼티는 Symbol의 toString() 메서드가 명시적으로 또는 암시적으로 호출될 때마다 읽혀집니다. firstName Symbol의 toString() 메서드는 이 예제에서 console.log()에 의해 암시적으로 호출되므로 설명이 log에 출력됩니다. 코드에서 직접 [[Description]]에 액세스할 수 없습니다. 필자는 항상 Symbol을 읽고 디버깅하기 쉽도록 설명을 제공할 것을 권장합니다. Symbol 식별하기Symbol은 Primitive이기 때문에 typeof 연산자를 사용하여 변수에 Symbol이 포함되어 있는지 확인할 수 있습니다. ECMAScript 6은 typeof를 확장하여 Symbol에 사용될 때 &quot;symbol&quot;을 반환하도록 합니다. 12let symbol = Symbol(\"test symbol\");console.log(typeof symbol); // \"symbol\" 변수가 Symbol인지 여부를 결정하는 다른 간접적인 방법이 있지만 typeof 연산자가 가장 정확하고 선호되는 기술입니다. Symbol 사용하기계산된 프로퍼티 이름을 사용하는 곳이면 어디에서나 Symbol을 사용할 수 있습니다. 이장에서 Symbol 과 함께 사용된 괄호 표기법을 이미 보았지만 아래의 호출과 같이 Object.defineProperty()와 Object.defineProperties()뿐만 아니라 계산된 객체 리터럴 프로퍼티 이름에서도 Symbol을 사용할 수 있습니다. 123456789101112131415161718192021let firstName = Symbol(\"first name\");// 계산된 객체 리터럴 프로퍼티 사용let person = &#123; [firstName]: \"Nicholas\"&#125;;// 프로퍼티를 읽기전용으로 만듭니다.Object.defineProperty(person, firstName, &#123; writable: false &#125;);let lastName = Symbol(\"last name\");Object.defineProperties(person, &#123; [lastName]: &#123; value: \"Zakas\", writable: false &#125;&#125;);console.log(person[firstName]); // \"Nicholas\"console.log(person[lastName]); // \"Zakas\" 위 예제는 먼저 계산된 객체 리터럴 프로퍼티를 사용하여 firstName Symbol 프로퍼티를 만듭니다. 그 다음 라인은 프로퍼티를 읽기 전용으로 설정합니다. 그후에, Object.defineProperties() 메서드를 사용하여 읽기 전용 lastName Symbol 프로퍼티를 생성합니다. 계산된 객체 리터럴 프로퍼티가 다시 한번 사용되지만 Object.defineProperties() 호출의 두 번째 파라미터의 일부입니다. Symbol은 계산된 프로퍼티 이름이 허용되는 곳이면 어디에서나 사용할 수 있지만, 효과적으로 사용할 수 있도록 이들 Symbol*을 다른 코드 사이에서 공유할 수있는 시스템이 필요합니다. Symbol 공유하기여러분은 코드의 다른 부분에서 같은 Symbol을 사용하기 원할 수도 있습니다. 예를 들어, 응용 프로그램에서 고유 식별자를 나타내기 위해 동일한 Symbol 프로퍼티를 사용해야하는 두개의 다른 객체 타입이 있다고 가정하겠습니다. 파일이나 큰 코드베이스에서 Symbol을 추적하는 것은 어렵고 오류가 발생할 수 있습니다. 그래서 ECMAScript 6는 어느 시점에서나 액세스할 수 있는 전역 Symbol 레지스트리를 제공합니다. 공유할 Symbol을 생성하려면 Symbol() 메서드를 호출하는 대신 Symbol.for() 메서드를 사용합니다. Symbol.for() 메서드는 여러분이 생성하고자하는 Symbol을 위한 문자열 식별자로 단일 파라미터를 받아들입니다. 그리고 이 파라미터는 Symbol의 설명으로도 사용됩니다. 1234567let uid = Symbol.for(\"uid\");let object = &#123;&#125;;object[uid] = \"12345\";console.log(object[uid]); // \"12345\"console.log(uid); // \"Symbol(uid)\" Symbol.for() 메서드는 먼저 전역 Symbol 레지스트리를 검색하여 “uid” 키가 있는 Symbol이 있는지 확인합니다. 만약 Symbol이 있다면 이 메서드는 기존의 Symbol을 리턴합니다. 그런데 만약 없다면 새로운 Symbol을 생성하고 지정된 키를 사용하여 전역 Symbol 레지스트리에 등록합니다. 그리고 새로운 Symbol을 리턴합니다. 즉, 같은 키를 사용하는 Symbol.for()에 대한 후속 호출은 다음과 같이 동일한 Symbol을 반환합니다. 12345678910111213let uid = Symbol.for(\"uid\");let object = &#123; [uid]: \"12345\"&#125;;console.log(object[uid]); // \"12345\"console.log(uid); // \"Symbol(uid)\"let uid2 = Symbol.for(\"uid\");console.log(uid === uid2); // trueconsole.log(object[uid2]); // \"12345\"console.log(uid2); // \"Symbol(uid)\" 위 예제에서 uid와 uid2는 같은 Symbol을 사용하고 있습니다. 그래서 서로 바꿔서 사용할 수도 있습니다. Symbol.for()에 대한 첫 번째 호출은 Symbol을 생성하고 두 번째 호출은 전역 Symbol 저장소에서 Symbol을 가져옵니다. 공유 Symbol의 또 다른 독특한 부분은 Symbol.keyFor() 메서드를 호출하여 전역 Symbol 레지스트리에서 Symbol과 연관된 키를 검색할 수 있다는 것입니다. 12345678let uid = Symbol.for(\"uid\");console.log(Symbol.keyFor(uid)); // \"uid\"let uid2 = Symbol.for(\"uid\");console.log(Symbol.keyFor(uid2)); // \"uid\"let uid3 = Symbol(\"uid\");console.log(Symbol.keyFor(uid3)); // undefined uid와 uid2는 모두 “uid”키를 반환합니다. Symbol uid3은 전역 Symbol 레지스트리에 존재하지 않으므로, 관련된 키가 없으며Symbol.keyFor()는 undefined를 리턴합니다. 글로벌 Symbol 레지스트리는 글로벌 Scope와 같은 공유 환경입니다. 이는 해당 환경에 이미 존재하거나 존재하지 않는 것에 대해 가정할 수 없음을 의미합니다. 서드파티 컴포넌트를 사용할 때 충돌을 일으킬 가능성을 줄이기 위해 Symbol 키의 네임 스페이스를 사용할 수 있습니다. 예를 들어,jQuery 코드는 &quot;jquery.element&quot;또는 유사한 방법으로 모든 키에 &quot;jquery.&quot; 접두사를 사용할 수 있습니다. Symbol 강제 변환 (Coercion)타입 강제 변환은 JavaScript의 중요한 부분이며, 한 데이터 타입을 다른 데이터 타입으로 강제 변환하는 것은 많은 유연성이 있습니다. 그러나 Symbol은 타입 강제 변환에 있어서는 꽤 융통성이 없습니다. 왜냐하면 다른 타입은 Symbol과 논리적으로 동등하지 않기 때문입니다. 특히 Symbol은 string이나 number로 강제 변환 될 수 없으므로 실수로 Symbol로 예상되는 프로퍼티에 다른 타입을 사용할 수 없습니다. 이 장에서는 console.log()를 사용하여 Symbol에 대한 결과를 보여줍니다. console.log()가 Symbol에 대해 String()을 호출하여 유용한 출력을 생성합니다. String()을 직접 사용해도 같은 결과를 얻을 수 있습니다. 1234let uid = Symbol.for(\"uid\"), desc = String(uid);console.log(desc); // \"Symbol(uid)\" String() 함수는 uid.toString()을 호출고 Symbol은 설명 문자열을 반환합니다. 그러나 Symbol을 문자열과 직접 연결하려고 하면 오류가 발생합니다. 12let uid = Symbol.for(\"uid\"), desc = uid + \"\"; // error! uid와 빈 문자열을 연결하려면 uid가 먼저 string으로 강제 변환 되어야합니다. JavaScript는 Symbol의 강제 변환이 발견되면 에러를 발생시킵니다. 비슷하게, Symbol을 number로 강제 변환할 수도 없습니다. 모든 수학 연산자가 Symbol에 적용될 때 오류를 발생시킵니다. 12let uid = Symbol.for(\"uid\"), sum = uid / 1; // error! 이 예제는 Symbol 변수를 1로 나눕니다. 사용된 수학 연산자에 관계없이 모두 오류가 발생합니다. 하지만 논리 연산자는 JavaScript의 다른 비어 있지 않은 값과 마찬가지로 true와 동일한 것으로 간주되기 때문에 오류가 발생하지 않습니다. Symbol 프로퍼티 검색하기Object.keys() 및 Object.getOwnPropertyNames() 메서드는 객체의 모든 프로퍼티 이름을 검색할 수 있습니다. 전자의 경우 열거 가능한 모든 프로퍼티 이름을 반환하고 후자는 열거 가능 여부에 관계없이 모든 프로퍼티를 반환합니다. 그러나 두 메서드 모두 ECMAScript 5 기능을 유지하기 위해 Symbol 프로퍼티를 반환하지 않습니다. 대신, 객체로부터 Symbol 프로퍼티를 검색할 수 있도록하기 위해 Object.getOwnPropertySymbols() 메서드가 ECMAScript 6에 추가되었습니다. Object.getOwnPropertySymbols()의 리턴 값은 자신의 Symbol 프로퍼티의 Array입니다. 12345678910let uid = Symbol.for(\"uid\");let object = &#123; [uid]: \"12345\"&#125;;let symbols = Object.getOwnPropertySymbols(object);console.log(symbols.length); // 1console.log(symbols[0]); // \"Symbol(uid)\"console.log(object[symbols[0]]); // \"12345\" 이 코드에서 object는 uid라는 단일 Symbol 프로퍼티를 가지고 있습니다. Object.getOwnPropertySymbols()에서 반환된 Array은 Symbol을 포함하는 Array입니다. 모든 객체는 0개의 자체 Symbol 프로퍼티로 시작하지만 프로토타입에서 Symbol 프로퍼티를 상속받을 수 있습니다. ECMAScript 6는 Well-known Symbol이라고 불리는 미리 구현된 여러 프로퍼티를 정의합니다. Well-Known Symbol을 이용한 내부 Operation 표현ECMAScript 5의 핵심 테마는 JavaScript의 “magic” 부분 중 일부를 노출하고 정의하는 것이 었습니다. 이부분은 개발자가 Emulate할 수 없는 부분이었습니다. ECMAScript 6는 이전 버전 언어의 내부 논리를 더 많이 드러냄으로써 그 전통을 이어 나갔습니다. 주로 특정 객체의 기본 동작을 정의하기 위해 Symbol 프로토 타입 프로퍼티를 사용합니다. ECMAScript 6에는 이전에 내부 전용 작업으로 간주되었던 JavaScript의 일반적인 동작을 나타내는 Well-known Symbol이라는 미리 정의된 Symbol이 있습니다. 각각의 Well-known Symbol은 Symbol.create와 같이 Symbol 객체의 프로퍼티로 표현됩니다. Well-known Symbol은 아래와 같습니다. Symbol.hasInstance - 객체의 상속을 결정하기 위해 instanceof가 사용하는 메서드. Symbol.isConcatSpreadable - 컬렉션이 Array.prototype.concat()에 파라미터로 전달되면 Array.prototype.concat()이 컬렉션의 요소를 flat하게 해야한다는 것을 나타내는 boolean 값. Symbol.iterator - Iterator를 반환하는 메서드. (Iterator는 7 장에서 다룹니다.) Symbol.match - 문자열을 비교하기 위해 String.prototype.match()에 의해 사용되는 메서드. Symbol.replace - String.prototype.replace()가 substring을 치환하기 위해서 사용하는 메서드. Symbol.search - String.prototype.search()가 substring의 위치를 찾아 내기 위해서 사용하는 메서드. Symbol.species - 파생된(Derived) 객체를 만들기위한 생성자. (Derived 객체에 대해서는 8 장에서 다룹니다.) Symbol.split - 문자열을 분할하기 위해 String.prototype.split()에서 사용하는 메서드. Symbol.toPrimitive - 객체의 Primitive 값 표현을 반환하는 메서드. Symbol.toStringTag - Object 설명을 생성하기 위해서 Object.prototype.toString()에 의해 사용되는 문자열. Symbol.unscopables - with 문에 포함되어서는 안되는 프로퍼티가 객체 프로퍼티의 이름인 객체. 흔히 사용되는 Well-known Symbol은 다음 절에서 논의하고 나머지는 책의 나머지 전체에서 논의합니다. 정의된 메서드를 Well-known Symbol로 덮어 쓰는 것은 내부 객체를 외부 객체로 바꾸는 것입니다. 결과적으로 코드에 실제적인 영향은 없으며, 객체 사양을 설명하는 방식이 변경됩니다. Symbol.hasInstance 프로퍼티모든 함수는 주어진 객체가 그 함수의 인스턴스인지 아닌지를 결정하는 Symbol.hasInstance 메서드를 가지고 있습니다. 이 메서드는 Function.prototype에 정의되어 모든 함수가 instanceof 프로퍼티에 대한 기본 동작을 상속받으며 메서드는 쓰기가 불가능(nonwritable)하고 설정이 불가능(nonconfigurable)하고 열거가 불가능(nonenumerable)하여 실수로 덮어 쓸수 없습니다. Symbol.hasInstance 메서드는 하나의 파라미터, 즉 확인할 값만 받아들입니다. 전달된 값이 함수의 인스턴스이면 true를 반환합니다. Symbol.hasInstance가 어떻게 작동하는지 이해하기 위해 다음 코드를 살펴보겠습니다. 1obj instanceof Array; 이 코드는 다음과 같습니다. 1Array[Symbol.hasInstance](obj); ECMAScript 6은 근본적으로 instanceof 연산자를 메서드 호출의 축약 구문으로 재정의했습니다. 메서드 호출로 변경되었기 때문에 여러분이 실제로 instanceof가 어떻게 작동하는지 원하는데로 바꿀 수 있습니다. 예를 들어, 객체를 인스턴스로 요구하지 않는 함수를 정의한다고 가정합니다. Symbol.hasInstance의 반환 값을 false로 하드 코딩하면 다음과 같이할 수 있습니다. 12345678910111213function MyObject() &#123; // ...&#125;Object.defineProperty(MyObject, Symbol.hasInstance, &#123; value: function(v) &#123; return false; &#125;&#125;);let obj = new MyObject();console.log(obj instanceof MyObject); // false 쓰기가 불가능한(nonwritable) 프로퍼티를 덮어 쓰려면 Object.defineProperty()를 사용 해야합니다. 그래서 이 예제는 그 메서드를 사용하여Symbol.hasInstance 메서드를 새로운 함수로 덮어 씁니다. 새로운 함수는 항상 false를 반환하기 때문에 obj가 실제로 MyObject 클래스의 인스턴스이더라도 instanceof 연산자는 Object.defineProperty()호출 후에 false를 반환합니다. 물론 여러분은 값을 검사하고 임의의 조건을 기반으로 값을 인스턴스로 간주해야하는지 여부를 결정할 수도 있습니다. 예를 들어, 1과 100 사이의 값을 가진 숫자는 특별한 number 타입의 인스턴스로 간주됩니다. 이 동작을 수행하기 위해 다음과 같이 코드를 작성할 수 있습니다. 123456789101112131415function SpecialNumber() &#123; // empty&#125;Object.defineProperty(SpecialNumber, Symbol.hasInstance, &#123; value: function(v) &#123; return (v instanceof Number) &amp;&amp; (v &gt;=1 &amp;&amp; v &lt;= 100); &#125;&#125;);let two = new Number(2), zero = new Number(0);console.log(two instanceof SpecialNumber); // trueconsole.log(zero instanceof SpecialNumber); // false 이 코드는 값이 Number의 인스턴스이고 또한 1과 100 사이의 값을 가지면 true를 리턴하는 Symbol.hasInstance 메서드를 정의합니다. 따라서 SpecialNumber 함수와 two 변수 사이에 직접 정의된 관계가 없더라도 SpecialNumber는 two를 인스턴스로 요구합니다. instanceof의 왼쪽 피연산자는 Symbol.hasInstance 호출을 트리거하는 객체여야합니다. 왜냐하면 객체가 아니면 instanceof가 항상 단순히 false를 반환하도록 해야하기 때문입니다. 또한 Date와 Error 함수와 같은 모든 내장 함수에 대한 기본 Symbol.hasInstance 프로퍼티을 덮어 쓸 수 있습니다. 그러나 코드에 미치는 영향이 예기치 않게 혼동될 수 있기 때문에 권장하지 않습니다. 자신의 함수에 대해서만 Symbol.hasInstance를 덮어 쓰는 것이 좋은 생각입니다. Symbol.isConcatSpreadable SymbolJavaScript Array는 두개의 Array을 연결하기 위해 concat() 메서드를 가지고 있습니다. 다음 예제를 살펴 보겠습니다. 12345let colors1 = [ \"red\", \"green\" ], colors2 = colors1.concat([ \"blue\", \"black\" ]);console.log(colors2.length); // 4console.log(colors2); // [\"red\",\"green\",\"blue\",\"black\"] 이 코드는 새로운 Array을 colors1의 끝에 연결하여 colors2를 생성합니다. 생성된 Array는 두 Array의 모든 항목을 갖는 Array입니다. 그러나 concat() 메서드는 Array이 아닌 파라미터도 받아 들일 수 있으며, 이 경우 그 파라미터는 단순히 Array의 끝에 추가됩니다. 12345let colors1 = [ \"red\", \"green\" ], colors2 = colors1.concat([ \"blue\", \"black\" ], \"brown\");console.log(colors2.length); // 5console.log(colors2); // [\"red\",\"green\",\"blue\",\"black\",\"brown\"] 여기에서 여분의 파라미터 &quot;brown&quot;은 concat()에 전달되고 colors2 Array의 다섯 번째 항목이됩니다. Array 파라미터가 문자열 파라미터와 다르게 취급되는 이유는 무엇일까요? JavaScript 사양에서는 Array가 자동으로 개별 항목으로 분리되고 다른 타입은 자동으로 분리되지 않는다고 말합니다. ECMAScript 6 이전에는 이 동작을 조정할 방법이 없었습니다. Symbol.isConcatSpreadable 프로퍼티는 객체가 length 프로퍼티와 숫자 키를 가지고 있으며 숫자 프로퍼티 값이 concat() 호출의 결과에 개별적으로 추가되어야 함을 나타내는 boolean 값입니다. 다른 Well-known Symbol과 달리 이 Symbol 프로퍼티는 기본적으로 표준 객체에 나타나지 않습니다. 대신 Symbol은 특정 타입의 객체에서 concat()이 어떻게 동작 하는지를 보완하는 방법으로 사용할 수 있어 기본 동작을 효과적으로 만듭니다. 다음과 같이 Array가 concat() 호출에서와 같이 동작하도록 모든 타입을 정의할 수 있습니다. 1234567891011let collection = &#123; 0: \"Hello\", 1: \"world\", length: 2, [Symbol.isConcatSpreadable]: true&#125;;let messages = [ \"Hi\" ].concat(collection);console.log(messages.length); // 3console.log(messages); // [\"Hi\",\"Hello\",\"world\"] 이 예제의 collection 객체는 length 프로퍼티와 두 개의 숫자 키를 가지고 있어 Array 처럼 보이도록 설정되어 있습니다. Symbol.isConcatSpreadable 프로퍼티는 true로 설정되어 프로퍼티 값이 Array의 개별 항목으로 추가되어야 함을 나타냅니다. collection이 concat() 메서드에 전달 될 때, 결과 Array는 &quot;Hello&quot;와 &quot;world&quot;가 분리되어 &quot;Hi&quot; 엘리먼트 다음에 나타납니다. concat() 호출로 항목이 분리되지 않도록 Array 서브 클래스에서 Symbol.isConcatSpreadable을 false로 설정할 수도 있습니다. 서브 클래스는 8 장에서 논의합니다. Symbol.match, Symbol.replace, Symbol.search, 그리고 Symbol.split Symbol들문자열과 정규 표현식은 JavaScript에서 밀접한 관계가 있습니다. 특히 문자열 타입에는 정규 표현식을 파라미터로 사용하는 여러 가지 메서드가 있습니다. match(regex) - 주어진 문자열이 정규 표현식과 일치하는지 여부를 판별합니다. replace(regex, replacement) - 정규 표현식에 매치된 문자열을 replacement 로 대체합니다. search(regex) - 문자열 내에서 정규 표현식과 일치하는 문자열을 찾습니다. split(regex) - 문자열을 정규 표현식과 일치하는 문자열 Array로 나눕니다. ECMAScript 6 이전에는 이러한 메서드가 정규 표현식과 상호 작용하는 방식이 개발자에게 숨겨져 있어 개발자가 정의한 객체에 정규 표현식을 사용할 수 없었습니다. ECMAScript 6은 이러한 네 가지 메서드에 해당하는 네 개의 Symbol을 정의하여 네이티브 동작을 RegExp 내장 객체에 효과적으로 아웃소싱할 수 있습니다. Symbol.match, Symbol.replace, Symbol.search 및 Symbol.split Symbol은 정규 표현식 파라미터에 대한 match() ,replace(), search(), split () 메서드 각각에 대한 첫 번째 파라미터에서 호출되어야 합니다. 네 개의 Symbol 프로퍼티는 RegExp.prototype에 문자열 메서드가 사용해야하는 기본 구현으로 정의됩니다. 이것을 알면 정규 표현식과 비슷한 방식으로 문자열 메서드에 사용할 객체를 만들 수 있습니다. 그렇게하기 위해 코드에서 다음과 같은 Symbol 함수를 사용할 수 있습니다. Symbol.match - 문자열 파라미터를 받아들이고 일치하는 Array를 반환하는 함수. 일치하는 것이 없으면 null입니다. Symbol.replace - 문자열 파라미터와 대체 문자열을 받아들이고 문자열을 반환하는 함수입니다. Symbol.search - 문자열 파라미터를 받아들이고 일치 항목의 숫자 인덱스를 반환하는 함수입니다. 일치하는 항목이 없으면 -1을 반환합니다. Symbol.split - 문자열 파라미터를 받아들이고 일치하는 문자열을 포함하는 Array를 반환하는 함수입니다. 객체에 이러한 프로퍼티를 정의할 수 있으므로 정규 표현식 없이 패턴 일치를 구현하는 객체를 만들고 정규 표현식을 필요로하는 메서드에서 사용할 수 있습니다. 다음은 이러한 Symbol이 실제로 작동하는 것을 보여주는 예입니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243// effectively equivalent to /^.&#123;10&#125;$/let hasLengthOf10 = &#123; [Symbol.match]: function(value) &#123; return value.length === 10 ? [value] : null; &#125;, [Symbol.replace]: function(value, replacement) &#123; return value.length === 10 ? replacement : value; &#125;, [Symbol.search]: function(value) &#123; return value.length === 10 ? 0 : -1; &#125;, [Symbol.split]: function(value) &#123; return value.length === 10 ? [\"\", \"\"] : [value]; &#125;&#125;;let message1 = \"Hello world\", // 11 characters message2 = \"Hello John\"; // 10 characterslet match1 = message1.match(hasLengthOf10), match2 = message2.match(hasLengthOf10);console.log(match1); // nullconsole.log(match2); // [\"Hello John\"]let replace1 = message1.replace(hasLengthOf10, \"Howdy!\"), replace2 = message2.replace(hasLengthOf10, \"Howdy!\");console.log(replace1); // \"Hello world\"console.log(replace2); // \"Howdy!\"let search1 = message1.search(hasLengthOf10), search2 = message2.search(hasLengthOf10);console.log(search1); // -1console.log(search2); // 0let split1 = message1.split(hasLengthOf10), split2 = message2.split(hasLengthOf10);console.log(split1); // [\"Hello world\"]console.log(split2); // [\"\", \"\"] hasLengthOf10 객체는 문자열 길이가 정확히 10일 때마다 일치하는 정규 표현식처럼 작동합니다. hasLengthOf10에있는 네 개의 메서드는 각각 적절한 Symbol 을 사용하여 구현되고 두 문자열에 상응하는 메서드가 호출됩니다. 첫 번째 문자열인 message1은 11 개의 문자를 가지므로 일치하지 않습니다. 두 번째 문자열 message2는 10 개의 문자를 가지므로 일치합니다. 정규식이 아니더라도 hasLengthOf10은 각 문자열 메서드에 전달되고 추가 메서드로 인해 올바르게 사용됩니다. 이것은 간단한 예제지만 보다 복잡한 매칭를 수행하는 기능도 가능합니다. 그리고 현재 정규 표현식으로 가능했던 것보다 커스텀 패턴 매처에 대한 많은 가능성을 열어줍니다. Symbol.toPrimitive 메서드JavaScript는 특정 작업을 적용할 때 객체를 Primitive 값으로 암시적으로 변환하려고 시도합니다. 예를 들어 문자열을 double equals (==) 연산자를 사용하여 객체와 비교하면 비교하기 전에 객체가 Primitive 값으로 변환됩니다. 정확하게 어떤 Primitive 값이 사용되어야 하는가는 이전에는 내부 연산 이었지만, ECMAScript 6에서는 Symbol.toPrimitive 메서드를 통해 그 값을 밖으로 노출시킵니다. Symbol.toPrimitive 메서드는 각 표준 타입의 프로토 타입에 정의되어 있으며, 객체가 Primitive로 변환 될 때 어떻게되어야 하는지를 규정합니다. Primitive 변환이 필요할 때, Symbol.toPrimitive는 하나의 파라미터를 가지고 호출되며, 명세서에서 hint라고 설명합니다. hint 파라미터는 세 개의 문자열 값 중 하나입니다. hint가 &quot;number&quot;이면 Symbol.toPrimitive는 number를 반환해야합니다. hint가 &quot;string&quot;이면 string이 반환되어야하고, “default”이면 해당 연산은 그 타입에 대한 선호도가 없습니다. 대부분의 표준 객체에서 number 모드는 우선 순위에 따라 다음과 같은 동작을합니다. valueOf() 메서드를 호출해, 결과가 Primitive인 경우는 그 값을 돌려 준다. 그렇지 않은 경우는,toString() 메서드를 호출해, 결과가 Primitive인 경우는 그 값을 돌려 준다. 그렇지 않으면 오류를 발생시킵니다. 마찬가지로 대부분의 표준 객체에서 string 모드의 동작은 다음과 같은 우선 순위를 갖습니다. toString() 메서드를 호출해, 결과가 Primitive인 경우는 그 값을 돌려 준다. 그렇지 않은 경우는, valueOf() 메서드를 호출해, 결과가 Primitive인 경우는 그 값을 돌려 준다. 그렇지 않으면 오류를 발생시킵니다. 대부분의 경우 표준 객체는 Default 모드를 number 모드와 동일하게 취급합니다 (Default 모드를 string 모드와 동일하게 취급하는 Date제외). Symbol.toPrimitive 메서드를 정의함으로써, 여러분은 이 Default 모드를 오버라이드 할 수 있습니다. Default 모드는 ==연산자, +연산자 및 Date 생성자에 단일 파라미터를 전달할 때만 사용됩니다. 대부분의 작업에는 string 또는 number 모드가 사용됩니다. Default 변환 행동을 무시하려면 아래 예제 처럼 Symbol.toPrimitive를 사용하고 함수를 값으로 지정하십시오. 1234567891011121314151617181920212223function Temperature(degrees) &#123; this.degrees = degrees;&#125;Temperature.prototype[Symbol.toPrimitive] = function(hint) &#123; switch (hint) &#123; case \"string\": return this.degrees + \"\\u00b0\"; // degrees symbol case \"number\": return this.degrees; case \"default\": return this.degrees + \" degrees\"; &#125;&#125;;let freezing = new Temperature(32);console.log(freezing + \"!\"); // \"32 degrees!\"console.log(freezing / 2); // 16console.log(String(freezing)); // \"32째\" 위의 예제는 Temperature 생성자를 정의하고 프로토타입에 대한 기본 Symbol.toPrimitive 메서드를 오버라이드합니다. hint 파라미터가string 모드,number 모드 또는 Default 모드 (JavaScript 엔진에 의해 hint 파라미터로 채워짐)를 나타내는지에 따라 다른값이 리턴됩니다. string 모드에서, Symbol.toPrimitive 메서드는 유니 코드 Symbol로 온도를 반환합니다. number 모드에서는 숫자값만 반환하고, Default 모드에서는 숫자 뒤에 &quot;degrees&quot;라는 단어를 추가합니다. 각각의 로그문은 다른 hint 파라미터를 트리거합니다. +연산자는 hint를 &quot;default&quot;로 설정함으로써 Default 모드를 트리거하고, / 연산자는 hint를 &quot;number&quot;로 설정함으로써 number 모드를 트리거하고, String() 함수는 hint를 &quot;string&quot;으로 설정함으로써 string 모드로 트리거합니다. 세 가지 모드 모두에 대해 다른 값을 반환하는 것이 가능합니다. 하지만 Default 모드를 string 또는 number 모드와 동일하게 설정하는 것이 훨씬 더 일반적입니다. Symbol.toStringTag SymbolJavaScript에서 가장 흥미로운 문제중 하나는 여러 글로벌 실행환경을 사용할 수 있다는 것입니다. 이는 페이지에 iframe이 포함될 때 웹 브라우저에서 발생합니다. 페이지와 iframe에는 각각 자체 실행 환경이 있기 때문입니다. 대부분의 경우 데이터를 주고받을 수 있으므로 문제가되지 않습니다. 하지만 문제는 객체가 다른 객체에 전달된 후 처리할 객체의 타입을 식별하려고 할 때 발생합니다. 이 문제의 일반적인 예는 iframe의 Array의 포함 페이지로 또는 그 반대로 전달하는 것입니다. ECMAScript 6 용어에서 iframe 및 포함 페이지는 각각 JavaScript의 실행 환경인 다른 영역(realm)을 나타냅니다. 각 영역에는 전역 객체의 자체 사본이 있는 고유한 전역 Scope이 있습니다. Array는 생성되는 영역에 관계없이 Array이어야 합니다. 그러나 다른 영역으로 넘어 갔을 때 Array가 이전 영역의 생성자로 만들어졌고 Array가 현재 영역의 생성자를 나타내므로 instanceof Array 호출은 false를 반환합니다. 식별 문제에 대한 해결 방법이 문제에 직면한 개발자들은 곧 Array를 식별하는 좋은 방법을 발견했습니다. 그들은 객체에 대해 표준 toString()메서드를 호출하면 항상 예측 가능한 문자열이 반환된다는 것을 발견했습니다. 그래서 많은 JavaScript 라이브러리는 다음과 같은 함수를 포함하기 시작했습니다. 12345function isArray(value) &#123; return Object.prototype.toString.call(value) === \"[object Array]\";&#125;console.log(isArray([])); // true 이 방법이 조금 어색해 보일지 모르지만 모든 브라우저에서 Array를 식별하는 데는 매우 효과적입니다. Array의 toString() 메서드는 객체를 포함하는 문자열 표현을 반환하기 때문에 객체 식별에 유용하지 않습니다. 그러나 Object.prototype에 대한 toString() 메서드는 quirk를 가지고 있습니다 : 반환된 결과에 [[Class]]로 불리는 내부적으로 정의된 이름을 포함합니다. 개발자는 객체에서 이 메서드를 사용하여 JavaScript 환경에서 객체의 데이터 타입이 무엇이라고 생각 하는지를 검색할 수 있습니다. 개발자는 이 동작을 변경할 방법이 없었기 때문에 동일한 방법을 사용하여 Native 객체와 개발자가 만든 객체를 구별할 수 있다는 것을 신속하게 깨달았습니다. 가장 중요한 경우는 ECMAScript 5 JSON 객체입니다. ECMAScript 5 이전에는 많은 개발자들이 Douglas Crockford의 json2.js를 사용하여 글로벌 JSON 객체를 생성했습니다. 하지만 브라우저가 JSON 전역 객체를 구현하기 시작하면서, JavaScript 환경에서 또는 다른 라이브러리를 통해 제공되는 전역 JSON이 필요하다는 것을 깨달았습니다. isArray() 함수에서 보여준 것과 같은 기술을 사용하여 많은 개발자들이 다음과 같은 함수를 만들었습니다. 1234function supportsNativeJSON() &#123; return typeof JSON !== \"undefined\" &amp;&amp; Object.prototype.toString.call(JSON) === \"[object JSON]\";&#125; 개발자가 iframe 경계를 넘어서 Array를 식별할 수있게 해주는 Object.prototype과 동일한 특성을 사용해 JSON이 기본 JSON 객체인지 여부를 알 수있는 방법을 제공합니다. 기본이 아닌 JSON 객체는 [object Object]를 반환하지만 Native 버전은 [object JSON]을 반환합니다. 이 접근법은 Native 객체를 식별하기 위한 사실상의 표준이되었습니다. ECMAScript 6의 해결책ECMAScript 6은 Symbol.toStringTag Symbol을 통해 이 동작을 재정의합니다. 이 Symbol은 Object.prototype.toString.call()이 호출될 때 생성되어야 하는 값을 정의하는 각 객체의 프로퍼티를 나타냅니다. Array의 경우 함수가 반환하는 값은 Symbol.toStringTag 프로퍼티에 &quot;Array&quot;를 저장하여 설명합니다. 마찬가지로, 자신의 객체에 대한 Symbol.toStringTag 값을 정의할 수 있습니다. 12345678910function Person(name) &#123; this.name = name;&#125;Person.prototype[Symbol.toStringTag] = \"Person\";let me = new Person(\"Nicholas\");console.log(me.toString()); // \"[object Person]\"console.log(Object.prototype.toString.call(me)); // \"[object Person]\" 이 예제에서 Symbol.toStringTag 프로퍼티는 Person.prototype에 정의되어 문자열 표현을 생성하기 위한 기본 동작을 제공합니다. Person.prototype은 Object.prototype.toString() 메서드를 상속 받기 때문에 Symbol.toStringTag에서 반환된 값은 me.toString() 메서드를 호출할 때도 사용됩니다. 그러나 Object.prototype.toString.call() 메서드의 사용에 영향을 미치지 않고 다른 동작을 제공하는 자신만의 toString() 메서드를 정의할 수 있습니다. 다음과 같이 사용할 수 있습니다. 1234567891011121314function Person(name) &#123; this.name = name;&#125;Person.prototype[Symbol.toStringTag] = \"Person\";Person.prototype.toString = function() &#123; return this.name;&#125;;let me = new Person(\"Nicholas\");console.log(me.toString()); // \"Nicholas\"console.log(Object.prototype.toString.call(me)); // \"[object Person]\" 이 코드는 Person.prototype.toString()을 정의하여 name 프로퍼티 값을 반환합니다. Person 인스턴스가 더 이상 Object.prototype.toString() 메서드를 상속하지 않기 때문에 me.toString()을 호출하면 다른 행동을 보입니다. 달리 명시하지 않는한 모든 객체는 Object.prototype에서 Symbol.toStringTag을 상속받습니다. &quot;Object&quot;문자열이 기본 프로퍼티 값입니다. 개발자가 정의한 객체에서 Symbol.toStringTag에 어떤 값을 사용할 수 있는지에 대한 제한은 없습니다. 예를 들어, 다음과 같이 Symbol.toStringTag 프로퍼티의 값으로 &quot;Array&quot;를 사용하지 못하게하는 방법은 없습니다. 1234567891011121314function Person(name) &#123; this.name = name;&#125;Person.prototype[Symbol.toStringTag] = \"Array\";Person.prototype.toString = function() &#123; return this.name;&#125;;let me = new Person(\"Nicholas\");console.log(me.toString()); // \"Nicholas\"console.log(Object.prototype.toString.call(me)); // \"[object Array]\" Object.prototype.toString()을 호출 한 결과는 이 코드에서 &quot;[object Array]&quot;이며 실제 Array에서 얻은 결과와 같습니다. 이것은 Object.prototype.toString()이 더 이상 객체 타입을 식별하는 완전히 신뢰할 수있는 방법이 아니라는 사실을 강조합니다. Native 객체에 대한 문자열 태그 변경도 가능합니다. 다음과 같이 객체의 프로토 타입에 Symbol.toStringTag을 할당하면 됩니다. 12345Array.prototype[Symbol.toStringTag] = \"Magic\";let values = [];console.log(Object.prototype.toString.call(values)); // \"[object Magic]\" 이 예제에서 Symbol.toStringTag가 Array에 대해 덮어 쓰여지더라도 Object.prototype.toString()을 호출하면 대신 [[Object Magic]]이 됩니다. 이런 방식으로 내장 객체를 변경하지 말 것을 권고 하지만 JavaScript에서 이것을 금지하지는 않습니다. Symbol.unscopables Symbolwith문은 JavaScript에서 가장 논쟁의 여지가 있는 부분중 하나입니다. 원래 반복적인 타이핑을 피하도록 설계된 with 문은 나중에 코드를 이해하기 어렵게 만들고 성능에 부정적이고 오류가 발생하기 쉬워서 많은 비난을 받고 있습니다. 결과적으로 with 문은 strict 모드에서는 허용되지 않습니다. 이러한 제한은 클래스와 모듈에도 영향을 미칩니다. 클래스와 모듈은 기본적으로 strict 모드이며 opt-out이 없습니다. 미래의 코드는 의심할 여지없이 with 문을 사용하지 않지만, ECMAScript 6는 하위 호환성을 위한 nonstrict 모드를 여전히 지원하며, with를 사용하는 코드가 계속해서 제대로 작동하도록 하는 방법을 찾아야만 합니다. 이 작업의 복잡성을 이해하기 위해 다음 코드를 살펴보겠습니다. 12345678910let values = [1, 2, 3], colors = [\"red\", \"green\", \"blue\"], color = \"black\";with(colors) &#123; push(color); push(...values);&#125;console.log(colors); // [\"red\", \"green\", \"blue\", \"black\", 1, 2, 3] 이 예제에서, with문 안에서 push()를 두 번 호출하면 colors.push()와 동등합니다. 왜냐하면 with 문은 push를 로컬 바인딩으로 추가했기 때문입니다. color의 참조는 values 참조처럼 with문 밖에서 생성된 변수를 참조합니다. ECMAScript 6는 Array에 values 메서드를 추가했습니다. (values 메서드에 대해서는 7 장 “Iterator와 Generator”에서 자세히 설명합니다.) 즉, ECMAScript 6 환경에서 with문 내의 values 참조는 지역 변수 values를 참조하는 것이 아니라 코드를 깨뜨릴 수 있는 Array의 values 메서드를 참조해야합니다. 이것이 Symbol.unscopables Symbol이 존재하는 이유입니다. Symbol.unscopables 심볼은 Array.prototype에 사용되어 어떤 프로퍼티가 with문 안에서 바인딩을 생성해서는 안된다는 것을 나타냅니다. 현재 존재하는 Symbol.unscopables는 with 명령문 바인딩을 생략하고 values가 true 인 블록을 시행하기 위한 식별자를 키로 가지는 객체입니다. 다음은 Array에 대한 기본 Symbol.unscopables 프로퍼티입니다. 12345678910// built into ECMAScript 6 by defaultArray.prototype[Symbol.unscopables] = Object.assign(Object.create(null), &#123; copyWithin: true, entries: true, fill: true, find: true, findIndex: true, keys: true, values: true&#125;); Symbol.unscopables 객체는 Object.create(null) 호출에 의해 생성되고 ECMAScript 6에 있는 새로운 Array 메서드들을 모두 포함하는 null 프로토 타입을 가지고 있습니다. (이 메서드들은 7장 “Iterator와 Generator”및 9장 “Arrays.”에서 설명합니다.) 이러한 메서드에 대한 바인딩은 with 문 내에 만들어지지 않으므로 이전 코드가 아무런 문제없이 계속 작동할 수 있습니다. 일반적으로 with 문을 사용하지 않고 코드베이스의 기존 객체를 변경하지 않는한 객체에 Symbol.unscopables을 정의할 필요가 없습니다. SummarySymbol은 JavaScript에서 새로운 유형의 Primitive 타입이며 Symbol을 참조하지 않고는 액세스할 수 없는 프로퍼티를 만드는데 사용됩니다. 진정한 Private은 아니지만 이러한 프로퍼티는 실수로 변경하거나 덮어 쓰기가 어렵기 때문에 개발자로부터 일정 수준의 보호가 필요한 기능에 적합합니다. Symbol 값을 쉽게 식별할 수 있도록 Symbol에 대한 설명을 제공할 수 있습니다. 동일한 설명을 사용하여 코드의 다른 부분에서 공유 Symbol을 사용할 수 있는 전역 Symbol 레지스트리가 있습니다. 이런 식으로 여러 장소에서 같은 이유로 동일한 Symbol을 사용할 수 있습니다. Object.keys() 또는 Object.getOwnPropertyNames()와 같은 메서드는 Symbol을 반환하지 않고, ECMAScript 6에 새로운 메서드인 Object.getOwnPropertySymbols()가 추가되어 Symbol 프로퍼티를 검색할 수 있습니다. Object.defineProperty()및Object.defineProperties ()메서드를 호출하여 Symbol 프로퍼티를 변경할 수 있습니다. Well-known Symbol은 표준 객체에 대한 이전의 내부 전용 기능을 정의하고 Symbol.hasInstance 프로퍼티와 같이 전역적으로 사용 가능한 Symbol 상수를 사용합니다. 이 Symbol은 스펙에서 접두어 Symbol.을 사용하며 개발자가 다양한 방법으로 표준 객체의 동작을 수정할 수 있도록 합니다. 이 내용은 나중에 참고하기 위해 제가 공부하며 정리한 내용입니다.의역, 오역, 직역이 있을 수 있음을 알려드립니다.This post is a translation of this original article [https://leanpub.com/understandinges6/read#leanpub-auto-symbols-and-symbol-properties] 참고 ECMAScript 6 Block Binding ECMAScript 6 문자열과 정규 표현식 ECMAScript 6 함수 ECMAScript 6 객체의 확장된 기능 ECMAScript 6 쉬운 데이터 액세스를 위한 Destructuring ECMAScript 6 Symbol과 Symbol 프로퍼티 ECMAScript 6 Set과 Map ECMAScript 6 Iterator와 Generator ECMAScript 6 JavaScript 클래스 소개 ECMAScript 6 Array 기능 향상 ECMAScript 6 Promise와 비동기 프로그램밍 ECMAScript 6 프록시와 리플렉션 API ECMAScript 6 Module로 코드 캡슐화하기 ECMAScript 6 부록 A. 작은 변경 사항 ECMAScript 6 부록 B. ECMAScript 7(2016) 이해하기","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://infoscis.github.io/categories/JavaScript/"},{"name":"ECMAScript 2015","slug":"JavaScript/ECMAScript-2015","permalink":"http://infoscis.github.io/categories/JavaScript/ECMAScript-2015/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://infoscis.github.io/tags/JavaScript/"},{"name":"ECMAScript 2015","slug":"ECMAScript-2015","permalink":"http://infoscis.github.io/tags/ECMAScript-2015/"}]},{"title":"ECMAScript 6 쉬운 데이터 액세스를 위한 Destructuring","slug":"ecmascript-6-destructuring-for-easier-data-access","date":"2018-01-25T15:08:59.000Z","updated":"2018-02-27T14:12:17.847Z","comments":true,"path":"2018/01/26/ecmascript-6-destructuring-for-easier-data-access/","link":"","permalink":"http://infoscis.github.io/2018/01/26/ecmascript-6-destructuring-for-easier-data-access/","excerpt":"","text":"쉬운 데이터 액세스를 위한 Destructuring객체와 Array 리터럴은 JavaScript에서 가장 많이 사용되는 표기법중 두가지이며, 널리 사용되는 JSON 데이터 형식 덕분에 특히 중요한 부분이되었습니다. 객체와 Array를 정의한 다음 해당 구조에서 관련 정보를 체계적으로 추출하는 것이 일반적인 사용법입니다. ECMAScript 6은 데이터 구조를 더작은 부분으로 나누는 과정인 Destructuring을 추가하여 이 작업을 단순화했습니다. 이 장에서는 객체와 Array 모두에 대해 Destructuring을 이용하는 방법을 설명합니다. 왜 Destructuring이 유용할까요?ECMAScript 5 및 이전 버전에서는 객체 및Array의 정보를 가져와서 로컬 변수에 대입할 때 코드가 많이 생길 수 있었습니다. 12345678let options = &#123; repeat: true, save: false &#125;;// 객체에서 데이터를 추출합니다.let repeat = options.repeat, save = options.save; 위 코드는 options 객체에서 repeat와 save의 값을 추출하여 같은 이름의 로컬 변수에 저장합니다. 위 코드는 단순하지만, 만약 할당할 변수가 많은 경우를 생각해보십시오. 그들 모두를 하나씩 할당해야할 것입니다. 정보를 찾기 위해 순회하는 중첩된 데이터 구조가 있는 경우 전체 구조를 파헤쳐 한조각의 데이터를 찾아야할 수도 있습니다. 그래서 ECMAScript 6는 객체와 Array 모두에 Destructuring을 추가 했습니다. 데이터 구조를 작은 부분으로 나누면 필요한 정보를 얻는 것이 훨씬 쉬워집니다. 많은 언어들이 최소한의 문법으로 Destructuring를 구현하여 프로세스를 더 간단하게 사용합니다. ECMAScript 6의 구현은 실제로 익숙한 구문을 사용합니다(객체 및 Array 리터럴 구문). 객체 Destructuring객체 Destructuring 문법은 할당 연산의 왼쪽에 객체 리터럴을 사용합니다. 123456789let node = &#123; type: \"Identifier\", name: \"foo\" &#125;;let &#123; type, name &#125; = node;console.log(type); // \"Identifier\"console.log(name); // \"foo\" 이 코드에서 node.type의 값은 type이라는 변수에 저장되고 node.name의 값은 name이라는 변수에 저장됩니다. 이 문법은 4 장에서 소개된 객체 리터럴 프로퍼티 초기화와 동일합니다. 변수 type과 name은 지역 변수이며 node 객체에서 값을 읽어올 프로퍼티들입니다. 초기화를 잊지마세요.Destructuring 을 사용하여 var, let 또는 const를 사용하여 변수를 선언할 때 초기화값(등호 뒤에 오는 값)를 제공해야합니다. 다음 코드는 모두 초기화 프로그램이 없어서 구문 오류를 발생시킵니다. 12345678// syntax error!var &#123; type, name &#125;;// syntax error!let &#123; type, name &#125;;// syntax error!const &#123; type, name &#125;; const는 Nondestructured 변수를 사용하는 경우에도 항상 초기화가 필요하고, var와 let은 Destructuring 을 사용할 때만 초기화가 필요합니다. Destructuring 할당지금까지 객체의 Destructuring 예제는 변수 선언을 사용했습니다. 그러나 할당에서 Destructuring을 사용할 수도 있습니다. 예를 들어, 다음과 같이 정의된 변수 값을 변경하기로 결정할 수 있습니다. 123456789101112let node = &#123; type: \"Identifier\", name: \"foo\" &#125;, type = \"Literal\", name = 5;// destructuring 사용하여 다른 값 할당(&#123; type, name &#125; = node);console.log(type); // \"Identifier\"console.log(name); // \"foo\" 이 예제에서 type과 name은 선언될 때 초기화 되고, 같은 이름의 서로 다른 변수는 각각 다른 값으로 초기화됩니다. 다음 줄은 Destructuring 할당을 사용하여 node 객체의 값을 변경합니다. Destructuring 할당문에 괄호를 써야하는 것을 잊지 마세요. 여는 중괄호는 블록문이어야하고 블록문은 할당의 왼쪽에 나타날 수 없기 때문입니다. 괄호는 다음 중괄호가 블록문이 아니며 표현식으로 해석 되어야하며 할당이 완료될 수 있음을 나타냅니다. Destructuring 할당 표현식은 표현식의 오른쪽 (= 뒤)으로 평가됩니다. 즉, 값이 예상되는 모든 위치에서 Destructuring 할당 표현식을 사용할 수 있습니다. 예를 들어, 함수에 값을 전달하는 경우 123456789101112131415let node = &#123; type: \"Identifier\", name: \"foo\" &#125;, type = \"Literal\", name = 5;function outputInfo(value) &#123; console.log(value === node); // true&#125;outputInfo(&#123; type, name &#125; = node);console.log(type); // \"Identifier\"console.log(name); // \"foo\" outputInfo() 함수는 Destructuring 할당 표현식으로 호출됩니다. 표현식은 표현식에서 오른쪽 값이기 때문에 node로 평가됩니다. type과 name에 대한 할당은 정상적으로 동작하고 node는 outputInfo()에 전달됩니다. Destructuring 할당 표현식 (= 뒤의 표현식)의 오른쪽이 null 또는 undefined로 평가되면 에러가 발생합니다. 이는 null 또는 undefined 속성을 읽으려고 하면 런타임 오류가 발생하기 때문입니다. Default 값Destructuring 할당 문을 사용할 때, 객체에 존재하지 않는 프로퍼티 이름을 가진 지역 변수를 지정하면, 그 지역 변수는 undefined의 값이 할당됩니다. 12345678910let node = &#123; type: \"Identifier\", name: \"foo\" &#125;;let &#123; type, name, value &#125; = node;console.log(type); // \"Identifier\"console.log(name); // \"foo\"console.log(value); // undefined 이 코드는 value라는 추가 로컬 변수를 정의하고 값을 할당하려고 시도합니다. 그러나, node 객체에는 상응하는 value 속성이 없으므로, value 변수는 undefined 값이 할당됩니다. 선택적으로 지정된 속성이 존재하지 않을때 사용할 Default 값을 정의할 수 있습니다. 이렇게하려면 속성 이름 뒤에 등호 (=)를 삽입하고 다음과 같이 Default 값을 지정하십시오. 12345678910let node = &#123; type: \"Identifier\", name: \"foo\" &#125;;let &#123; type, name, value = true &#125; = node;console.log(type); // \"Identifier\"console.log(name); // \"foo\"console.log(value); // true 이 예제에서 변수 value는 Default 값으로 true가 주어집니다. Default 값은 프로퍼티가 node에 없거나 undefined 값을 가진 경우에만 사용됩니다. node.value 프로퍼티가 없기 때문에, 변수 값은 Default 값을 사용합니다. 이는 3장에서 논의된 것처럼 함수에 대한 Default 파라미터와 비슷하게 작동합니다. 다른 이름의 지역 변수 지정지금까지 각 예제의 Destructuring 할당은 객체 프로퍼티 이름을 로컬 변수 이름으로 사용했습니다. 예를 들어, node.type의 값은 type 변수에 저장되었습니다. 같은 이름을 사용하고 싶을 때 잘 작동하지만 그렇지 않은 경우 어떻게 해야할까요? ECMAScript 6에는 지역 변수에 다른 이름을 할당할 수있는 확장 구문이 있으며 그 구문은 객체 리터럴 비단축 프로퍼티 초기화 구문과 비슷합니다. 다음은 그 예입니다. 123456789let node = &#123; type: \"Identifier\", name: \"foo\" &#125;;let &#123; type: localType, name: localName &#125; = node;console.log(localType); // \"Identifier\"console.log(localName); // \"foo\" 이 코드는 Destructuring 할당을 사용하여 각각 node.type과 node.name 프로퍼티의 값을 포함하는 localType과 localName 변수를 선언합니다. type:localType 구문은 type이라는 프로퍼티를 읽고 그 값을 localType 변수에 저장한다는 의미입니다. 이 구문은 콜론 왼쪽에 이름이 있고 오른쪽에 값이 있는 전통적인 객체 리터럴 구문의 반대입니다. 콜론 오른쪽에 이름이 표시되고 읽을 값의 위치는 왼쪽에 있습니다. 다른 변수 이름을 사용할 때 Default 값을 추가할 수 있습니다. 등호와 Default 값은 지역 변수 이름 뒤에 위치합니다. 12345678let node = &#123; type: \"Identifier\" &#125;;let &#123; type: localType, name: localName = \"bar\" &#125; = node;console.log(localType); // \"Identifier\"console.log(localName); // \"bar\" 여기서 localName 변수는 &quot;bar&quot;의 Default 값을 가집니다. node.name 프로퍼티가 없으므로 변수에 Default 값이 할당됩니다. 지금까지 프로퍼티가 Primitive 값인 객체의 Destructuring을 처리하는 방법을 살펴 보았습니다. 객체의 Destructuring은 중첩된 객체 구조의 값을 검색하는 데에도 사용할 수 있습니다. 중첩된 객체 Destructuring객체 리터럴과 유사한 구문을 사용하여 중첩된 객체 구조에서 원하는 정보만 검색할 수 있습니다. 다음은 그 예입니다. 12345678910111213141516171819let node = &#123; type: \"Identifier\", name: \"foo\", loc: &#123; start: &#123; line: 1, column: 1 &#125;, end: &#123; line: 1, column: 4 &#125; &#125; &#125;;let &#123; loc: &#123; start &#125;&#125; = node;console.log(start.line); // 1console.log(start.column); // 1 이 예제에서 Destructuring 패턴은 중괄호를 사용하여 패턴이 node에서 loc이라는 이름의 프로퍼티로 내려 가야하고 start 프로퍼티를 찾는다는 것을 나타냅니다. 마지막 섹션에서 Destructuring 패턴에 콜론 전에 검사할 위치를 제공하는 식별자를 의미하고 오른쪽은 값을 할당한다는 것을 기억하세요. 콜론 다음에 중괄호가 있으면 목적지가 객체의 다른 레벨에 중첩되어 있음을 나타냅니다. 한단계 더 나아가 로컬 변수에 다른 이름을 사용할 수 있습니다. 1234567891011121314151617181920let node = &#123; type: \"Identifier\", name: \"foo\", loc: &#123; start: &#123; line: 1, column: 1 &#125;, end: &#123; line: 1, column: 4 &#125; &#125; &#125;;// extract node.loc.startlet &#123; loc: &#123; start: localStart &#125;&#125; = node;console.log(localStart.line); // 1console.log(localStart.column); // 1 이 버전의 코드에서 node.loc.start는 localStart라는 새로운 로컬 변수에 저장됩니다. Destructuring 패턴은 임의의 레벨 깊이로 중첩될 수 있으며 각 레벨에서 모든 기능을 사용할 수 있습니다. 객체 Destructuring은 매우 강력하고 많은 옵션을 가지고 있습니다. 그러나 Array Destructuring은 Array로부터 정보를 추출할 수 있는 몇 가지 독특한 기능을 제공합니다. Syntax Gotcha부작용이 없는 문장을 실수로 생성할 수 있기 때문에 중첩된 Destructuring을 사용할 때는 주의해야 합니다. 빈 중괄호는 객체Destructuring에서 유효하지만 아무 것도 하지않습니다. 12// 아무 변수도 선언하지 않았습니다.let &#123; loc: &#123;&#125; &#125; = node; 이 선언문에 선언된 바인딩이 없습니다. 오른쪽에 있는 중괄호로 인해 loc는 바인딩 만들기가 아닌 검사할 위치로 사용됩니다. 이 경우, 의도를 정의하기 위해 : 대신에 Default 값을 정의하는 =를 사용하는 것이 그럴듯합니다. 이 구문이 앞으로 유효하지 않을 가능성이 있지만, 현재로서는 이 부분을 주의해야합니다. Array DestructuringArray Destructuring 문법은 객체 Destructuring과 매우 비슷합니다. 객체 리터럴 구문 대신 Array 리터럴 구문을 사용합니다. Destructuring은 객체에서 사용 가능한 명명된 프로퍼티가 아니라 Array 내의 위치에 작동합니다. 123456let colors = [ \"red\", \"green\", \"blue\" ];let [ firstColor, secondColor ] = colors;console.log(firstColor); // \"red\"console.log(secondColor); // \"green\" 여기서 Destructuring Array는 colors Array에서 &quot;red&quot;와 &quot;green&quot;값을 꺼내서 firstColor와 secondColor 변수에 저장합니다. 이러한 값은 Array에서의 위치 때문에 선택됩니다. 실제 변수 이름은 무엇이든 될 수 있습니다. Destructuring 패턴에서 명시적으로 언급되지 않은 항목은 무시됩니다. Array 자체는 어떤식으로든 변경되지 않는다는 것을 명심하십시오. Destructuring 패턴의 항목을 생략하고 관심있는 항목에 대해서만 변수 이름을 제공할 수도 있습니다. 예를 들어 Array의 세 번째 값만 원하면 첫 번째 및 두 번째 항목에 변수 이름을 제공할 필요가 없습니다. 방식은 다음과 같습니다. 12345let colors = [ \"red\", \"green\", \"blue\" ];let [ , , thirdColor ] = colors;console.log(thirdColor); // \"blue\" 이 코드는 Destructuring 할당을 사용하여 colors에서 세 번째 항목을 검색합니다. 패턴에서 thirdColor 앞에 오는 쉼표는 그앞에 오는 Array 항목의 자리 표시입니다. 이 접근법을 사용하면 변수 이름을 제공할 필요없이 Array의 중간에 있는 슬롯에서 값을 쉽게 선택할 수 있습니다. 객체 Destructuring 과 마찬가지로 Array Destructuring을 var, let 또는 const로 사용할 때 항상 초기화를 해야 합니다. Destructuring 할당할당에서 Array Destructuring을 사용할 수 있지만 객체 Destructuring과는 달리 괄호 안에 표현식을 감쌀 필요는 없습니다. 12345678let colors = [ \"red\", \"green\", \"blue\" ], firstColor = \"black\", secondColor = \"purple\";[ firstColor, secondColor ] = colors;console.log(firstColor); // \"red\"console.log(secondColor); // \"green\" 이 코드에서 Destructuring 할당은 마지막 Array Destructuring 예제와 비슷한 방식으로 작동합니다. 유일한 차이점은 firstColor와 secondColor가 이미 정의되었다는 것입니다. 지금까지 설명한 내용이 Array Destructuring 할당에 대해 알아야할 것이 전부이지만 조금 더 유용한 내용이 있습니다. Array Destructuring 할당은 두변수의 값을 쉽게 바꿀 수있게 해주는 매우 독특한 사용 사례입니다. 값 교환은 정렬 알고리즘에서 일반적인 작업이며 ECMAScript 5 변수값 교환 방법은 아래 예제에서와 같이 세 번째 임시 변수를 사용합니다. 1234567891011// ECMAScript 5에서 변수값 교환let a = 1, b = 2, tmp;tmp = a;a = b;b = tmp;console.log(a); // 2console.log(b); // 1 임시변수 tmp는 a와 b 값을 교환하기 위해 필요합니다. 그러나 Array Destructuring 할당을 사용하면 추가 변수가 필요하지 않습니다. ECMAScript 6에서 변수를 교환하는 방법은 다음과 같습니다. 12345678// ECMAScript 6에서 변수값 교환let a = 1, b = 2;[ a, b ] = [ b, a ];console.log(a); // 2console.log(b); // 1 이 예제에서 Destructuring Array는 미러 이미지처럼 보입니다. 할당의 왼쪽(등호 앞에)은 다른 Array Destructuring의 예제와 마찬가지인 Destructuring 패턴입니다. 오른쪽은 교환에 대해 임시로 생성되는 Array 리터럴입니다. Destructuring은 임시 Array에서 발생합니다. 이 Array는 b와 a 값이 첫 번째와 두 번째 위치에 복사됩니다. 결과는 변수 값을 바꿉니다. 객체의 Destructuring 할당과 마찬가지로 Array의 Destructuring 할당 표현식의 오른쪽이 null 또는 undefined로 평가되면 에러가 발생합니다. Default 값Array Destructuring 할당은 Array의 어느 위치에 대해서도 Default 값을 지정할 수 있게합니다. Default 값은 주어진 위치의 프로퍼티가 존재하지 않거나 undefined 값을 가질 때 사용됩니다. 123456let colors = [ \"red\" ];let [ firstColor, secondColor = \"green\" ] = colors;console.log(firstColor); // \"red\"console.log(secondColor); // \"green\" 위 코드에서 colors Array에는 하나의 항목만 있으므로 secondColor가 일치하는 항목은 없습니다. 하지만 Default 값이 있기 때문에 secondColor는 undefined 대신에 &quot;green&quot;으로 설정됩니다. 중첩된 Destructuring중첩된 객체를 Destructuring하는 것과 비슷한 방식으로 중첩된 Array를 Destructuring 시킬 수 있습니다. 전체 패턴에 다른 Array 패턴을 삽입하면 Destructuring은 다음과 같이 중첩 Array로 내려갑니다. 12345678let colors = [ \"red\", [ \"green\", \"lightgreen\" ], \"blue\" ];// laterlet [ firstColor, [ secondColor ] ] = colors;console.log(firstColor); // \"red\"console.log(secondColor); // \"green\" 여기서 secondColor 변수는 colors Array 안의 &quot;green&quot;값을 가리킵니다. 이 항목은 두 번째 Array에 포함되어 있으므로 Destructuring 패턴에서 secondColor 주위에 여분의 대괄호가 필요합니다. 객체와 마찬가지로 Array를 반복적으로 중첩시킬 수 있습니다. Rest 아이템3 장에서는 함수에 대한 Rest 파라미터를 소개했고, Array Destructuring에는 Rest 아이템이라는 유사한 개념이 있습니다. Rest 아이템은 ... 구문을 사용하여 Array의 나머지 아이템을 특정 변수에 지정합니다. 12345678let colors = [ \"red\", \"green\", \"blue\" ];let [ firstColor, ...restColors ] = colors;console.log(firstColor); // \"red\"console.log(restColors.length); // 2console.log(restColors[0]); // \"green\"console.log(restColors[1]); // \"blue\" colors의 첫 번째 항목은 firstColor에 할당되고 나머지는 새로운 restColors Array에 할당됩니다. 그러므로restColors Array에는 두개의 항목, &quot;green&quot;과 &quot;blue&quot;가 입력됩니다. Rest 아이템은 Array에서 특정 아이템을 추출하고 나머지 아이템을 유지하는데 유용하지만 또 다른 유용한 용도가 있습니다. JavaScript Array에서 눈에 띄지 않는 부분중 하나는 복제본을 쉽게 만들 수 있는 기능입니다. ECMAScript 5에서 개발자는 Array을 복제하는 쉬운 방법으로 concat() 메서드를 자주 사용했습니다. 12345// ECMAScript 5에서 Array 복제본 만들기var colors = [ \"red\", \"green\", \"blue\" ];var clonedColors = colors.concat();console.log(clonedColors); //\"[red,green,blue]\" concat() 메서드는 두개의 Array를 연결 하기위한 것이지만, 인자없이 호출하면 Array의 복제본을 반환합니다. ECMAScript 6에서는 Rest 아이템을 사용하여 같은 방식으로 작동하도록 할 수 있습니다. 12345// ECMAScript 6에서 Array 복제본 만들기let colors = [ \"red\", \"green\", \"blue\" ];let [ ...clonedColors ] = colors;console.log(clonedColors); //\"[red,green,blue]\" 이 예제에서 Rest 아이템은 colors Array의 값을 clonedColors Array에 복제하는데 사용됩니다. 이 기법이 concat() 메서드를 사용하는 것보다 개발자의 의도를 더 명확하게 하는지 여부에 대한 문제는 있지만 유용한 기능입니다. Rest 아이템은 Destructuring Array의 마지막 엔트리여야하며 뒤에 쉼표를 붙일 수 없습니다. Rest 아이템 뒤에 쉼표를 포함시키면 구문 오류가 발생합니다. 혼합된 Destructuring객체와 Array Destructuring은 더 복잡한 표현식을 만들기 위해 함께 사용될 수 있습니다. 이렇게하면 객체와 Array을 혼합하여 원하는 정보만 추출할 수 있습니다. 123456789101112131415161718192021222324let node = &#123; type: \"Identifier\", name: \"foo\", loc: &#123; start: &#123; line: 1, column: 1 &#125;, end: &#123; line: 1, column: 4 &#125; &#125;, range: [0, 3] &#125;;let &#123; loc: &#123; start &#125;, range: [ startIndex ]&#125; = node;console.log(start.line); // 1console.log(start.column); // 1console.log(startIndex); // 0 이 코드는 node.loc.start와 node.range[0]을 start와 startIndex로 각각 추출합니다. Destructuring 패턴의 loc:과 range:는 node 객체의 프로퍼티에 해당하는 위치에 지나지 않습니다. 객체와 Array Destructuring의 조합을 사용할 때 node에서 Destructuring을 사용하여 모두 추출 가능합니다. 이 방법은 전체 구조를 탐색하지 않고도 JSON 설정에서 값을 가져 오는데 특히 유용합니다. Destructuring 파라미터Destructuring은 특히 유용한 유스케이스를 가지고 있으며, 그것은 함수 파라미터를 전달할 때입니다. JavaScript 함수가 많은 수의 Optional 파라미터를 가질때의 공통 패턴은 다음과 같이 추가 파라미터를 지정하는 프로퍼티가 있는 options 객체를 만드는 것입니다. 123456789101112131415161718// options의 프로퍼티는 추가 파라미터를 나타냅니다.function setCookie(name, value, options) &#123; options = options || &#123;&#125;; let secure = options.secure, path = options.path, domain = options.domain, expires = options.expires; // code to set the cookie&#125;// 세 번째 파라미터가 options에 매핑됩니다.setCookie(\"type\", \"js\", &#123; secure: true, expires: 60000&#125;); 많은 JavaScript 라이브러리에는 위 예제와 비슷한 setCookie() 함수를 가지고 있습니다. 이 함수에서 name과 value 파라미터는 있지만 secure, path, domain, expires는 없습니다. 다른 데이터에 대한 우선 순위가 없으므로 이름이 붙은 속성을 가진 options 객체를 파라미터로 받는 것은 효율적입니다. 하지만 이 접근 방식은 잘 작동하지만 함수 정의를 보면 함수가 예상하는 입력을 알 수 없고 함수 본문을 봐야합니다. Destructured 파라미터는 함수가 예상하는 인수를 명확하게 하는 대안을 제공합니다. Destructured 파라미터는 명명된 파라미터 대신에 객체 또는 Array Destructuring 패턴을 사용합니다. 이것을 실제로 보기위해 setCookie() 함수를 다시 작성해 보겠습니다. 123456789function setCookie(name, value, &#123; secure, path, domain, expires &#125;) &#123; // code to set the cookie&#125;setCookie(\"type\", \"js\", &#123; secure: true, expires: 60000&#125;); 이 함수는 이전 예제와 비슷하게 동작하지만, 이제는 세 번째 파라미터가 Destructuring을 사용하여 필요한 데이터를 추출합니다. Destructured 파라미터 밖의 파라미터는 명확하게 예상되는 동시에 setCookie()를 사용하는 사람에게는 여분의 인수로 options를 사용할 수 있다는 것을 분명히합니다. 물론 세 번째 파라미터가 필요한 경우에는 그 값을 명확히 해야합니다. Destructured 파라미터는 전달되지 않는 경우 undefined로 설정된다는 점에서 일반 파라미터 처럼 작동합니다. Destructured 파라미터는 지금까지 이 장에서 배웠던 Destructuring의 모든 기능을 가지고 있습니다. Default 값, 혼합 객체 및 Array 패턴을 사용할 수 있으며, 읽고있는 프로퍼티 이름과 다른 변수 이름을 사용할 수 있습니다. Destructured 파라미터는 필수 항목 입니다.Destructured 파라미터의 한가지 단점은 기본적으로 함수 호출에서 파라미터가 제공되지 않으면 오류가 발생한다는 것입니다. 예를 들어, 마지막 예제에서 setCookie() 함수를 아래와 같이 호출하면 에러가 발생합니다. 12// Error!setCookie(\"type\", \"js\"); 세 번째 파라미터가 누락되어 예상대로 undefined으로 평가됩니다. 이것은 Destructured 파라미터가 Destructuring 선언의 축약이기 때문에 오류가 발생합니다. setCookie() 함수가 호출될 때, JavaScript 엔진은 실제로 아래와 같이 수행합니다. 123456function setCookie(name, value, options) &#123; let &#123; secure, path, domain, expires &#125; = options; // code to set the cookie&#125; 오른쪽 표현식이 null 또는 undefined로 평가될 때 Destructuring은 에러를 던지기 때문에 세 번째 파라미터가 setCookie()함수에 전달되지 않을 때도 마찬가지입니다. Destructured 파라미터가 필요하다면 이 동작이 문제가 되지 않습니다. 그러나 Destructured 파라미터를 Optional로 하고 싶다면 다음과 같이 Destructured 파라미터에 Default 값을 제공하면 이 문제를 해결할 수 있습니다. 1234function setCookie(name, value, &#123; secure, path, domain, expires &#125; = &#123;&#125;) &#123; // ...&#125; 이 예제는 새로운 객체를 세 번째 파라미터의 Default 값으로 제공합니다. setCookie()의 세 번째 파라미터인 Destructured 파라미터에 Default 값을 지정하면 secure, path, domain, expires는 undefined가 제공되며 오류가 발생하지 않습니다. Destructuring 파라미터의 Default 값Destructured 파라미터에 Default 값을 지정할 수 있습니다. 파라미터에 등호를 추가하고 Default 값을 지정하면됩니다. 1234567891011function setCookie(name, value, &#123; secure = false, path = \"/\", domain = \"example.com\", expires = new Date(Date.now() + 360000000) &#125; = &#123;&#125;) &#123; // ...&#125; Destructured 파라미터의 각 프로퍼티는 이 코드에서 Default 값을 가지므로 올바른 값을 사용하기 위해 주어진 프로퍼티가 포함되었는지 확인하는 것을 피할 수 있습니다. 또한, 전체 Destructured 파라미터는 빈 객체의 기본값을 가지며, 파라미터는 Optional 입니다. 이렇게 하면 함수 선언이 평소보다 약간 더 복잡해 보이지만 각 파라미터에 사용할 수있는 값이 있는지 확인하는데 드는 비용이 더 적습니다. 요약Destructuring은 JavaScript에서 객체와 Array로 작업하는 것을 더 쉽게 만듭니다. 익숙한 객체 리터럴 및 Array 리터럴 구문을 사용하면 관심있는 정보만 얻을 수 있는 데이터 구조를 선택할 수 있습니다. 객체 패턴을 사용하면 객체에서 데이터를 추출할 수 있으며 Array 패턴을 사용하면 Array에서 데이터를 추출할 수 있습니다. 객체와 Array Destructuring은 undefined인 프로퍼티나 항목에 대해 Default 값을 지정할 수 있으며, 할당의 오른쪽이 null 또는 undefined로 평가되면 오류를 던집니다. 임의의 깊이로 내림차순으로 오브젝트와 Array Destructuring을 사용하여 깊이 중첩된 데이터 구조를 탐색할 수도 있습니다. Destructuring 선언은 변수를 만들기 위해 var, let 또는 const를 사용하며 항상 초기화를 해야합니다. Destructuring 할당은 다른 할당 대신에 사용되며, 객체 프로퍼티와 이미 존재하는 변수로 분해할 수 있습니다. Destructured 파라미터는 Destructuring 구문을 사용하여 함수 파라미터로 사용될 때 &quot;options&quot;객체를 더 투명하게 만듭니다. 관심있는 실제 데이터를 다른 명명된 파라미터와 함께 나열할 수 있습니다. Destructured 파라미터는 Array 패턴, 오브젝트 패턴 또는 혼합 패턴이 될 수 있으며 Destructuring의 모든 기능을 사용할 수 있습니다. 이 내용은 나중에 참고하기 위해 제가 공부하며 정리한 내용입니다.의역, 오역, 직역이 있을 수 있음을 알려드립니다.This post is a translation of this original article [https://leanpub.com/understandinges6/read#leanpub-auto-destructuring-for-easier-data-access] 참고 ECMAScript 6 Block Binding ECMAScript 6 문자열과 정규 표현식 ECMAScript 6 함수 ECMAScript 6 객체의 확장된 기능 ECMAScript 6 쉬운 데이터 액세스를 위한 Destructuring ECMAScript 6 Symbol과 Symbol 프로퍼티 ECMAScript 6 Set과 Map ECMAScript 6 Iterator와 Generator ECMAScript 6 JavaScript 클래스 소개 ECMAScript 6 Array 기능 향상 ECMAScript 6 Promise와 비동기 프로그램밍 ECMAScript 6 프록시와 리플렉션 API ECMAScript 6 Module로 코드 캡슐화하기 ECMAScript 6 부록 A. 작은 변경 사항 ECMAScript 6 부록 B. ECMAScript 7(2016) 이해하기","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://infoscis.github.io/categories/JavaScript/"},{"name":"ECMAScript 2015","slug":"JavaScript/ECMAScript-2015","permalink":"http://infoscis.github.io/categories/JavaScript/ECMAScript-2015/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://infoscis.github.io/tags/JavaScript/"},{"name":"ECMAScript 2015","slug":"ECMAScript-2015","permalink":"http://infoscis.github.io/tags/ECMAScript-2015/"}]},{"title":"ECMAScript 6 객체의 확장된 기능","slug":"ecmascript-6-expanded-object-functionality","date":"2018-01-25T14:51:56.000Z","updated":"2018-02-27T14:12:12.901Z","comments":true,"path":"2018/01/25/ecmascript-6-expanded-object-functionality/","link":"","permalink":"http://infoscis.github.io/2018/01/25/ecmascript-6-expanded-object-functionality/","excerpt":"","text":"객체의 확장된 기능ECMAScript 6은 객체의 유용성을 향상 시키는데 중점을 두고 있습니다. 이것은 JavaScript의 거의 모든 값이 어떤 유형의 객체이기 때문에 의미가 있습니다. 또한 JavaScript 프로그램에 평균적으로 사용되는 객체의 수는 JavaScript 응용 프로그램의 복잡성이 증가함에 따라 계속 증가하고 있습니다. 이는 복잡한 프로그램이 항상 더 많은 객체를 생성한다는 것을 의미합니다. 객체가 많을수록 객체를 보다 효과적으로 사용할 필요성이 커집니다. ECMAScript 6는 간단한 구문 확장부터 조작 및 상호 작용을 위한 옵션에 이르기까지 다양한 방법으로 객체의 사용성을 향상시킵니다. 객체 카테고리 (Object Category)JavaScript는 브라우저나 Node.js와 같은 실행 환경에 의해 추가된 것과 다르게, 표준에 정의된 객체를 설명하기 위해 여러 용어를 사용하며, ECMAScript 6 사양은 이러한 객체의 각 카테고리에 대한 명확한 정의를 가지고 있습니다. 또한 언어 전체를 잘 이해하려면 이러한 용어를 이해하는 것이 매우 중요합니다. 객체의 카테고리는 다음과 같습니다. 평범한 객체(Ordinary object)는 JavaScript의 객체에 대한 모든 기본 내부 동작을 가집니다. 특수한 객체(Exotic object)는 어떤면에서 기본과 다른 내부 동작이 있습니다. 표준 객체(Standard object)는 Array, Date등과 같이 ECMAScript 6에 의해 정의된 객체입니다. 표준 객체는 평범하거나 특이할 수 있습니다. Built-in 객체는 스크립트가 실행되기 시작하면 JavaScript 실행 환경에 존재하게 됩니다. 모든 표준 객체는 Built-in 객체입니다. ECMAScript 6에 정의된 다양한 객체를 설명하기 위해 위의 용어를 사용합니다. 객체 리터럴 문법 확장객체 리터럴은 JavaScript에서 가장 인기있는 패턴 중 하나입니다. 구문에 따라 작성된 JSON은 인터넷의 거의 모든 JavaScript 파일에 있습니다. 객체 리터럴은 여러줄의 코드를 필요로하는 객체를 만드는 간결한 구문이기 때문에 매우 유용합니다. 다행히도 개발자를 위해 ECMAScript 6은 여러 가지 방법으로 구문을 확장하여 객체 리터럴을 더욱 강력하고 간결하게 만듭니다. 프로퍼티 초기화 단축 (Property Initializer Shorthand) 기능ECMAScript 5 및 이전 버전에서 객체 리터럴은 단순히 name-value 쌍의 모음이었습니다. 즉, 값을 초기화할 때 중복이 있을 수 있습니다. 123456function createPerson(name, age) &#123; return &#123; name: name, age: age &#125;;&#125; createPerson() 함수는 프로퍼티 이름이 함수 파라미터 이름과 같은 객체를 생성합니다. 하나는 객체 프로퍼티의 이름이고 다른 하나는 그 프로퍼티에 대한 값을 제공하지만 결과는 name과 age의 중복으로 나타납니다. 리턴 객체의 키 name에는 파라미터 name 값이 할당되고 키 age에는 파라미터 age의 값이 할당됩니다. ECMAScript 6에서는 프로퍼티 초기화의 단축(Property Initializer Shorthand)을 사용하여 프로퍼티 이름과 로컬 변수에 존재하는 중복을 제거할 수 있습니다. 객체 프로퍼티 이름이 로컬 변수 이름과 같으면 콜론과 값 없이 name을 포함할 수 있습니다. 예를 들어, createPerson()은 다음과 같이 ECMAScript 6으로 재작성할 수 있습니다. 123456function createPerson(name, age) &#123; return &#123; name, age &#125;;&#125; 객체 리터럴의 프로퍼티에 이름만 있으면 JavaScript 엔진은 Scope내의 같은 이름의 변수를 조사합니다. 변수를 찾으면 해당 변수의 값이 객체 리터럴의 동일한 이름에 지정됩니다. 위 예제에서, 객체 리터럴 프로퍼티 name에는 로컬 변수 name의 값이 할당됩니다. 이러한 확장 기능은 객체 리터럴 초기화를 훨씬 간결하게 만들고 명명 오류를 제거하는데 도움이됩니다. 로컬 변수와 같은 이름의 프로퍼티를 할당하는 것은 JavaScript에서 매우 빈번히 발견되는 패턴이므로 이런 확장기능은 환영할만 합니다. 간결한 메서드 (Concise Method)또한 ECMAScript 6은 메서드를 객체 리터럴에 할당하는 구문을 향상시켰습니다. ECMAScript 5 및 이전 버전에서는 다음과 같이 이름을 먼저 지정하고 함수 정의를 지정하여 객체에 메서드를 추가해야합니다. 123456var person = &#123; name: \"Nicholas\", sayName: function() &#123; console.log(this.name); &#125;&#125;; ECMAScript 6에서는 콜론 및 function 키워드를 제거하여 구문을 보다 간결하게 만듭니다. 이전 예제를 다음과 같이 다시 작성할 수 있습니다. 123456var person = &#123; name: \"Nicholas\", sayName() &#123; console.log(this.name); &#125;&#125;; 간결한 메서드 (Concise Method) 구문 이라고 하는 이 단축 구문은 앞의 예와 마찬가지로 person 객체에 대한 메서드를 만듭니다. sayName() 프로퍼티는 익명의 함수에 할당되며 ECMAScript 5 sayName() 함수와 동일한 특성을 가지고 있습니다. 한가지 차이점은 간결한 메서드 (Concise Method) 구문은 super(“super 참조를 사용한 쉬운 프로토 타입 액세스”섹션에서 나중에 설명합니다.)를 사용하는 반면 간결하지 않는 방법은 사용할 수 없다는 점입니다. 간결한 메서드 (Concise Method) 구문을 사용하여 생성된 메서드의 name 프로퍼티는 괄호 앞에 사용된 이름입니다. 마지막 예제에서 person.sayName()의 name 프로퍼티는 “sayName”입니다. 프로퍼티의 계산된 이름ECMAScript 5 및 이전 버전에서는 프로퍼티를 점 표기 대신 대괄호로 설정하면 객체 인스턴스의 프로퍼티 이름을 계산하여 지정할 수 있었습니다. 대괄호를 사용하여 변수의 식별자를 사용하면, 구문 오류가 발생할 수 있는 문자가 포함된 문자열 및 문자열 리터럴을 사용하여 프로퍼티 이름을 지정할 수 있습니다. 아래 예제를 살펴보겠습니다. 12345678var person = &#123;&#125;, lastName = \"last name\";person[\"first name\"] = \"Nicholas\";person[lastName] = \"Zakas\";console.log(person[\"first name\"]); // \"Nicholas\"console.log(person[lastName]); // \"Zakas\" lastName에 &quot;last name&quot; 값이 할당되어 이 예제의 두 프로퍼티 이름 모두 공백을 사용합니다. 그러므로 점 표기법을 사용하여 프로퍼티 이름을 참조할 수 없습니다. 그러나 대괄호 표기법을 사용하면 모든 문자열 값을 프로퍼티 이름으로 사용할 수 있으므로 &quot;first name&quot;을 &quot;Nicholas&quot;에 할당하고, &quot;last name&quot;을 “Zakas”에 할당하면 정상 실행됩니다. 또한 아래와 같이 문자열 리터럴을 객체 리터럴의 프로퍼티 이름으로 직접 사용할 수 있습니다. 12345var person = &#123; \"first name\": \"Nicholas\"&#125;;console.log(person[\"first name\"]); // \"Nicholas\" 이 패턴은 미리 알려진 프로퍼티 이름에 적용되며 문자열 리터럴로 나타낼 수 있습니다. 그러나 프로퍼티 이름 &quot;first name&quot;이 변수에 포함되어 있거나 (앞의 예에서와 같이) 계산되어야 하는 경우 ECMAScript 5에서 객체 리터럴을 사용하여 해당 프로퍼티를 정의할 수 있는 방법이 없습니다. ECMAScript 6에서 계산된 프러퍼티 이름은 객체 리터럴 구문의 일부이며 객체 인스턴스에서 계산된 프로퍼티 이름을 참조하는데 사용된 동일한 대괄호 표기법을 사용합니다. 123456789var lastName = \"last name\";var person = &#123; \"first name\": \"Nicholas\", [lastName]: \"Zakas\"&#125;;console.log(person[\"first name\"]); // \"Nicholas\"console.log(person[lastName]); // \"Zakas\" 객체 리터럴 안의 대괄호는 속성 이름이 계산됨을 나타내므로 내용이 문자열로 평가됩니다. 즉, 다음과 같이 표현식을 포함할 수도 있습니다. 123456789var suffix = \" name\";var person = &#123; [\"first\" + suffix]: \"Nicholas\", [\"last\" + suffix]: \"Zakas\"&#125;;console.log(person[\"first name\"]); // \"Nicholas\"console.log(person[\"last name\"]); // \"Zakas\" 이러한 속성은 “first name”과 “last name”으로 평가되며 나중에 이 문자열을 사용하여 프로퍼티를 참조할 수 있습니다. 객체 인스턴스에 대괄호 표기법을 사용하면, 객체 리터럴 내에서 계산된 프로퍼티 이름으로 적용되기 때문에 어떤것 이든 대괄호 안에 넣을 수 있습니다. 새로운 메서드들ECMAScript가 ECMAScript 5를 시작할때 디자인한 목표 중 하나는 Object.prototype에 새로운 전역 함수 또는 메서드를 만드는 것을 피하고 대신 새 메서드를 사용할 수 있는 객체를 찾으려고 했습니다. 결과적으로, Global Object는 다른 오브젝트가 더 적합하지 않을 때 점점 많은 메서드가 추가되었습니다. ECMAScript 6에서는 특정 작업을 보다 쉽게하기 위해 디자인된 Global Object에 몇 가지 새로운 메서드를 도입했습니다. Object.is() 메서드JavaScript에서 두 값을 비교하고자 할 때, ==(equals 연산자) 또는 ===(Identically equals 연산자)를 사용하는 데 익숙합니다. 많은 개발자들이 비교하는 동안 타입 강제(Type coercion)를 피하기 위해 후자를 선호합니다. 그러나 === 연산자조차도 완전히 정확하지는 않습니다. 예를 들어, +0과 -0 값은 JavaScript 엔진에서 다르게 표현 되더라도 ===는 같은 값으로 간주됩니다. 또한 NaN === NaN은 false를 반환합니다. NaN 프로퍼티를 적절히 감지하기 위해서는 isNaN()을 사용해야합니다. ECMAScript 6는 Identically equals 연산자의 단점을 보충하기 위해 Object.is() 메서드를 도입했습니다. 이 메서드는 두 개의 파라미터를 받아들여 값이 동일하면 true를 리턴합니다. 두 값은 동일한 타입이고 동일한 값을 가질 때 동등한 것으로 간주됩니다. 여기 몇 가지 예제를 살펴보겠습니다. 1234567891011121314console.log(+0 == -0); // trueconsole.log(+0 === -0); // trueconsole.log(Object.is(+0, -0)); // falseconsole.log(NaN == NaN); // falseconsole.log(NaN === NaN); // falseconsole.log(Object.is(NaN, NaN)); // trueconsole.log(5 == 5); // trueconsole.log(5 == \"5\"); // trueconsole.log(5 === 5); // trueconsole.log(5 === \"5\"); // falseconsole.log(Object.is(5, 5)); // trueconsole.log(Object.is(5, \"5\")); // false 대부분의 경우 Object.is()는 === 연산자와 똑같이 작동합니다. 유일한 차이점은 +0과 -0이 동등하지 않은 것으로 간주되고 NaN이 NaN과 같은 것으로 간주된다는 것입니다. 그렇기 때문에 Equal 연산자 사용을 중지할 필요는 없습니다. 위와 같이 특수한 경우에 == 또는 === 대신 Object.is() 사용을 선택할 수도 있습니다. Object.assign() 메서드Mixin은 JavaScript에서 객체 구성을 위한 가장 인기있는 패턴 중 하나입니다. Mixin에서 한 객체는 다른 객체에서 프로퍼티와 메서드를 받습니다. 많은 JavaScript 라이브러리에는 다음과 유사한 Mixin 메서드가 있습니다. 1234567function mixin(receiver, supplier) &#123; Object.keys(supplier).forEach(function(key) &#123; receiver[key] = supplier[key]; &#125;); return receiver;&#125; mixin() 함수는 supplier 자신의 프로퍼티를 반복하여 receiver에 복사합니다 (얕은 복사, 프로퍼티 값이 객체 일 때 객체 참조가 공유됩니다). 이렇게하면 아래 코드와 같이 receiver가 상속 없이 새 프로퍼티를 얻을 수 있습니다. 1234567891011function EventTarget() &#123; /*...*/ &#125;EventTarget.prototype = &#123; constructor: EventTarget, emit: function() &#123; /*...*/ &#125;, on: function() &#123; /*...*/ &#125;&#125;;var myObject = &#123;&#125;;mixin(myObject, EventTarget.prototype);myObject.emit(\"somethingChanged\"); 위 코드에서 myObject는 EventTarget.prototype 객체로부터 메서드를 받습니다. 이것은 myObject에게 이벤트를 퍼블리시하고 emit()과 on()메서드를 사용하여 이벤트를 구독하는 기능을 제공합니다. 이 패턴은 ECMAScript 6가 Object.assign() 메서드를 추가할 만큼 충분히 대중적이되어, 같은 방식으로 동작하고, Receiver 와 임의의 Supplier를 받아 들인 다음 Receiver를 반환합니다. mixin()에서 assign()으로 이름을 바꾸면 실제 작업이 반영됩니다. mixin()함수는 대입 연산자(=)를 사용하기 때문에 접근자(accessor) 프로퍼티를 접근자(accessor) 프로퍼티로 Receiver에 복사할 수 없습니다. 이러한 차이를 반영하기 위해 Object.assign()이라는 이름이 선택되었습니다. 다양한 라이브러리에서 동일한 기능을 수행하는 비슷한 메서드가 있을 수 있으며 대부분 extend()및 mix()을 사용합니다. ECMAScript 6에는 Object.assign() 메서드 외에도 Object.mixin() 메서드가 있습니다. 가장 큰 차이점은 Object.mixin()도 접근자 프로퍼티를 이용해 복사되었지만 super (이 장의 “Super 참조를 이용한 쉬운 프로토 타입 액세스”절에서 설명 함) 사용에 대한 우려로 이 메서드가 제거 되었습니다. mixin() 함수가 사용된 곳이면 어디에서나 Object.assign()을 사용할 수 있습니다. 다음 코드는 그러한 예제입니다. 1234567891011function EventTarget() &#123; /*...*/ &#125;EventTarget.prototype = &#123; constructor: EventTarget, emit: function() &#123; /*...*/ &#125;, on: function() &#123; /*...*/ &#125;&#125;var myObject = &#123;&#125;Object.assign(myObject, EventTarget.prototype);myObject.emit(\"somethingChanged\"); Object.assign() 메서드는 여러 Supplier를 받아들이며 Receiver는 Supplier가 지정된 순서대로 프로퍼티를 수신합니다. 이는 두 번째 Supplier가 Receiver의 첫 번째 Supplier의 값을 덮어 쓸 수 있음을 의미합니다. 다음 코드를 살펴 보겠습니다. 1234567891011121314var receiver = &#123;&#125;;Object.assign(receiver, &#123; type: \"js\", name: \"file.js\" &#125;, &#123; type: \"css\" &#125;);console.log(receiver.type); // \"css\"console.log(receiver.name); // \"file.js\" receiver.type의 값은 “css”입니다. 왜냐하면 두 번째 Supplier가 첫 번째 Supplier의 값을 덮어 쓰기 때문입니다. Object.assign() 메서드는 ECMAScript 6에 큰 변경사항은 아니지만 많은 JavaScript 라이브러리에서 볼 수있는 공통 기능을 공식화 한것입니다. 접근자(Accessor) 프로퍼티로 작업하기Object.assign()은 Supplier가 접근자(Accessor) 프로퍼티를 가질 때 Receiver에 접근자(Accessor) 프로퍼티를 생성하지 않는다는 것을 명심하십시오. Object.assign()은 대입 연산자를 사용하기 때문에 Supplier의 접근자(Accessor) 프로퍼티는 Receiver의 데이터 프로퍼티가 됩니다. 12345678910111213var receiver = &#123;&#125;, supplier = &#123; get name() &#123; return \"file.js\" &#125; &#125;;Object.assign(receiver, supplier);var descriptor = Object.getOwnPropertyDescriptor(receiver, \"name\");console.log(descriptor.value); // \"file.js\"console.log(descriptor.get); // undefined 이 코드에서 Supplier는 name이라는 접근자(Accessor) 프로퍼티를 가지고 있습니다. Object.assign() 메서드를 사용한 후에 receiver.name의 값은 &quot;file.js&quot;인 데이터 프로퍼티로서 존재합니다. 왜냐하면 Object.assign()을 호출 했기 때문에 supplier.name이 &quot;file.js&quot;를 리턴했기 때문입니다. 객체 리터럴의 중복 프로퍼티 처리ECMAScript 5 strict 모드는 중복이 발견되면 오류를 던질 중복 객체 프로퍼티에 대한 검사를 도입했습니다. 예를 들어, 이 코드는 문제가 있었습니다. 123456\"use strict\";var person = &#123; name: \"Nicholas\", name: \"Greg\" // ES5 strict mode에서는 구문오류가 발생합니다.&#125;; ECMAScript 5의 strict 모드에서 실행될 때, 두 번째 name 프로퍼티는 구문 오류를 일으킵니다. 그러나 ECMAScript 6에서는 중복 프로퍼티 검사가 제거되었습니다. strict와 nonstrict 모드 코드는 더 이상 중복 프로퍼티를 검사하지 않습니다. 대신, 아래 코드에서 보여주는 대로 같은 이름의 마지막 프로퍼티가 프로퍼티의 실제값이 됩니다. 12345678\"use strict\";var person = &#123; name: \"Nicholas\", name: \"Greg\" // ES6 strict mode에서 에러가 발생하지 않습니다.&#125;;console.log(person.name); // \"Greg\" 위 예제에서 person.name의 값은 그 프로퍼티에 할당된 마지막 값이기 때문에 “Greg”입니다. 자신의 프로퍼티 열거 순서ECMAScript 5는 객체 프로퍼티의 열거순서를 정의하지 않았습니다. JavaScript 엔진 공급 업체에 맡겨 놓았기 때문입니다. 그러나 ECMAScript 6에서는 열거될 경우 자신의 프로퍼티를 반환해야하는 순서를 엄격하게 정의합니다. 이것은 Object.getOwnPropertyNames()와 Reflect.ownKeys (12 장에서 다룹니다.)를 사용하여 프로퍼티를 반환하는 방법에 영향을 미칩니다. 그리고 Object.assign()에 의해 프로퍼티가 처리되는 순서에도 영향을 미칩니다. 자신의 프로퍼티 기본 열거 순서는 다음과 같습니다. 모든 숫자키는 오름차순으로 표시됩니다. 모든 문자열키는 객체에 추가된 순서대로 표시됩니다. 모든 Symbol(6 장에서 다룹니다.)키는 객체에 추가된 순서대로 표시됩니다. 아래 예제를 살펴보겠습니다. 123456789101112var obj = &#123; a: 1, 0: 1, c: 1, 2: 1, b: 1, 1: 1&#125;;obj.d = 1;console.log(Object.getOwnPropertyNames(obj).join(\"\")); // \"012acbd\" Object.getOwnPropertyNames() 메서드는 obj의 프로퍼티를 0, 1, 2, a, c, b, d 순서로 리턴합니다. 숫자 키는 객체 리터럴에서 순서가 어긋나지만 함께 그룹화되고 정렬됩니다. 문자열 키는 숫자 키 뒤에 오며 obj에 추가된 순서대로 나타납니다. 객체 리터럴 자신의 키가 먼저오고 나중에 추가된 동적 키 (이 경우 d)가 옵니다. for-in loop는 여전히 모든 JavaScript 엔진이 같은 방식으로 구현하지 않았기 때문에 불특정한 열거 순서를 가지고 있습니다. Object.keys() 메서드와 JSON.stringify()는 모두 for-in과 같은 (불특정한) 열거 순서를 사용하도록 지정되어 있습니다. 열거 순서는 JavaScript가 작동하는 방식에 미묘한 변화이지만, 정확한 열거에 의존하는 프로그램을 찾는건 드문일이 아닙니다. 열거 순서를 정의함으로써 ECMAScript 6은 열거형에 의존하는 JavaScript 코드가 어디에 실행되는지에 관계없이 올바르게 작동하도록합니다. 더 강력한 프로퍼티들Prototype은 JavaScript의 상속의 토대이며 ECMAScript 6는 Prototype을 계속해서 더 강력하게 만듭니다. 초기 버전의 JavaScript는 Prototype을 통해 수행할 수있는 작업을 심각하게 제한했습니다. 그러나 언어가 발전하고 개발자가 Prototype이 어떻게 작동하는지 더 잘 알게됨에 따라 개발자들은 Prototype을 더 많이 컨트롤 하고, 쉬운 방법으로 제어하기를 원했습니다. 결과적으로 ECMAScript 6는 Prototype을 약간 개선했습니다. Object의 Prototype 변경일반적으로 객체의 Prototype은 객체가 생성될 때 생성자 또는 Object.create()메서드를 통해 지정됩니다. 인스턴스 생성후 객체의 Prototype이 변경되지 않는다는 생각은 ECMAScript 5까지 JavaScript 프로그래밍에서 가장 큰 가정 중 하나였습니다. ECMAScript 5는 주어진 객체의 Prototype을 찾기하기 위해 Object.getPrototypeOf() 메서드를 추가했지만 인스턴스화 후에 객체의 Prototype을 변경하는 표준 방법이 여전히 부족했습니다. ECMAScript 6는 Object.setPrototypeOf() 메서드를 추가함으로써 이러한 가정을 바꿉니다. 이 메서드는 주어진 객체의 Prototype을 변경할 수 있게합니다. Object.setPrototypeOf() 메서드는 두 개의 파라미터를 받는데, 첫 번째는 Prototype이 변경 되어야하는 객체, 그리고 두 번째는 첫 번째 파라미터의 Prototype이 되어야하는 객체입니다. 123456789101112131415161718192021let person = &#123; getGreeting() &#123; return \"Hello\"; &#125;&#125;;let dog = &#123; getGreeting() &#123; return \"Woof\"; &#125;&#125;;// prototype은 personlet friend = Object.create(person);console.log(friend.getGreeting()); // \"Hello\"console.log(Object.getPrototypeOf(friend) === person); // true// prototype을 dog로 설정Object.setPrototypeOf(friend, dog);console.log(friend.getGreeting()); // \"Woof\"console.log(Object.getPrototypeOf(friend) === dog); // true 위 코드는 person과 dog라는 두 개의 기본 객체를 정의합니다. 두객체 모두 문자열을 반환하는 getGreeting() 메서드를 가지고 있습니다. 객체 friend는 먼저 person 객체를 상속받았기 때문에 getGreeting()은 &quot;Hello&quot;를 출력합니다. 그리고 Prototype이 dog 객체가 될 때 person.getGreeting()은 원래의 person과 관계가 깨졌기 때문에 &quot;Woof&quot;를 출력합니다. 객체의 Prototype의 실제 값은[[Prototype]]이라는 내부 전용 프로퍼티에 저장됩니다. Object.getPrototypeOf() 메서드는 [[Prototype]]에 저장된 값을 리턴하고 Object.setPrototypeOf()는 [[Prototype]]에 저장된 값을 변경합니다. 그러나 이 메서드들이 [[Prototype]]의 값을 이용해 작업하는 유일한 방법은 아닙니다. Super 참조를 이용한 쉬운 Prototype 접근앞서 언급했듯이, Prototype은 JavaScript에 매우 중요하며 많은 작업이 ECMAScript 6에서 사용하기가 더 쉬워졌습니다. 또 다른 개선점은 객체의 Prototype에 대한 기능을 보다 쉽게 액세스할 수 있게 해주는 super 참조의 도입입니다. 예를 들어, 객체 인스턴스의 메서드를 오버라이드하여 동일한 이름의 Prototype 메서드도 호출하도록 하는 다음 예제를 참고하세요. 12345678910111213141516171819202122232425262728let person = &#123; getGreeting() &#123; return \"Hello\"; &#125;&#125;;let dog = &#123; getGreeting() &#123; return \"Woof\"; &#125;&#125;;let friend = &#123; getGreeting() &#123; return Object.getPrototypeOf(this).getGreeting.call(this) + \", hi!\"; &#125;&#125;;// prototype을 person으로 설정Object.setPrototypeOf(friend, person);console.log(friend.getGreeting()); // \"Hello, hi!\"console.log(Object.getPrototypeOf(friend) === person); // true// prototype을 dog로 설정Object.setPrototypeOf(friend, dog);console.log(friend.getGreeting()); // \"Woof, hi!\"console.log(Object.getPrototypeOf(friend) === dog); // true 위의 예제에서, friend에 대한 getGreeting()은 같은 이름의 Prototype 메서드를 호출합니다. Object.getPrototypeOf() 메서드는 올바른 Prototype이 호출되었는지 확인한 다음 추가 문자열이 출력에 더해집니다. 게다가 .call(this)는 Prototype 메서드 내의 this 값이 올바르게 설정되도록합니다. Prototype에서 메서드를 호출하기 위해 Object.getPrototypeOf()와 .call(this)를 사용하는 것은 다소 복잡하기 때문에 ECMAScript 6는 super를 도입했습니다. 간단히 말해,super는 현재 객체의 Prototype을 가리키는 포인터이며, 사실상Object.getPrototypeOf(this) 값입니다. 다음과 같이 getGreeting() 메서드를 단순화할 수있습니다. 1234567let friend = &#123; getGreeting() &#123; // 이전 예제에서 이것은 다음과 같습니다. // Object.getPrototypeOf(this).getGreeting.call(this) return super.getGreeting() + \", hi!\"; &#125;&#125;; 위 예제에서 super.getGreeting()에 대한 호출은 Object.getPrototypeOf(this).getGreeting.call(this)와 동일합니다. 비슷하게, 간결한 메서드 내부에 있는 경우 super 참조를 사용하여 객체 Prototype의 모든 메서드를 호출할 수 있습니다. 하지만 간결한 메서드 밖에서 super를 사용하려고 시도하면 다음과 같이 구문 오류가 발생합니다. 123456let friend = &#123; getGreeting: function() &#123; // syntax error return super.getGreeting() + \", hi!\"; &#125;&#125;; 이 예제는 함수와 함께 명명된 프로퍼티를 사용하고 super가 이 컨텍스트에서 유효하지 않기 때문에 super.getGreeting()을 호출하면 구문 오류가 발생합니다. super 레퍼런스는 여러 레벨의 상속이있을 때 정말 강력합니다. 왜냐하면 Object.getPrototypeOf()가 더 이상 모든 상황에서 작동하지 않기 때문입니다. 123456789101112131415161718192021let person = &#123; getGreeting() &#123; return \"Hello\"; &#125;&#125;;// prototype is personlet friend = &#123; getGreeting() &#123; return Object.getPrototypeOf(this).getGreeting.call(this) + \", hi!\"; &#125;&#125;;Object.setPrototypeOf(friend, person);// prototype is friendlet relative = Object.create(friend);console.log(person.getGreeting()); // \"Hello\"console.log(friend.getGreeting()); // \"Hello, hi!\"console.log(relative.getGreeting()); // error! relative.getGreeting()이 호출되어 Object.getPrototypeOf()를 호출하면 오류가 발생합니다. 그것은 this가 relative이고, relative의 Prototype이 friend 객체이기 때문입니다. friend.getGreeting().call()이 relative를 this로 호출하면 프로세스는 다시 시작되어 스택 오버 플로우 오류가 발생할 때까지 재귀적으로 계속 호출됩니다. 이 문제를 ECMAScript 5에서는 해결하기가 어렵지만 ECMAScript 6의 super를 이용하면 쉽게 해결할 수 있습니다. 123456789101112131415161718192021let person = &#123; getGreeting() &#123; return \"Hello\"; &#125;&#125;;// prototype is personlet friend = &#123; getGreeting() &#123; return super.getGreeting() + \", hi!\"; &#125;&#125;;Object.setPrototypeOf(friend, person);// prototype is friendlet relative = Object.create(friend);console.log(person.getGreeting()); // \"Hello\"console.log(friend.getGreeting()); // \"Hello, hi!\"console.log(relative.getGreeting()); // \"Hello, hi!\" super 참조는 동적이 아니기 때문에 항상 올바른 객체를 참조합니다. 이 경우, super.getGreeting()은 얼마나 많은 다른 객체가 그 메서드를 상속 받았는지에 관계없이 항상 person.getGreeting ()을 참조합니다. Method의 공식적인 정의ECMAScript 6 이전에는 &quot;Method&quot;의 개념이 공식적으로 정의되지 않았습니다. Method는 데이터 대신 함수가 포함된 객체 프로퍼티었습니다. ECMAScript 6는 Method를 객체 내부의 [[HomeObject]] 프라퍼티를 가진 함수로 공식적으로 정의합니다. 다음 내용을 살펴보겠습니다. 123456789101112let person = &#123; // method getGreeting() &#123; return \"Hello\"; &#125;&#125;;// not a methodfunction shareGreeting() &#123; return \"Hi!\";&#125; 위 예제는 getGreeting()이라는 단일 메서드로 person을 정의합니다. getGreeting()의 [[HomeObject]]는 함수를 객체에 직접 할당함으로써 person을 정의합니다. 반면에 shareGreeting() 함수는 생성될 때 객체에 할당되지 않았으므로 [[HomeObject]]가 지정되어 있지 않습니다. 대부분의 경우 이 차이는 중요하지 않지만 super 참조를 사용할 때 매우 중요합니다. super에 대한 참조는 무엇을 할 것인가를 결정하기 위해 [[HomeObject]]를 사용합니다. 첫 번째 단계는 [[HomeObject]]에서 Object.getPrototypeOf()를 호출하여 Prototype에 대한 참조를 가져 오는 것입니다. 그런 다음 Prototype의 이름이 같은 함수가 검색됩니다. 마지막으로, 바인딩이 설정되고 Method가 호출됩니다. 다음은 예제를 살펴보겠습니다. 123456789101112131415let person = &#123; getGreeting() &#123; return \"Hello\"; &#125;&#125;;// prototype is personlet friend = &#123; getGreeting() &#123; return super.getGreeting() + \", hi!\"; &#125;&#125;;Object.setPrototypeOf(friend, person);console.log(friend.getGreeting()); // \"Hello, hi!\" friend.getGreeting() 호출은 person.getGreeting()의 값을 &quot;, hi!&quot;와 결합된 문자열을 반환합니다. friend.getGreeting()의 [[HomeObject]]는 friend이고 friend의 Prototype은 person이므로 super.getGreeting()은 person.getGreeting.call(this)와 동일합니다. 요약객체는 JavaScript 프로그래밍의 중심이며, ECMAScript 6는 객체를 보다 쉽게 다루고 더 강력하게 만드는 유용한 변경 사항을 만들었습니다. ECMAScript 6은 객체 리터럴을 몇 가지 변경했습니다. 간략한 프로퍼티 정의는 Scope 내 변수와 동일한 이름을 가진 프로퍼티를 쉽게 지정합니다. 계산된 프로퍼티 이름을 사용하면 리터럴 이외의 값을 프로퍼티 이름으로 지정할 수 있습니다. 간략한 메서드는 콜론과 function 키워드를 완전히 생략함으로써 훨씬 적은 수의 문자를 입력하여 객체 리터럴에 대한 메서드를 정의할 수 있게합니다. ECMAScript 6는 객체의 중복 프로퍼티 이름에 대해서도 strict 모드 검사를 느슨하게합니다. 즉, 객체 리터럴에 오류가 발생하지 않고 같은 이름의 두 프로퍼티를 가질 수 있습니다. Object.assign() 메서드는 한번에 하나의 객체에 대해 여러 속성을 변경하는 것을 더 쉽게 만듭니다. mixin 패턴을 사용하면 매우 유용할 수 있습니다. Object.is() 메서드는 어떤 값에 대해서도 엄격한 equal을 수행하며 특별한 JavaScript 값을 다룰 때 효과적인 ===의 안전한 버전입니다. ECMAScript 6에서는 자체 프로퍼티에 대한 열거 순서가 명확하게 정의되었습니다. 프로퍼티를 열거하면 숫자 키가 항상 오름차순으로 먼저 나오고 문자열 키가 삽입 순서에 맞춰 나오고 Symbol 키가 삽입 순서로 옵니다. ECMAScript 6의Object.setPrototypeOf()메서드 덕택에 객체의 Prototype을 이미 생성 한 후에 수정할 수 있습니다. 마지막으로,super 키워드를 사용하여 객체의 Prototype에 대한 메서드를 호출할 수 있습니다. super를 사용하여 호출된 메서드 내부의 this 바인딩은 this의 현재 값으로 자동으로 작동하도록 설정됩니다. 이 내용은 나중에 참고하기 위해 제가 공부하며 정리한 내용입니다.의역, 오역, 직역이 있을 수 있음을 알려드립니다.This post is a translation of this original article [https://leanpub.com/understandinges6/read#leanpub-auto-expanded-object-functionality] 참고 ECMAScript 6 Block Binding ECMAScript 6 문자열과 정규 표현식 ECMAScript 6 함수 ECMAScript 6 객체의 확장된 기능 ECMAScript 6 쉬운 데이터 액세스를 위한 Destructuring ECMAScript 6 Symbol과 Symbol 프로퍼티 ECMAScript 6 Set과 Map ECMAScript 6 Iterator와 Generator ECMAScript 6 JavaScript 클래스 소개 ECMAScript 6 Array 기능 향상 ECMAScript 6 Promise와 비동기 프로그램밍 ECMAScript 6 프록시와 리플렉션 API ECMAScript 6 Module로 코드 캡슐화하기 ECMAScript 6 부록 A. 작은 변경 사항 ECMAScript 6 부록 B. ECMAScript 7(2016) 이해하기","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://infoscis.github.io/categories/JavaScript/"},{"name":"ECMAScript 2015","slug":"JavaScript/ECMAScript-2015","permalink":"http://infoscis.github.io/categories/JavaScript/ECMAScript-2015/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://infoscis.github.io/tags/JavaScript/"},{"name":"ECMAScript 2015","slug":"ECMAScript-2015","permalink":"http://infoscis.github.io/tags/ECMAScript-2015/"}]},{"title":"ECMAScript 6 함수","slug":"ecmascript-6-functions","date":"2018-01-24T14:15:28.000Z","updated":"2018-02-27T14:12:01.601Z","comments":true,"path":"2018/01/24/ecmascript-6-functions/","link":"","permalink":"http://infoscis.github.io/2018/01/24/ecmascript-6-functions/","excerpt":"","text":"함수 (Function)함수는 JavaScript 프로그래밍 언어의 중요한 부분이며, JavaScript가 시작된 이후로 ECMAScript 6 이전까지 많이 변경되지 않았습니다. 이로 인해 실수가 많았고, 아주 기본적인 행동을하기 위해 더 많은 코드가 필요했으며, 미묘한 행동의 백 로그(backlog)가 남았습니다. ECMAScript 6 함수는 JavaScript 개발자의 수년간의 불만과 요청을 고려하여 큰 발전을 이루었습니다. 결과적으로 ECMAScript 5 기능 위에 점진적인 개선이 이루어져 JavaScript에서 오류를 발생시키지 않고 보다 강력하게 프로그래밍할 수있게 되었습니다. Default 파라미터 값이 있는 함수JavaScript의 함수는 함수 정의에 선언된 파라미터 수에 관계없이 여러 파라미터를 전달할 수 있다는 점에서 독특합니다. 이렇게하면 파라미터가 제공되지 않을 때 Default 값을 채우기만 하면 다른 개수의 파라미터를 처리할 수있는 함수를 정의할 수 있습니다. 이 절에서는 Default 파라미터가 ECMAScript 6에서 작동하는 방법과 arguments 객체에 대한 몇 가지 중요한 정보, 표현식을 파라미터로 사용하는 방법 및 또다른 TDZ에 대해 설명합니다. ECMAScript 5에서 Default 파라미터 시뮬레이션ECMAScript 5 및 이전 버전에서는 다음 패턴을 사용하여 Default 파라미터가 있는 함수를 만들 수 있습니다. 12345678function makeRequest(url, timeout, callback) &#123; timeout = timeout || 2000; callback = callback || function() &#123;&#125;; // 함수의 나머지 부분&#125; 이 예제에서, timeout과 callback은 실제로 파라미터가 제공되지 않을 때 Default 값이 주어지기 때문에 Optional입니다. 논리합 연산자 (||)는 첫 번째가 거짓 일 때 항상 두 번째 피연산자를 반환합니다. 명시적으로 제공되지 않은 명명된 함수 파라미터는 undefined로 설정되므로 논리 OR 연산자는 누락된 파라미터의 Default값을 제공하는 데 자주 사용됩니다. 그러나 timeout이 유효한 값 0일 수 있지만 0은 false이기 때문에 2000으로 바꿀 수 있다는 점에서 이 접근법에 결함이 있습니다. 이 경우보다 안전한 대안은 다음 예와 같이 typeof를 사용하여 파라미터의 유형을 확인하는 것입니다. 12345678function makeRequest(url, timeout, callback) &#123; timeout = (typeof timeout !== \"undefined\") ? timeout : 2000; callback = (typeof callback !== \"undefined\") ? callback : function() &#123;&#125;; // 함수의 나머지 부분&#125; 이 방법이 더 안전하지만 매우 기본적인 작업을 위해서는 많은 추가 코드가 필요합니다. 인기있는 JavaScript 라이브러리에는 이러한 비슷한 패턴으로 채워집니다. 이는 공통적으로 비슷한 패턴을 사용하기 때문입니다. ECMAScript 6의 Default 파라미터 값ECMAScript 6을 사용하면 파라미터가 전달되지 않을 때 사용되는 Default값을 보다 쉽게 제공할 수 있습니다. 12345function makeRequest(url, timeout = 2000, callback = function() &#123;&#125;) &#123; // 함수의 나머지 부분&#125; 이 함수는 첫 번째 파라미터가 항상 전달될 것으로 예상합니다. 다른 두 파라미터에는 Default 값이 있으므로 누락된 값을 확인하기 위해 코드를 추가할 필요가 없으므로 함수 본문이 훨씬 단순해집니다. makeRequest()가 세개의 파라미터 모두로 호출될 때, Default값은 사용되지 않습니다. 12345678910// uses default timeout and callbackmakeRequest(\"/foo\");// uses default callbackmakeRequest(\"/foo\", 500);// doesn't use defaultsmakeRequest(\"/foo\", 500, function(body) &#123; doSomething(body);&#125;); ECMAScript 6에서는 url이 필요하다고 생각하기 때문에 makeRequest()를 호출할 때마다 &quot;/foo&quot;가 전달됩니다. Default값이 있는 두 개의 파라미터는 선택적으로 간주됩니다. Default값은 함수 선언에서 파라미터의 어느 위치나 지정할 수 있습니다. 그렇기 때문에 모든 파라미터에 Default값을 지정할 수 있습니다. 예를 들면 다음과 같습니다. 12345function makeRequest(url, timeout = 2000, callback) &#123; // the rest of the function&#125; 이 경우 timeout의 Default값은 두 번째 파라미터가 전달되지 않았거나 두 번째 파라미터가 명시 적으로 undefined로 전달된 경우에만 사용됩니다. 123456789101112// default timeout을 사용합니다.makeRequest(\"/foo\", undefined, function(body) &#123; doSomething(body);&#125;);// default timeout을 사용합니다.makeRequest(\"/foo\");// default timeout을 사용하지 않습니다.makeRequest(\"/foo\", null, function(body) &#123; doSomething(body);&#125;); Default 파라미터의 경우, null의 값은 유효하다고 간주됩니다. 즉,makeRequest()에 대한 세 번째 호출에서 timeout의 Default 값은 사용되지 않습니다 Default 파라미터 값이 arguments Object에 미치는 영향Default 파라미터가 존재할 때 arguments 객체의 동작이 다르다는 것을 기억 해야 합니다. ECMAScript 5 nonstrict mode에서arguments 객체는 함수의 명명된 파라미터의 변경을 반영합니다. 이러한 작동 방식을 보여주는 코드는 다음과 같습니다. 12345678910function mixArgs(first, second) &#123; console.log(first === arguments[0]); console.log(second === arguments[1]); first = \"c\"; second = \"d\"; console.log(first === arguments[0]); console.log(second === arguments[1]);&#125;mixArgs(\"a\", \"b\"); 출력 결과 : 1234truetruetruetrue arguments 객체는 nonstrict mode에서 명명된 파라미터의 변경은 항상 업데이트 합니다. 따라서 첫 번째와 두 번째가 새로운 값으로 할당될 때 arguments[0]과 arguments[1]는 그에 따라 업데이트되어 모든 === 비교가 true로 해석됩니다. ECMAScript 5의 strict 모드는 arguments 객체의 혼란스러운면을 제거합니다. strict 모드에서, arguments 객체는 명명된 파라미터에 대한 변경을 반영하지 않습니다. 아래의 예제는 strict 모드에서 mixArgs() 함수를 보여줍니다. 123456789101112function mixArgs(first, second) &#123; \"use strict\"; console.log(first === arguments[0]); console.log(second === arguments[1]); first = \"c\"; second = \"d\" console.log(first === arguments[0]); console.log(second === arguments[1]);&#125;mixArgs(\"a\", \"b\"); mixArgs()의 실행 결과는 다음과 같습니다. 1234truetruefalsefalse 이번에는 first와 second를 변경해도 arguments에 영향을 미치지 않으므로 예상대로 실행됩니다. 그러나 ECMAScript 6의 Default 파라미터를 사용하는 함수의 arguments 객체는 함수가 명시적으로 strict 모드로 실행되는지 여부에 관계없이 ECMAScript 5 strict 모드와 동일한 방식으로 동작합니다. Default 파라미터가 있으면 arguments 객체가 명명된 파라미터에서 분리된 상태로 유지됩니다. 이는 arguments객체가 어떻게 사용되는 지에 대한 미묘하지만 중요한 세부 변경사항입니다. 다음 코드를 살펴 보겠습니다. 123456789101112// strict mode가 아님function mixArgs(first, second = \"b\") &#123; console.log(arguments.length); console.log(first === arguments[0]); console.log(second === arguments[1]); first = \"c\"; second = \"d\" console.log(first === arguments[0]); console.log(second === arguments[1]);&#125;mixArgs(\"a\"); 실행 결과 : 123451truefalsefalsefalse 이 예제에서 arguments.length는 1입니다. 왜냐하면 오직 하나의 파라미터가 mixArgs()에 전달 되었기 때문입니다. 이는 또한 arguments[1]이 undefined라는 것을 의미합니다. 이는 하나의 인수만 함수에 전달될 때 예상되는 동작입니다. 즉, first는arguments[0]과 같습니다. first와 second를 변경해도 arguments에는 아무런 영향을 미치지 않습니다. 이러한 현상은 nonstrict와 strict 모드 모두에서 발생하기 때문에 arguments를 사용하여 항상 초기 호출 상태를 확인할 수 있습니다. Default 파라미터 표현식아마도 Default 파라미터의 가장 흥미로운 특징은 Default 값이 Primitive 값일 필요는 없다는 것입니다. 예를 들어, 다음과 같이 함수를 실행하여 Default 파라미터를 검색할 수 있습니다. 12345678910function getValue() &#123; return 5;&#125;function add(first, second = getValue()) &#123; return first + second;&#125;console.log(add(1, 1)); // 2console.log(add(1)); // 6 여기에서 마지막 파라미터가 제공되지 않으면 getValue() 함수가 호출되어 올바른 Default 값을 검색합니다. getValue()는 두 번째 파라미터 없이 add()가 호출될 때만 호출되며 함수 선언이 처음 구문 분석될 때 호출되지 않는다는 점에 유의하십시오. 즉, getValue()가 다르게 작성된 경우 잠재적으로 다른 값을 반환할 수 있습니다. 12345678910111213let value = 5;function getValue() &#123; return value++;&#125;function add(first, second = getValue()) &#123; return first + second;&#125;console.log(add(1, 1)); // 2console.log(add(1)); // 6console.log(add(1)); // 7 이 예제에서, value는 5로 시작하고 getValue()가 호출될 때마다 증가합니다. add(1)에 대한 첫 번째 호출은 6을 반환하고, 두 번째 호출은 value가 증가했기 때문에 add(1)에 대한 호출은 7을 반환합니다. second에 대한 Default 값은 함수가 호출될 때만 평가되기 때문에 언제든지 그 값을 변경할 수 있습니다. 함수 호출을 Default 파라미터로 사용할 때는 주의하십시오. 마지막 예제에서 second = getValue와 같이 괄호를 잊어 버린 경우 함수 호출 결과가 아닌 함수에 대한 참조를 전달합니다. 이 동작은 또 다른 흥미로운 기능을 제공합니다. 이전 파라미터를 이후 파라미터의 Default로 사용할 수 있습니다. 다음은 그 예입니다. 123456function add(first, second = first) &#123; return first + second;&#125;console.log(add(1, 1)); // 2console.log(add(1)); // 2 이 코드에서 파라미터 second는 first를 Default 값으로 받습니다. 즉, 하나의 파라미터만 전달하면 두 인수가 같은 값으로 남게됩니다. add(1)은 2를 반환하고 add(1, 1)도 2를 반환합니다. 이 단계를 더 진행하면, first를 second의 값을 얻기위한 함수로 다음과 같이 전달할 수 있습니다 : 12345678910function getValue(value) &#123; return value + 5;&#125;function add(first, second = getValue(first)) &#123; return first + second;&#125;console.log(add(1, 1)); // 2console.log(add(1)); // 7 이 예제는 second를 getValue(first)에 의해 반환된 값과 동일하게 설정하므로 add(1, 1)은 여전히 2를 반환하지만 add(1)은 7 (1 + 6)을 반환합니다. Default 파라미터 지정에서 파라미터를 참조하는 기능은 앞의 arguments 에 대해서만 작동하므로 앞서는 arguments는 나중 arguments를 액세스할 수 없습니다. 123456function add(first = second, second) &#123; return first + second;&#125;console.log(add(1, 1)); // 2console.log(add(undefined, 1)); // throws error second가 first 다음에 정의되고 따라서 Default 값으로 사용할 수 없기 때문에 add(undefined, 1)에 대한 호출은 에러를 던집니다. 그런 일이 일어나는 이유를 이해하려면 Temporal dead zone을 다시 이해해야 합니다. Default 파라미터 Temporal Dead Zone1 장에서는 let과 const에 관련된 TDZ (Temporary Dead Zone)를 소개했고, Default 파라미터 중에 파라미터에 접근할 수 없는 TDZ도 있습니다. let 선언과 유사하게, 각 파라미터는 오류를 던지지 않고 초기화 전에 참조할 수 없는 새로운 식별자 바인딩을 생성합니다. 파라미터 초기화는 함수에 대한 값을 전달하거나 Default 파라미터를 사용하여 함수를 호출할 때 발생합니다. Default 파라미터 TDZ를 알아 보기위해 아래 예제와 같이 “Default 파라미터 표현식”에 대해 생각해 보겠습니다.. 12345678910function getValue(value) &#123; return value + 5;&#125;function add(first, second = getValue(first)) &#123; return first + second;&#125;console.log(add(1, 1)); // 2console.log(add(1)); // 7 add(1, 1)과 add(1)에 대한 호출은 효과적으로 first와 second 파라미터 값을 생성하기 위해 다음 코드를 실행합니다 : 1234567// add(1, 1)에 대한 JavaScript 표현let first = 1;let second = 1;// add(1)에 대한 JavaScript 표현let first = 1;let second = getValue(first); add()함수가 처음 실행될 때, first와 second 바인딩은 특정한 파라미터의 TDZ에 추가됩니다 (let의 동작과 유사합니다). 따라서 second가 first의 값으로 초기화될 수 있습니다. 왜냐하면 first는 항상 그때 초기화 되기 때문이고, 그 반대는 성립하지 않습니다. 이제, 다시 작성된 add()함수를 살펴 보겠습니다. 123456function add(first = second, second) &#123; return first + second;&#125;console.log(add(1, 1)); // 2console.log(add(undefined, 1)); // throws error 이 예제에서 add(1, 1)과 add(undefined, 1)에 대한 호출은 이제 아래 코드와 매핑됩니다. 1234567// add(1, 1) 호출의 JavaScript 표현let first = 1;let second = 1;// add(undefined, 1) 호출의 JavaScript 표현let first = second;let second = 1; 이 예제에서 add(undefined, 1) 호출은 first가 초기화될 때 second가 아직 초기화되지 않았기 때문에 에러를 던집니다. 이 시점에서 second는 TDZ에 있으므로 second에 대한 참조는 오류를 발생시킵니다. 이것은 1 장에서 논의한 let 바인딩의 동작이 반영됩니다. 함수의 파라미터는 자신의 scope와 함수 몸체 scope와는 별도의 TDZ를 가지고 있습니다. 즉, 파라미터의 Default값은 함수 본문 내에서 선언된 변수에 액세스할 수 없습니다. Unnamed 파라미터로 작업하기지금까지 이 장의 예제는 함수 정의에서 명명된 파라미터만을 다뤘습니다. 그러나 JavaScript 함수는 정의된 이름이 부여된 파라미터의 개수로, 전달할 수있는 파라미터의 수를 제한하지 않습니다. 공식적으로 지정된 것보다 더 적은 또는 더 많은 파라미터를 항상 전달할 수 있습니다. Default 파라미터 값은 함수가 더 적은 수의 파라미터를 받아 들일 수 있을 때 명확하게하고, ECMAScript 6는 정의된 것보다 더 많은 파라미터를 전달하는 문제를 만들려고했습니다. ECMAScript 5의 Unnamed 파라미터초기에 JavaScript는 각 파라미터를 개별적으로 정의하지 않고 전달된 모든 함수 파라미터를 검사하는 방법으로 arguments 객체를 제공했습니다. 대부분의 경우 arguments의 검사는 잘 작동하지만, 이 객체는 작업하기가 약간 번거로울 수 있습니다. 예를 들어, arguments 객체를 검사하는 이 코드를 생각해 보겠습니다. 123456789101112131415161718192021function pick(object) &#123; let result = Object.create(null); // 두 번째 파라미터에서 시작 for (let i = 1, len = arguments.length; i &lt; len; i++) &#123; result[arguments[i]] = object[arguments[i]]; &#125; return result;&#125;let book = &#123; title: \"Understanding ECMAScript 6\", author: \"Nicholas C. Zakas\", year: 2015&#125;;let bookData = pick(book, \"author\", \"year\");console.log(bookData.author); // \"Nicholas C. Zakas\"console.log(bookData.year); // 2015 이 함수는 Underscore.js 라이브러리의 pick () 메서드를 모방한 것입니다. 이 라이브러리는 원본 객체의 프로퍼티 중 일부가 복사된 객체를 반환합니다. 이 예에서는 하나의 파라미터만 정의하고 첫 번째 파라미터는 프로퍼티를 복사할 대상이될 것으로 예상합니다. 전달된 다른 모든 파라미터는 결과에 복사해야하는 프로퍼티의 이름입니다. 이 pick ()함수에 대해 주의해야 할 몇 가지 점이 있습니다. 첫째, 함수가 둘 이상의 파라미터를 처리할 수 있다는 것이 전혀 분명하지 않습니다. 몇 가지 파라미터를 더 정의할 수는 있지만 이 함수가 여러 파라미터를 사용할 수 있음을 나타낼 수는 없습니다. 둘째, 첫 번째 파라미터의 이름이 지정되어 직접 사용되므로 복사할 속성을 찾을 때 인덱스 0 대신 인덱스 1의 arguments 객체에서 시작해야합니다. 적절한 파라미터를 arguments와 함께 사용하는 것을 기억하는 것은 반드시 어렵다고는 할 수 없지만, 추적이 용이한 것이 더 중요합니다. ECMAScript 6에서는 이러한 문제를 해결할 수있는 Rest 파라미터를 도입했습니다. Rest 파라미터Rest 파라미터는 명명된 파라미터 앞에 세 개의 점 (...)으로 표시됩니다. 이 명명된 파라미터는 함수에 전달된 나머지 파라미터를 포함하는 Array가 되며, 이것이 “Rest“ 파라미터 이름의 출처입니다. 예를 들어 pick()은 다음과 같이 Rest 파라미터를 사용하여 다시 작성할 수 있습니다 : 123456789function pick(object, ...keys) &#123; let result = Object.create(null); for (let i = 0, len = keys.length; i &lt; len; i++) &#123; result[keys[i]] = object[keys[i]]; &#125; return result;&#125; 이 버전의 함수에서 keys는 object 다음에 전달된 모든 파라미터를 포함하는 Rest 파라미터입니다 (첫 번째 파라미터를 포함하여 모든 파라미터를 포함하는 arguments와는 다릅니다). 즉, keys를 처음부터 끝까지 반복할 수 있다는 뜻입니다. 이 함수를 보면 보너스로 임의의 여러 파라미터를 처리할 수있다는 것을 알수 있습니다. Rest 파라미터는 함수에서 이름이 지정된 파라미터의 수를 나타내는 length 프로퍼티에 영향을주지 않습니다. 이 예제에서 pick()에 대한length 값은object 만이 값으로 계산되기 때문에 1입니다. Rest 파라미터 제약사항Rest 파라미터에는 두 가지 제약이 있습니다. 첫 번째 제약 사항은 하나의 Rest 파라미터만 있을 수 있으며 Rest 파라미터가 마지막이어야 한다는 것입니다. 예를 들어 다음 코드는 작동하지 않습니다. 12345678910// Syntax error: rest 파라미터 다음에 명명된 파라미터를 가질 수 없습니다.function pick(object, ...keys, last) &#123; let result = Object.create(null); for (let i = 0, len = keys.length; i &lt; len; i++) &#123; result[keys[i]] = object[keys[i]]; &#125; return result;&#125; 여기서 파라미터 last는 Rest 파라미터 keys 다음에 오기 때문에 구문오류가 발생합니다. 두 번째 제약은 Rest 파라미터를 객체 리터럴 Setter에서 사용할 수 없다는 것입니다. 즉, 아래 코드도 구문 오류를 발생시킵니다. 1234567let object = &#123; // Syntax error: Can't use rest param in setter set name(...value) &#123; // do something &#125;&#125;; 이 제약은 개체 리터럴 setter가 단일 파라미터로 제한되기 때문에 발생합니다. Rest 파라미터는 정의상 무한한 수의 파라미터이므로 이 문맥에서는 허용되지 않습니다. Rest 파라미터가 arguments 객체에 미치는 영향Rest 파라미터는 ECMAScript의 arguments를 대체하도록 설계되었습니다. 원래 ECMAScript 4는 arguments를 없애고 Rest 파라미터를 추가하여 무제한의 파라미터를 함수에 전달할 수 있었습니다. 하지만 ECMAScript 4는 발표 되지 않았고, 이러한 내용은 ECMAScript 6에서 계속 유지되었습니다. arguments 객체는 이 프로그램에서 처럼 호출될 때 함수에 전달된 arguments를 반영하여 Rest 파라미터와 함께 작동합니다. 12345678function checkArgs(...args) &#123; console.log(args.length); console.log(arguments.length); console.log(args[0], arguments[0]); console.log(args[1], arguments[1]);&#125;checkArgs(\"a\", \"b\"); checkArgs() 실행은 다음을 출력합니다 : 123422a ab b arguments 객체는 Rest 파라미터 사용에 관계없이 함수에 전달된 파라미터를 항상 정확하게 반영합니다. 이러한 내용이 Rest 파라미터를 사용하기 위해 알아야 할 전부입니다. 함수 Constructor의 향상된 기능Function의 Constructor는 새로운 함수를 동적으로 생성할 수 있도록 하지만 JavaScript에서 자주 사용하지는 않습니다. Constructor에 대한 arguments는 함수 및 함수 본문에 대한 파라미터이며 모두 문자열입니다. 다음은 그 예입니다. 123var add = new Function(\"first\", \"second\", \"return first + second\");console.log(add(1, 1)); // 2 ECMAScript 6는 Default 파라미터와 Rest 파라미터를 허용하기 위해 Function Constructor 함수의 기능을 보강했습니다. Default 파라미터는 다음과 같이 파라미터 이름에 등호와 값을 추가하기 만하면됩니다. 12345var add = new Function(\"first\", \"second = first\", \"return first + second\");console.log(add(1, 1)); // 2console.log(add(1)); // 2 위의 예제에서 하나의 파라미터만 전달되면 second 파라미터에 first값이 할당됩니다. 이 구문은 Function을 사용하지 않는 함수 선언과 같습니다. Rest 파라미터의 경우, 마지막 파라미터 앞에 ...를 다음과 같이 추가할 수 있습니다. 123var pickFirst = new Function(\"...args\", \"return args[0]\");console.log(pickFirst(1, 2)); // 1 위 코드는 하나의 Rest 파라미터만을 사용하고 전달된 첫 번째 파라미터를 반환하는 함수를 만듭니다. Default와 Rest 파라미터가 추가되어 Function이 함수의 선언적 형식과 동일한 기능을 모두 갖췄습니다. Spread 연산자Rest 파라미터와 밀접하게 관련된 것은 Spread 연산자입니다. Rest 파라미터를 사용하면 여러 독립 파라미터를 Array에 결합해야 한다고 지정할 수 있지만 Spread 연산자를 사용하면 분할해야 하는 Array을 지정하고 해당 항목을 함수에 대한 별도 파라미터로 전달할 수 있습니다. Math.max() 메서드를 생각해 보겠습니다. 이 메서드는 파라미터를 받아들이고 값중 가장 큰 값을 반환합니다. 다음은 이 메서드의 간단한 사용 예입니다. 1234let value1 = 25, value2 = 50;console.log(Math.max(value1, value2)); // 50 이 예제에서와 같이 단지 두 개의 값을 다룰 때, Math.max()는 매우 사용하기 쉽습니다. 두 값이 전달되고 더 큰 값이 반환됩니다. 그러나 Array에서 값을 추적하고 있고 이제 가장 높은 값을 찾고 싶다면 어떻게해야 할까요? Math.max() 메서드는 Array을 전달할 수 없기 때문에, ECMAScript 5와 그 이전 버전에서는 Array을 직접 찾거나 다음과 같이 apply()를 사용했습니다. 123let values = [25, 50, 75, 100]console.log(Math.max.apply(Math, values)); // 100 이 방법으로 실행은 되지만, apply()를 이런 방식으로 사용하는 것은 다소 혼란스러울 수 있습니다. 실제로 추가 구문이 코드의 진정한 의미를 모호하게 만드는 것으로 보입니다. ECMAScript 6 Spread 연산자는 이 경우를 매우 간단하게 만듭니다. apply()를 호출하는 대신 Array을 Math.max()에 직접 전달하고 Rest 파라미터와 함께 사용되는 ...패턴의 접두사를 붙일 수 있습니다. 그러면 JavaScript 엔진이 Array을 개별 파라미터로 분리하여 다음과 같이 전달합니다. 12345let values = [25, 50, 75, 100]// console.log(Math.max(25, 50, 75, 100));// 위 코드와 동일합니다.console.log(Math.max(...values)); // 100 이제 Math.max()에 대한 호출은 좀 더 보편적으로 보이며 간단한 수학 연산을 위해 this-binding(앞의 예제에서 Math.max.apply()의 첫 번째 파라미터)을 지정하는 복잡성을 피할 수 있습니다. Spread 연산자를 다른 파라미터와 혼합하여 사용할 수도 있습니다. Math.max()에서 반환되는 가장 작은 숫자가 0이 되길 원한다고 가정하십시오. (음수가 Array에 들어가는 경우를 대비해서). 그 파라미터를 개별적으로 전달할 수 있으며 다음과 같이 다른 파라미터에 대해서는 여전히 Spread 연산자를 사용합니다. 123let values = [-25, -50, -75, -100]console.log(Math.max(...values, 0)); // 0 이 예제에서,Math.max()에 전달된 마지막 파라미터는 0이며, 다른 파라미터들은 Spread 연산자를 사용하여 전달됩니다. 파라미터 전달을 위한 Spread 연산자는 함수 파라미터에 대한 Array 사용을 훨씬 쉽게 만듭니다. 대부분의 상황에서 apply() 메서드를 적절하게 대체할 수있을 것입니다. ECMAScript 6에서는 지금까지 Default 및 Rest 파라미터에서 사용한 용도 외에도 JavaScript의 Function 생성자에 두 파라미터 유형을 모두 적용할 수 있습니다. ECMAScript 6의 name 프로퍼티JavaScript에서 다양한 방법으로 함수를 정의할 수 있어면 함수 식별이 어려울 수 있습니다. 또한, 익명 함수식이 널리 보급됨에 따라 디버깅이 조금 더 어려워지고, 종종 스택 추적의 읽기 및 해독이 어려워질수 있습니다. 이러한 이유로 ECMAScript 6은 모든 함수에 name 프로퍼티을 추가했습니다. 적절한 이름 선택하기ECMAScript 6 프로그램의 모든 함수는 name 프로퍼티에 적절한 이름이 부여됩니다. 함수와 함수 표현식을 보여주는 다음 예제의 name 프로퍼티를 출력해 보겠습니다. 12345678910function doSomething() &#123; // ...&#125;var doAnotherThing = function() &#123; // ...&#125;;console.log(doSomething.name); // \"doSomething\"console.log(doAnotherThing.name); // \"doAnotherThing\" 이 코드에서 doSomething()은 함수 선언이기 때문에 &quot;doSomething&quot;과 같은 name 프로퍼티를 가지고 있습니다. 익명 함수 표현 인 doAnotherThing()은 &quot;doAnotherThing&quot;의 name을 가지고 있습니다. 왜냐하면 그 이름이 할당된 변수의 이름이기 때문입니다. name 프로퍼티의 특별한 Case함수 선언 및 함수 표현식에 대한 이름은 쉽게 찾을 수 있습니다. 그리고 ECMAScript 6은 모든 함수가 적절한 이름을 갖도록합니다. 이것을 설명하기 위해 다음 프로그램을 살펴보겠습니다. 123456789101112131415161718var doSomething = function doSomethingElse() &#123; // ...&#125;;var person = &#123; get firstName() &#123; return \"Nicholas\" &#125;, sayName: function() &#123; console.log(this.name); &#125;&#125;console.log(doSomething.name); // \"doSomethingElse\"console.log(person.sayName.name); // \"sayName\"var descriptor = Object.getOwnPropertyDescriptor(person, \"firstName\");console.log(descriptor.get.name); // \"get firstName\" 이 예제에서,doSomething.name은 &quot;doSomethingElse&quot;입니다. 왜냐하면 함수 표현식 자체가 이름을 갖고, 그 이름이 함수가 할당된 변수보다 우선합니다. person.sayName()의 name 프로퍼티는 값이 객체 리터럴로부터 해석 되었기 때문에 &quot;sayName&quot;입니다. 비슷하게, person.firstName은 실제로 Getter 함수이므로 이 차이를 나타 내기 위해 이름은 &quot;get firstName&quot;입니다. Setter 함수 앞에는 &quot;set&quot;이 붙습니다.(Getter 및 Setter 함수는 모두 Object.getOwnPropertyDescriptor()를 사용하여 검색해야 합니다.) 함수 이름에도 몇 가지 특별한 경우가 있습니다. bind()를 사용하여 생성된 함수의 이름은 &quot;bound&quot;로 시작하고, Function 생성자를 사용하여 생성된 함수의 이름은 &quot;anonymous&quot;입니다. 1234567var doSomething = function() &#123; // ...&#125;;console.log(doSomething.bind().name); // \"bound doSomething\"console.log((new Function()).name); // \"anonymous\" Bound 함수의 name은 바운드되는 함수의 name에 문자열 &quot;bound&quot;로 접두사가 붙을 것이기 때문에 doSomething()의 바운드 버전은 &quot;bound doSomething&quot;입니다. 함수의 name 값이 반드시 같은 name 변수를 참조하는 것은 아닙니다. name 프로퍼티는 정보를 얻는 수단이되고 디버깅에 유익하지만, name의 값을 사용하여 함수에 대한 참조를 얻는 방법은 없습니다. 함수의 이중 목적을 명확히 하기ECMAScript 5 및 이전 버전에서는 함수가 new 유무에 관계없이 호출할 수있는 이중 목적을 제공합니다. new와 함께 사용하면, 함수 안에있는 이 값은 새로운 객체이며, 다음 예제와 같이 새로운 객체가 반환됩니다 : 123456789function Person(name) &#123; this.name = name;&#125;var person = new Person(\"Nicholas\");var notAPerson = Person(\"Nicholas\");console.log(person); // \"[Object object]\"console.log(notAPerson); // \"undefined\" notAPerson을 만들 때 new가 없이 Person ()을 호출하면 undefined가됩니다.(nonstrict 모드에서 전역 객체에 name 프로퍼티를 설정합니다). Person의 대문자 사용은 일반적인 JavaScript 프로그램에서 new를 사용하여 함수를 호출할 수 있다는 유일한 지표입니다. 함수의 이중 역할에 대한 혼란으로 인해 ECMAScript 6은 일부 변경되었습니다. JavaScript는 함수를 위한 두 가지 내부 전용 메서드를 가지고있습니다. :[[Call]]과[[Construct]]. new 없이 함수가 호출되면 [[Call]]메서드가 실행되고 코드의 함수 본문이 실행됩니다. new로 함수를 호출하면, [[Construct]]메서드가 호출됩니다. [[Construct]]메서드는 new.target이라는 새로운 객체를 생성 한 후 this를 new.target으로 설정하여 함수 본문을 실행합니다. [[Construct]]메서드를 가진 함수를 Constructor라고 부릅니다. 모든 함수가 [[Construct]]를 가지고있는 것은 아니므로 new로 모든 함수를 호출할 수있는 것은 아닙니다. “Arrow Function” 섹션에서 논의된 Arrow 함수에는 [[Construct]] 메서드가 없습니다. ECMAScript 5에서 함수 호출 방법 결정ECMAScript 5에서 함수가 new와 함께 (그리고 Constructor와 함께) 호출되었는지 결정하는 가장 보편적 인 방법은 instanceof를 사용하는 것입니다. 12345678910function Person(name) &#123; if (this instanceof Person) &#123; this.name = name; // using new &#125; else &#123; throw new Error(\"You must use new with Person.\") &#125;&#125;var person = new Person(\"Nicholas\");var notAPerson = Person(\"Nicholas\"); // throws error 이 코드에서 this 값은 그것이 Constructor의 인스턴스인지를 검사하고, 만약 그렇다면 실행은 정상적으로 계속됩니다. this가 Person의 인스턴스가 아니라면 에러가 발생합니다. 이것은[[Construct]] 메서드가 Person의 새로운 인스턴스를 생성하고 이것을 this에 할당하기 때문에 작동합니다. 불행히도, 이 접근법은 완전히 신뢰할 만하지 않습니다. 왜냐하면 아래의 예제에서와 같이 new를 사용하지 않고 Person의 인스턴스가될 수 있기 때문입니다 : 12345678910function Person(name) &#123; if (this instanceof Person) &#123; this.name = name; // using new &#125; else &#123; throw new Error(\"You must use new with Person.\") &#125;&#125;var person = new Person(\"Nicholas\");var notAPerson = Person.call(person, \"Michael\"); // works! Person.call()을 호출하면 person 변수가 첫 번째 인수로 전달됩니다. 이는 Person 함수 안에서 person으로 설정되었음을 의미합니다. 이 함수에는 new로 불리는 것과 구별할 방법이 없습니다. new.target MetaProperty이 문제를 해결하기 위해 ECMAScript 6는 new.target metaproperty를 도입했습니다. 메타 속성은 대상과 관련된 추가 정보 (예 : new)를 제공하는 비 객체의 프로퍼티입니다. 함수의 [[Construct]] 메서드가 호출되면 new.target은 new 연산자의 대상으로 채워집니다. 이 타겟은 일반적으로 새로 생성된 객체 인스턴스의 생성자이며, 이 객체 인스턴스는 함수 본문에서 this가 됩니다. [[Call]]이 실행되면 new.target은 undefined가됩니다. 이 새로운 메타 속성을 사용하면 new.target이 다음과 같이 정의되어 있는지 여부를 확인하여 new 함수가 호출되었는지를 안전하게 감지할 수 있습니다 : 12345678910function Person(name) &#123; if (typeof new.target !== \"undefined\") &#123; this.name = name; // using new &#125; else &#123; throw new Error(\"You must use new with Person.\") &#125;&#125;var person = new Person(\"Nicholas\");var notAPerson = Person.call(person, \"Michael\"); // error! 이 instanceof Person 대신 new.target을 사용함으로써, Person 생성자는 new없이 사용될 때 정확하게 에러를 던집니다. 특정 생성자를 사용하여 new.target이 호출되었는지 확인할 수 있습니다. 예를 들어 다음 예제를 살펴보겠습니다. 1234567891011121314function Person(name) &#123; if (new.target === Person) &#123; this.name = name; // using new &#125; else &#123; throw new Error(\"You must use new with Person.\") &#125;&#125;function AnotherPerson(name) &#123; Person.call(this, name);&#125;var person = new Person(\"Nicholas\");var anotherPerson = new AnotherPerson(\"Nicholas\"); // error! 이 코드를 보면 제대로 작동하기 위해서는 new.target이 Person이어야합니다. new AnotherPerson( &quot;Nicholas&quot;)가 호출될 때, Person.call(this, name)에 대한 후속 호출은 new.target이 Person 생성자 내부에서 undefined이기 때문에 오류를 던질 것입니다. (`new ‘없이 호출 되었다). 경고 : 함수 밖에서 new.target을 사용하는 것은 구문 오류입니다. new.target을 추가함으로써, ECMAScript 6은 함수 호출에 대한 모호함을 명확히하는 데 도움이되었습니다. 이 주제에 따라, ECMAScript 6은 언어의 또 다른 모호한 부분 인 Block-level 함수를 선언합니다. Block-Level 함수ECMAScript 3 및 이전 버전에서는 블록 내부에서 발생하는 함수 선언 (Block-level 함수)은 기술적으로 구문 오류 였지만 모든 브라우저가 여전히 이를 지원했습니다. 불행히도 구문을 허용하는 각 브라우저는 약간 다른 방식으로 동작하므로 블록 내부에서 함수 선언을 피하는 것이 가장 좋습니다 (함수 표현식을 사용하는 것이 가장 좋습니다). 이 호환되지 않는 동작을 억제하기 위해 ECMAScript 5 strict 모드에서는 함수 선언이 다음과 같이 블록 내부에서 사용될 때마다 오류가 발생했습니다. 123456789\"use strict\";if (true) &#123; // ES5에서는 구문 오류가 발생하지만 ES6에서는 발생하지 않습니다. function doSomething() &#123; // ... &#125;&#125; ECMAScript 5에서 이 코드는 구문 오류를 발생시킵니다. ECMAScript 6에서 doSomething() 함수는 Block-level선언으로 간주되며, 정의된 동일한 블록 내에서 액세스하고 호출할 수 있습니다. 예 : 1234567891011121314\"use strict\";if (true) &#123; console.log(typeof doSomething); // \"function\" function doSomething() &#123; // ... &#125; doSomething();&#125;console.log(typeof doSomething); // \"undefined\" Block-level 함수는 정의된 블럭의 맨 위로 올라가므로 typeof doSomething은 코드의 함수 선언 앞에 나타나도, “function”을 반환합니다. if 블록의 실행이 끝나면 doSomething()은 더 이상 존재하지 않습니다. Block-level 함수 사용시기 결정Block-level 함수는 let 함수 표현식과 유사합니다. 함수 정의는 함수가 정의된 블록에서 실행된 후 제거됩니다. 중요한 차이점은 Block-level 함수는 포함 블록의 상단에 hoisting 된다는 것입니다. let을 사용하는 함수 표현식은 다음 예제와 같이hoisting되지 않습니다 : 1234567891011121314\"use strict\";if (true) &#123; console.log(typeof doSomething); // throws error let doSomething = function () &#123; // ... &#125; doSomething();&#125;console.log(typeof doSomething); 여기서 typeof doSomething이 실행되면 let 문이 아직 실행되지 않았기 때문에 코드 실행이 멈추고 TDZ에 doSomething()이 남게됩니다. 이 차이점을 안다면, Block-level 함수를 사용할 것인지, hoisting동작을 원하는지 여부에 따라 let 표현식을 사용할 것인지 선택할 수 있습니다. Nonstrict 모드의 Block-level 함수ECMAScript 6은 nonstrict 모드에서 Block-level 함수를 허용하지만, 동작은 약간 다릅니다. 함수 선언문을 블록의 상단으로 hoisting 하는 대신에, 함수를 포함하는 함수, 또는 전역 환경으로 계속 끌어 올립니다. 12345678910111213// ECMAScript 6 behaviorif (true) &#123; console.log(typeof doSomething); // \"function\" function doSomething() &#123; // ... &#125; doSomething();&#125;console.log(typeof doSomething); // \"function\" 위 예제에서, doSomething()은 전역 Scope로 끌어 올려 지므로 if 블록의 바깥에 존재합니다. ECMAScript 6은 이 동작을 표준화하여 이전에는 존재하지 않는 호환되지 않는 브라우저 동작을 제거하므로 모든 ECMAScript 6 런타임은 동일한 방식으로 동작해야합니다. Block-level 함수는 JavaScript에서 함수를 선언하는 기능이 향상시켰지만 ECMAScript 6에서는 함수를 선언하는 완전히 새로운 방법을 도입했습니다. 화살표 함수 (Arrow Function)ECMAScript 6의 가장 흥미로운 부분 중 하나는 Arrow 함수입니다. Arrow 함수는 이름에서 알 수 있듯이 “Arrow”(=&gt;)를 사용하는 새로운 구문으로 정의된 함수입니다. 하지만 Arrow 함수는 여러 가지 중요한 부분이 기존의 JavaScript 함수와 다르게 작동합니다. this, super, arguments 및 new.target 바인딩은 없습니다 - 함수 내부의 this, super, arguments 및 new.target의 값은 가장 인접한 nonarrow 함수를 나타냅니다. (super는 4 장에서 다룬다.) new로 호출할 수 없습니다 - Arrow 함수는 [[Construct]] 메서드를 가지지 않으므로 생성자를 사용할 수 없습니다. Arrow 함수는 new와 함께 사용될 때 에러를 던집니다. prototype이 없습니다 - Arrow 함수에 new를 사용할 수 없으므로 prototype이 필요 없습니다. Arrow 함수는 prototype 프로퍼티가 존재하지 않습니다. this를 바꿀 수 없습니다 - 함수 안의 this 값은 변경할 수 없습니다. 함수의 전체 라이프 사이클 동안 동일하게 유지됩니다. arguments 객체가 없습니다 - Arrow 함수에는 arguments 바인딩이 없으므로 함수 파라미터에 액세스하려면 명명된 파라미터와 rest 파라미터에 의존해야합니다. 이름이 중복된 파라미터가 없습니다 - Arrow 함수는 nonstrict 모드에서 중복된 이름의 파라미터를 가질수 있는 nonarrow 함수와는 달리 strict 또는 nonstrict 모드에서 중복된 이름의 파라미터를 가질수 없습니다. 이러한 차이에는 몇 가지 이유가 있습니다. 무엇보다 먼저, this 바인딩은 JavaScript의 일반적인 오류 원인입니다. 의도하지 않은 프로그램 동작을 초래할 수있는 함수 내에서 this값을 추적하는 것을 잃어 버리기가 매우 쉽습니다. Arrow 함수는 이러한 혼란을 없애줍니다. 둘째, Arrow 함수를 단일 this값으로 코드를 실행하는 것으로 제한함으로써 JavaScript 엔진은 생성자로 사용되거나 수정될 수있는 일반 함수와 달리 연산을 보다 쉽게 최적화할 수 있습니다. 나머지 차이점은 Arrow 함수 내부의 오류와 모호성을 줄이는 데에도 초점을 맞추고 있습니다. 그렇게함으로써, JavaScript 엔진은 Arrow 함수 실행을 더 잘 최적화할 수 있습니다. 참고 : Arrow 함수에는 다른 함수와 동일한 규칙을 따르는 name 프로퍼티는 있습니다. Arrow 함수 SyntaxArrow 함수의 구문은 여러분이 원하는 모양에 따라 다양한 형태로 가능합니다. 하지만 모든 Arrow 함수는 파라미터와 화살표, 함수 본문 순으로 시작됩니다. 파라미터와 본문 모두 사용법에 따라 다른 형태를 취할 수 있습니다. 예를 들어, 다음 Arrow 함수는 단일 파라미터를 받고 이를 단순히 반환합니다. 1234567var reflect = value =&gt; value;// 다음과 동일한 효과를 나타냅니다.var reflect = function(value) &#123; return value;&#125;; Arrow 함수에 대해 파라미터가 하나만 있을 경우, 그 파라미터는 더 이상의 구문없이 직접 사용될 수 있습니다. 다음에 화살표가오고 화살표 오른쪽에 있는 표현식이 계산되어 반환됩니다. 명시적 return 문이 없더라도 이 Arrow 함수는 전달된 첫 번째 파라미터를 반환합니다. 둘 이상의 파라미터를 전달하는 경우 다음과 같이 파라미터를 괄호로 묶어야합니다. 1234567var sum = (num1, num2) =&gt; num1 + num2;// 다음과 동일한 효과를 나타냅니다.var sum = function(num1, num2) &#123; return num1 + num2;&#125;; sum() 함수는 두개의 파라미터를 더하고 그 결과를 반환합니다. 이 Arrow 함수와 reflect() 함수의 유일한 차이점은 파라미터가 괄호 안에 쉼표로 구분되어 있습니다 (기존 함수처럼). 함수에 대한 파라미터가가 없으면 다음과 같이 빈 괄호 세트를 선언에 포함해야합니다. 1234567var getName = () =&gt; \"Nicholas\";// 다음과 동일한 효과를 나타냅니다.var getName = function() &#123; return \"Nicholas\";&#125;; 두 개 이상의 표현식으로 구성되는 더 전통적인 함수 본문을 제공하려면 이 버전의 sum ()에서와 같이 함수 본문을 중괄호로 묶고 반환 값을 명시적으로 정의해야합니다. 123456789var sum = (num1, num2) =&gt; &#123; return num1 + num2;&#125;;// 다음과 동일한 효과를 나타냅니다.var sum = function(num1, num2) &#123; return num1 + num2;&#125;; 중괄호 내부는 arguments를 사용할 수 없다는 점을 제외하면 전통적인 함수와 동일합니다. 아무 것도하지 않는 함수를 만들려면 다음과 같이 중괄호를 포함해야합니다. 12345var doNothing = () =&gt; &#123;&#125;;// 다음과 동일한 효과를 나타냅니다.var doNothing = function() &#123;&#125;; 중괄호는 함수의 몸체를 나타 내기 위해 사용되며, 지금까지 보았던 경우에는 잘 작동합니다. 그러나 객체 리터럴을 반환하고자하는 화살표 함수는 괄호 안에 리터럴을 래핑해야합니다. 1234567891011var getTempItem = id =&gt; (&#123; id: id, name: \"Temp\" &#125;);// 다음과 동일한 효과를 나타냅니다.var getTempItem = function(id) &#123; return &#123; id: id, name: \"Temp\" &#125;;&#125;; 괄호 안에 객체 리터럴을 래핑하면 중괄호가 함수 본문 대신 객체 리터럴임을 알립니다. 즉시 호출 함수 표현식 만들기 (Immediately-Invoked Function Expression)JavaScript 함수의 인기있는 사용은 즉시 호출 함수 표현식 (Immediately-Invoked Function Expression - IIFE)을 작성하는 것입니다. IIFE를 사용하면 익명의 함수를 정의하여 참조를 저장하지 않고 즉시 호출할 수 있습니다. 이 패턴은 프로그램의 나머지 부분으로부터 보호되는 Scope를 만들 때 유용합니다. 예 : 1234567891011let person = function(name) &#123; return &#123; getName: function() &#123; return name; &#125; &#125;;&#125;(\"Nicholas\");console.log(person.getName()); // \"Nicholas\" 이 코드에서 IIFE는 getName() 메서드를 사용하여 객체를 만드는 데 사용됩니다. 이 메서드는 name 파라미터를 리턴 값으로 사용하여 반환된 객체의 private 멤버를 만듭니다. 괄호를 이용하여 래핑하면 동일한 작업을 수행 하는 Arrow 함수를 만들수 있습니다. 1234567891011let person = ((name) =&gt; &#123; return &#123; getName: function() &#123; return name; &#125; &#125;;&#125;)(\"Nicholas\");console.log(person.getName()); // \"Nicholas\" 괄호는 Arrow 함수 정의 주위에서만 있고 (&quot;Nicholas&quot;)는 포함하지 않습니다. 이것이 기존의 함수와 다른데, 괄호는 입력된 파라미터를 포함하여 함수 정의 주변만 배치 할 수 있습니다. this 바인딩이 없음JavaScript에서 가장 일반적인 오류 중 하나는 함수 내부에 this를 바인딩하는 것입니다. this의 값은 함수가 호출되는 문맥에 따라 하나의 함수 안에서 바뀔 수 있기 때문에, 의도하지 않지만 실수로 다른 객체에 영향을 미칠 수 있습니다. 다음 예제를 살펴보겠습니다. 1234567891011121314var PageHandler = &#123; id: \"123456\", init: function() &#123; document.addEventListener(\"click\", function(event) &#123; this.doSomething(event.type); // error &#125;, false); &#125;, doSomething: function(type) &#123; console.log(\"Handling \" + type + \" for \" + this.id); &#125;&#125;; 위 코드에서 객체 PageHandler는 페이지와 상호 작용을 처리하도록 설계되었습니다. 상호 작용을 설정하기 위해 init() 메서드가 호출되고, 그 메서드는 차례대로 this.doSomething()을 호출하는 이벤트 핸들러를 할당합니다. 그러나 이 코드는 의도 한대로 정확하게 작동하지 않습니다. this.doSomething()에 대한 호출은 this가 PageHandler에 바인딩되는 대신 이벤트 대상 (이 경우 document)에 대한 참조이기 때문에 끊어집니다. 이 코드를 실행하려고하면 this.doSomething()이 대상 document 객체에 없기 때문에 이벤트 핸들러가 실행될 때 오류가 발생합니다. bind() 메서드를 이용해 명시적으로 PageHandler에 바인딩함으로써 이 문제를 해결할 수 있습니다 : 1234567891011121314var PageHandler = &#123; id: \"123456\", init: function() &#123; document.addEventListener(\"click\", (function(event) &#123; this.doSomething(event.type); // no error &#125;).bind(this), false); &#125;, doSomething: function(type) &#123; console.log(\"Handling \" + type + \" for \" + this.id); &#125;&#125;; 이제 코드는 예상대로 작동하지만 약간 이상하게 보일 수 있습니다. bind(this)를 호출함으로써 실제로 this가 현재 this에 바인드된 새로운 함수,PageHandler를 생성하고 있습니다. 이 코드를 수정하는 더 좋은 방법은 Arrow 함수를 사용하는 것입니다. Arrow 함수에는 this 바인딩이 없습니다. 즉, Arrow 함수 안에있는 this의 값은 Scope 체인을 찾는 것으로만 결정될 수 있습니다. Arrow 함수가 nonarrow 함수 내에 포함되어 있다면, this는 포함 함수와 같습니다. 그렇지 않으면 this는 전역 Scope에서 this의 값과 같습니다. Arrow 함수를 사용하여 이 코드를 작성할 수있는 한 가지 방법은 다음과 같습니다. 12345678910111213var PageHandler = &#123; id: \"123456\", init: function() &#123; document.addEventListener(\"click\", event =&gt; this.doSomething(event.type), false); &#125;, doSomething: function(type) &#123; console.log(\"Handling \" + type + \" for \" + this.id); &#125;&#125;; 이 예제의 이벤트 핸들러는 this.doSomething()을 호출하는 Arrow 함수입니다. this의 값은 init() 안에있는 것과 같기 때문에, 이 버전의 코드는 bind (this)를 사용하는 것과 비슷하게 동작합니다. doSomething() 메서드는 값을 반환하지 않지만, 여전히 함수 본문 내에서 실행되는 유일한 명령문이므로, 중괄호를 포함할 필요가 없습니다. Arrow 함수는 “제거 가능한(throwaway)” 함수로 설계되었으므로 새 타입을 정의하는 데 사용할 수 없습니다. 이것은 일반 함수에 있는 prototype 속성이 빠져 있음을 알 수 있습니다. 화살표 함수로 new 연산자를 사용하려고하면 다음 예제와 같이 오류가 발생합니다. 12var MyType = () =&gt; &#123;&#125;, object = new MyType(); // error - you can't use arrow functions with 'new' 이 코드에서, MyType은 Arrow 함수이므로 [[Construct]] 행위를 하지 않기 때문에 새로운 MyType()에 대한 호출은 실패합니다. JavaScript 엔진은 Arrow 함수가 new와 함께 사용할 수 없다는 사실을 알게 되면 자신의 행동을 더욱 최적화할 수 있습니다. 또한, this값은 Arrow 함수가 정의된 포함 함수에 의해 결정되므로 call(), apply() 또는 bind()를 사용하여 this의 값을 변경할 수 없습니다. Arrow 함수와 ArrayArrow 함수의 간결한 구문은 Array 처리와 함께 사용하기에 이상적입니다. 예를 들어, 사용자 정의 Comparator를 사용하여Array을 정렬하려면 일반적으로 다음과 같이 작성합니다. 123var result = values.sort(function(a, b) &#123; return a - b;&#125;); 이것은 매우 간단한 기능을 위해 많은 구문이 필요합니다. 더 간결한 Arrow 함수 버전과 비교해보십시오. 1var result = values.sort((a, b) =&gt; a - b); sort(), map(), reduce()와 같은 콜백 함수를 받아들이는 Array 메서드는 단순한 코드로 복잡한 프로세스를 변경하는 Arrow 함수 구문의 이점을 모두 누릴 수 있습니다. arguments 바인딩 없음Arrow 함수가 자신의 arguments 객체를 가지고 있지는 않지만 포함 함수의 arguments 객체에 접근할 수 있습니다. Arrow함수가 어디에서 실행 되든 관계없이 포함 함수의 arguments객체를 사용할 수 있습니다. 1234567function createArrowFunctionReturningFirstArg() &#123; return () =&gt; arguments[0];&#125;var arrowFunction = createArrowFunctionReturningFirstArg(5);console.log(arrowFunction()); // 5 createArrowFunctionReturningFirstArg() 내부에서, arguments[0] 요소는 생성된 Arrow 함수에 의해 참조됩니다. 그 참조는createArrowFunctionReturningFirstArg() 함수에 전달 된 첫 번째 파라미터를 나타냅니다. Arrow 함수가 나중에 실행되면 5를 반환하는데, 이것은 createArrowFunctionReturningFirstArg()에 전달된 첫 번째 인파라미터입니다. Arrow 함수가 더 이상 자신를 생성 한 Scope에 없더라도 arguments 식별자의 Scope chain resolution 때문에 arguments는 여전히 접근 가능합니다. Arrow 함수 식별하기다른 구문에도 불구하고 Arrow 함수는 여전히 함수이며 식별 가능합니다. 다음 코드를 생각해 보겠습니다. 1234var comparator = (a, b) =&gt; a - b;console.log(typeof comparator); // \"function\"console.log(comparator instanceof Function); // true console.log() 결과는, typeof와 instanceof가 다른 함수와 마찬가지로 Arrow 함수가 똑같이 행동한다는 것을 보여줍니다. 함수의 this-binding은 영향을 받지 않지만, 다른 함수와 마찬가지로 Arrow 함수는 여전히 call(), apply() 및 bind()를 사용할 수 있습니다. 여기 몇 가지 예가 있습니다. 12345678var sum = (num1, num2) =&gt; num1 + num2;console.log(sum.call(null, 1, 2)); // 3console.log(sum.apply(null, [1, 2])); // 3var boundSum = sum.bind(null, 1, 2);console.log(boundSum()); // 3 sum() 함수는 다른 함수와 마찬가지로 call()과 apply()를 사용하여 파라미터를 전달합니다. bind()메서드는 boundSum()을 생성하는데 사용되며, 두개의 파라미터는 1과 2에 연결되어 직접 전달할 필요가 없습니다. Arrow 함수는 콜백과 같이 현재의 익명 함수 표현식을 사용하고있는 곳이면 어디서든 사용하기에 적합합니다. 다음 섹션은 또 다른 주요한 ECMAScript 6을 다루지만, 이것은 모두 내부적이며 new 구문을 가지고 있지 않습니다. Tail Call 최적화아마도 ECMAScript 6의 기능 중 가장 흥미로운 변화는 Tail call 시스템을 변경하는 엔진 최적화입니다. Tail call은 함수가 다음과 같이 함수의 마지막 명령문으로 다른 함수를 호출하는 패턴입니다. 123function doSomething() &#123; return doSomethingElse(); // tail call&#125; ECMAScript 5 엔진에서 구현된 Tail call은 다른 함수 호출과 마찬가지로 처리됩니다. 새 스택 프레임이 만들어지고 Call 스택에 푸시되어 함수 호출을 나타냅니다. 이는 모든 이전 스택 프레임이 메모리에 유지된다는 것을 의미하며, 호출 스택이 너무 커지면 문제가됩니다. 무엇이 다른가?ECMAScript 6는 strict 모드에서 특정 Tail call에 대한 호출 스택의 크기를 줄이려고 시도합니다 (nonstrict 모드 Tail call은 그대로 유지됩니다). 이 최적화를 통해 Tail call에 대한 새 스택 프레임을 만드는 대신 다음 조건이 충족되는 한 현재 스택 프레임이 지워지고 다시 사용됩니다. Tail call은 현재 스택 프레임의 변수에 액세스할 필요가 없습니다 (함수가 클로저가 아님을 의미) Tail call을 수행하는 함수는 Tail call이 리턴 한 후에 더 이상 수행할 작업이 없습니다. Tail call의 결과는 함수 값으로 반환됩니다. 예를 들어 다음 코드는 세 가지 기준 모두에 적합하기 때문에 이 코드를 쉽게 최적화할 수 있습니다. 123456\"use strict\";function doSomething() &#123; // optimized return doSomethingElse();&#125; 위의 함수는 doSomethingElse()에 대해 Tail call을 하고 결과를 즉시 반환하며 로컬 범위의 변수에 액세스하지 않습니다. 하지만 아래의 함수는 결과를 반환하지 않기 때문에 최적화되지 않습니다. 123456\"use strict\";function doSomething() &#123; // not optimized - no return doSomethingElse();&#125; 마찬가지로 Tail call에서 복귀 한 후 작업을 수행하는 경우 함수를 최적화할 수 없습니다. 123456\"use strict\";function doSomething() &#123; // not optimized - must add after returning return 1 + doSomethingElse();&#125; 위 예제는 값을 반환하기 전에 doSomethingElse()에 단지 1을 더하지만 최적화를 끄기에 충분합니다. 실수로 최적화를 끄는 또 다른 일반적인 실수는 함수 호출 결과를 변수에 저장 한 다음 결과를 반환하는 것입니다. 예를 들면 다음과 같습니다. 1234567\"use strict\";function doSomething() &#123; // not optimized - call isn't in tail position var result = doSomethingElse(); return result;&#125; 위 예제는 doSomethingElse()의 값이 즉시 리턴되지 않기 때문에 최적화될 수 없습니다. 아마도 가장 어려운 상황은 클로저 사용에 있습니다. 클로저가 포함된 Scope의 변수에 액세스할 수 있으므로 Tail call 최적화가 해제될 수 있습니다. 123456789\"use strict\";function doSomething() &#123; var num = 1, func = () =&gt; num; // not optimized - 함수가 closure 입니다. return func();&#125; 클로저 func()는 이 예제에서 지역 변수 num에 접근할 수 있습니다. func()를 호출하면 즉시 결과가 반환되지만 변수 num을 참조하기 때문에 최적화할 수 없습니다. Tail call 최적화를 활용하는 방법실제로 Tail call 최적화는 배후에서 발생하기 때문에 함수를 최적화하려고 시도하지 않는 한 생각할 필요가 없습니다. Tail call 최적화의 주요 사용 사례는 재귀 함수입니다. 최적화가 가장 큰 효과를 발휘하기 때문입니다. 팩토리얼을 계산하는 이 함수를 생각해 보겠습니다. 12345678910function factorial(n) &#123; if (n &lt;= 1) &#123; return 1; &#125; else &#123; // not optimized - must multiply after returning return n * factorial(n - 1); &#125;&#125; 곱셈이 factorial()을 재귀 호출 한 후에 일어나야하기 때문에 이 버전의 함수는 최적화될 수 없습니다. n이 매우 큰 경우 호출 스택 크기가 커지고 잠재적으로 스택 오버플로가 발생할 수 있습니다. 함수를 최적화 하려면 마지막 함수 호출 후에 곱셈이 발생하지 않도록 해야합니다. 이를 위해 Default 파라미터를 사용하여 곱하기 연산을 return 문 외부로 옮길 수 있습니다. 결과 함수는 임시 결과를 따라 다음 반복으로 전달되어 동일하게 동작하지만 ECMAScript 6 엔진에서 최적화할 수있는 함수를 만듭니다. 다음은 새로운 코드입니다. 1234567891011function factorial(n, p = 1) &#123; if (n &lt;= 1) &#123; return 1 * p; &#125; else &#123; let result = n * p; // optimized return factorial(n - 1, result); &#125;&#125; 이 다시 작성된 factorial() 버전에서 두 번째 파라미터 p가 추가되었고 Default 값이 1입니다. p 파라미터는 이전 곱셈 결과를 유지하므로 다른 함수 호출없이 다음 결과를 계산할 수 있습니다. n이 1보다 크면 곱셈이 먼저 수행된 후 두 번째 인수로 factorial()으로 전달됩니다. 이를 통해 ECMAScript 6 엔진이 재귀 호출을 최적화할 수 있습니다. Tail call 최적화는 재귀 함수를 작성할 때, 특히 연산이 많은 함수에 적용할 때 상당한 성능 향상을 제공할 수 있으므로 생각해야할 부분입니다. 요약함수는 ECMAScript 6에서 큰 변화를 겪지는 않았지만 일련의 점진적 변경으로 인해 작업이 더 쉬워졌습니다. 함수의 Default 파라미터를 사용하면 특정 파라미터가 전달되지 않을 때 사용할 값을 쉽게 지정할 수 있습니다. ECMAScript 6 이전에는 함수 내부에 몇 가지 추가 코드가 필요 했으므로 파라미터가 있는지 확인하고 다른 값을 할당할 수 있었습니다. Rest 파라미터를 사용하면 나머지 모든 파라미터를 배치할 Array을 지정할 수 있습니다. 실제 Array을 사용하고 포함시킬 파라미터를 지정하게하면 Rest 파라미터가 arguments보다 훨씬 더 유연한 해결책이됩니다. Spread 연산자는 Rest 파라미터와 함께 사용되므로 함수를 호출할 때 Array을 개별 파라미터로 분해할 수 있습니다. ECMAScript 6 이전에는 Array에 포함된 개별 파라미터를 전달하는 두 가지 방법이 있었습니다. 수동으로 각 파라미터를 지정하거나 apply()를 사용하는 것입니다. Spread 연산자를 사용하면 함수의 ‘this’ 바인딩에 대한 걱정없이 모든 함수에 Array을 쉽게 전달할 수 있습니다. name 프로퍼티을 추가하면 디버깅 및 평가 목적을 쉽게 식별할 수 있습니다. 또한 ECMAScript 6는 Block-level 함수의 동작을 공식적으로 정의하므로 더 이상 strict 모드에서는 구문 오류가 아닙니다. ECMAScript 6에서 함수의 동작은 [[Call]], 일반 함수 실행, [[Construct]]에 의해 정의되며, new로 호출이 됩니다. new.target 메타 속성은 new를 사용하여 함수가 호출되었는지 아닌지를 결정할 수 있게합니다. ECMAScript 6에서 가장 많이 변경된 기능은 Arrow 함수가 추가된 것입니다. Arrow 함수는 익명의 함수 표현식 대신 사용되도록 설계되었습니다. Arrow 함수는 보다 간결한 문법, 어휘, this 바인딩 없음, arguments 객체를 가지고 있지 않습니다. 또한, Arrow 함수는 this 바인딩을 변경할 수 없으므로 Constructor로 사용할 수 없습니다. Tail call 최적화는 더 작은 호출 스택을 유지하고 더 적은 메모리를 사용하며 스택 오버플로 오류를 방지하기 위해 일부 함수 호출을 최적화할 수 있습니다. 이 최적화는 엔진에서 자동으로 적용되므로 안전하지만 이 최적화를 이용하려면 재귀 함수를 다시 작성하기로 결정할 수도 있습니다. 이 내용은 나중에 참고하기 위해 제가 공부하며 정리한 내용입니다.의역, 오역, 직역이 있을 수 있음을 알려드립니다.This post is a translation of this original article [https://leanpub.com/understandinges6/read#leanpub-auto-functions] 참고 ECMAScript 6 Block Binding ECMAScript 6 문자열과 정규 표현식 ECMAScript 6 함수 ECMAScript 6 객체의 확장된 기능 ECMAScript 6 쉬운 데이터 액세스를 위한 Destructuring ECMAScript 6 Symbol과 Symbol 프로퍼티 ECMAScript 6 Set과 Map ECMAScript 6 Iterator와 Generator ECMAScript 6 JavaScript 클래스 소개 ECMAScript 6 Array 기능 향상 ECMAScript 6 Promise와 비동기 프로그램밍 ECMAScript 6 프록시와 리플렉션 API ECMAScript 6 Module로 코드 캡슐화하기 ECMAScript 6 부록 A. 작은 변경 사항 ECMAScript 6 부록 B. ECMAScript 7(2016) 이해하기","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://infoscis.github.io/categories/JavaScript/"},{"name":"ECMAScript 2015","slug":"JavaScript/ECMAScript-2015","permalink":"http://infoscis.github.io/categories/JavaScript/ECMAScript-2015/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://infoscis.github.io/tags/JavaScript/"},{"name":"ECMAScript 2015","slug":"ECMAScript-2015","permalink":"http://infoscis.github.io/tags/ECMAScript-2015/"}]},{"title":"ECMAScript 6 문자열과 정규 표현식","slug":"ecmascript-6-strings-and-regular-expressions","date":"2018-01-24T14:08:10.000Z","updated":"2018-02-27T14:12:07.677Z","comments":true,"path":"2018/01/24/ecmascript-6-strings-and-regular-expressions/","link":"","permalink":"http://infoscis.github.io/2018/01/24/ecmascript-6-strings-and-regular-expressions/","excerpt":"","text":"문자열과 정규 표현식논쟁의 여지는 있지만 String은 프로그래밍에서 가장 중요한 데이터 타입중 하나입니다. 문자열은 거의 모든 고급 프로그래밍 언어에 포함되어 있고, 개발자가 유용한 프로그램을 만드는데 중요한 요소입니다. 정규 표현식은 개발자가 문자열을 다양하게 다룰수 있도록 하기 때문에 매우 중요합니다. 이러한 내용을 고려한 ECMAScript 6의 제작자는 새로운 기능과 오랫동안 누락된 기능들을 추가하여 문자열과 정규 표현식을 향상 시켰습니다. 이 장에서는 이러한 두가지 타입의 변경 사항에 대해 설명합니다. 더 나은 Unicode 지원ECMAScript 6 이전에는 JavaScript 문자열이 16-bit 문자 인코딩(UTF-16)이 중심이었습니다. 각 16-bit 시퀀스는 문자를 나타내는 코드 단위입니다. length 속성과 charAt() 메서드와 같은 모든 문자열 속성과 메서드는 이 16-bit 코드 단위를 기반으로 했습니다. 물론 16-bit는 모든 문자를 포함하기에 충분했습니다. 하지만 Unicode가 도입 한 확장 문자 세트 덕분에 더 이상 충분하지 않습니다. UTF-16 Code Point문자 길이를 16-bit로 제한하는 것은 세계의 모든 문자를 전 세계적으로 고유 한 식별자로 제공하겠다는 Unicode의 목표를 이룰수 없습니다. Code Point라고 하는 이러한 전역적으로 고유 한 식별자는 단순히 0부터 시작하는 숫자일 뿐입니다. Code Point는 문자 코드로 생각할 수 있습니다. 숫자는 문자를 나타냅니다. 문자 인코딩은 Code Point를 내부적으로 일관된 Code Unit으로 인코딩해야 합니다. UTF-16의 경우 Code Point를 많은 Code Unit으로 구성할 수 있습니다. UTF-16의 첫 2^16 개 Code Point는 하나의 16-bit Code Unit으로 표현됩니다. 이 범위를 BMP (Basic Multilingual Plane)이라고 합니다. 그 이상에 있는 것은 Supplementary plane 중 하나에있는 것으로 생각되어 더 이상 16-bit만으로 Code Point를 표현할 수 없습니다. UTF-16은 단일 Code Point가 두 개의 16-bit Code Unit으로 표현되는 Surrogate pair을 도입하여 이 문제를 해결했습니다. 즉, 문자열의 모든 단일 문자는, BMP 문자의 경우 하나의 Code Unit이 되어 총 16-bit를 제공하거나 Supplementary plane 문자의 경우 총 32-bit를 제공 합니다. ECMAScript5에서 모든 문자열 연산은 16-bit Code Unit에서 작동합니다. 즉, 아래 코드에서와 같이 Surrogate pair가 포함된 UTF-16 인코딩된 문자열에서 예기치 않은 결과가 발생할 수 있습니다. 12345678var text = \"𠮷\";console.log(text.length); // 2console.log(/^.$/.test(text)); // falseconsole.log(text.charAt(0)); // \"\"console.log(text.charAt(1)); // \"\"console.log(text.charCodeAt(0)); // 55362console.log(text.charCodeAt(1)); // 57271 Unicode 문자&quot;𠮷&quot;는 Surrogate pair를 사용하여 표현되며 위의 JavaScript 문자열 연산은 문자열을 두 개의 16-bit 문자로 취급합니다. 이러한 의미는 다음을 나타냅니다. text의length는 1이어야 할 때 2입니다. 한 문자와 일치하는 정규식은 두 문자가 있다고 생각하기 때문에 실패합니다. charAt() 메서드는 유효한 문자열을 반환 할 수 없습니다. 왜냐하면 16-bit의 문자는 출력 가능한 문자가 아니기 때문입니다. 또한 charCodeAt() 메서드는 문자를 제대로 식별 할 수 없습니다. 각 Code Unit에 대해 적절한 16-bit 숫자를 반환하지만 ECMAScript5에서 text의 실제 값에 유사한 값이기 때문입니다. 반면 ECMAScript 6은 이러한 Address Problem을 해결하기 위해 UTF-16 문자열 인코딩을 시행합니다. 이 문자 인코딩을 기반으로 문자열 연산을 표준화하면 JavaScript가 Surrogate pair와 함께 작동하도록 설계된 기능을 사용할 수 있습니다. 이 절의 나머지 부분에서는 해당 기능의 몇 가지 주요한 예제를 설명합니다. codePointAt() 메서드완벽하게 UTF-16을 지원하기 위해 추가된 ECMAScript 6 메서드 중 하나는 codePointAt() 메서드입니다.이 메서드는 문자열의 주어진 위치에 매핑되는 유니 코드 Code Point를 검색합니다. 이 메서드는 문자 위치가 아닌 Code Unit 위치를 받아 들여 정수 값을 반환합니다. 아래 예제를 살펴 보겠습니다. 123456789var text = \"𠮷a\";console.log(text.charCodeAt(0)); // 55362console.log(text.charCodeAt(1)); // 57271console.log(text.charCodeAt(2)); // 97console.log(text.codePointAt(0)); // 134071console.log(text.codePointAt(1)); // 57271console.log(text.codePointAt(2)); // 97 codePointAt() 메서드는 문자가 BMP이면 charCodeAt()메서드와 같은 값을 반환합니다. 변수 text의 첫 번째 문자는 BMP가 아니기 때문에 두 개의 Code Unit으로 구성됩니다. 즉, length 값은 2가 아니라 3입니다. charCodeAt() 메서드는 0 번 위치의 첫 번째 Code Unit만 반환하지만 codePointAt()는 Code Point가 여러 개의 Code Unit에 걸쳐 있더라도 전체 Code Point를 반환합니다. 두 메서드는 모두 위치 1 (첫 번째 문자의 두 번째 Code Unit)과 2 ( &quot;a&quot;문자)에 대해 동일한 값을 반환합니다. 문자에 대해 codePointAt() 메서드를 호출하는 것은 그 문자가 하나 또는 두 개의 코드 포인트로 표현되는지를 결정하는 가장 쉬운 방법이다. 이러한 확인을 위해 다음 코드를 사용할 수 있습니다. 123456function is32Bit(c) &#123; return c.codePointAt(0) &gt; 0xFFFF;&#125;console.log(is32Bit(\"𠮷\")); // trueconsole.log(is32Bit(\"a\")); // false 16-bit로 표시가능한 최대 숫자는 16 진수로 FFFF로 표현되므로, 그 숫자 위의 모든 Code Point는 총 32-bit의 두 Code Unit으로 표현되어야 합니다. String.fromCodePoint() 메서드ECMAScript는 어떤 일을 할 수있는 방법을 제공 할 때, 또한 반대로도 할 수있는 방법을 제공하는 경향이 있습니다. codePointAt() 메서드를 사용하여 문자열의 문자에 대한 Code Point를 찾을 수 있고, `String.fromCodePoint()’ 메서드는 주어진 Code Point에서 단일 문자열을 생성합니다. 1console.log(String.fromCodePoint(134071)); // \"𠮷\" String.fromCharCode() 메서드의 보다 완벽한 버전 인 String.fromCodePoint()를 생각해 보십시오. 둘 다 BMP의 모든 문자에 대해 동일한 결과를 제공합니다. 하지만 BMP 외부의 문자에 대한 Code Point를 전달할 때 차이가 있습니다. normalize() 메서드Unicode의 또 다른 흥미로운 점은 정렬이나 다른 비교 기반 작업을 위해 서로 다른 문자를 비교할수 있다는 것입니다. 비교를 위한 이러한 연관 관계를 정의하는 두 가지 방법이 있습니다. 첫째 Canonical equivalence는 모든 점에서 Code Point의 두 시퀀스가 상호 교환 가능하다고 간주됨을 의미합니다. 예를 들어, 두 문자의 조합은 기본적으로 한 문자와 같을 수 있습니다. 두 번째는 Compatibility(호환성)입니다. Code point의 시퀀스는 서로 다르게 보이지만 특정 상황에서는 서로 바꿔서 사용할 수 있습니다. 이러한 관계로 인해 근본적으로 동일한 텍스트를 나타내는 두 개의 문자열은 서로 다른 Code point 시퀀스를 포함 할 수 있습니다. 예를 들어, 문자 &quot;æ&quot;와 두 자의 문자열 &quot;ae&quot;는 어떤 방식으로든 표준화를 하지 않으면 엄격하게 동등하지 않기 때문에 서로 바꿔서 사용할 수 없습니다. ECMAScript 6는 문자열에 normalize()가 있어서 Unicode 정규화 형식을 지원합니다. 이 메서드에 사용할 정규화 타입중 하나를 나타내는 하나의 문자열을 파라미터로 사용할 수 있습니다. Normalization Form Canonical Composition (&quot;NFC&quot;) - 기본값 Normalization Form Canonical Decomposition (&quot;NFD&quot;) Normalization Form Compatibility Composition (&quot;NFKC&quot;) Normalization Form Compatibility Decomposition (&quot;NFKD&quot;) 이 네 가지 형식의 차이점을 설명하는 것은이 책의 범위를 벗어납니다. 문자열을 비교할 때 두 문자열을 같은 형식으로 정규화해야한다는 점을 명심하십시오. 12345678910111213var normalized = values.map(function(text) &#123; return text.normalize();&#125;);normalized.sort(function(first, second) &#123; if (first &lt; second) &#123; return -1; &#125; else if (first === second) &#123; return 0; &#125; else &#123; return 1; &#125;&#125;); 위 코드는 변수 values Array의 문자열을 정규화된 형식으로 변환하여 Array을 적절히 정렬 할 수 있도록 합니다. 아래 코드와 같이 Comparator의 일부로서normalize() 를 호출하여 원래의 Array을 정렬 할 수도 있습니다. 123456789101112values.sort(function(first, second) &#123; var firstNormalized = first.normalize(), secondNormalized = second.normalize(); if (firstNormalized &lt; secondNormalized) &#123; return -1; &#125; else if (firstNormalized === secondNormalized) &#123; return 0; &#125; else &#123; return 1; &#125;&#125;); 위 코드의 중요한 점은 first와 second가 같은 방식으로 표준화 되어야 한다는 것입니다. 이 예제는 기본 NFC를 사용했지만 다음과 같이 나머지 중 하나를 쉽게 지정할 수 있습니다. 123456789101112values.sort(function(first, second) &#123; var firstNormalized = first.normalize(\"NFD\"), secondNormalized = second.normalize(\"NFD\"); if (firstNormalized &lt; secondNormalized) &#123; return -1; &#125; else if (firstNormalized === secondNormalized) &#123; return 0; &#125; else &#123; return 1; &#125;&#125;); 이전에 Unicode 표준화에 대해 걱정 해 본 적이 없다면 아마 이 방법을 사용하지 않을 것입니다. 하지만 국제화된 응용 프로그램에서 작업한다면 normalize() 메서드가 도움이 될 것입니다. normalize() 메서드가 ECMAScript 6에서 Unicode 문자열 작업에 제공하는 유일한 메서드가 아닙니다. ECMAScript 6은 또한 두가지의 유용한 구문을 추가 했습니다. Regular Expression의 u 플래그정규 표현식을 통해 일반적인 많은 문자열 연산을 수행 할 수 있습니다. 그러나 정규 표현식은 16-bit Code unit를 가정하고 각 Code unit은 하나의 문자를 나타냅니다. 이 문제를 해결하기 위해 ECMAScript 6에서 Unicode를 나타내는 정규 표현식에 대해 u 플래그를 정의합니다. 실행중일 때의 u 플래그정규 표현식에 u 플래그가 설정되면, Code unit이 아닌 문자에 대한 작업 모드로 전환됩니다. 즉 정규 표현식이 문자열의 Surrogate pair에 대해 더 이상 혼동하지 않아야 하며 예상대로 작동해야합니다. 예를 들어 다음 코드를 생각해 보겠습니다. 12345var text = \"𠮷\";console.log(text.length); // 2console.log(/^.$/.test(text)); // falseconsole.log(/^.$/u.test(text)); // true 정규 표현식 /^.$/은 입력 문자열을 단일 문자와 일치시킵니다. u 플래그없이 사용하면 이 정규 표현식이 Code unit으로 일치를 판단 하기 때문에 한자(두개의 Code unit으로 표현됨)가 정규 표현식과 일치하지 않습니다. u 플래그와 함께 사용하면 정규식은 Code unit 대신 문자들을 비교하므로 한자 문자가 일치합니다. Code Point 카운트유감스럽게도 ECMAScript 6은 문자열의 Code point 수를 알려주는 메서드를 추가하지 않았습니다. 하지만 u 플래그를 사용하면 정규 표현식을 사용하여 다음과 같이 계산할 수 있습니다. 1234567function codePointLength(text) &#123; var result = text.match(/[\\s\\S]/gu); return result ? result.length : 0;&#125;console.log(codePointLength(\"abc\")); // 3console.log(codePointLength(\"𠮷bc\")); // 3 위 코드는 match()를 호출할 때 u 옵션을 이용하여 전체 문자열에서 공백 문자와 공백 문자가 아닌 문자([\\s\\S]는 개행문자도 포함합니다.)를 text에서 둘다 확인합니다. result는 일치가 발생한 문자의 Array이기 때문에 Array의 길이는 문자열의 Code point 수가 됩니다. Unicode에서 문자열 &quot;abc&quot;와 &quot;𠮷bc&quot;는 둘 다 3 개의 문자를 가지므로 Array 길이는 3입니다. 위의 예제는 효과적 일지는 몰라도, 특히 긴 문자열에 적용 할 때 빠르지는 않습니다. 문자열 Iterator(나중에 설명)를 사용할 수 있습니다. Code point 카운트를 최소화하는게 좋습니다. u 플래그 지원 여부 확인하기u 플래그는 구문 변경이므로 ECMAScript 6과 호환되지 않는 JavaScript 엔진에서 사용하려고 시도하면 구문 오류가 발생합니다. u 플래그가 지원되는지를 결정하는 가장 안전한 방법은 다음과 같은 함수를 사용하는 것입니다. 12345678function hasRegExpU() &#123; try &#123; var pattern = new RegExp(\".\", \"u\"); return true; &#125; catch (ex) &#123; return false; &#125;&#125; 이 함수는 RegExp 생성자를 사용하여 u 플래그를 인수로 전달합니다. 이 구문은 구형 JavaScript 엔진에서도 유효하지만, ‘u’가 지원되지 않으면 생성자는 오류를 발생시킵니다. 코드가 오래된 JavaScript 엔진에서 작동해야하는 경우, u 플래그를 사용할 때 항상 RegExp 생성자를 사용하십시오. 이렇게하면 구문 오류가 방지되고, 실행을 중단하지 않고 선택적으로 u플래그를 감지하여 사용할 수 있습니다. String의 다른 변경사항JavaScript 문자열 관련 기능들은 다른 언어보다 항상 뒤떨어져 있습니다. 예를 들어 ECMAScript 5에서 문자열의 trim() 메서드가 추가 되었으며 ECMAScript 6는 JavaScript의 기능을 확장하여 새로운 기능으로 문자열을 파싱합니다. Substring 문자열 식별 메서드개발자들은 JavaScript가 처음 소개된 이래로 indexOf() 메서드를 사용하여 문자열 내부에서 어떤 텍스트가 있는지 판단 했습니다. ECMAScript 6에는 다음과 같은 세 가지 방법이 추가 되었습니다. includes() 메서드는 주어진 텍스트가 문자열 내의 어느 위치에서든 발견되면 true를 반환합니다. 그렇지 않으면 false를 반환합니다. startsWith() 메서드는 지정된 텍스트가 문자열의 시작 부분에서 발견되면 true를 반환합니다. 그렇지 않으면 false를 반환합니다. endsWith() 메서드는 주어진 텍스트가 문자열의 끝에서 발견되면 true를 반환합니다. 그렇지 않으면 false를 반환합니다. 각 메서드는 검색 할 텍스트와 검색을 시작할 인덱스(Optional)라는 두 개의 파라미터를 사용할 수 있습니다. 두 번째 파라미터가 입력 되면 includes()는 입력된 파라미터 이후에 일치하는 텍스트가 있는지 확인하고, startsWith()는 입력받은 파라미터의 인덱스에 첫 번째 입력 받은 텍스트가 일치 하는지 검사합니다. 그리고 endsWith ()는 두 번째 파라미터를 문자열의 마지막으로 설정해서 문자열에서 마지막 텍스트가 일치하는지 확인합니다. 두 번째 인수가 생략되면 endsWith()가 맨 끝에서 시작하고, includes () 및 startsWith ()는 문자열의 처음부터 검색합니다.결과적으로 두 번째 인수는 검색되는 문자열의 양을 최소화합니다. 다음은이 세 가지 방법을 보여주는 몇 가지 예입니다. 12345678910111213var msg = \"Hello world!\";console.log(msg.startsWith(\"Hello\")); // trueconsole.log(msg.endsWith(\"!\")); // trueconsole.log(msg.includes(\"o\")); // trueconsole.log(msg.startsWith(\"o\")); // falseconsole.log(msg.endsWith(\"world!\")); // trueconsole.log(msg.includes(\"x\")); // falseconsole.log(msg.startsWith(\"o\", 4)); // msg: \"o world!\" =&gt; trueconsole.log(msg.endsWith(\"o\", 8)); // msg: \"Hello wo\" =&gt; trueconsole.log(msg.includes(\"o\", 8)); // msg: \"rld!\" =&gt; false 처음 6 개 호출에는 두 번째 파라미터가 없으므로 전체 문자열을 검색에 사용합니다. 마지막 세 건의 호출은 문자열의 일부만 검사합니다. msg.startsWith( &quot;o&quot;, 4)를 호출하면 “Hello”에서 “o”인 msg 문자열의 4개의 문자를 건너뛰고 일치를 시작합니다. msg.endsWith(&quot;o&quot;, 8) 호출은 전체 문자열 길이(12)중에서 처음부터 입력받은 8개까지 문자열의 마지막에서 텍스트 일치를 시작합니다. msg.includes(&quot;o&quot;, 8)호출은 “world”의 “r”인 8개의 문자를 건너뛰고 일치를 시작합니다. 이 세 가지 방법을 사용하면 하위 문자열의 존재를 다 쉽게 식별 할 수 있지만 각각 true/false 값만 반환합니다. 한 문자열의 실제 위치를 다른 문자열 내에서 찾으려면 indexOf() 또는 lastIndexOf () 메서드를 사용하십시오. startsWith(), endsWith() 및 includes() 메서드는 문자열 대신 정규 표현식을 파라미터로 전달하면 오류가 발생합니다. 정규 표현식이 포함된 파라미터를 문자열로 변환 한 다음 해당 문자열을 검색하는 indexOf(), lastIndexOf()와는 대조적입니다. repeat() 메서드ECMAScript 6은 String에 repeat () 메서드를 추가했습니다. 이 메서드는 파라미터로 입력한 회수 만큼 문자열을 반복합니다. 123console.log(\"x\".repeat(3)); // \"xxx\"console.log(\"hello\".repeat(2)); // \"hellohello\"console.log(\"abc\".repeat(4)); // \"abcabcabcabc\" 이 메서드는 텍스트를 조작 할 때 특히 유용하고 편리한 함수입니다. 다음과 같이 들여 쓰기 수준을 만들어야 하는 코드 서식 유틸리티에서 특히 유용합니다. 123456// indent using a specified number of spacesvar indent = \" \".repeat(4), indentLevel = 0;// whenever you increase the indentvar newIndent = indent.repeat(++indentLevel); 첫 번째 repeat() 호출은 4개의 공백이 포함된 문자열을 생성하고, indentLevel 변수는 들여 쓰기 레벨을 추적합니다. 그런 다음, repeat()를 증가된 indentLevel과 함께 호출하여 공백(“ “)의 수를 변경할 수 있습니다. 또한 ECMAScript 6은 특정 범주에 맞지 않는 정규 표현식 기능을 일부 변경했습니다. 다음 섹션에서는 몇 가지 사항을 집중적으로 설명합니다. 정규 표현식(Regular Expression)의 다른 변경 사항정규 표현식은 JavaScript로 문자열을 다루는 중요한 부분이며, JavaScript의 다른 많은 부분과 마찬가지로 최근 버전까지 많이 변경되지 않았습니다. 하지만 ECMAScript 6에서 문자열에 대한 몇몇 업데이트와 함께 정규 표현식이 몇 가지 개선되었습니다. 정규 표현식(Regular Expression) y 플래그ECMAScript 6은 파이어 폭스에서 정규 표현식을 독점적으로 확장 구현 후 y 플래그를 표준화 했습니다. y 플래그는 정규 표현식 검색의 sticky 속성에 영향을 미치며 정규 표현식의 lastIndex 속성에 의해 지정된 위치의 문자열에서 일치하는 문자를 검색하도록 검색을 지시합니다. 해당 위치에서 일치하는 항목이 없으면 정규식은 매칭을 중지합니다. 이것이 어떻게 작동하는지 다음 코드를 보도록 하겠습니다. 1234567891011121314151617181920212223var text = \"hello1 hello2 hello3\", pattern = /hello\\d\\s?/, result = pattern.exec(text), globalPattern = /hello\\d\\s?/g, globalResult = globalPattern.exec(text), stickyPattern = /hello\\d\\s?/y, stickyResult = stickyPattern.exec(text);console.log(result[0]); // \"hello1 \"console.log(globalResult[0]); // \"hello1 \"console.log(stickyResult[0]); // \"hello1 \"pattern.lastIndex = 1;globalPattern.lastIndex = 1;stickyPattern.lastIndex = 1;result = pattern.exec(text);globalResult = globalPattern.exec(text);stickyResult = stickyPattern.exec(text);console.log(result[0]); // \"hello1 \"console.log(globalResult[0]); // \"hello2 \"console.log(stickyResult[0]); // Error! stickyResult is null 이 예제에는 3 개의 정규 표현식이 있습니다. pattern의 표현식에는 플래그가 없으며 globalPattern의 표현식은 g 플래그를 사용하고stickyPattern의 표현식은 y 플래그를 사용합니다. 첫 번째의 3개 console.log()에서 세 정규식은 모두 끝에 스페이스가 포함된 &quot;hello1 &quot;를 반환 합니다. 그런 다음 lastIndex 속성은 세 패턴 모두에서 1로 변경됩니다. 즉 정규 표현식이 두 번째에서 일치를 시작합니다. 플래그가 없는 정규 표현식은lastIndex에 대한 변경 사항을 완전히 무시하고 &quot;hello1 &quot;과 아무런 문제없이 일치합니다. g 플래그를 사용하는 정규 표현식은 문자열의 두 번째 문자(&quot;e&quot;)에서 검색을 시작하기 때문에 &quot;hello2 &quot;와 일치합니다. sticky 정규 표현은 두 번째 문자에서 시작하는 것과 일치하지 않으므로stickyResult는 null입니다. sticky 플래그는 작업이 수행될 때마다 lastIndex에서 마지막으로 일치 한 다음 문자 다음의 인덱스를 저장합니다. 연산 결과가 일치하지 않으면 lastIndex가 0으로 다시 설정됩니다. 전역 stickyPattern.lastIndex는 다음과 같이 동일한 방식으로 동작합니다. 123456789101112131415161718192021222324252627var text = \"hello1 hello2 hello3\", pattern = /hello\\d\\s?/, result = pattern.exec(text), globalPattern = /hello\\d\\s?/g, globalResult = globalPattern.exec(text), stickyPattern = /hello\\d\\s?/y, stickyResult = stickyPattern.exec(text);console.log(result[0]); // \"hello1 \"console.log(globalResult[0]); // \"hello1 \"console.log(stickyResult[0]); // \"hello1 \"console.log(pattern.lastIndex); // 0console.log(globalPattern.lastIndex); // 7console.log(stickyPattern.lastIndex); // 7result = pattern.exec(text);globalResult = globalPattern.exec(text);stickyResult = stickyPattern.exec(text);console.log(result[0]); // \"hello1 \"console.log(globalResult[0]); // \"hello2 \"console.log(stickyResult[0]); // \"hello2 \"console.log(pattern.lastIndex); // 0console.log(globalPattern.lastIndex); // 14console.log(stickyPattern.lastIndex); // 14 lastIndex의 값은 stickyPattern 변수와 globalPattern 변수 모두에 대해 exec()의 첫 번째 호출 후에 7로 변경되고 두 번째 호출 후에 14로 변경됩니다. 염두에 두어야 할 sticky 플래그에 대한 두 가지 미묘한 세부 사항이 있습니다. lastIndex 속성은 exec()및 test() 메서드와 같이 정규 표현식 객체에 존재하는 메서드를 호출 할 때만 적용됩니다. 정규 표현식을 match ()와 같은 문자열 메서드에 전달하면 sticky를 실행하지 않습니다. 문자열의 시작과 일치시키기 위해^문자를 사용할 때, sticky 정규 표현식은 문자열의 시작 부분 또는 여러 줄 모드의 줄 시작 부분에서만 일치합니다. lastIndex가 0 일때 ^는 non-sticky 정규 표현식과 sticky 정규 표현식의 결과가 같습니다. lastIndex가 단일 행 모드에서 문자열의 시작이나 다중 행 모드에서 행의 시작과 일치하지 않으면 sticky 정규 표현식은 절대로 매칭하지 않습니다. 일반 다른 정규식 플래그와 마찬가지로 프로퍼티를 사용하여 sticky 플래그의 존재를 확인 할 수 있습니다. 다음 코드는 sticky 속성을 검사 하는 예제입니다. 123var pattern = /hello\\d/y;console.log(pattern.sticky); // true sticky 속성은 sticky 플래그가 있으면 true로 설정되고, 그렇지 않으면 false로 설정됩니다. sticky 속성은 플래그의 존재에 기초한 읽기 전용이며 코드라서 변경할 수 없습니다. u 플래그와 비슷하게, y 플래그는 구문 변경이므로 오래된 JavaScript 엔진에서는 구문 오류가 발생할 수 있습니다. 다음 방법을 사용하여 sticky 지원을 검사 할 수 있습니다. 12345678function hasRegExpY() &#123; try &#123; var pattern = new RegExp(\".\", \"y\"); return true; &#125; catch (ex) &#123; return false; &#125;&#125; u 검사와 마찬가지로, y 플래그를 가진 정규 표현식을 만들 수 없다면 false를 반환합니다. u 플래그와 유사하게 오래된 JavaScript 엔진에서 실행되는 코드 내부에 y를 사용해야 할 경우, 정규 표현식을 정의 할 때 RegExp 생성자를 사용하여 구문 오류를 피하십시오. 정규 표현식 복제(Duplicating Regular Expressions)ECMAScript 5에서는 다음과 같이 RegExp 생성자에 정규 표현식을 전달하여 복제할 수 있습니다. 12var re1 = /ab/i, re2 = new RegExp(re1); re2 변수는 re1 변수의 복사본입니다. 그러나 정규식에 대한 플래그를 지정하는 RegExp 생성자에 두 번째 파라미터를 제공하면 다음 코드와 같이 정상 작동하지 않습니다. 1234var re1 = /ab/i, // ES5에서는 error 발생, ES6에서는 OK re2 = new RegExp(re1, \"g\"); ECMAScript 5 환경에서 이 코드를 실행하면 첫 번째 파라미터가 정규 표현식 일 때 두 번째 파라미터를 사용할 수 없다는 오류가 발생합니다. ECMAScript 6은 두 번째 파라미터가 허용되고 첫 번째 파라미터에있는 플래그를 무시하도록이 동작이 변경 되었습니다. 1234567891011121314var re1 = /ab/i, // ES5에서는 error 발생, ES6에서는 OK re2 = new RegExp(re1, \"g\");console.log(re1.toString()); // \"/ab/i\"console.log(re2.toString()); // \"/ab/g\"console.log(re1.test(\"ab\")); // trueconsole.log(re2.test(\"ab\")); // trueconsole.log(re1.test(\"AB\")); // trueconsole.log(re2.test(\"AB\")); // false 이 코드에서,re1은 대소 문자를 구분하지 않는 i 플래그를, re2는 전역 g 플래그만을 가지고 있습니다. RegExp 생성자는 re1에서 패턴을 복사하고 i 플래그를 g 플래그로 대체했습니다. 두 번째 인수가 없으면 re2는 re1과 같은 플래그를가집니다. 플래그 프로퍼티새 플래그를 추가하고 플래그를 사용하여 작업하는 방법을 변경하는 것과 함께 ECMAScript 6은 이와 관련된 프로퍼티를 추가했습니다. ECMAScript 5에서는 source 프로퍼티를 사용하여 정규 표현식의 텍스트를 얻을 수 있지만 플래그 문자열을 얻으려면 아래와 같이toString ()메서드의 출력을 파싱해야합니다. 123456789function getFlags(re) &#123; var text = re.toString(); return text.substring(text.lastIndexOf(\"/\") + 1, text.length);&#125;// toString() is \"/ab/g\"var re = /ab/g;console.log(getFlags(re)); // \"g\" 정규식을 문자열로 변환 한 다음 마지막 / 다음에 나오는 문자를 반환합니다. / 이후의 문자가 플래그입니다. ECMAScript 6는 flags 프로퍼티를 source 프로퍼티와 함께 추가하여 플래그를 쉽게 가져옵니다. 두 프로퍼티는 모두 getter 만 할당된 프로토 타입 접근자이므로 읽기 전용입니다. flags 프로퍼티는 디버깅과 상속 목적을 위해 정규 표현식을 더 쉽게 검사하게 합니다. ECMAScript 6에 추가된 flags 프로퍼티는 정규 표현식에 적용된 플래그의 문자열 표현을 반환합니다. 예 : 1234var re = /ab/g;console.log(re.source); // \"ab\"console.log(re.flags); // \"g\" 위 코드는 re에 있는 모든 플래그를 가져 와서 toString () 기법보다 훨씬 적은 코드로 결과를 콘솔에 출력합니다. source와 flags를 함께 사용하면 정규식 문자열을 직접 파싱하지 않고도 필요한 정규 표현식을 추출할 수 있습니다. 이 장에서 지금까지 다루었던 일반 문자열과 정규 표현식에 대한 변경 사항은 분명 강력하지만 ECMAScript 6는 훨씬 더 강력한 방식의 문자열을 지원합니다. Template literal(템플릿 리터럴)항상 JavaScript의 문자열 처리 기능은 다른 언어와 비교하면 기능이 제한적이었습니다. 예를 들어, ECMAScript 6까지 문자열은 지금까지 위에서 다루었던 메서드가 없었으며 문자열 연결은 가능한 간단했습니다. 개발자가 보다 복잡한 문제를 해결할 수 있도록 ECMAScript 6의 Template literal은 ECMAScript 5 이하에서 사용할 수있는 솔루션보다 안전한 방법으로 콘텐츠 작업을 위한 도메인 별 언어 (DSL) 생성 구문을 제공합니다. (DSL은 JavaScript와 같은 범용 언어와 달리 특정 목적을 위해 설계된 프로그래밍 언어입니다.) ECMAScript wiki는 template literal strawman에 대해 다음과 같이 설명합니다. 이 스키마는 Syntactic sugar를 활용한 ECMAScript 구문을 확장하여 라이브러리가 다른 언어의 내용을 쉽게 생성, 쿼리 및 조작할 수있는 DSL을 제공 하여 XSS, SQL Injection 등과 같이 Injection attack에 대항하거나 면역 기능을 부여 합니다. 실제로 Template literal은 JavaScript가 ECMAScript 5를 통해 부족했던 다음 기능에 대한 ECMAScript 6의 대답입니다. Multiline strings 여러 줄 문자열의 공식 개념. Basic string formatting 변수값으로 문자열의 일부를 대체할 수있는 기능. HTML escaping HTML에 삽입하는 것이 안전하도록 문자열을 변환하는 기능. Template literal은 JavaScript의 기존 문자열에 더 많은 기능을 추가하기 보다는 이러한 문제를 해결하기 위한 완전히 새로운 접근 방식입니다. 기본 문법 (Basic Syntax)가장 단순한 Template literal은 이중 따옴표(&quot;) 나 작은 따옴표(&#39;) 대신 백팅(` )으로 문자열을 감싸면 됩니다. 12345let message = `Hello world!`;console.log(message); // \"Hello world!\"console.log(typeof message); // \"string\"console.log(message.length); // 12 위 코드는 message 변수가 일반적인 JavaScript 문자열을 포함하고 있음을 보여줍니다. Template literal 구문은 문자열의 Code point을 생성하는 데 사용되며, 이 Code point는 message 변수에 할당됩니다. 문자열에서 백틱을 사용하려면 아래의 코드의 message 변수 처럼 백 슬래시 (\\)를 사용하여 이스케이프합니다. 12345let message = `\\`Hello\\` world!`;console.log(message); // \"`Hello` world!\"console.log(typeof message); // \"string\"console.log(message.length); // 14 Template literal 안의 이중 따옴표 나 작은 따옴표는 이스케이프할 필요가 없습니다. 여러 줄의 문자열 (Multiline String)JavaScript 개발자는 첫 번째 버전 이후로 항상 여러 줄을 만드는 방법을 원했습니다. 그러나 이중 따옴표 나 작은 따옴표를 사용하는 경우 문자열은 한줄로 완전히 포함되어야합니다. ECMAScript 6 이전 방법하지만 오래 지속되는 문법 버그 덕분에 JavaScript는 해결 방법이 있습니다. 개행 전에 백 슬래시 (\\)가 있으면 여러 줄을 만들 수 있습니다. 다음은 그 예입니다. 1234var message = \"Multiline \\string\";console.log(message); // \"Multiline string\" 하지만 백 슬래시가 개행이 아닌 연속으로 처리되기 때문에 message 문자열에는 콘솔에 출력할 때 개행 문자가 없습니다. 출력에 개행 문자를 표시하려면 수동으로 포함시켜야합니다. 12345var message = \"Multiline \\n\\string\";console.log(message); // \"Multiline // string\" 이것은 모든 주요한 JavaScript 엔진에서 두줄로된 Multiline String을 출력 하는 방법입니다. 그러나 이 동작은 버그로 정의되어 있으므로 많은 개발자들은 이를 피하는 것을 권장합니다. 일반적으로 ECMAScript 6 이전 버전으로 다중 문자열을 만들기 위한 방법은 다음과 같이 Array이나 문자열 연결에 의존합니다. 1234567var message = [ \"Multiline \", \"string\"].join(\"\\n\");let message = \"Multiline \\n\" + \"string\"; JavaScript에서 여러 줄을 사용하지 못하게하는 하는 문제는 개발자의 오랜 숙원이었습니다. 쉽게 여러줄의 문자열 만드는 방법ECMAScript 6의 Template literal은 특수 구문이 없기 때문에 여러 줄 문자열을 쉽게 만듭니다. 원하는 위치에 개행을 포함하면 결과에 나타납니다. 예 : 123456let message = `Multilinestring`;console.log(message); // \"Multiline // string\"console.log(message.length); // 16 백틱의 모든 공백은 문자열의 일부이므로 들여 쓰기에 주의하십시오. 123456let message = `Multiline string`;console.log(message); // \"Multiline // string\"console.log(message.length); // 31 이 코드에서 Template literal의 두 번째 줄 앞에있는 공백은 모두 문자열 자체의 일부로 간주됩니다. 적절한 들여 쓰기로 텍스트 줄을 만드는 것이 중요하다면 다음과 같이 여러 줄 Template literal의 첫 줄에 아무 것도 남기지 말고 그 다음에 들여 쓰기하는 것을 생각해 볼수 있습니다. 1234let html = `&lt;div&gt; &lt;h1&gt;Title&lt;/h1&gt;&lt;/div&gt;`.trim(); 이 코드는 첫 번째 줄에서 Template literal을 시작하지만 두 번째 줄까지는 텍스트가 없습니다. HTML 태그는 올바른 모양으로 들여 쓰여지고 trim() 메서드가 호출되어 초기 빈 줄이 제거됩니다. 원하는 경우, Template literal에서 \\n을 사용하여 개행을 삽입할 위치를 지정할 수도 있습니다. 12345let message = `Multiline\\nstring`;console.log(message); // \"Multiline // string\"console.log(message.length); // 16 문자열 치환 하기이 시점에서 Template literal은 일반적인 JavaScript 문자열보다 더 멋진 버전처럼 보일 수 있습니다. 하지만 일반 JavaScript의 문자열과 Template literal의 실제 차이는 Substitution(치환)에 있습니다. 치환 기능을 사용하면 유효한 JavaScript 표현식을 Template literal에 포함시키고 결과를 문자열의 일부로 출력할 수 있습니다. 문자열 치환은 문자열 내부에 임의의 JavaScript 표현식이 포함된 여는 ${ 및 닫는}로 처리 됩니다. 가장 간단한 치환은 다음과 같이 결과 문자열에 지역 변수를 직접 포함시킬 수 있습니다. 1234let name = \"Nicholas\", message = `Hello, $&#123;name&#125;.`;console.log(message); // \"Hello, Nicholas.\" 치환 ${name}은 로컬 변수 name에 접근하여 name을 message 문자열에 삽입합니다. message 변수는 즉시 치환 결과를 저장합니다. Template literal은 정의된 Scope에서 액세스할 수있는 모든 변수를 액세스할 수 있습니다. Template literal에서 선언되지 않은 변수를 사용하려고 시도하면 엄격 모드와 비 엄격 모드 모두에서 오류가 발생합니다. 모든 치환은 JavaScript 표현식이므로 간단한 변수 값의 치환 그 이상을 할 수 있습니다. 계산, 함수 호출 등도 쉽게 포함할 수 있습니다. 12345let count = 10, price = 0.25, message = `$&#123;count&#125; items cost $$&#123;(count * price).toFixed(2)&#125;.`;console.log(message); // \"10 items cost $2.50.\" 이 코드는 Template literal의 일부로 계산 기능을 수행합니다. count와 price 변수를 곱해서 결과를 얻은 다음.toFixed()를 사용하여 소수점 두 자리까지 포맷합니다. 두 번째 치환 이전의 달러 기호는 여는 중괄호가 없기 때문에 그대로 출력됩니다. Template literal은 JavaScript 표현식이기도합니다. 즉,이 예제에서와 같이 다른 Template literal의 치환 내부에 Template literal을 배치할 수 있습니다. 123456let name = \"Nicholas\", message = `Hello, $&#123; `my name is $&#123; name &#125;` &#125;.`;console.log(message); // \"Hello, my name is Nicholas.\" 이 예제는 첫 번째 템플릿 안에 두 번째 Template literal을 중첩합니다. 첫 번째 ${ 다음에 다른 Template literal이 시작됩니다. 두 번째 ${는 내부 Template literal 안에 삽입된 표현식의 시작을 나타냅니다. 그 표현식은 결과에 삽입되는 변수 name입니다. 템플릿 Tag(Tagged Template)지금까지 Template literal이 여러 줄을 만들고 따로 연결없이(+) 문자열에 값을 삽입하는 방법을 살펴 보았습니다. 그러나 Template literal의 진정한 힘은 태그가있는 템플릿에서 비롯됩니다. Template tag는 Template literal에 대한 치환을 수행하고 최종 문자열 값을 반환합니다. 이 태그는 첫 번째` 문자 바로 앞에있는 템플릿의 시작 부분에 다음과 같이 지정합니다. 1let message = tag`Hello world`; 이 예제에서 tag는 `Hello world` Template literal에 적용할 템플릿 태그입니다. Tag 정의하기Tag는 단순히 처리된 Template literal 데이터가 호출되는 함수입니다. Tag는 Template literal에 대한 데이터를 개별 조각으로 수신하고 조각을 결합하여 결과를 만들어야 합니다. 첫 번째 파라미터는 JavaScript에 의해 해석되는 리터럴 문자열을 포함하는 Array입니다. 후속 파라미터는 각 치환에 사용될 값입니다. Tag 함수는 일반적으로 다음과 같은 파라미터를 사용하여 정의되어 데이터를 보다 쉽게 처리할 수 있습니다. 123function tag(literals, ...substitutions) &#123; // return a string&#125; 무엇이 Tag로 전달되는지 더 잘 이해하기 위해 다음 코드를 살펴 보겠습니다. 123let count = 10, price = 0.25, message = passthru`$&#123;count&#125; items cost $$&#123;(count * price).toFixed(2)&#125;.`; 위 코드를 보면, passthru() 함수는 3 개의 파라미터를 받습니다. 첫 번째 파라미터는 아래의 요소를 포함하는 literals Array입니다. 첫 번째 치환 전의 빈 문자열 (&quot;&quot;) 첫 번째 치환 후 두 번째 문자열 앞에있는 문자열 ( &quot;items cost $&quot;) 두 번째 치환 후의 문자열 (&quot;.&quot;) 두 번째 파라미터는 count 변수에 대한 해석된 값인 10입니다. 이것은 substitutions Array의 첫 번째 요소가됩니다. 마지막 인수는(count * price).toFixed(2)의 해석된 값이고 substitutions Array의 두 번째 요소인 &quot;2.50&quot;이 될 것입니다. literals의 첫 번째 항목은 빈 문자열입니다. 이것은 literals[literals.length - 1]이 항상 문자열의 끝인 것처럼 literals[0]이 항상 문자열의 시작임을 보장합니다. 항상 substitutions.length === literals.length - 1이라는 표현이 true라는 것은 substitutions이 literals보다 항상 하나 더 적다는 것을 의미합니다. 이 패턴을 사용하면 literals과 substitutions Array을 결합하여 결과 문자열을 만들 수 있습니다. literals의 첫 번째 항목이 먼저오고, substitutions의 첫 번째 항목은 다음 항목이며, 이런 순서는 문자열이 완료될 때까지 계속됩니다. 예를 들어, 다음 두 Array의 값을 교대로 사용하여 Template literal의 기본 동작을 모방할 수 있습니다. 1234567891011121314151617181920function passthru(literals, ...substitutions) &#123; let result = \"\"; // loop는 substitutions 카운트 만큼 실행합니다. for (let i = 0; i &lt; substitutions.length; i++) &#123; result += literals[i]; result += substitutions[i]; &#125; // 마지막 literal result += literals[literals.length - 1]; return result;&#125;let count = 10, price = 0.25, message = passthru`$&#123;count&#125; items cost $$&#123;(count * price).toFixed(2)&#125;.`;console.log(message); // \"10 items cost $2.50.\" 위 예제는 Template literal의 기본 액션과 동일한 치환을 수행하는 passthru Tag를 정의합니다. 유일한 트릭은 substitutions Array의 끝을 지나치는 것을 피하기 위해 literalals.length가 아닌 substitutions.length를 loop에서 사용하는 것입니다. 이것은 literalals와 substitutions 사이의 관계가 ECMAScript 6에서 잘 정의되어 있기 때문에 가능합니다. ‘substitutions’에 포함된 값은 반드시 문자열 일 필요는 없습니다. 앞의 예에서와 같이 표현식이 숫자로 평가되면 숫자 값이 전달됩니다. 이러한 값이 결과에 어떻게 출력되어야 하는지를 결정하는 것은 Tag 작업의 일부입니다. Template literal의 Raw Value 사용하기템플릿 Tag는 Raw string 정보에도 접근할 수 있습니다. 이 정보는 주로 문자 이스케이프에 대한 액세스를 의미합니다. Raw string 값으로 작업하는 가장 간단한 방법은 내장된 String.raw() Tag를 사용하는 것입니다. 123456let message1 = `Multiline\\nstring`, message2 = String.raw`Multiline\\nstring`;console.log(message1); // \"Multiline // string\"console.log(message2); // \"Multiline\\\\nstring\" 이 코드에서 message1의 \\n은 개행 문자로 해석되고 message2의 \\n은 &quot;\\\\n&quot;(역슬래시 및 문자 n)의 Raw string으로 해석됩니다. 이와 같이 Raw string 정보를 찾을려면 생각보다 복잡한 처리가 필요합니다. Raw string 정보는 또한 템플릿 Tag로 전달됩니다. Tag 함수의 첫 번째 파라미터는 raw라는 추가 프로퍼티가 있는 Array입니다. raw 프로퍼티는 각 리터럴 값과 정확히 일치하는 Raw을 포함하는 Array입니다. 예를 들어, literals[0]의 값은 항상 Raw string 정보를 포함하는 literals.raw[0]과 일치합니다. 다음 코드를 사용하여 String.raw()을 모방할 수 있습니다. 12345678910111213141516171819function raw(literals, ...substitutions) &#123; let result = \"\"; // loop는 substitutions 카운트 만큼 실행합니다. for (let i = 0; i &lt; substitutions.length; i++) &#123; result += literals.raw[i]; // 대신 raw 값을 사용하세요. result += substitutions[i]; &#125; // 마지막 리터럴을 더합니다. result += literals.raw[literals.length - 1]; return result;&#125;let message = raw`Multiline\\nstring`;console.log(message); // \"Multiline\\\\nstring\"console.log(message.length); // 17 result를 만들기 위해 위해 literalals대신에 literals.raw를 사용합니다. 즉, Unicode Code point 이스케이프를 비롯한 모든 문자 이스케이프는 Raw 형식으로 반환되어야합니다. Raw string은 이스케이프 문자를 포함해야 하는 코드가 포함된 문자열을 출력하려는 경우 유용합니다. (예를 들어, 일부 코드에 대한 설명서를 생성하려면 실제 코드가 나타나는대로 출력하고 싶을 수 있습니다.) 요약완전한 Unicode 지원을 통해 JavaScript는 논리적 인 방식으로 UTF-16 문자를 처리할 수 있습니다. codePointAt()와 String.fromCodePoint()를 통해 Code point와 캐릭터 사이를 옮기는 능력은 문자열 조작을 위한 중요한 단계입니다. 정규 표현식 u 플래그를 추가하면 16-bit 문자 대신 Code point에서 연산을 수행할 수 있으며, normalize() 메서드는 보다 적절한 문자열 비교에 유용합니다. ECMAScript 6는 문자열 작업을위한 새로운 방법을 추가하여 부모 문자열의 위치에 관계없이 하위 문자열을 보다 쉽게 식별할 수 있도록합니다. 정규 표현식에 더 많은 기능이 추가되었습니다. Template literal은 ECMAScript 6에 중요한 추가 기능으로 문자열 작성을 쉽게하기 위해 도메인 별 언어 (DSL)를 만들 수 있습니다. 변수를 Template literal에 직접 포함시킬 수 있다는 것은 개발자가 변수가 있는 긴 문자열을 작성하기 위해 문자열 연결보다 안전한 도구라는 것을 의미합니다. 여러 줄 문자열에 대한 지원 기능이 내장되어 있어 Template literal은 일반적인 JavaScript 문자열보다 유용합니다. Template literal 내부에 개행을 직접 허용하더라도 여전히 \\n과 다른 문자 이스케이프 시퀀스를 사용할 수 있습니다. 템플릿 Tag는 DSL을 생성할 때 가장 중요한 부분입니다. Tag는 Template literal 조각을 인수로받는 함수입니다. 그런 다음 해당 데이터를 사용하여 적절한 문자열 값을 반환할 수 있습니다. 제공된 데이터에는 리터럴, raw 값 및 치환 값이 포함됩니다. 그런 다음 이러한 정보를 사용하여 태그의 정확한 리턴을 결정할 수 있습니다. 이 내용은 나중에 참고하기 위해 제가 공부하며 정리한 내용입니다.의역, 오역, 직역이 있을 수 있음을 알려드립니다.This post is a translation of this original article [https://leanpub.com/understandinges6/read#leanpub-auto-strings-and-regular-expressions] 참고 ECMAScript 6 Block Binding ECMAScript 6 문자열과 정규 표현식 ECMAScript 6 함수 ECMAScript 6 객체의 확장된 기능 ECMAScript 6 쉬운 데이터 액세스를 위한 Destructuring ECMAScript 6 Symbol과 Symbol 프로퍼티 ECMAScript 6 Set과 Map ECMAScript 6 Iterator와 Generator ECMAScript 6 JavaScript 클래스 소개 ECMAScript 6 Array 기능 향상 ECMAScript 6 Promise와 비동기 프로그램밍 ECMAScript 6 프록시와 리플렉션 API ECMAScript 6 Module로 코드 캡슐화하기 ECMAScript 6 부록 A. 작은 변경 사항 ECMAScript 6 부록 B. ECMAScript 7(2016) 이해하기","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://infoscis.github.io/categories/JavaScript/"},{"name":"ECMAScript 2015","slug":"JavaScript/ECMAScript-2015","permalink":"http://infoscis.github.io/categories/JavaScript/ECMAScript-2015/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://infoscis.github.io/tags/JavaScript/"},{"name":"ECMAScript 2015","slug":"ECMAScript-2015","permalink":"http://infoscis.github.io/tags/ECMAScript-2015/"}]},{"title":"ECMAScript 6 Block binding","slug":"ecmascript-6-block-binding","date":"2018-01-24T14:03:14.000Z","updated":"2018-02-27T14:11:53.789Z","comments":true,"path":"2018/01/24/ecmascript-6-block-binding/","link":"","permalink":"http://infoscis.github.io/2018/01/24/ecmascript-6-block-binding/","excerpt":"","text":"Block BindingJavascript의 전통적인 식별자(Identifier - 변수, 상수, 이름 있는 함수 등) 선언이 작동하는 방식은 JavaScript 프로그래밍의 까다로운 부분 중 하나였습니다. 대부분의 C 기반 언어에서 식별자(Identifier - 변수 바인딩)는 선언이 발생한 지점에 만들어집니다. 그러나 JavaScript에서는 그렇지 않습니다. 식별자(Identifier)를 실제로 생성하는 위치는 선언하는 방법에 따라 다르며, ECMAScript 6에서는 제어 Scope을 더 쉽게 만들 수 있는 옵션을 제공합니다. 이 챕터에서는 고전적인 var 식별자 선언이 왜 혼란스럽게 하는지와, ECMAScript 6의 Block level binding의 소개, 그리고 이를 사용하는 몇 가지 모범 사례를 제시합니다. var 식별자 선언 및 Hoisting(호이스팅) 식별자 JavaScript의 식별자는 간단히 말해서 이름입니다JavaScript 식별자는 변수, 상수, 함수에 이름을 붙이거나 자바스크립트 코드 내 루프 문에 레이블을 붙이는 데 사용됩니다.올바른 식별자가 되기 위한 규칙은 자바나 다른 수많은 언어의 규칙과 동일합니다.첫 번째 문자는 알파벳(letter), 밑줄(_) 혹은 달러표시($) 여야 한다. 이어지는 문자들은 알바벳(letter), 숫자, 밑줄(_) 혹은 달러 표시여야 한다.JavaScript가 숫자와 식별자를 쉽게 구별할 수 있게 하기 위해, 숫자는 첫 번째 문자로 허용되지 않는다. 출처 http://www.devholic.net/1000687 var를 이용한 식별자 선언은 실제 선언이 어디에서 발생하는지에 관계없이 해당 Scope의 맨 위에있는 것처럼 처리됩니다. (또는 함수 외부에서 선언된 경우 전역 Scope로 처리됩니다.) 이것을 JavaScript에서 Hoisting이라고합니다. 아래 예제 함수를 보면 Hoisting에 대해 쉽게 이해할 수 있습니다. 1234567891011function getValue(condition) &#123; if (condition) &#123; var value = \"blue\"; // 다른 코드들 return value; &#125; else &#123; // value는 여기에서 'undefined' 입니다. return null; &#125; // value는 여기에서 'undefined' 입니다.&#125; JavaScript에 익숙하지 않은 경우 위 코드에서 if 조건이 true로 평가되는 경우에만 value가 생성될 것으로 예상할 수 있지만 실제로 value 변수는 선언한 위치와 관계없이 생성됩니다. JavaScript 엔진은 getValue 함수를 다음과 같이 변경합니다. 12345678910function getValue(condition) &#123; var value; // 변수의 선언 위치가 바뀝니다. if (condition) &#123; value = \"blue\"; // 변수의 초기화는 여기에서 이뤄집니다. // 다른 코드들 return value; &#125; else &#123; return null; &#125;&#125; value 변수의 선언은 Scope 맨 위로 올라가고 변수의 초기화는 동일한 지점에 남아 있습니다. 즉, value는 else 절에서 실제로 액세스할 수 있습니다. 하지만 else 구문에서 접근할 경우 변수는 초기화되지 않았기 때문에 undefined값을 갖게됩니다. 새로 JavaScript를 공부하는 개발자가 Hoisting에 익숙해지기까지 어느정도 시간이 걸리며, 이 독특한 동작을 잘못 이해하면 버그가 발생할 수 있습니다. 이러한 이유로 ECMAScript 6에는 식별자(Identifier)의 생명주기 제어를 좀 더 강력하게 만들기 위한 Block level scope 옵션이 도입되었습니다. Block-Level 식별자 선언Block level 식별자 선언은 지정된 Block scope 외부에서 액세스할 수없는 식별자(Identifier)를 정의하는 방법입니다. 이런 방식은 Lexical scope이라고도 하는 Block scope이 만들어집니다. Function 내부 Block 내부 ( {와 } 문자 사이를 나타냄) Block scope은 C 기반 언어의 작동 방식이며 ECMAScript 6의 Block-level 식별자(Identifier) 선언은 JavaScript에 C 기반 언어와 동일한 유연성(균일성)을 제공하기 위한 것입니다. let 식별자 선언let을 이용한 식별자 선언 구문은 var 구문과 동일합니다. 기본적으로 var를 let으로 바꾸면 똑같이 식별자를 선언할 수 있지만 Scope이 현재 코드 Block으로 제한됩니다. (하지만 잠시후에 논의할 약간의 차이점은 있습니다). let 선언은 자동으로 Block의 맨 위로 올려지지 않기 때문에 let 선언을 Block의 최상단에 배치해야만 Block 전체에서 사용할 수 있습니다. 아래의 예제를 살펴 보도록 하겠습니다. 1234567891011function getValue(condition) &#123; if (condition) &#123; let value = \"blue\"; // 다른 코드들 return value; &#125; else &#123; // value 변수는 이 Block에 존재하지 않습니다. return null; &#125; // value 변수는 이 Block에 존재하지 않습니다.&#125; 이 버전의 getValue 함수는 다른 C 기반 언어의 실행 방식과 매우 유사합니다. 변수 value는 var 대신에 let을 사용하여 선언 되었기 때문에, 변수 선언이 함수 정의 맨위로 끌어 올려지지 않습니다. 그리고 value는 if을 벗어나면 더 이상 접근할 수 없습니다. if 조건이 false로 평가되면 value 변수는 선언이 되지 않고 값의 초기화도 이뤄지지 않습니다. 재선언 안됨식별자(변수)가 이미 Scope내에서 정의된 경우 해당 Scope에서 같은 이름으로 let 선언을 다시하면 오류가 발생합니다. 예를 들어 아래의 코드는 에러가 발생합니다. 123var count = 30;// 구문 오류let count = 40; 위의 예제에서 count는 두 번 선언되었습니다(한 번은 var, 다른 한 번은 let). let은 이미 선언된 식별자를 동일한 Scope에 다시 정의하지 않기 때문에 let 변수 선언은 오류를 발생시킵니다. 반면에 아래 예제와 같이 let 선언이 포함된 코드가 새로운 Scope에서 동일한 이름의 식별자로 선언될 경우 오류가 발생하지 않습니다. 123456var count = 30;// 에러가 발생하지 않습니다.if (condition) &#123; let count = 40; // 다른 코드들&#125; 위 코드의 let 선언은 if 블럭에 count라는 새로운 변수를 생성하기 때문에 오류를 발생시키지 않습니다. if 블럭 안에서 선언한 count 변수가 전역 count 변수를 shadows 처리하여 Block 내부에서는 전역 count에 대한 암시적 접근을 차단합니다. Constant 선언ECMAScript 6에서 const 선언 구문을 사용하여 식별자를 정의할 수있습니다. const를 사용하여 선언된 식별자는 상수(Constant)로 간주되며, 일단 값을 설정하면 변경할 수 없습니다. 이런 이유로 모든 const 식별자는 다음 예제와 같이 선언시 초기화 되어야합니다. 12345// 유효한 상수 선언const maxItems = 30;// 초기화가 빠져있어서 구문 오류const name; 위 예제에서 maxItems 변수는 초기화 코드가 있어서 const 선언이 문제없이 실행됩니다. 그러나 name 변수는 초기화되지 않았으므로 만약 이 코드가 포함된 프로그램을 실행하려고 하면 name 변수 선언에서 구문 오류를 일으킬 수 있습니다. 상수와 let 선언 관계let 선언 변수는 Block-level 변수 선언입니다. 이것은 프로그램의 실행 흐름이 변수가 선언된 Block을 벋어 나면 변수를 더이상 액세스할 수 없다는 것을 의미합니다. 아래의 예제에서 보듯이, 선언된 변수가 Hoisting되지 않습니다. 123456if (condition) &#123; const maxItems = 5; // 다른 코드&#125;// maxItems은 여기에서 액세스할 수 없습니다. 이 코드에서 변수 maxItems는 if 블럭 안에서 선언되었습니다. 그리고 명령문 실행이 끝나면 maxItems 변수는 해당 블럭 외부에서 액세스할 수 없습니다. let과 동일하게 같은 Scope에 이미 정의된 식별자 이름을 또 사용하면 const 선언시 오류가 발생합니다. 변수가 var (전역 또는 함수 Scope의 경우) 또는 let (Block scope의 경우)을 사용하여 선언되었는지는 중요하지 않습니다. 예를 들어 다음 코드를 살펴 보겠습니다. 123456var message = \"Hello!\";let age = 25;// 에러가 발생합니다.const message = \"Goodbye!\";const age = 30; 위 예제에서 상위 두개의 const 선언을 단독으로 사용하면 유효하지만, 위 코드에서는 앞의 var 및 let 선언이 있어서 오류가 발생합니다. let과 const가 이러한 비슷한 점이 있지만 주요한 큰 차이점이 하나 있습니다. 아래의 예제에서 보듯이 이전에 정의된 const 식별자에 새로운 상수값을 할당하려고 하면 strict 모드와 non-strict 모드 모두에서 오류가 발생합니다. 12const maxItems = 5;maxItems = 6; // 에러가 발생합니다. 다른 언어의 상수와 매우 비슷하게 나중에 maxItems 상수에 새로운 값을 할당할 수 없습니다. 그러나 다른 언어와 달리 JavaScript의 상수가 객체인 경우 객체의 프로퍼티값은 수정할 수 있습니다. const를 이용한 객체 선언const 변수 선언은 값 자체가 아닌 바인딩의 수정을 방지합니다. 이는 객체의 const 선언이 객체의 수정을 막지 않는다는 것을 의미합니다. 예를 들어 아래 코드를 살펴 보겠습니다. 12345678910const person = &#123; name: \"Nicholas\"&#125;;// 실행됨person.name = \"Greg\";// 에러 발생person = &#123; name: \"Greg\"&#125;; 위 코드에서 person 변수는 하나의 프로퍼티를 가진 JavaScript 객체이고, 초기값을 가지고 생성됩니다. person.name의 값을 변경하는건 오류 없이 가능합니다. 왜냐하면 person에 바인드된 값을 변경하는 것이 아니고 person에 포함된 것을 변경하기 때문입니다. 만약 코드에서 person에 값을 할당하려고 시도하면 (바인딩을 변경하려고 하면) 오류가 발생합니다. const가 객체와 어떻게 작동하는지에 대한 이 미묘한 점이 오해하기 쉽습니다. const는 바인딩 값의 수정이 아니라 바인딩 자체의 수정을 방지한다는 것을 기억 해야 합니다. TDZ (The Temporal Dead Zone) let 초기화와 관련하여 발생하는 오류를 가리켜 TDZ(TEMPORAL DEAD ZONE) 오류라고 부릅니다. let 또는 const로 선언된 식별자는 선언 전에는 액세스할 수 없습니다. 아래의 예제와 같이 일반적으로 안전한 typeof 연산자를 사용하는 경우에도 참조 오류가 발생합니다. 1234if (condition) &#123; console.log(typeof value); // ReferenceError! let value = \"blue\";&#125; 여기서 식별자 value는 let을 사용하여 정의되고 초기화 되지만 이전행에서 오류가 발생하므로 해당 명령문은 실행되지 않습니다. value 식별자가 JavaScript 커뮤니티에서 불리는 The Temporal Dead Zone(TDZ)에 존재한다는 것이 문제입니다. TDZ는 ECMAScript 사양에서 명시적으로 설명하고 있지는 않지만, 식별자를 let 및 const 선언전에 액세스할 수없는 이유를 설명할 때 자주 이용됩니다. 여기에서 TDZ를 발생시키는 선언 배치의 미묘한 부분에 대해 설명합니다. 모든 예제에서 let을 사용하지만 const에도 동일하게 적용됩니다. JavaScript engine이 실행될 때에 블록({ })에서 선언된 변수를 찾아 선언된 식별자가 var 선언자를 이용한 선언이면 변수의 선언을 함수의 최상단 또는 전역 Scope으로 가져가고, let 또는 const 선언자로 선언된 경우 변수의 선언을 TDZ에 배치합니다. TDZ의 변수에 대한 액세스는 런타임 오류가 발생합니다. 이러한 변수를 TDZ에서 제거하고 변수를 선언된 이후에 사용하면 안전하게 사용할 수 있습니다. let 또는 const 선언자로 선언된 변수는 사용하기 전에 defined 됩니다. 이런 부분은 이전 예제에서 보여줬던 안전한 연산자인 typeof에도 적용이 됩니다. 그리고 변수가 선언된 블록의 외부에서 변수에 대해 typeof를 사용할 수는 있지만 정상적인 결과를 받지 못합니다. 다음 코드를 살펴보겠습니다. 12345console.log(typeof value); // \"undefined\"if (condition) &#123; let value = \"blue\";&#125; value가 선언된 블록 외부에서 사용되기 때문에 typeof 연산자가 실행될 때 변수 value는 TDZ에 없습니다. 이 의미는 value 변수에 바인딩이 없기 대문에 typeof 연산자는 &quot;undefined&quot;를 반환합니다. TDZ는 Block-binding의 독특한 부분입니다.그리고 또 다른 독특한 부분은 루프 내부에서의 사용과 관련이 있습니다. Loop 안에서의 Block Binding개발자가 Block-level scope을 가장 많이 원하는 곳 중 하나는 for loop 이고, 일반적으로 임시로 사용하는 카운터 변수는 루프 내부에서만 사용해야 합니다. 예를 들어 기존 JavaScript 코드에서 아래와 같은 코드는 보기 드물지 않습니다. 12345for (var i = 0; i &lt; 10; i++) &#123; process(items[i]);&#125;// i 는 여전히 여기에서 액세스 가능합니다.console.log(i); // 10 Block level scope가 기본인 다른 언어에서는 이 예제가 의도 한대로 실행되고, for loop 내부에서만 i 변수에 액세스할 수 있습니다. 그러나 JavaScript에서는 var 선언이 Hoisting되기 때문에 loop가 완료된 후에도 변수 i를 계속 액세스할 수 있습니다. 다음 코드와 같이 var 선언자 대신 let 선언자를 사용하여 원래 의도 한 동작이 실행 되도록 해야 합니다. 123456for (let i = 0; i &lt; 10; i++) &#123; process(items[i]);&#125;// i는 접근할 수 없기 때문에 error가 발생합니다.console.log(i); 위 코드에서 변수 i는 for loop 내에만 존재합니다. loop가 완료되면 변수는 더 이상 다른 곳에서 액세스할 수 없습니다. loop 안의 함수var 변수 선언자의 특징 중에 loop 내부에서 생성한 변수를 loop 밖에서 액세스할 수 있는 특징 때문에 loop 내부에서 함수를 만들때 오랫동안 문제가 있었습니다. 다음 코드를 생각해 보겠습니다. 123456789var funcs = [];for (var i = 0; i &lt; 10; i++) &#123; funcs.push(function() &#123; console.log(i); &#125;);&#125;funcs.forEach(function(func) &#123; func(); // 숫자 '10'이 열번 출력됩니다.&#125;); 이 코드는 일반적으로 0에서 9까지의 숫자를 출력할 것으로 예상되지만 10을 10번 출력합니다. 왜냐하면 i는 반복문의 반복마다 서로 공유되기 때문입니다. 즉, loop 내부에서 생성한 함수는 모두 동일한 변수를 참조합니다. 변수 i는 loop가 완료되면 10의 값을 가지므로 console.log (i)가 호출될 때마다 10을 매번 출력합니다. 이 문제를 해결하기 위해 대부분의 개발자는 루프 내에서 즉시 호출되는 함수 표현식 (IIFE: Immediately-invoked function expression)을 사용하여 아래 예제에서 처럼 반복할 변수의 새 복사본을 강제로 만듭니다. 12345678910111213var funcs = [];for (var i = 0; i &lt; 10; i++) &#123; funcs.push((function(value) &#123; return function() &#123; console.log(value); &#125; &#125;(i)));&#125;funcs.forEach(function(func) &#123; func(); // outputs 0, then 1, then 2, up to 9&#125;); 위의 예제에서는 IIFE를 loop 내부에서 사용했습니다. 변수 i는 IIFE 형태로 전달되고, IIFE는 자체 복사본을 만들어 value로 저장합니다. 이것은 반복에서 함수가 사용하는 값이므로 각 함수를 호출하면 loop에서 0부터 9까지 카운트될 때 예상 값이 리턴됩니다. 하지만 ECMAScript 6에서는 let및 const를 사용하여 Block-level 바인딩을 하면 이러한 작업이 단순화 됩니다. Loop 안에서의 let 선언let선언은 앞의 예제에서 IIFE가 수행하는 것을 효과적으로 대체함으로써 loop를 단순화합니다. 각 반복에서 loop는 새 변수를 만들고 이전 반복과 같은 이름을 가진 변수 값으로 초기화합니다. 즉, IIFE를 생략하고 다음과 같이 원하는 결과를 얻을 수 있습니다. 1234567891011var funcs = [];for (let i = 0; i &lt; 10; i++) &#123; funcs.push(function() &#123; console.log(i); &#125;);&#125;funcs.forEach(function(func) &#123; func(); // outputs 0, then 1, then 2, up to 9&#125;) 위 예제는 var와 IIFE를 사용했던 예제와 정확히 똑같이 실행되지만 훨씬더 깔끔합니다. let 선언은 매번 loop를 통해 새로운 변수 i를 생성하므로 loop 안에 생성된 각 함수는 i의 복사된 값을 갖습니다. 각 i의 복사본은 loop의 시작 부분에서 생성된 값이 할당됩니다. 다음 예제와 같이 for-in, for-of loop에도 똑같이 적용됩니다. 12345678910111213141516var funcs = [], object = &#123; a: true, b: true, c: true &#125;;for (let key in object) &#123; funcs.push(function() &#123; console.log(key); &#125;);&#125;funcs.forEach(function(func) &#123; func(); // outputs \"a\", then \"b\", then \"c\"&#125;); 이 예제에서 for-in loop는 for loop와 같은 결과를 보여줍니다. loop가 실행될 때마다 새로운 key 바인딩이 생성되고 각 함수는 key 변수의 복사본을 가지고 있습니다. 함수가 다른 값을 출력하는 결과를 보여줍니다. 만약 key를 var 선언자를 이용해 선언하면 모든 함수는 동일한 &quot;c&quot;를 출력할 것입니다. loop에서 let 선언 동작은 스펙에서 특별히 정의된 동작이고, let의 Non-Hoisting 특성과 반드시 관련이 없다는 것을 이해하는 것이 중요합니다. 실제로, let의 초기 구현은 이러한 동작을 하지 못했고, ECMAScript 6 명세 Process가 진행되면서 추가된 것입니다. Loop 안에서의 상수 선언ECMAScript 6 명세는 loop내부 const 선언을 명시적으로 허용하지 않습니다. 그러나 여러분이 사용중인 loop 종류에 따라 const 선언을 사용하여 다른 처리를 할 수 있습니다. 일반적인 for loop의 경우 초기화시 const를 사용할 수 있지만 첫 번째 이터레이션 후 오류를 던집니다. 12345678var funcs = [];// 첫 번째 이터레이션 후에 에러를 던짐for (const i = 0; i &lt; 10; i++) &#123; funcs.push(function() &#123; console.log(i); &#125;);&#125; 위 예제에서 변수 i를 상수로 선언했습니다. i가 0 인 첫번째 loop의 반복은 성공적으로 실행됩니다. 하지만 i++가 상수를 수정하려하기 때문에 i++ 구문이 실행되변 에러가 발생합니다. 따라서 변수를 수정하지 않는 loop 초기화 부분의 변수를 선언할 때만 const를 사용할 수 있습니다. 반면에 for-in 또는 for-of loop에서 사용될 때 const 변수는let 변수와 똑같이 동작합니다. 다음 코드는 오류가 발생하지 않습니다. 1234567891011121314151617var funcs = [], object = &#123; a: true, b: true, c: true &#125;;// 에러를 발생하지 않습니다.for (const key in object) &#123; funcs.push(function() &#123; console.log(key); &#125;);&#125;funcs.forEach(function(func) &#123; func(); // outputs \"a\", then \"b\", then \"c\"&#125;); 이 코드는 “Loop 안에서의 let 선언” 부분의 두 번째 예제와 거의 동일한 실행 결과를 보여줍니다. 유일한 차이점은 key의 값을 loop 내에서 변경할 수 없다는 것입니다. for-in과 for-of loop는 const와 함께 실행할 수 있습니다. loop 초기화는 기존 바인딩의 값을 수정하려고 시도하는 대신 loop가 반복할 때마다 새로운 바인딩을 생성하기 때문입니다 (이전 예제에서 에러가 발생한 이유는 for-in 대신 for loop을 사용했기 때문입니다.). 전역 Block Bindinglet과 const가 var와 또 다른 부분은 전역 Scope 입니다. 전역 Scope에서 var을 사용할 때, 전역 객체 (브라우저의 window)에 대한 프로퍼티로 새로운 전역 변수를 만듭니다. 이는 실수로 var를 사용하여 기존 전역 변수의 값을 덮어 쓸 수 있음을 의미합니다. 123456// browser에서 실행.var RegExp = \"Hello!\";console.log(window.RegExp); // \"Hello!\"var ncz = \"Hi!\";console.log(window.ncz); // \"Hi!\" 글로벌 RegExp가 window에 정의되어 있더라도 var 선언으로 덮어 쓰는 것은 안전하지 않습니다. 이 예제는 원본을 덮어 쓰는 새로운 전역 변수 RegExp를 선언했습니다. 비슷하게 변수 ncz는 전역 변수로 정의되고 즉시 window에 프로퍼티로 정의됩니다. 이것이 항상 JavaScript가 작동하는 방법입니다. 전역 Scope에서 let 또는const를 var 대신 사용하면 전역 범위에 새로운 바인딩이 생성되지만 전역 객체에 프로퍼티가 추가 되지는 않습니다. 즉 let 또는 const를 사용하여 전역 변수를 덮어 쓸 수 없다는 것을 의미합니다. 다음 코드를 살펴 보겠습니다. 12345678// in a browserlet RegExp = \"Hello!\";console.log(RegExp); // \"Hello!\"console.log(window.RegExp === RegExp); // falseconst ncz = \"Hi!\";console.log(ncz); // \"Hi!\"console.log(\"ncz\" in window); // false 이 코드에서 RegExp에 대한 새로운 let 선언은 전역 변수 RegExp를 가리키는 바인딩을 만듭니다. 즉, window.RegExp와 RegExp는 같지 않으므로 전역 Scope에 혼란이 없습니다. 또한, ncz에 대한 const 선언은 바인딩은 생성하지만 전역 객체에 대한 프로퍼티를 추가하지 않습니다. 이 기능은 전역 객체에 프로퍼티을 생성하고 싶지 않을 때 전역 영역에서 let과 const가 훨씬 더 안전하게 할수 있도록 합니다. 만약 전역 객체에서 사용할 수 있어야 하는 코드가 필요하다면 전역 Scope에서 var을 여전히 사용할 수 있습니다. 이런 방법은 일반적으로 프레임이나 윈도우에서 코드에 액세스하는 경우에 일반적으로 사용합니다. Block-Binding에 대한 새로운 Best PracticesECMAScript 6가 개발 중에 있는 동안, 변수 선언에 var 대신에 let을 디폴트로 사용해야 한다는 생각이 널리 퍼졌습니다. 많은 JavaScript 개발자들은 let이 var의 실행 방식과 똑같이 실행된다고 생각했습니다. 그래서 선언자 키워드의 1:1 대체(Direct replacement)가 논리적으로 합당하게 생각되었습니다. 그리고 값의 수정에 대한 보호가 필요한 변수에는 const를 사용하도록 생각했습니다. 하지만 더많은 개발자가 ECMAScript 6으로 마이그레이션할 때에는 대체 접근법(Alternative approach)이 인기를 얻었습니다. 기본적으로 const를 사용하고 변수 값을 변경해야 한다는 것을 알때 let을 사용하십시오. 이유는 예상치 못한 값 변경이 버그의 원인이기 되기 때문에 초기화 후 대부분의 변수가 값을 변경해서는 안된다는 것입니다. 이 아이디어는 많은 공감을 얻었으면 ECMAScript 6을 채택할 때 고려할만한 가치가 있습니다. 요약let과 const Block-binding은 JavaScript에 Lexical scoping을 도입합니다. 이러한 선언은 Hoisting되지 않으며 선언된 블록내에만 존재합니다. 변수가 다른 언어와 더 유사하고 의도하지 않은 오류가 발생할 가능성이 적은 동작을 제공하므로 변수가 필요한 위치에 정확히 선언될 수 있습니다. 부작용으로 typeof와 같이 안전한 연산자를 사용하더라도 변수가 선언되기 전에 변수에 액세스할 수 없습니다. 선언전에 Block-binding에 액세스하려고 하면 TDZ(Temporary Dead Zone) 바인딩의 존재로 인해 오류가 발생합니다. 대부분의 경우 let과 const는 var와 비슷한 방식으로 동작합니다. 하지만 for loop에서는 그렇지 않습니다. let과 const 둘다에 대해서, for-in과 for-of loop는 반복할 때마다 새로운 바인딩을 생성합니다. 즉, loop 본문 내부에서 작성된 함수는 loop의 최종 반복 이후(loop를 벗어난 이후)가 아닌 현재 반복중인 loop 내부에서만 액세스할 수 있음을 의미합니다. for loop에서 let 선언에 대해서도 마찬가지입니다. 반면에 for loop에서 const 선언을 사용하려고 하면 에러가 발생할 수 있습니다. Block-binding을 위한 현재의 최선의 관행은 디폴트로 const를 사용하고 변수의 값을 변경할 필요가 있을 때만 let을 사용하는 것입니다. 이렇게하면 특정 유형의 오류를 방지하는데 도움이되고 코드의 기본 무결성이 보장됩니다. 이 내용은 나중에 참고하기 위해 제가 공부하며 정리한 내용입니다.의역, 오역, 직역이 있을 수 있음을 알려드립니다.This post is a translation of this original article [https://leanpub.com/understandinges6/read#leanpub-auto-block-bindings] 참고 ECMAScript 6 Block Binding ECMAScript 6 문자열과 정규 표현식 ECMAScript 6 함수 ECMAScript 6 객체의 확장된 기능 ECMAScript 6 쉬운 데이터 액세스를 위한 Destructuring ECMAScript 6 Symbol과 Symbol 프로퍼티 ECMAScript 6 Set과 Map ECMAScript 6 Iterator와 Generator ECMAScript 6 JavaScript 클래스 소개 ECMAScript 6 Array 기능 향상 ECMAScript 6 Promise와 비동기 프로그램밍 ECMAScript 6 프록시와 리플렉션 API ECMAScript 6 Module로 코드 캡슐화하기 ECMAScript 6 부록 A. 작은 변경 사항 ECMAScript 6 부록 B. ECMAScript 7(2016) 이해하기","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://infoscis.github.io/categories/JavaScript/"},{"name":"ECMAScript 2015","slug":"JavaScript/ECMAScript-2015","permalink":"http://infoscis.github.io/categories/JavaScript/ECMAScript-2015/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://infoscis.github.io/tags/JavaScript/"},{"name":"ECMAScript 2015","slug":"ECMAScript-2015","permalink":"http://infoscis.github.io/tags/ECMAScript-2015/"}]},{"title":"Webpack Plugin 개발","slug":"develop-webpack-plugin","date":"2018-01-24T13:02:32.000Z","updated":"2018-02-13T15:11:27.900Z","comments":true,"path":"2018/01/24/develop-webpack-plugin/","link":"","permalink":"http://infoscis.github.io/2018/01/24/develop-webpack-plugin/","excerpt":"","text":"Webpack Plugin 개발Plugin은 Webpack 엔진의 모든것을 개발자에게 공개합니다. 단계별 빌드 Callback을 사용하여 개발자는 Webpack 빌드 프로세스에 자신의 동작을 추가할 수 있습니다. Plugin 작성은 Loader를 빌드하는 것보다 조금더 진보된 것입니다. 왜냐하면 Webpack 하위 레벨 내부를 이해해야 할 필요가 있기 때문입니다. Plugin 만들기Webpack 용 Plugin은 다음과 같이 구성됩니다. 이름이 부여된 JavaScript 함수. 프로토 타입에 apply 메서드를 정의. Webpack의 Event Hook을 특정하고 Attach. Webpack 내부 인스턴스 특정 데이터를 조작. 기능이 완료된 후 Webpack에서 Callback을 호출. 123456789101112131415// 이름이 부여된 JavaScript의 함수function MyExampleWebpackPlugin() &#123;&#125;;// prototype에 `apply` 메서드 정의MyExampleWebpackPlugin.prototype.apply = function(compiler) &#123; // Webpack의 Event Hook을 지정하고 Attack compiler.plugin('webpacksEventHook', function(compilation /* Webpack 내부 인스턴스 특정 데이터 조작. */, callback) &#123; console.log(\"This is an example plugin!!!\"); // 기능이 완료된 후 Webpack에서 Callback을 호출. callback(); &#125;);&#125;; Plugin을 개발할 때 가장 중요한 두가지 자원 compiler와 compilation 객체가 있습니다. 이 두 객체의 역할을 이해하는 것은 Webpack 엔진을 확장하는 중요한 첫단계입니다. compiler 객체는 완전히 구성된 Webpack 환경을 나타냅니다. 이 객체는 Webpack이 시작할 때 한번 빌드되며 Option, Loader 및 Plugin을 포함한 모든 작업 설정으로 구성됩니다. Webpack 환경에 Plugin을 적용할 때 Plugin이 compiler에 대한 참조를 받습니다. compiler를 사용하여 기본 Webpack 환경을 액세스할 수 있습니다. compilation 객체는 버전이 있는 Asset 하나의 빌드를 나타냅니다. Webpack 개발 미들웨어를 실행하는 동안 파일 변경이 감지될 때마다 새로운 compilation이 생성되어 새로운 컴파일된 Asset이 생성됩니다. compilation은 모듈 리소스, 컴파일된 Asset, 변경된 파일 감시및 종속성의 현재 상태에 대한 정보를 나타냅니다. compilation은 또한 Plugin이 사용자 정의 작업을 수행하도록 선택할 수 있는 많은 Callback 포인트를 제공합니다. 두 구성 요소는 모든 Webpack Plugin (특히 compilation)의 핵심 부분이므로 개발자는 다음 소스 파일을 알아두면 도움이됩니다. Compiler Source Compilation Source Plugin 기본 구조Plugin은 프로토타입에 apply 메서드가있는 인스턴스 객체입니다. 이 apply 메서드는 Plugin을 설치하는 동안 Webpack compiler에 의해 한번 호출됩니다. apply 메서드는 compiler Callback에 대한 액세스를 허용하는 기본 Webpack compiler에 대한 참조를 제공받습니다. 간단한 Plugin은 다음과 같이 구성됩니다. 1234567891011function HelloWorldPlugin(options) &#123; // Option으로 Plubin 인스턴스 설정...&#125;HelloWorldPlugin.prototype.apply = function(compiler) &#123; compiler.plugin('done', function() &#123; console.log('Hello World!'); &#125;);&#125;;module.exports = HelloWorldPlugin; 그런 다음 Plugin을 설치하려면 Webpack 설정파일의 plugins 배열에 인스턴스를 포함하면 됩니다. 12345678var HelloWorldPlugin = require('hello-world');var webpackConfig = &#123; // ... config settings here ... plugins: [ new HelloWorldPlugin(&#123;options: true&#125;) ]&#125;; compilation 접근하기compiler 객체를 사용하면 각각의 새로운 compilation에 대한 참조를 제공하는 Callback을 바인드할 수 있습니다. 이러한 compilation은 빌드 프로세스 내에서 수많은 단계를 Hook하기 위한 콜백을 제공합니다. 123456789101112131415function HelloCompilationPlugin(options) &#123;&#125;HelloCompilationPlugin.prototype.apply = function(compiler) &#123; // compilation에 접근하기 위한 Callback 설정 compiler.plugin(\"compilation\", function(compilation) &#123; // 이제 compilation 단계들에 접근하기 위한 Callback 설정 compilation.plugin(\"optimize\", function() &#123; console.log(\"Assets are being optimized.\"); &#125;); &#125;);&#125;;module.exports = HelloCompilationPlugin; compiler,compilation 및 다른 중요한 객체에서 사용할 수있는 Callback에 대한 자세한 내용은 plugins을 참조하십시오. 비동기 compilation Plugin일부 compilation Plugin 단계는 비동기이며, Plugin 실행이 끝나면 호출되어야하는 Callback 함수를 전달합니다. 123456789101112131415function HelloAsyncPlugin(options) &#123;&#125;HelloAsyncPlugin.prototype.apply = function(compiler) &#123; compiler.plugin(\"emit\", function(compilation, callback) &#123; // Do something async... setTimeout(function() &#123; console.log(\"Done with async work...\"); callback(); &#125;, 1000); &#125;);&#125;;module.exports = HelloAsyncPlugin; 예제일단 Webpack compiler와 개별 compilation에 접근하게 되면 엔진을 이용해할 수 있는 일이 많아집니다. 기존 파일을 다시 형식화하거나 파생 파일을 만들거나 완전히 새로운 Asset을 만들 수 있습니다. filelist.md라는 새로운 빌드 파일을 생성하는 간단한 예제 Plugin을 작성해 보겠습니다. 이 파일의 내용에는 빌드의 모든 Asset 파일이 나열됩니다. 이 Plugin은 아래와 같습니다. 12345678910111213141516171819202122232425262728function FileListPlugin(options) &#123;&#125;FileListPlugin.prototype.apply = function(compiler) &#123; compiler.plugin('emit', function(compilation, callback) &#123; // Create a header string for the generated file: var filelist = 'In this build:\\n\\n'; // Loop through all compiled assets, // adding a new line item for each filename. for (var filename in compilation.assets) &#123; filelist += ('- '+ filename +'\\n'); &#125; // Insert this list into the webpack build as a new file asset: compilation.assets['filelist.md'] = &#123; source: function() &#123; return filelist; &#125;, size: function() &#123; return filelist.length; &#125; &#125;; callback(); &#125;);&#125;;module.exports = FileListPlugin; Plugin의 다른 형태Plugin은 등록된 이벤트에 따라 여러 종류로 분류할 수 있습니다. 모든 Event Hook은 레지스트리에 Plugin을 적용하는 방법을 결정합니다. synchronous Tapable 인스턴스는 다음을 사용하여 Plugin을 적용합니다. 1applyPlugins(name: string, args: any...) 1applyPluginsBailResult(name: string, args: any...) 즉, 각 Plugin 콜백은 특정 args를 사용하여 차례로 호출됩니다. 이것은 Plugin의 가장 간단한 형식입니다. &quot;compile&quot;, &quot;this-compilation&quot;과 같은 많은 유용한 이벤트는 Plugin이 동기 실행할 것을 요구합니다. waterfall Plugin을 사용하여 적용 1applyPluginsWaterfall(name: string, init: any, args: any...) 여기서 각 Plugin은 이전 Plugin의 반환값에서 args를 사용하여 순차적으로 호출됩니다. Plugin은 실행 순서를 고려해야합니다. 실행된 이전 Plugin의 인수를 받아 들여야합니다. 첫 번째 Plugin의 값은 init입니다. 이 패턴은 ModuleTemplate, ChunkTemplate과 같은webpack 템플릿과 관련된 Tapable 인스턴스에서 사용됩니다. asynchronous 모든 Plugin이 비동기적으로 적용될 때1applyPluginsAsync(name: string, args: any..., callback: (err?: Error) -&gt; void) Plugin 핸들러 함수는 모든 args와 (err ?: Error) -&gt; void 시그니처를 가진 콜백 함수로 호출됩니다. 핸들러 함수는 등록된 순서로 호출되며 callback은 모든 핸들러가 호출된 후에 호출됩니다. 이것은 또한 &quot;emit&quot;, &quot;run&quot;과 같은 Event에 일반적으로 사용되는 패턴입니다. async waterfall Plugin은 waterfall 방식으로 비동기로 적용됩니다 1applyPluginsAsyncWaterfall(name: string, init: any, callback: (err: Error, result: any) -&gt; void) Plugin 핸들러 함수는 현재 값과 (err : Error, nextValue : any) -&gt; void 시그니처가 있는 콜백 함수로 호출됩니다. nextValue가 호출되면 다음 핸들러의 현재 값이 됩니다. 첫 번째 핸들러의 현재 값은 init입니다. 모든 핸들러가 적용된 후 마지막 값으로 callback이 호출됩니다. 어떤 핸들러가 err에 값을 전달하면, 이 에러와 함께 callback이 호출되고 핸들러는 더 이상 호출되지 않습니다. 이 Plugin 패턴은 &quot;before-resolve&quot;및 &quot;after-resolve&quot;와 같은 Event에 필요합니다. async series 비동기와 동일하지만 등록된 Plugin 중 하나라도 실패하면 Plugin이 더 이상 호출되지 않습니다. 1applyPluginsAsyncSeries(name: string, args: any..., callback: (err: Error, result: any) -&gt; void) parallel 1applyPluginsParallel(name: string, args: any..., callback: (err?: Error) -&gt; void) 123456789101112131415161718192021222324252627282930313233343536373839 applyPluginsParallelBailResult(name: string, args: any..., callback: (err: Error, result: any) -&gt; void) ``## 유용한 Plugin 패턴Plugin은 Webpack 빌드 시스템 내에서 사용자 정의를 수행할 수 있는 무제한의 기회를 부여합니다. 이를 통해 사용자 정의 Asset을 만들거나, 고유한 빌드 수정을 수행하거나, 미들웨어를 사용하면서 Webpack 런타임을 향상시킬 수 있습니다. 다음은 Plugin 작성 중에 매우 유용하게 사용되는 Webpack의 일부 기능입니다.### Asset, Chunk, 모듈 및 종속성 탐색`compilation`이 완료된 후 `compilation` 내의 모든 구조를 탐색할 수 있습니다.```javascriptfunction MyPlugin() &#123;&#125;MyPlugin.prototype.apply = function(compiler) &#123; compiler.plugin('emit', function(compilation, callback) &#123; // 각 chunk를 탐색 (build output): compilation.chunks.forEach(function(chunk) &#123; // chunk 내의 각 모듈 탐색 (built inputs): chunk.forEachModule(function(module) &#123; // 모듈에 포함된 각 소스 파일 경로를 탐색합니다.: module.fileDependencies.forEach(function(filepath) &#123; // 이제 소스 구조에 대해 많은 것을 알게 되었습니다. &#125;); &#125;); // chunk에 의해 생성된 각 asset 파일을 탐색합니다. chunk.files.forEach(function(filename) &#123; // chunk에 의해 생성된 각 파일의 asset 소스 가져 오기 var source = compilation.assets[filename].source(); &#125;); &#125;); callback(); &#125;);&#125;;module.exports = MyPlugin; compilation.modules : compilation의 모듈 배열 (Built 입력). 각 모듈은 소스 라이브러리에서 Raw 파일의 빌드를 관리합니다. module.fileDependencies : 모듈에 포함된 소스 파일 경로의 배열. 여기에는 소스 JavaScript 파일 자체 (예 : index.js) 및 필요한 모든 종속성 Asset 파일 (스타일 시트, 이미지 등)이 포함됩니다. 종속성 검토는 소스 파일이 모듈에 속하는지 확인하는데 유용합니다. compilation.chunks : 컴파일에서 chunk 배열 (빌드 결과). 각 Chunk는 최종 렌더링 Asset의 구성을 관리합니다. chunk.modules : Chunk에 포함되는 모듈의 배열. 확장에 따라 각 모듈의 종속성을 조사하여 청크에 공급된 Raw 소스 파일을 확인할 수 있습니다. chunk.files : Chunk에 의해 생성된 결과 파일 이름들의 배열. compilation.assets 테이블에서 이러한 Asset 소스에 액세스할 수 있습니다. Watch 그래프 모니터링Webpack 미들웨어를 실행하는 동안 각 compilation에는 Watch 대상 파일인 fileDependencies 배열과 Watch된 파일 경로를 타임스탬프에 매핑하는 fileTimestamps가 포함됩니다. 이는 compilation 과정에서 변경된 파일을 탐지하는데 매우 유용합니다. 123456789101112131415161718function MyPlugin() &#123; this.startTime = Date.now(); this.prevTimestamps = &#123;&#125;;&#125;MyPlugin.prototype.apply = function(compiler) &#123; compiler.plugin('emit', function(compilation, callback) &#123; var changedFiles = Object.keys(compilation.fileTimestamps).filter(function(watchfile) &#123; return (this.prevTimestamps[watchfile] || this.startTime) &lt; (compilation.fileTimestamps[watchfile] || Infinity); &#125;.bind(this)); this.prevTimestamps = compilation.fileTimestamps; callback(); &#125;.bind(this));&#125;;module.exports = MyPlugin; 새로운 파일 경로를 Watch 그래프에 제공하여 파일이 변경될 때 compilation 트리거를 수신할 수 있습니다. 유효한 파일 경로를 compilation.fileDependencies 배열에 넣어 Watch에 추가하면됩니다. 참고 : fileDependencies 배열은 각 compilation에서 다시 작성되므로 Plugin은 Watch 종속성을 각 compilation에 넣어 Watch를 계속 유지해야합니다. 변경된 ChunkWatch 그래프와 마찬가지로 해시를 추적하여 compilation내에서 변경된 Chunk(또는 해당 모듈)를 모니터링하는 것도 가능합니다. 123456789101112131415161718function MyPlugin() &#123; this.chunkVersions = &#123;&#125;;&#125;MyPlugin.prototype.apply = function(compiler) &#123; compiler.plugin('emit', function(compilation, callback) &#123; var changedChunks = compilation.chunks.filter(function(chunk) &#123; var oldVersion = this.chunkVersions[chunk.name]; this.chunkVersions[chunk.name] = chunk.hash; return chunk.hash !== oldVersion; &#125;.bind(this)); callback(); &#125;.bind(this));&#125;;module.exports = MyPlugin; 이 내용은 나중에 참고하기 위해 제가 공부하며 정리한 내용입니다.의역, 오역, 직역이 있을 수 있음을 알려드립니다.This post is a translation of this original article [https://webpack.js.org/contribute/writing-a-plugin/]참고 : https://github.com/webpack/docs/wiki/How-to-write-a-plugin","categories":[{"name":"Webpack","slug":"Webpack","permalink":"http://infoscis.github.io/categories/Webpack/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://infoscis.github.io/tags/Webpack/"}]},{"title":"Angular에서 간단하게 번역기능 구현하기","slug":"angular-translation-service","date":"2018-01-24T13:02:10.000Z","updated":"2018-02-13T15:07:48.308Z","comments":true,"path":"2018/01/24/angular-translation-service/","link":"","permalink":"http://infoscis.github.io/2018/01/24/angular-translation-service/","excerpt":"","text":"Angular에서 간단하게 번역기능 구현하기이글은 Angular에서 번역을 구현하는 방법에 대해 설명합니다. 소개이 글에서 다음과 같은 방법을 배웁니다. 아래와 같이 HTML 뷰에서 단어를 번역하는데 사용할 수있는 Pipe를 만듭니다. 12&lt;!-- should display 'hola mundo' when translate to Spanish --&gt;&lt;p&gt;&#123;&#123; 'hello world' | translate &#125;&#125;&lt;/p&gt; 아래와 같이 JS/Typescript로 단어를 번역할 때 사용할 수 있는 Service를 만듭니다. 1234...// should display 'hola mundo' when translated to Spanishthis.translatedText = this.translate.instant('hello world'); // this.translate is our translate service... 여러 번역 (예 : 영어, 스페인어, 중국어 등)을 정의한 다음 현재 언어를 설정할 수 있습니다. 123...this.translate.use('es'); // use spanish... 번역을 위한 Placeholder 사용할 수 있습니다. 예를 들어, 아래와 같이 번역하고 싶다고 가정 해보십시오. 1Hello, [first_name] [last name]! 다음과 같이 변환 값을 정의할 수 있어야합니다.1234// translation definition, %&lt;number&gt; as placeholder...'hello greet': 'Hello %0 %1'... 우리는 다음과 같이 translate Service를 사용할 수 있기를 원합니다.1this.translate.instant('hello greet', [customer.firstName, customer.lastName]); HTML View도 마찬가지입니다. 매개 변수를 전달할 수 있어야합니다.1&lt;p&gt;&#123;&#123; 'hello greet' | translate: [customer.firstName, customer.lastName] &#125;&#125;&lt;/p&gt; 새로 고침 텍스트와 같은 기능을 실행하기 위해 언어가 변경 될 때마다 Publish하고 Subscribe합니다. 기본 언어를 사용하고 대비책을 사용하도록 설정합니다. 예를 들어 주어진 사용자가 현재 언어를 ‘중국어’로, 기본 언어를 ‘영어’로 설정합니다. 하지만 중국어에서 ‘hello’라는 단어를 찾을 수 없으면 영어 번역 정의에서 대체 단어를 찾아야합니다. 아래는 우리가 만들 UI입니다. 요구사항 사용자가 언어 버튼을 클릭하면 그에 따라 번역이 업데이트되어야합니다. App 설정다음은 파일 구조입니다. 12345678910111213141516|- app/ |- app.component.html |- app.component.ts |- app.module.ts |- main.ts |- translate/ |- index.ts |- lang-en.ts |- lang-es.ts |- lang-zh.ts |- translate.pipe.ts |- translate.service.ts |- translation.ts|- index.html|- systemjs.config.js|- tsconfig.json 설명 모든 translate 관련 파일을 위해 app 폴더 아래에 translate 폴더를 만들었습니다. lang-[name].ts 파일은 번역 정의를 보관하는 곳입니다. 이 예에서는 영어(en), 스페인어(es) 및 중국어(zh)를 사용합니다. translations.ts는 모든 번역을 연결하는 곳입니다. translate.pipe.ts와 translate.service.ts는 우리 Service와 Pipe의 파일입니다. index.ts는 Barrel로 export하기 위한 파일입니다. 나중에 Barrel에 대한 자세히 알아보겠습니다. 번역 정의 추가lang-[name] 형식의 파일이름에 번역을 추가하겠습니다. 1234567// lang-en.tsexport const LANG_EN_NAME = 'en';export const LANG_EN_TRANS = &#123; 'hello world': 'hello world',&#125;; 1234567// lang-es.tsexport const LANG_ES_NAME = 'es';export const LANG_ES_TRANS = &#123; 'hello world': 'hola mundo',&#125;; 1234567// lang-zh.tsexport const LANG_ZH_NAME = 'zh';export const LANG_ZH_TRANS = &#123; 'hello world': '你好，世界',&#125;; 번역이제 translation.ts 파일의 모든 번역 파일을 연결합니다. 1234567891011121314151617181920212223// app/translate/translation.tsimport &#123; OpaqueToken &#125; from '@angular/core';// import translationsimport &#123; LANG_EN_NAME, LANG_EN_TRANS &#125; from './lang-en';import &#123; LANG_ES_NAME, LANG_ES_TRANS &#125; from './lang-es';import &#123; LANG_ZH_NAME, LANG_ZH_TRANS &#125; from './lang-zh';// translation tokenexport const TRANSLATIONS = new OpaqueToken('translations');// all translationsconst dictionary = &#123; [LANG_EN_NAME]: LANG_EN_TRANS, [LANG_ES_NAME]: LANG_ES_TRANS, [LANG_ZH_NAME]: LANG_ZH_TRANS,&#125;;// providersexport const TRANSLATION_PROVIDERS = [ &#123; provide: TRANSLATIONS, useValue: dictionary &#125;,]; 설명 모든 번역 정의 파일을 가져 왔습니다. 우리는 translations라는 Opaque 토큰을 만들었습니다. Opaque 토큰은 응용 프로그램 인터페이스가 없는 오브젝트입니다. 이것은 의존성 주입에 사용되는 특별한 종류의 Provider lookup key입니다. 자세한 내용은 Angular 공식 문서를 참조하십시오. dictionary 변수는 모든 번역을 링크합니다. TRANSLATION_PROVIDERS는 앞에서 정의한 Opaque 토큰을 사용하고 dictionary을 값으로 제공한다고 설명합니다. 나중에 부트스트랩 (main.ts)에 TRANSLATION_PROVIDERS를 등록할 것입니다. Translate ServiceService를 만들어 봅시다. 1234567891011121314151617181920212223242526272829303132333435363738// app/translate/translate.service.tsimport &#123;Injectable, Inject&#125; from '@angular/core';import &#123; TRANSLATIONS &#125; from './translations'; // import our opaque token@Injectable()export class TranslateService &#123; private _currentLang: string; public get currentLang() &#123; return this._currentLang; &#125; // inject our translations constructor(@Inject(TRANSLATIONS) private _translations: any) &#123; &#125; public use(lang: string): void &#123; // set current language this._currentLang = lang; &#125; private translate(key: string): string &#123; // private perform translation let translation = key; if (this._translations[this.currentLang] &amp;&amp; this._translations[this.currentLang][key]) &#123; return this._translations[this.currentLang][key]; &#125; return translation; &#125; public instant(key: string) &#123; // call translation return this.translate(key); &#125;&#125; 설명 TRANSLATIONS 토큰을 가져 와서 생성자에 주입합니다. Translate Pipe이제 Translate Pipe를 만듭니다. Pipe는 간단합니다 - Pipe에 로직이 없습니다. 번역을 수행하기 위해 translate Service를 import하고 호출할 것입니다. 123456789101112131415161718// app/translate/translate.pipe.tsimport &#123; Pipe, PipeTransform &#125; from '@angular/core';import &#123; TranslateService &#125; from '../translate'; // our translate service@Pipe(&#123; name: 'translate',&#125;)export class TranslatePipe implements PipeTransform &#123; constructor(private _translate: TranslateService) &#123; &#125; transform(value: string, args: any[]): any &#123; if (!value) return; return this._translate.instant(value); &#125;&#125; 번역 사용하기Translate Service와 Pipe가 모두 완료되었습니다. App Component에서 사용해 봅시다. App Module로 Import 하기Translate Service와 Pipe를 사용하려면 응용 프로그램 모듈로 Import 해야합니다. 12345678910111213141516// app.module.tsimport &#123; NgModule &#125; from '@angular/core';import &#123; BrowserModule &#125; from '@angular/platform-browser';import &#123; AppComponent &#125; from './app.component';import &#123; TRANSLATION_PROVIDERS, TranslatePipe, TranslateService &#125; from './translate';@NgModule(&#123; imports: [ BrowserModule ], declarations: [ AppComponent, TranslatePipe ], // Inject Translate Pipe here bootstrap: [ AppComponent ], providers: [ TRANSLATION_PROVIDERS, TranslateService ]&#125;)export class AppModule &#123; &#125; 설명 응용프로그램 레벨에서 Service와 Pipe를 등록합니다. Translate Pipe를 global하게 (응용 프로그램 전체에서) 사용할 수 있도록합니다. 이 포스트를 참고하세요. App Component이제 Component에서 사용할 수 있습니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// app/app.component.tsimport &#123; Component, OnInit &#125; from '@angular/core';import &#123; TranslateService &#125; from './translate';@Component(&#123; moduleId: module.id, selector: 'app-root', templateUrl: 'app.component.html',&#125;)export class AppComponent implements OnInit &#123; public translatedText: string; public supportedLanguages: any[]; constructor(private _translate: TranslateService) &#123; &#125; ngOnInit() &#123; // standing data this.supportedLangs = [ &#123; display: 'English', value: 'en' &#125;, &#123; display: 'Español', value: 'es' &#125;, &#123; display: '华语', value: 'zh' &#125;, ]; // set current langage this.selectLang('es'); &#125; isCurrentLang(lang: string) &#123; // check if the selected lang is current lang return lang === this._translate.currentLang; &#125; selectLang(lang: string) &#123; // set current lang; this._translate.use(lang); this.refreshText(); &#125; refreshText() &#123; // refresh translation when language change this.translatedText = this._translate.instant('hello world'); &#125;&#125; 설명 지원되는 모든 언어를 저장하는 supportedLanguages 배열을 사용합니다. 기본적으로 언어는 스페인어로 설정됩니다. 물론 사용자의 브라우저 언어 navigator.language를 읽고 그에 따라 기본 언어를 설정할 수 있습니다. 새로운 언어가 선택되면 우리는 translatedText를 새로 고칩니다. (이어지는 내용에서 새로 고침을 처리하는 방법을 향상시킬 것입니다). App HTML 뷰다음은 HTML 뷰입니다. 12345678910111213141516171819202122&lt;!--app/app.component.html--&gt;&lt;div class=\"container\"&gt; &lt;h4&gt;Translate: Hello World&lt;/h4&gt; &lt;!--languages--&gt; &lt;div class=\"btn-group\"&gt; &lt;button *ngFor=\"let lang of supportedLangs\" (click)=\"selectLang(lang.value)\" class=\"btn btn-default\" [class.btn-primary]=\"isCurrentLang(lang.value)\"&gt; &#123;&#123; lang.display &#125;&#125; &lt;/button&gt; &lt;/div&gt; &lt;div&gt; &lt;!--translate with pipe--&gt; &lt;p&gt; Translate With Pipe: &lt;strong&gt;&#123;&#123; 'hello world' | translate &#125;&#125;&lt;/strong&gt; &lt;/p&gt; &lt;!--reanslate with service--&gt; &lt;p&gt; Translate with Service: &lt;strong&gt;&#123;&#123; translatedText &#125;&#125;&lt;/strong&gt; &lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 배럴(Barrel)로 묶기배럴(barrel)로 Export 하기translation 모듈을 배럴로 Export할 것입니다. 배럴은 여러 모듈의 Export를 단일 모듈로 감싸는 방법입니다. 배럴 자체는 다른 모듈의 선택된 Export를 다시 Export하는 모듈 파일입니다. 자세한 내용은 Angular 공식 문서를 참조하십시오. 12345// app/translate/index.tsexport * from './translate.service';export * from './translations';export * from './translate.pipe'; 부트스트랩(Bootstrap)이제 응용 프로그램을 부트스트랩 합니다. 12345678// app/main.tsimport &#123; platformBrowserDynamic &#125; from '@angular/platform-browser-dynamic';import &#123; AppModule &#125; from './app.module';const platform = platformBrowserDynamic();platform.bootstrapModule(AppModule); 시스템 설정systemjs를 사용하고 Angular CLI를 프로젝트 설정에 사용하는 경우 translate barrel을 system-config.ts 파일에 포함합니다. 1234567// system.config.ts// App specific barrels. 'app', 'app/translate', // include this line 'app/shared', /** @cli-barrel */ 거의 끝났습니다. 하지만..애플리케이션을 실행해 봅시다. 응용 프로그램이 로드되면 스페인어가 선택되고 번역은 예상대로 hola mundo를 표시합니다.영어를 선택해 보십시오. 하지만 Translate Pipe 값이 업데이트되지 않습니다. 왜 그럴까요?Angular 2 Pipe는 기본적으로 Pure합니다. Angular는 입력값에 대한 순수한 변경을 감지한 경우에만 Pure Pipe를 실행합니다. 우리의 경우, 입력값이 변경되지 않아 여전히 Hello world입니다. 따라서 값이 업데이트되지 않습니다. 해결책우리 Pipe를 impure로 만듭니다. Angular는 모든 Component 변경 감지 사이클 동안 Impure Pipe를 실행합니다. 이 경우 언어 선택을 업데이트하면 변경 사항이 트리거되고 Impure Pipe가 그에 따라 업데이트됩니다. 우리 Pipe를 Impure로 만들려면 app/translate/translate.pipe.ts를 열고 다음 한줄을 추가하십시오. 123456789// app/translate/translate.pipe.ts...@Pipe(&#123; name: 'translate', pure: false // add in this line, update value when we change language&#125;)... Pipe에 대한 자세한 내용은 Angular 2 Pipes 문서를 참조하십시오. Placeholder 사용을 위한 번역 정의 추가먼저 번역 정의 파일에 번역을 추가해 보겠습니다. 12345678910// lang-en.tsexport const LANG_EN_NAME = 'en';export const LANG_EN_TRANS = &#123; 'hello world': 'hello world', 'hello greet': 'Hello, %0 %1!', // two placeholder 'well done': 'Well done %0', // one placeholder 'good bye': 'bye bye', // only define in English&#125;; 123456789// lang-es.tsexport const LANG_ES_NAME = 'es';export const LANG_ES_TRANS = &#123; 'hello world': 'hola mundo', 'hello greet': 'Hola, %0 %1!', 'well done': '%0 bien hecho',&#125;; 123456789// lang-zh.tsexport const LANG_ZH_NAME = 'zh';export const LANG_ZH_TRANS = &#123; 'hello world': '你好，世界', 'hello greet': '你好, %0 %1!', 'well done': '干得好, %0',&#125;; 번역에서 Placeholder 사용이 작업은 꽤 쉽습니다. translate.service.ts의 instant 함수를 수정하여 선택적 파라미터를 받아 들이도록 하면 됩니다. 파라미터가 문자열 또는 문자열 배열을 허용할 수 있도록 하면 더 좋습니다. Translate Service 수정하기1234567891011// app/translate/translate.service.ts...public instant(key: string, words?: string | string[]) &#123; // add optional parameter const translation: string = this.translate(key); if (!words) return translation; return this.replace(translation, words); // call replace function&#125;... 이제 replace 함수를 구현해야합니다. 1234567891011121314151617// app/translate/translate.service.ts...private PLACEHOLDER = '%'; // our placeholderpublic replace(word: string = '', words: string | string[] = '') &#123; let translation: string = word; const values: string[] = [].concat(words); values.forEach((e, i) =&gt; &#123; translation = translation.replace(this.PLACEHOLDER.concat(&lt;any&gt;i), e); &#125;); return translation;&#125;... Translate Pipe 변경Pipe도 업데이트 해야합니다. 12345678// app/translate/translate.pipe.ts...transform(value: string, args: string | string[]): any &#123; // args can be string or string array if (!value) return; return this._translate.instant(value, args); // pass in args&#125;... HTML 뷰에서 사용이제 번역을 사용하기 위해 HTML 뷰를 업데이트 해 보겠습니다. 123456789101112131415&lt;!--app/app.component.html--&gt;&lt;!--multiple value--&gt;&lt;p&gt; Translate &lt;strong class=\"text-muted\"&gt;Hello, %0 %1!&lt;/strong&gt;:&lt;br&gt; &lt;strong&gt;&#123;&#123; 'hello greet' | translate:['Jane', 'Doe'] &#125;&#125;&lt;/strong&gt;&lt;/p&gt;&lt;!--single value--&gt;&lt;p&gt; Translate &lt;strong class=\"text-muted\"&gt;Well done %0&lt;/strong&gt;: &lt;br&gt; &lt;strong&gt;&#123;&#123; 'well done' | translate:'John' &#125;&#125;&lt;/strong&gt;&lt;/p&gt; 언어 변경 Event를 Publish하고 Subscribe 하기translate.service.ts 파일에 Event 발생기능을 추가합니다. Translate Service 변경하기1234567891011121314151617// app/translate/translate.service.ts...import &#123; Injectable, Inject, EventEmitter &#125; from '@angular/core'; // import event emitter...// add eventpublic onLangChanged: EventEmitter&lt;string&gt; = new EventEmitter&lt;string&gt;();..public use(lang: string): void &#123; ... this.onLangChanged.emit(lang); // publish changes&#125;... App Component에서 사용하기이제 App Component에서 사용할 수 있습니다. 앞서 논의한 selectLang()에서 refreshText()를 제거하기 위한 코드를 리팩토링 합니다. 123456789101112131415161718192021222324252627// app/app.component.ts...ngOnInit() &#123; // standing data ... this.subscribeToLangChanged(); // subscribe to language changes // set current language this.selectLang('es');&#125;selectLang(lang: string) &#123; // set default; this._translate.use(lang); // this.refreshText(); // remove this line&#125;subscribeToLangChanged() &#123; // refresh text // please unsubribe during destroy return this._translate.onLangChanged.subscribe(x =&gt; this.refreshText());&#125;... 이제 언어가 변경될 때마다 번역이 계속 업데이트됩니다. 기본언어 사용 및 대체언어 사용새로운 속성을 추가하고 translate.service.ts의 translate 함수를 리팩토링 합니다. Translate Service 변경하기123456789101112131415161718192021222324252627282930313233343536373839404142// app/translate/translate.service.ts...// add these 3 new propertiesprivate _defaultLang: string;private _currentLang: string;private _fallback: boolean;public get currentLang() &#123; return this._currentLang || this._defaultLang; // return default lang if no current lang&#125;public setDefaultLang(lang: string) &#123; this._defaultLang = lang; // set default lang&#125;public enableFallback(enable: boolean) &#123; this._fallback = enable; // enable or disable fallback language&#125;private translate(key: string): string &#123; // refactor our translate implementation let translation = key; // found in current language if (this._translations[this.currentLang] &amp;&amp; this._translations[this.currentLang][key]) &#123; return this._translations[this.currentLang][key]; &#125; // fallback disabled if (!this._fallback) &#123; return translation; &#125; // found in default language if (this._translations[this._defaultLang] &amp;&amp; this._translations[this._defaultLang][key]) &#123; return this._translations[this._defaultLang][key]; &#125; // not found return translation;&#125;... App Component에서 사용하기ngOnInit()에서 기본언어와 대체언어를 설정할 수 있습니다. 123456789101112131415161718// app/app.component.ts...ngOnInit() &#123; // standing data ... this.subscribeToLangChanged(); // set language this._translate.setDefaultLang('en'); // set English as default this._translate.enableFallback(true); // enable fallback // set current language this.selectLang('es');&#125;... HTML 뷰에서 사용HTML에서 테스트해 봅시다. 이전에 번역 정의 추가 단계에서 영어 번역을 위해 good bye를 추가했지만 스페인어와 중국어로 추가하지 않았습니다. 사용자가 스페인어 또는 중국어를 선택한 경우 디스플레이는 bye bye입니다. 왜냐하면 우리는 컴포너트에서 대체 언어 사용을 설정했기 때문입니다. 12345&lt;p&gt; Translate &lt;strong class=\"text-muted\"&gt;Good bye (fallback)&lt;/strong&gt;: &lt;br&gt; &lt;strong&gt;&#123;&#123; 'good bye' | translate &#125;&#125;&lt;/strong&gt;&lt;/p&gt; 요약이게 전부입니다. Service 및 Pipe와 대체언어, Event Publish/Subscribe 및 기본 언어와 같은 고급 기능을 사용하여 기본적인 번역 설정을 설명했습니다. 이 내용은 나중에 참고하기 위해 제가 공부하며 정리한 내용입니다.의역, 오역, 직역이 있을 수 있음을 알려드립니다.This post is a translation of this original article [https://scotch.io/tutorials/simple-language-translation-in-angular-2-part-1, https://scotch.io/tutorials/simple-language-translation-in-angular-2-part-2] 참고 Angular 튜토리얼 - 소개 Angular 튜터리얼 - Hero 에디터 Angular 튜터리얼 - Master/Detail Angular 튜터리얼 - 다중 콤포넌트 Angular 튜터리얼 - 서비스 Angular 튜터리얼 - 라우팅 Angular 튜터리얼 - HTTP Angular HttpClient Angular에서 간단하게 번역기능 구현하기 Angular 동적 컴포넌트 로딩 Angular에서 동적 컨텐츠 생성 Angular에서 ViewChildren, ContentChildren, 그리고 QueryList 이해하기","categories":[{"name":"Angular","slug":"Angular","permalink":"http://infoscis.github.io/categories/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://infoscis.github.io/tags/Angular/"}]},{"title":"Angular 동적 컴포넌트 로딩","slug":"angular-dynamic-component","date":"2018-01-24T13:01:43.000Z","updated":"2018-02-13T15:10:41.047Z","comments":true,"path":"2018/01/24/angular-dynamic-component/","link":"","permalink":"http://infoscis.github.io/2018/01/24/angular-dynamic-component/","excerpt":"","text":"Dynamic Component LoaderComponent 템플릿이 항상 고정되어있는 것은 아닙니다. 응용 프로그램은 런타임에 새로운 Component를 로드할 수 있어야 합니다.이 포스트는 ComponentFactoryResolver를 사용하여 Component를 동적으로 추가하는 방법을 설명합니다. live example을 보거나 다운로드할 수 있습니다. 동적 Component 로드하기다음 예는 동적 배너 광고를 작성하는 방법을 설명합니다. hero agency는 배너를 통해 순환하는 여러가지 광고로 광고 캠페인을 계획하고 있습니다. 새로운 광고 Component는 여러 팀에서 자주 추가됩니다. 이로 인해 정적 Component 구조의 템플릿을 사용하는 것은 비현실적입니다. 대신 배너 광고 서식 파일의 Component에 고정된 참조없이 새로운 Component를 로드하는 방법이 필요합니다. Angular는 Component를 동적으로 로드하기 위해 자체 API를 제공합니다. 앵커(Anchor) directiveComponent를 추가하기 전에 Anchor 포인트를 정의하여 Angular에 Component를 삽입할 위치를 지정해야합니다. 배너 광고 는 AdDirective라는 핼퍼 Directive를 사용하여 템플릿에 유효한 삽입 지점을 표시합니다. src/app/ad.directive.ts 12345678import &#123; Directive, ViewContainerRef &#125; from '@angular/core';@Directive(&#123; selector: '[ad-host]',&#125;)export class AdDirective &#123; constructor(public viewContainerRef: ViewContainerRef) &#123; &#125;&#125; AdDirective는 ViewContainerRef를 Inject하여 동적으로 추가된 Component를 호스팅할 요소의 뷰 컨테이너에 액세스합니다. @Directive Decorator에서 selector 이름인 ad-host를 설정합니다. 이 이름으로 요소에 Directive을 적용할 때 사용합니다. Component 로드하기대부분의 배너 광고 구현은 ad-banner.component.ts에 있습니다. 이 예제에서 간단히하기 위해 HTML은 @Component Decorator의 template 프로퍼티에 템플릿 문자열로 지정합니다. &lt;ng-template&gt; 요소는 방금 만든 Directive를 적용하는 곳입니다. AdDirective를 적용하기 위해 ad.directive.ts에 있는 ad-host selector를 사용합니다. 이 selector를 대괄호없이 &lt;ng-template&gt;에 적용합니다. 이제 Angular는 동적으로 Component를 로드할 위치를 알수 있습니다. src/app/ad-banner.component.ts (template)123456template: ` &lt;div class=\"ad-banner\"&gt; &lt;h3&gt;Advertisements&lt;/h3&gt; &lt;ng-template ad-host&gt;&lt;/ng-template&gt; &lt;/div&gt; ` &lt;ng-template&gt;는 추가 출력을 렌더링하지 않으므로 동적 Component에 적합합니다. Resolving componentsad-banner.component.ts의 메서드를 자세히 살펴보십시오. AdBannerComponent는 AdService에서 가져온 AdItem 객체 배열을 입력으로 사용합니다. AdItem 객체는 로드할 Component의 유형과 Component에 바인딩할 데이터를 지정합니다. AdService는 광고 캠페인을 구성하는 실제 광고를 반환합니다. AdBannerComponent에 Component 배열을 전달하면 템플릿에 정적 요소가 없는 광고의 동적 목록이 허용됩니다. getAds() 메서드를 사용하면 AdBannerComponent가 AdItem의 배열을 순회하고 loadComponent()를 호출하여 3초마다 새로운 Component를 로드합니다. src/app/ad-banner.component.ts (excerpt)12345678910111213141516171819202122232425262728293031323334353637export class AdBannerComponent implements AfterViewInit, OnDestroy &#123; @Input() ads: AdItem[]; currentAddIndex: number = -1; @ViewChild(AdDirective) adHost: AdDirective; subscription: any; interval: any; constructor(private componentFactoryResolver: ComponentFactoryResolver) &#123; &#125; ngAfterViewInit() &#123; this.loadComponent(); this.getAds(); &#125; ngOnDestroy() &#123; clearInterval(this.interval); &#125; loadComponent() &#123; this.currentAddIndex = (this.currentAddIndex + 1) % this.ads.length; let adItem = this.ads[this.currentAddIndex]; let componentFactory = this.componentFactoryResolver.resolveComponentFactory(adItem.component); let viewContainerRef = this.adHost.viewContainerRef; viewContainerRef.clear(); let componentRef = viewContainerRef.createComponent(componentFactory); (&lt;AdComponent&gt;componentRef.instance).data = adItem.data; &#125; getAds() &#123; this.interval = setInterval(() =&gt; &#123; this.loadComponent(); &#125;, 3000); &#125;&#125; loadComponent() 메서드는 여기서 많은 작업을 수행하고 있습니다. 단계별 살펴보겠습니다. 첫번째로 광고를 선택합니다. loadComponent()가 광고를 선택하는 방법 loadComponent() 메서드는 몇 가지 계산을 사용하여 광고를 선택합니다. 현재의 currentAddIndex에 1을 더한 값을 AdItem 배열의 길이로 나눈 나머지값을 currentAddIndex 값으로 취합니다. 그런 다음 해당 값을 사용하여 배열에서 adItem을 선택합니다. loadComponent()가 광고를 선택하면 ComponentFactoryResolver를 사용하여 각 특정 Component에 대한 ComponentFactory를 확인합니다. 그런 다음 ComponentFactory는 각 Component의 인스턴스를 만듭니다. 다음으로 Component의 특정 인스턴스에 있는 viewContainerRef를 대상으로 지정합니다. 이 특정 인스턴스를 어떻게 알 수 있을까요? 그것은 adHost를 참조하고 있기 때문에 알수 있습니다. adHost는 이전에 Angular에 동적 Component를 삽입할 위치를 지정하기 위해 설정한 Directive입니다. ViewContainerRef는 AdDirective 생성자에서 주입됩니다. 이 방법이 Directive를 이용한 동적 Component를 호스팅하는 요소에 액세스하는 방법입니다. Component를 템플릿에 추가하려면 ViewContainerRef의 createComponent()를 호출합니다. createComponent() 메서드는 로드된 Component에 대한 참조를 반환합니다. 이 참조를 사용하여 프로퍼티에 할당하거나 메서드를 호출하여 Component와 상호 작용할 수 있습니다. Selector references일반적으로 Angular 컴파일러는 템플릿에서 참조되는 모든 Component에 대해 ComponentFactory를 생성합니다. 그러나 동적으로 로드된 Component는 런타임에 로드되기 때문에 Component 템플릿에는 selector 참조가 없습니다. 컴파일러가 팩토리를 생성하도록 하려면 동적으로 로드된 Component를 NgModule의 entryComponents 배열에 추가 해야합니다. src/app/app.module.ts (entry components) 1entryComponents: [ HeroJobAdComponent, HeroProfileComponent ], AdComponent 인터페이스배너 광고에서 모든 Component는 공통 AdComponent 인터페이스를 구현하여 API를 표준화하고 데이터를 Component로 전달합니다. 다음은 두가지 샘플 Component와 참조용 AdComponent 인터페이스입니다. ad.component.ts123export interface AdComponent &#123; data: any;&#125; hero-profile.component.ts12345678910111213141516171819import &#123; Component, Input &#125; from '@angular/core'; import &#123; AdComponent &#125; from './ad.component'; @Component(&#123; template: ` &lt;div class=\"hero-profile\"&gt; &lt;h3&gt;Featured Hero Profile&lt;/h3&gt; &lt;h4&gt;&#123;&#123;data.name&#125;&#125;&lt;/h4&gt; &lt;p&gt;&#123;&#123;data.bio&#125;&#125;&lt;/p&gt; &lt;strong&gt;Hire this hero today!&lt;/strong&gt; &lt;/div&gt; `&#125;)export class HeroProfileComponent implements AdComponent &#123; @Input() data: any;&#125; hero-job-ad.component.ts1234567891011121314151617import &#123; Component, Input &#125; from '@angular/core'; import &#123; AdComponent &#125; from './ad.component'; @Component(&#123; template: ` &lt;div class=\"job-ad\"&gt; &lt;h4&gt;&#123;&#123;data.headline&#125;&#125;&lt;/h4&gt; &#123;&#123;data.body&#125;&#125; &lt;/div&gt; `&#125;)export class HeroJobAdComponent implements AdComponent &#123; @Input() data: any; &#125; 최종 배너 광고최종 배너 광고는 다음과 같습니다. 이 내용은 나중에 참고하기 위해 제가 공부하며 정리한 내용입니다.의역, 오역, 직역이 있을 수 있음을 알려드립니다.This post is a translation of this original article [https://angular.io/guide/dynamic-component-loader] 참고 Angular 튜토리얼 - 소개 Angular 튜터리얼 - Hero 에디터 Angular 튜터리얼 - Master/Detail Angular 튜터리얼 - 다중 콤포넌트 Angular 튜터리얼 - 서비스 Angular 튜터리얼 - 라우팅 Angular 튜터리얼 - HTTP Angular HttpClient Angular Webpack 설정 Angular에서 간단하게 번역기능 구현하기 Angular 동적 컴포넌트 로딩 Angular에서 동적 컨텐츠 생성 Angular에서 ViewChildren, ContentChildren, 그리고 QueryList 이해하기","categories":[{"name":"Angular","slug":"Angular","permalink":"http://infoscis.github.io/categories/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://infoscis.github.io/tags/Angular/"}]},{"title":"Angular HttpClient","slug":"angular-http-client","date":"2017-07-21T13:41:00.000Z","updated":"2018-01-27T15:19:30.445Z","comments":true,"path":"2017/07/21/angular-http-client/","link":"","permalink":"http://infoscis.github.io/2017/07/21/angular-http-client/","excerpt":"","text":"HttpClient대부분의 프런트 엔드 응용 프로그램은 HTTP 프로토콜을 통해 백엔드 서비스와 통신합니다. 최신 브라우저는 HTTP 요청을하기 위해 XMLHttpRequest 인터페이스와 fetch() API의 두 가지 API를 지원합니다. @angular/common/http의 HttpClient를 사용하면 브라우저에서 공개되는 XMLHttpRequest 인터페이스 위에 구축된 Angular 응용 프로그램에서 사용할 수 있도록 HTTP 기능에 대한 간단한 API를 제공합니다. HttpClient의 추가 이점으로는 테스트 가능성 지원, 요청 및 응답 객체의 강력한 입력, 요청 및 응답 인터셉터 지원, Observables를 기반으로 한 api를 통한 더 나은 오류 처리가 있습니다. Setup: installing the moduleHttpClient를 사용하려면 먼저 HttpClient를 제공하는 HttpClientModule을 설치해야합니다. 이것은 응용 프로그램 모듈에서 수행할 수 있으며 한번만 필요합니다. 1234567891011121314151617// app.module.ts: import &#123;NgModule&#125; from '@angular/core';import &#123;BrowserModule&#125; from '@angular/platform-browser'; // Import HttpClientModule from @angular/common/httpimport &#123;HttpClientModule&#125; from '@angular/common/http'; @NgModule(&#123; imports: [ BrowserModule, // Include it under 'imports' in your application module // after BrowserModule. HttpClientModule, ],&#125;)export class MyAppModule &#123;&#125; HttpClientModule을 앱 모듈로 import하면 HttpClient를 Component 및 Service에 삽입할 수 있습니다. Making a request for JSON data백엔드에서 가장 많이 요구되는 요청 애플리케이션은 JSON 데이터를 요청하는 것이다. 예를 들어 다음과 같은 형식의 JSON 객체를 반환하는 /api/items 항목을 나열하는 API가 있다고 가정합니다. 123456&#123; \"results\": [ \"Item 1\", \"Item 2\", ]&#125; HttpClient에서 get() 메서드를 사용하면 이 데이터에 간단하게 액세스할 수 있습니다. 12345678910111213141516@Component(...)export class MyComponent implements OnInit &#123; results: string[]; // Inject HttpClient into your component or service. constructor(private http: HttpClient) &#123;&#125; ngOnInit(): void &#123; // Make the HTTP request: this.http.get('/api/items').subscribe(data =&gt; &#123; // Read the result field from the JSON response. this.results = data['results']; &#125;); &#125;&#125; Typechecking the response위의 예에서 괄호를 사용하여 결과 필드에 액세스하기 때문에 data[&#39;results&#39;] 필드 액세스가 두드러집니다. data.results를 작성하려고 시도하면 TypeScript는 HTTP에서 돌아 오는 Object에 results 속성이 없음을 올바르게 알립니다. HttpClient가 JSON 응답을 Object로 파싱하는 동안 그 객체가 어떤 모양인지 모르기 때문입니다. 그러나 HttpClient에 응답 유형이 무엇인지 알려 줄 수 있습니다. 이는 권장 사항입니다. 이렇게하려면 먼저 올바른 모양으로 Interface를 정의하십시오. 123interface ItemsResponse &#123; results: string[];&#125; 그런 다음 HttpClient.get 호출할 때 타입 파라미터를 전달하십시오. 1234http.get&lt;ItemsResponse&gt;('/api/items').subscribe(data =&gt; &#123; // data is now an instance of type ItemsResponse, so you can do this: this.results = data.results;&#125;); Reading the full response응답 본문은 필요한 모든 데이터를 반환하지 않습니다. 경우에 따라 서버는 특정 조건을 나타내는 특수 헤더나 상태 코드를 반환하고 필요할 때 검사할 수 있어야 합니다. 이렇게 하려면 observe 옵션을 이용하여 Body 대신 전체 응답을 원한다고 HttpClient에 알릴 수 있습니다. 123456789http .get&lt;MyJsonData&gt;('/data.json', &#123;observe: 'response'&#125;) .subscribe(resp =&gt; &#123; // Here, resp is of type HttpResponse&lt;MyJsonData&gt;. // You can inspect its headers: console.log(resp.headers.get('X-Custom-Header')); // And access the body directly, which is typed as MyJsonData as requested. console.log(resp.body.someField); &#125;); 보시다시피 결과 객체에는 올바른 유형의 body 프로퍼티가 있습니다. Error handling서버에서 요청이 실패하거나 네트워크 연결이 좋지 않아 서버에 도달하지 못하면 어떻게될까요? HttpClient는 성공적인 응답 대신 오류를 반환합니다. 이를 처리하려면 .subscribe() 호출에 오류 핸들러를 추가합니다. 12345678910http .get&lt;ItemsResponse&gt;('/api/items') .subscribe( // Successful responses call the first callback. data =&gt; &#123;...&#125;, // Errors will call this callback instead: err =&gt; &#123; console.log('Something went wrong!'); &#125; &#125;); Getting error details오류가 발생했음을 감지하는 것이 중요하지만 실제로 발생한 오류를 확인하는 것이 더 유용할 수 있습니다. 위의 콜백에 대한 err 파라미터는 HttpErrorResponse 타입이고, 무엇이 잘못되었는지에 대한 유용한 정보를 담고 있습니다. 발생할 수 있는 두 가지 유형의 오류가 있습니다. 백엔드가 실패한 응답 코드(404, 500 등)를 반환하면 오류로 반환됩니다. 또한 RxJS 연산자에서 예외가 발생하거나 네트워크 오류로 인해 요청이 성공적으로 완료되지 못하는 경우등 클라이언트 측에서 잘못된 것이 발생하면 실제 Error가 발생됩니다. 두 경우 모두 HttpErrorResponse를 보고 무슨 일이 일어 났는지 확인할 수 있습니다. 123456789101112131415http .get&lt;ItemsResponse&gt;('/api/items') .subscribe( data =&gt; &#123;...&#125;, (err: HttpErrorResponse) =&gt; &#123; if (err.error instanceof Error) &#123; // A client-side or network error occurred. Handle it accordingly. console.log('An error occurred:', err.error.message); &#125; else &#123; // The backend returned an unsuccessful response code. // The response body may contain clues as to what went wrong, console.log(`Backend returned code $&#123;err.status&#125;, body was: $&#123;err.error&#125;`); &#125; &#125; &#125;); .retry()오류를 처리하는 한 가지 방법은 단순히 요청을 다시 시도하는 것입니다. 이 전략은 오류가 일시적이고 반복 가능성이 없는 경우에 유용할 수 있습니다. RxJS는 Observable에 자동으로 다시 Subscribe하여, 오류가 발생하면 요청을 다시 발생시키는 .retry()라는 유용한 연산자가 있습니다. 먼저 import 하기 : 1import 'rxjs/add/operator/retry'; 그러면 다음과 같이 HTTP Observable과 함께 사용할 수 있습니다. 123456http .get&lt;ItemsResponse&gt;('/api/items') // Retry this request up to 3 times. .retry(3) // Any errors after the 3rd retry will fall through to the app. .subscribe(...); Requesting non-JSON data모든 API가 JSON 데이터를 반환하지는 않습니다. 서버에서 텍스트 파일을 읽으려 한다고 가정하십시오. 텍스트 응답을 기대한다고 HttpClient에 알려야합니다. 123456http .get('/textfile.txt', &#123;responseType: 'text'&#125;) // The Observable returned by get() is of type Observable&lt;string&gt; // because a text response was specified. There's no need to pass // a &lt;string&gt; type parameter to get(). .subscribe(data =&gt; console.log(data)); Sending data to the serverHttpClient는 서버에서 데이터를 가져 오는것 외에도 여러 가지 형태로 서버에 데이터를 전송하는 요청을 지원합니다. Making a POST request하나의 공통된 작업은 예를 들어 Form을 제출할 때 서버에 데이터를 POST하는 것입니다. POST 요청을 보내는 코드는 GET 코드와 매우 유사합니다. 123456const body = &#123;name: 'Brad'&#125;;http .post('/api/developers/add', body) // See below - subscribe() is still necessary when using post(). .subscribe(...); subscribe() 메서드에 유의하십시오. HttpClient에서 반환된 모든 Observable은 콜드(cold)입니다. 즉 요청을 하기위한 blueprint입니다. subscribe()를 호출할 때까지 아무 일도 일어나지 않으며 모든 호출이 별도의 요청을 합니다. 예를 들어, 아래 코드는 동일한 데이터가 있는 POST 요청을 두 번 보냅니다. 123456const req = http.post('/api/items/add', body);// 0 requests made - .subscribe() not called.req.subscribe();// 1 request made.req.subscribe();// 2 requests made. Configuring other parts of the requestURL과 요청 가능한 본문 외에도 구성하려는 요청의 다른 측면이 있습니다. 이 모든 것은 요청에 전달하는 옵션 객체를 통해 사용할 수 있습니다. Headers일반적인 작업중 하나는 나가는 요청에 Authorization 헤더를 추가하는 것입니다. 방법은 다음과 같습니다. 12345http .post('/api/items/add', body, &#123; headers: new HttpHeaders().set('Authorization', 'my-auth-token'), &#125;) .subscribe(); HttpHeaders 클래스는 변경 불가능하므로 모든 set()은 새로운 인스턴스를 반환하고 변경 사항을 적용합니다. URL ParametersURL 파라미터를 추가하는 방법도 동일합니다. id 파라미터가 3으로 설정된 요청을 보내려면 다음을 수행합니다. 12345http .post('/api/items/add', body, &#123; params: new HttpParams().set('id', '3'), &#125;) .subscribe(); 이 방법으로 POST 요청을 /api/items/add?id=3 URL로 보냅니다. Advanced usage위의 섹션에서는 @angular/common/http의 기본 HTTP 기능을 사용하는 방법을 자세히 설명했지만 때로는 요청을 만들고 데이터를 다시 가져 오는것 이상을 수행해야합니다. Intercepting all requests or responses@angular/common/http의 주요 기능은 응용 프로그램과 백엔드 사이에 있는 인터셉터를 선언할 수있는 Interception 기능입니다. 응용 프로그램이 요청을 하면 인터셉터는 서버로 보내기 전에 이를 변환하고 인터셉터는 응용 프로그램이 보기 전에 응답을 변환합니다. 이것은 인증에서 로깅에 이르기까지 모든 경우에 유용합니다. Writing an interceptor인터셉터를 구현하려면 intercept() 메소드 하나가 있는 HttpInterceptor Interface를 구현하는 클래스를 선언해야 합니다. 다음은 아무것도 하지 않고 요청을 변경하지 않고 그대로 전달하는 간단한 인터셉터입니다. 123456789import &#123;Injectable&#125; from '@angular/core';import &#123;HttpEvent, HttpInterceptor, HttpHandler, HttpRequest&#125; from '@angular/common/http';@Injectable()export class NoopInterceptor implements HttpInterceptor &#123; intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; &#123; return next.handle(req); &#125;&#125; intercept는 요청을 Observable로 변환하여 response를 반환하는 메소드입니다. 이러한 의미에서 각 인터셉터는 전적으로 자체적으로 요청을 처리해야합니다. 대부분의 경우, 인터셉터는 요청에 약간의 변경을 가하여 체인의 나머지 부분으로 전달합니다. next 파라미터가 오는 곳입니다. next는 intercept와 비슷한 인터페이스인 HttpHandler입니다. 요청 응답을 위해 Observable로 변환합니다. 인터셉터에서 next는 항상 체인의 다음 인터셉터를 나타내며, 더 이상 인터셉터가 없는 경우 최종 백엔드를 나타냅니다. 그래서 대부분의 인터셉터들은 그들이 요청을 변형시키고 next를 호출함으로써 끝납니다. 우리의 do-nothing 핸들러는 단순히 원래 요청에서 next.handle을 호출하여 요청을 전혀 변경하지 않고 전달합니다. 이 패턴은 Express.js와 같은 미들웨어 프레임 워크의 패턴과 유사합니다. Providing your interceptor단순히 위의 NoopInterceptor를 선언한다고 해서 인터셉터를 앱에서 사용하지는 않습니다. 다음과 같이 인터셉터를 제공하여 앱 모듈에 연결해야합니다. 1234567891011import &#123;NgModule&#125; from '@angular/core';import &#123;HTTP_INTERCEPTORS&#125; from '@angular/common/http';@NgModule(&#123; providers: [&#123; provide: HTTP_INTERCEPTORS, useClass: NoopInterceptor, multi: true, &#125;],&#125;)export class AppModule &#123;&#125; multi: true 옵션에 유의하십시오. 이것은 필수이며 Angular에 HTTP_INTERCEPTORS가 단일 값이 아닌 값의 배열임을 알려줍니다. Eventsintercept와 HttpHandler.handle에 의해 반환된 Observable이 Observable&lt;HttpResponse&lt;any &gt;&gt;가 아니라 Observable &lt;HttpEvent&lt;any&gt;&gt;라는 것을 알았을 수도 있습니다. 이는 인터셉터가 HttpClient 인터페이스보다 낮은 수준에서 작동하기 때문입니다. 단일 요청은 업로드 및 다운로드 진행 이벤트를 포함하여 여러 이벤트를 생성할 수 있습니다. HttpResponse 클래스는 실제로는 HttpEventType.HttpResponseEvent 타입의 이벤트 자체입니다. 인터셉터는 이해하지 못하거나 수정하려는 모든 이벤트를 통과 시켜야합니다. 처리할 것으로 예상되지 않은 이벤트를 필터링해서는 안됩니다. 많은 인터셉터는 나가는 요청에 대해서만 관심이 있으며, 단순히 next에서 이벤트 스트림을 수정하지 않고 반환합니다. Ordering응용 프로그램에서 여러 개의 인터셉터를 제공하면 Angular는 사용자가 제공한 순서대로 적용합니다. Immutability인터셉터는 나가는 요청과 들어오는 응답을 검사하고 변경합니다. 그러나 HttpRequest 및 HttpResponse 클래스가 대부분 변경 불가능하다는 사실을 알면 놀랄 수 있습니다. 이유는 앱이 요청을 다시 시도할 수 있고 인터셉터 체인이 개별 요청을 여러번 처리할 수 있기 때문입니다. 요청이 변경 가능하면 다시 시도한 요청은 원래 요청과 다를 수 있습니다. Immutability는 인터셉터가 각 시도에 대해 동일한 요청을 볼 수 있도록합니다. 인터셉터(request body)를 작성할 때 타입 안전성으로 보호할 수없는 경우가 있습니다. 인터셉터 내에서 요청 본문을 변경하는 것은 유효하지 않고, 타입 시스템에 의해 검증되지 않습니다. 요청 본문을 변경해야하는 경우 본문을 copy하고 copy본을 변경한 다음 clone()을 사용하여 요청을 복사하고 새로운 본문을 설정해야합니다. 요청은 변경 불가능하기 때문에 직접 수정할 수 없습니다. 이들을 변경 시키려면 clone()을 사용하십시오. 1234567intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpError&lt;any&gt;&gt; &#123; // This is a duplicate. It is exactly the same as the original. const dupReq = req.clone(); // Change the URL and replace 'http://' with 'https://' const secureReq = req.clone(&#123;url: req.url.replace('http://', 'https://')&#125;);&#125; 보시다시피,clone()을 사용하면 요청의 특정 프로퍼티를 변경하면서 다른 내용을 복사할 수 있습니다. Setting new headers인터셉터의 일반적인 사용은 나가는 요청에 기본 헤더를 설정하는 것입니다. 예를 들어, 인증 토큰을 제공할 수있는 AuthService가 있다고 가정하면 다음과 같이 모든 나가는 요청에 인터셉터를 추가하는 방법이 있습니다. 12345678910111213141516import &#123;Injectable&#125; from '@angular/core';import &#123;HttpEvent, HttpInterceptor, HttpHandler, HttpRequest&#125; from '@angular/common/http'; @Injectable()export class AuthInterceptor implements HttpInterceptor &#123; constructor(private auth: AuthService) &#123;&#125; intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; &#123; // Get the auth header from the service. const authHeader = this.auth.getAuthorizationHeader(); // Clone the request to add the new header. const authReq = req.clone(&#123;headers: req.headers.set('Authorization', authHeader)&#125;); // Pass on the cloned request instead of the original request. return next.handle(authReq); &#125;&#125; 새로운 헤더를 설정하기위해 요청을 복제하는 관행은 너무 일반적이어서 실제적인 단축키가 있습니다. 1const authReq = req.clone(&#123;setHeaders: &#123;Authorization: authHeader&#125;&#125;); 헤더를 변경하는 인터셉터는 다음을 포함하여 여러 가지 다른 작업에 사용할 수 있습니다. Authentication/authorization Caching behavior; for example, If-Modified-Since XSRF protection Logging인터셉터는 요청과 응답을 함께 처리할 수 있기 때문에 로그 또는 요청 소요 시간 확인과 같은 작업을 수행할 수 있습니다. console.log를 사용하여 각 요청의 소요 시간을 보여주는 이 인터셉터를 생각해볼 수 있습니다. 1234567891011121314151617import 'rxjs/add/operator/do'; export class TimingInterceptor implements HttpInterceptor &#123; constructor(private auth: AuthService) &#123;&#125; intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; &#123; const started = Date.now(); return next .handle(req) .do(event =&gt; &#123; if (event instanceof HttpResponse) &#123; const elapsed = Date.now() - started; console.log(`Request for $&#123;req.urlWithParams&#125; took $&#123;elapsed&#125; ms.`); &#125; &#125;); &#125;&#125; RxJS do() 연산자는 스트림의 값에 영향을 주지 않으면서 Observable에 추가작업을 추가합니다. 여기서는 HttpResponse 이벤트를 감지하고 요청이 발생한 시간을 기록합니다. Caching인터셉터를 사용하여 캐싱을 구현할 수도 있습니다. 이 예제에서는 간단한 인터페이스로 HTTP 캐시를 작성했다고 가정합니다. 1234567891011abstract class HttpCache &#123; /** * Returns a cached response, if any, or null if not present. */ abstract get(req: HttpRequest&lt;any&gt;): HttpResponse&lt;any&gt;|null; /** * Adds or updates the response in the cache. */ abstract put(req: HttpRequest&lt;any&gt;, resp: HttpResponse&lt;any&gt;): void;&#125; 인터셉터는 나가는 요청에 이 캐시를 적용할 수 있습니다. 123456789101112131415161718192021222324252627282930@Injectable()export class CachingInterceptor implements HttpInterceptor &#123; constructor(private cache: HttpCache) &#123;&#125; intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; &#123; // Before doing anything, it's important to only cache GET requests. // Skip this interceptor if the request method isn't GET. if (req.method !== 'GET') &#123; return next.handle(req); &#125; // First, check the cache to see if this request exists. const cachedResponse = this.cache.get(req); if (cachedResponse) &#123; // A cached response exists. Serve it instead of forwarding // the request to the next handler. return Observable.of(cachedResponse); &#125; // No cached response exists. Go to the network, and cache // the response when it arrives. return next.handle(req).do(event =&gt; &#123; // Remember, there may be other events besides just the response. if (event instanceof HttpResponse) &#123; // Update the cache. this.cache.put(req, event); &#125; &#125;); &#125;&#125; 이 예제는 요청의 일치, 캐시 무효화 등을 설명하지만 인터셉터는 요청을 변형하는것 이상의 많은 힘을 가지고 있음을 쉽게 볼 수 있습니다. 원하는 경우 요청 흐름을 완전히 변경하는데 사용할 수 있습니다. 실제로 위의 예제를 변경하여 캐시에 요청이있는 경우 두 개의 응답 이벤트 (캐시된 응답 먼저)와 업데이트된 네트워크 응답을 나중에 반환할 수 있습니다. 1234567891011121314151617181920212223242526272829intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; &#123; // Still skip non-GET requests. if (req.method !== 'GET') &#123; return next.handle(req); &#125; // This will be an Observable of the cached value if there is one, // or an empty Observable otherwise. It starts out empty. let maybeCachedResponse: Observable&lt;HttpEvent&lt;any&gt;&gt; = Observable.empty(); // Check the cache. const cachedResponse = this.cache.get(req); if (cachedResponse) &#123; maybeCachedResponse = Observable.of(cachedResponse); &#125; // Create an Observable (but don't subscribe) that represents making // the network request and caching the value. const networkResponse = next.handle(req).do(event =&gt; &#123; // Just like before, check for the HttpResponse event and cache it. if (event instanceof HttpResponse) &#123; this.cache.put(req, event); &#125; &#125;); // Now, combine the two and send the cached response first (if there is // one), and the network response second. return Observable.concat(maybeCachedResponse, networkResponse);&#125; 이제 http.get(url)을 수행하면 이전에 해당 URL이 캐시된 경우 두 개의 응답을 받게됩니다. Listening to progress events때때로 응용 프로그램은 많은 양의 데이터를 전송 해야하며 이러한 전송에는 시간이 걸릴 수 있습니다. 이러한 전송 진행 상황에 대한 피드백을 제공하는 것은 좋은 사용자 경험입니다. (예를 들어, 파일 업로드 - @angular/common/http는 이를 지원합니다.) 진행 이벤트를 사용하도록 요청하려면 먼저 특수한 reportProgress 옵션 집합을 사용하여 HttpRequest의 인스턴스를 만듭니다. 123const req = new HttpRequest('POST', '/upload/file', file, &#123; reportProgress: true,&#125;); 이 옵션을 사용하면 진행 이벤트를 추적할 수 있습니다. 각 진행 상황 이벤트는 변경 감지를 트리거하므로 실제로 각 이벤트에서 UI를 업데이트하려는 경우에만 진행 상태를 설정하십시오. 그런 다음 HttpClient의 request() 메소드를 통해 요청하십시오. 결과는 인터셉터와 마찬가지로 Observable 이벤트가 됩니다. 1234567891011http.request(req).subscribe(event =&gt; &#123; // Via this API, you get access to the raw event stream. // Look for upload progress events. if (event.type === HttpEventType.UploadProgress) &#123; // This is an upload progress event. Compute and show the % done: const percentDone = Math.round(100 * event.loaded / event.total); console.log(`File is $&#123;percentDone&#125;% uploaded.`); &#125; else if (event instanceof HttpResponse) &#123; console.log('File is completely uploaded!'); &#125;&#125;); Security: XSRF ProtectionCross-Site Request Forgery(CSRF)는 공격자가 인증된 사용자를 속여서 웹 사이트에서 무의식적으로 실행하는 공격 기법입니다. HttpClient는 XSRF 공격을 막는데 사용되는 일반적인 메커니즘을 지원합니다. HTTP 요청을 수행할 때 인터셉터는 쿠키에서 토큰 (기본적으로 XSRF-TOKEN)을 읽고 HTTP 헤더인 X-XSRF-TOKEN으로 설정합니다. 도메인에서 실행되는 코드만 쿠키를 읽을 수 있기 때문에 백엔드는 HTTP 요청이 공격자가 아닌 클라이언트 응용 프로그램에서 온 것임을 확신할 수 있습니다. 기본적으로 인터셉터는 모든 변경 요청 (POST 등)에 대해 이 쿠키를 상대 URL로 보내지만 GET/HEAD 요청이나 절대 URL이 있는 요청에는 보내지 않습니다. 이 기능을 이용하려면 서버가 페이지 로드 또는 첫 번째 GET 요청에서 XSRF-TOKEN이라는 JavaScript로 읽을 수있는 세션 쿠키로 토큰을 설정해야합니다. 후속 요청에서 서버는 쿠키가 X-XSRF-TOKEN HTTP 헤더와 일치하는지 확인할 수 있으므로 도메인에서 실행중인 코드만 요청을 보낼 수 있는지 확인합니다. 토큰은 각 사용자마다 고유해야하며 서버에서 확인할 수 있어야합니다. 이것은 클라이언트가 자신의 토큰을 만들지 못하게합니다. 토큰의 보안 강화를 위해 salt로 사이트 인증 쿠키 다이제스트로 설정하십시오. 여러 Angular 응용 프로그램이 동일한 도메인 또는 하위 도메인을 공유하는 환경에서 충돌을 방지하려면 각 응용 프로그램에 고유한 쿠키 이름을 지정하십시오. HttpClient의 지원은 XSRF 보호 체계의 클라이언트 절반에 불과합니다. 백엔드 서비스는 페이지의 쿠키를 설정하고 헤더가 모든 적합한 요청에 존재하는지 확인하도록 구성되어야합니다. 그렇지 않은 경우 Angular의 기본 보호가 효과적이지 않습니다. Configuring custom cookie/header names백엔드 서비스가 XSRF 토큰 쿠키 또는 헤더에 다른 이름을 사용하는 경우 HttpClientXsrfModule.withConfig()를 사용하여 기본값을 대체하십시오. 1234567imports: [ HttpClientModule, HttpClientXsrfModule.withConfig(&#123; cookieName: 'My-Xsrf-Cookie', headerName: 'My-Xsrf-Header', &#125;),] Testing HTTP requests외부 의존성과 마찬가지로, HTTP 백엔드는 좋은 테스트 관행의 일부로 Mock를 제공 해야합니다. @angular/common/http는 Mocking을 직접 설정하는 테스트 라이브러리 @angular/common/http/testing을 제공합니다. Mocking philosophyAngular의 HTTP 테스트 라이브러리는 앱이 코드를 실행하고 요청을 수행하는 테스트 패턴을 위해 설계되었습니다. 그 후, 테스트는 특정 요청이 있었는지 여부를 예상하고, 각 요청을 “플러시”하여 최종적으로 응답을 제공함으로써 더 많은 새로운 요청을 트리거할 수 있습니다. 결국 테스트는 앱이 예기치 않은 요청을 하지 않았음을 선택적으로 확인할 수 있습니다. SetupHttpClient를 통해 만들어진 요청을 테스트하려면 HttpClientTestingModule을 가져 와서 TestBed 설정에 추가하십시오. 12345678910import &#123;HttpClientTestingModule&#125; from '@angular/common/http/testing';beforeEach(() =&gt; &#123; TestBed.configureTestingModule(&#123; ..., imports: [ HttpClientTestingModule, ], &#125;)&#125;); 이게 전부입니다. 이제 테스트 과정의 요청은 정상 백엔드가 아닌 테스트 백엔드를 사용합니다. Expecting and answering requests모듈을 통해 Mock이 설치된 상태에서 GET 요청이 발생할 것으로 예상되는 테스트를 작성하여 Mock 응답을 제공할 수 있습니다. 다음 예제는 HttpClient를 테스트와 HttpTestingController라는 클래스에 모두 주입하여 수행합니다. 123456789101112131415161718192021222324it('expects a GET request', inject([HttpClient, HttpTestingController], (http: HttpClient, httpMock: HttpTestingController) =&gt; &#123; // Make an HTTP GET request, and expect that it return an object // of the form &#123;name: 'Test Data'&#125;. http .get('/data') .subscribe(data =&gt; expect(data['name']).toEqual('Test Data')); // At this point, the request is pending, and no response has been // sent. The next step is to expect that the request happened. const req = httpMock.expectOne('/data'); // If no request with that URL was made, or if multiple requests match, // expectOne() would throw. However this test makes only one request to // this URL, so it will match and return a mock request. The mock request // can be used to deliver a response or make assertions against the // request. In this case, the test asserts that the request is a GET. expect(req.request.method).toEqual('GET'); // Next, fulfill the request by transmitting a response. req.flush(&#123;name: 'Test Data'&#125;); // Finally, assert that there are no outstanding requests. httpMock.verify();&#125;)); 마지막 단계는 아직 해결되지 않은 요청이 남아 있지 않음을 확인하는 것입니다. 이것은 afterEach()로 충분합니다. 123afterEach(inject([HttpTestingController], (httpMock: HttpTestingController) =&gt; &#123; httpMock.verify();&#125;)); Custom request expectationsURL 일치로 충분하지 않으면 자체적으로 일치 기능을 구현할 수 있습니다. 예를 들어 Authorization 헤더가있는 발신 요청을 찾을 수 있습니다. 1const req = httpMock.expectOne((req) =&gt; req.headers.has('Authorization')); 위의 테스트에서 URL 별 expectOne()과 마찬가지로 0 또는 2개 이상의 요청이 이 예측과 일치하면 throw됩니다. Handling more than one request테스트에서 중복 요청에 응답해야하는 경우 expectOne() 대신 match() API를 사용할 수 있습니다. 이 메서드는 동일한 파라미터를 사용하지만 일치하는 요청의 배열을 반환합니다. 반환된 이러한 요청은 향후 검색에서 제거되며 확인하고 플러시할 책임이 있습니다. 1234// Expect that 5 pings have been made and flush them.const reqs = httpMock.match('/ping');expect(reqs.length).toBe(5);reqs.forEach(req =&gt; req.flush()); 이 내용은 나중에 참고하기 위해 제가 공부하며 정리한 내용입니다.의역, 오역, 직역이 있을 수 있음을 알려드립니다.This post is a translation of this original article [https://angular.io/guide/http] 참고 Angular 튜토리얼 - 소개 Angular 튜터리얼 - Hero 에디터 Angular 튜터리얼 - Master/Detail Angular 튜터리얼 - 다중 콤포넌트 Angular 튜터리얼 - 서비스 Angular 튜터리얼 - 라우팅 Angular 튜터리얼 - HTTP Angular HttpClient Angular 동적 컴포넌트 로딩","categories":[{"name":"Angular","slug":"Angular","permalink":"http://infoscis.github.io/categories/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://infoscis.github.io/tags/Angular/"}]},{"title":"Angular 튜터리얼 - HTTP","slug":"angular-tutorial-http","date":"2017-07-21T13:27:53.000Z","updated":"2018-01-27T15:19:28.905Z","comments":true,"path":"2017/07/21/angular-tutorial-http/","link":"","permalink":"http://infoscis.github.io/2017/07/21/angular-tutorial-http/","excerpt":"","text":"HTTP이 페이지에서 다음과 같이 개선할 것입니다. 서버에서 Hero 데이터를 가져옵니다. 사용자가 Hero 이름을 추가, 편집 및 삭제할 수 있습니다. 변경 사항을 서버에 저장합니다. 원격 서버의 웹 API에 해당 HTTP 호출을 하도록 앱을 수정합니다. 이 페이지를 끝내면 앱은이 라이브 예제/예제 다운로드처럼 보일 것입니다. 어디까지 했었나?이전 페이지에서는 대시 보드와 고정된 Hero들 목록을 Navigate하면서 선택한 Hero를 편집하는 방법을 배웠습니다. 그것이 이 페이지의 출발점입니다. 앱 실행과 트랜스파일을 유지하기터미널 창에서 다음 명령을 입력합니다. 1npm start 이 명령은 TypeScript 컴파일러를 “watch mode”에서 실행하여 코드가 변경되면 자동으로 다시 컴파일 하도록합니다. 또한 이 명령은 앱이 브라우저에서 동시에 실행되고 코드가 변경되면 브라우저를 새로 고칩니다. 다시 컴파일하거나 새로 고치지 않고 브라우저를 일시 정지하지 않아 Tour of Heroes 앱을 계속 만들 수 있습니다. HTTP Service 지원하기HttpModule은 Angular core 모듈이 아닙니다. HttpModule은 웹 접근에 대한 Angular의 선택적인 접근 방식입니다. 이것은 @angular/http라고 하는 별도의 애드온 모듈로 존재하며 Angular npm 패키지의 일부로 별도의 스크립트 파일로 제공됩니다. SystemJS가 필요할 때 라이브러리를 로드하기 위해 systemjs.config에서 설정 했으므로 @angular/http를 import할 준비가되었습니다. HTTP Service 등록응용 프로그램은 Angular http서비스에 따라 달라지며, 그 자체는 다른 Service의 지원에 의존합니다. @angular/http 라이브러리의 HttpModule은 완전한 HTTP 서비스 집합을 제공합니다. 앱의 어느 곳에서나 http 서비스에 접근할 수 있게하려면 AppModule의 import 목록에 HttpModule을 추가합니다. src/app/app.module.ts (v1)123456789101112131415161718192021222324252627282930import &#123; NgModule &#125; from '@angular/core';import &#123; BrowserModule &#125; from '@angular/platform-browser';import &#123; FormsModule &#125; from '@angular/forms';import &#123; HttpModule &#125; from '@angular/http'; import &#123; AppRoutingModule &#125; from './app-routing.module'; import &#123; AppComponent &#125; from './app.component';import &#123; DashboardComponent &#125; from './dashboard.component';import &#123; HeroesComponent &#125; from './heroes.component';import &#123; HeroDetailComponent &#125; from './hero-detail.component';import &#123; HeroService &#125; from './hero.service'; @NgModule(&#123; imports: [ BrowserModule, FormsModule, HttpModule, AppRoutingModule ], declarations: [ AppComponent, DashboardComponent, HeroDetailComponent, HeroesComponent, ], providers: [ HeroService ], bootstrap: [ AppComponent ]&#125;)export class AppModule &#123; &#125; 루트 NgModule AppModule에서 imports 배열의 일부로 HttpModule을 제공합니다. Web API 시뮬래이트우리는 루트AppModule의 providers에 app-wide 서비스를 등록할 것을 권장합니다. Heroes 데이터에 대한 요청을 처리할 수있는 웹 서버가 있을 때까지 HTTP 클라이언트는 Mock Service인 in-memory 웹 API에서 데이터를 가져오고 저장합니다. src/app/app.module.ts을 Mock 서비스 사용하는 이 버전으로 업데이트합니다. src/app/app.module.ts (v2) 1234567891011121314151617181920212223242526272829303132333435import &#123; NgModule &#125; from '@angular/core';import &#123; BrowserModule &#125; from '@angular/platform-browser';import &#123; FormsModule &#125; from '@angular/forms';import &#123; HttpModule &#125; from '@angular/http'; import &#123; AppRoutingModule &#125; from './app-routing.module'; // Imports for loading &amp; configuring the in-memory web apiimport &#123; InMemoryWebApiModule &#125; from 'angular-in-memory-web-api';import &#123; InMemoryDataService &#125; from './in-memory-data.service'; import &#123; AppComponent &#125; from './app.component';import &#123; DashboardComponent &#125; from './dashboard.component';import &#123; HeroesComponent &#125; from './heroes.component';import &#123; HeroDetailComponent &#125; from './hero-detail.component';import &#123; HeroService &#125; from './hero.service'; @NgModule(&#123; imports: [ BrowserModule, FormsModule, HttpModule, InMemoryWebApiModule.forRoot(InMemoryDataService), AppRoutingModule ], declarations: [ AppComponent, DashboardComponent, HeroDetailComponent, HeroesComponent, ], providers: [ HeroService ], bootstrap: [ AppComponent ]&#125;)export class AppModule &#123; &#125; 실제 API 서버를 요구하는 대신,이 예제는 InMemoryWebApiModule을 import에 추가함으로써 원격 서버와의 통신을 시뮬레이트하고, Http 클라이언트의 XHR 백엔드 서비스를 메모리 내에서 효과적으로 대체합니다. 1InMemoryWebApiModule.forRoot(InMemoryDataService), forRoot() 설정 메서드는 in-memory 데이터베이스를 준비하는 InMemoryDataService 클래스를 사용합니다. 다음과 같은 내용으로 app에 in-memory-data.service.ts 파일을 추가합니다. src/app/in-memory-data.service.ts12345678910111213141516171819import &#123; InMemoryDbService &#125; from 'angular-in-memory-web-api';export class InMemoryDataService implements InMemoryDbService &#123; createDb() &#123; const heroes = [ &#123; id: 0, name: 'Zero' &#125;, &#123; id: 11, name: 'Mr. Nice' &#125;, &#123; id: 12, name: 'Narco' &#125;, &#123; id: 13, name: 'Bombasto' &#125;, &#123; id: 14, name: 'Celeritas' &#125;, &#123; id: 15, name: 'Magneta' &#125;, &#123; id: 16, name: 'RubberMan' &#125;, &#123; id: 17, name: 'Dynama' &#125;, &#123; id: 18, name: 'Dr IQ' &#125;, &#123; id: 19, name: 'Magma' &#125;, &#123; id: 20, name: 'Tornado' &#125; ]; return &#123;heroes&#125;; &#125;&#125; 이 파일은 mock-heroes.ts를 대체합니다. 이제는 mock-heroes.ts 파일을 삭제해도 안전합니다. Hero “Zero”를 추가하여 데이터 서비스가 id == 0인 Hero를 처리할 수 있음을 확인했습니다. in-memory 웹 API는 개발 초기와 이 Tour of Heroes와 같이 시연에서 유용합니다. 이 백엔드 대체에 대한 세부 사항은 걱정하지 마십시오. 실제 웹 API 서버를 가지고있을 때 건너 뛸 수 있습니다.in-memory 웹 API에 대한 자세한 내용은 HTTP Client 페이지의 Appendix: Tour of Heroes in-memory web api 섹션을 참조하십시오. Hero들과 HTTP현재 HeroService 구현에서는 Mock Heroes가 Resolved Promise를 반환합니다. src/app/hero.service.ts (old getHeroes)123getHeroes(): Promise&lt;Hero[]&gt; &#123; return Promise.resolve(HEROES);&#125; 이것은 궁극적으로 비동기 작업이어야하는 HTTP 클라이언트로 Heroes를 가져 오는 것을 예상하여 구현되었습니다. 이제 HTTP를 사용하도록 getHeroes()를 변환합니다. src/app/hero.service.ts (updated getHeroes and new class members)123456789101112131415private heroesUrl = 'api/heroes'; // URL to web api constructor(private http: Http) &#123; &#125; getHeroes(): Promise&lt;Hero[]&gt; &#123; return this.http.get(this.heroesUrl) .toPromise() .then(response =&gt; response.json().data as Hero[]) .catch(this.handleError);&#125; private handleError(error: any): Promise&lt;any&gt; &#123; console.error('An error occurred', error); // for demo purposes only return Promise.reject(error.message || error);&#125; 다음과 같이 import 문을 업데이트하십시오. src/app/hero.service.ts (updated imports) 123456import &#123; Injectable &#125; from '@angular/core';import &#123; Headers, Http &#125; from '@angular/http';import 'rxjs/add/operator/toPromise';import &#123; Hero &#125; from './hero'; 브라우저를 새로 고칩니다. Hero 데이터가 Mock 서버에서 성공적으로 로드 되어야합니다. HTTP PromiseAngular http.get은 RxJS Observable을 반환합니다. Observable은 비동기 데이터 흐름을 관리하는 강력한 방법입니다. 이 페이지의 뒷부분에있는 Observable에 대해서 읽어 보십시오 지금은 toPromise 연산자를 사용하여 Observable을 Promise로 변환합니다. 1.toPromise() Angular Observable에는 toPromise 연산자가 기본적으로 제공되지 않습니다. Observable을 확장하는 toPromise와 같은 유용한 연산자가 많이 있습니다. 이러한 기능을 사용하려면 연산자를 추가해야합니다. 이것은 RxJS 라이브러리에서 다음과 같이 import할 수 있습니다. 1import 'rxjs/add/operator/toPromise'; 이 튜토리얼의 뒷부분에서 더 많은 연산자를 추가하고 그렇게해야하는 이유를 배웁니다. then callback 안에서 데이터 추출Promise then() 콜백에서 HTTP 응답의 json 메소드를 호출하여 응답내의 데이터를 추출합니다. 1.then(response =&gt; response.json().data as Hero[]) 응답 JSON에는 호출자가 원하는 Heroes 배열을 보유하는 단일 data 속성이 있습니다. 그래서 그 배열을 해결된 Promise 값으로 반환합니다. 서버가 반환하는 데이터의 모양에 유의하십시오. 이 특정 in-memory 웹 API 예제는 데이터 프로퍼티가 있는 객체를 반환합니다. API가 다른 것을 반환할 수 있습니다. 웹 API와 일치하도록 코드를 조정하십시오. 호출자는 (Mock) 서버에서 Hero들을 가져온 것을 알지 못합니다. 그것은 이전처럼 Hero의 Promise를 받습니다. 에러 핸들링getHeroes()의 끝에서 서버 실패를 catch하고 error handler에 전달합니다. 1.catch(this.handleError); 이것은 중요한 단계입니다. HTTP 오류는 사용자가 제어할 수없는 이유로 자주 발생하므로 대비 해야합니다. 1234private handleError(error: any): Promise&lt;any&gt; &#123; console.error('An error occurred', error); // for demo purposes only return Promise.reject(error.message || error);&#125; 이 데모 서비스는 오류를 console에 기록합니다. 실서비스에서는 코드의 오류를 처리할 것입니다. 데모에서는 이 방법이 유용합니다. 이 코드에는 Rejected된 Promise의 오류가 포함되어 있어 호출자가 사용자에게 적절한 오류 메시지를 표시할 수 있습니다. id로 Hero 얻어오기HeroDetailComponent가 Hero를 가져 오도록 HeroService에게 요청하면, HeroService는 모든 Hero등을 가져와서 id가 일치하는 하나의 Hero를 필터링 합니다. 시뮬레이션에서는 문제가 없지만 실제 서버에 모든 Hero들을 물어 보는 것은 낭비입니다. 대부분의 웹 API는 api/hero/:id (api/hero/11와 같은) 형태로 get-by-id 요청을 지원합니다. HeroService.getHero()메서드를 업데이트하여 get-by-id 요청을 만든다. src/app/hero.service.ts 1234567getHero(id: number): Promise&lt;Hero&gt; &#123; const url = `$&#123;this.heroesUrl&#125;/$&#123;id&#125;`; return this.http.get(url) .toPromise() .then(response =&gt; response.json().data as Hero) .catch(this.handleError);&#125; 이 요청은 getHeroes()와 거의 같습니다. URL의 Hero id는 서버가 업데이트 해야할 Hero를 식별합니다. 또한 응답의 data는 배열이 아닌 단일 Hero 객체입니다. getHeroes API 변경 없음getHeroes()와 getHero()에 내부적으로 중요한 변경을 가했지만 public 시그니처는 변경되지 않았습니다. 두 방법 모두에서 Promise를 반환합니다. 이를 호출하는 Component를 업데이트할 필요가 없습니다. 이제 Hero을 만들고 지울 수있는 기능을 추가할 차례입니다. Hero 상세 정보 업데이트 하기Hero 상세보기에서 Hero의 이름을 편집 해보십시오. 입력할 때 Hero 이름이 뷰 제목에 업데이트됩니다. 그러나 뒤로 단추를 클릭하면 변경 내용이 손실됩니다. 이전에는 업데이트가 손실되지 않았습니다. 무엇이 바뀌 었을까요? 앱이 Mock Heroes 목록을 사용하면 업데이트가 단일 앱 전체 공유 목록의 Hero 개체에 직접 적용됩니다. 이제 서버에서 데이터를 가져 오는 중이므로 변경 사항을 유지하려면 서버에 다시 써야합니다. Hero 상세 정보 저장하는 기능 추가Hero 상세 템플릿의 끝에서 save()라는 새로운 Component 메서드를 호출하는 click 이벤트 바인딩과 함께 save 버튼을 추가합니다. src/app/hero-detail.component.html (save)1&lt;button (click)=\"save()\"&gt;Save&lt;/button&gt; Hero Service update () 메서드를 사용하여 Hero 이름의 변경을 지속시키는 save() 메서드를 추가한 다음, 이전 뷰로 Navigate합니다. src/app/hero-detail.component.ts (save)1234save(): void &#123; this.heroService.update(this.hero) .then(() =&gt; this.goBack());&#125; Hero Service에 update() 메서드 추가update() 메서드의 전체적인 구조는 getHeroes()와 비슷하지만 HTTP put()를 사용하여 서버에 변경을 지속합니다. src/app/hero.service.ts (update)12345678910private headers = new Headers(&#123;'Content-Type': 'application/json'&#125;);update(hero: Hero): Promise&lt;Hero&gt; &#123; const url = `$&#123;this.heroesUrl&#125;/$&#123;hero.id&#125;`; return this.http .put(url, JSON.stringify(hero), &#123;headers: this.headers&#125;) .toPromise() .then(() =&gt; hero) .catch(this.handleError);&#125; 서버가 업데이트 해야하는 Hero를 식별하기 위해 Hero id가 URL에 인코딩됩니다. put() 본문은 JSON.stringify를 호출하여 얻은 Hero의 JSON 문자열 인코딩입니다. body의 content type(application/json)은 요청 헤더에서 식별됩니다. 브라우저를 새로 고치고 Hero 이름을 변경하고 변경 사항을 저장한 다음 브라우저 뒤로 버튼을 클릭하십시오. 변경 사항이 지속되어야합니다. Hero들 추가하는 기능 추가Hero를 추가하려면 Hero의 이름이 필요합니다. 추가 버튼과 쌍을 이루는 input 엘리먼트를 사용할 수 있습니다. Hero Component HTML에 제목 다음줄에 아래 내용을 추가합니다. src/app/heroes.component.html (add)123456&lt;div&gt; &lt;label&gt;Hero name:&lt;/label&gt; &lt;input #heroName /&gt; &lt;button (click)=\"add(heroName.value); heroName.value=''\"&gt; Add &lt;/button&gt;&lt;/div&gt; 클릭 이벤트에 응답하여 Component의 클릭 핸들러를 호출한 다음 입력 필드를 지우고 다른 이름을 사용할 준비를 합니다. src/app/heroes.component.ts (add)123456789add(name: string): void &#123; name = name.trim(); if (!name) &#123; return; &#125; this.heroService.create(name) .then(hero =&gt; &#123; this.heroes.push(hero); this.selectedHero = null; &#125;);&#125; 주어진 이름이 비어 있지 않으면, 핸들러는 Hero Service에 지명된 Hero의 생성을 위임한 다음, 새로운 Hero를 배열에 추가합니다. HeroService 클래스에 create() 메서드를 구현합니다. src/app/hero.service.ts (create)1234567create(name: string): Promise&lt;Hero&gt; &#123; return this.http .post(this.heroesUrl, JSON.stringify(&#123;name: name&#125;), &#123;headers: this.headers&#125;) .toPromise() .then(res =&gt; res.json().data as Hero) .catch(this.handleError);&#125; 브라우저를 새로 고침하고 Hero를 만듭니다. Hero 삭제기능 추가Hero 뷰의 각 Hero는 삭제 버튼이 있어야합니다. Hero Component HTML의 반복적인 &lt;li&gt; 엘리먼트 다음에 아래의 버튼 엘리먼트를 추가합니다. 12&lt;button class=\"delete\" (click)=\"delete(hero); $event.stopPropagation()\"&gt;x&lt;/button&gt; &lt;li&gt; 엘리먼트는 이제 다음과 같아야합니다. src/app/heroes.component.html (li-element)1234567&lt;li *ngFor=\"let hero of heroes\" (click)=\"onSelect(hero)\" [class.selected]=\"hero === selectedHero\"&gt; &lt;span class=\"badge\"&gt;&#123;&#123;hero.id&#125;&#125;&lt;/span&gt; &lt;span&gt;&#123;&#123;hero.name&#125;&#125;&lt;/span&gt; &lt;button class=\"delete\" (click)=\"delete(hero); $event.stopPropagation()\"&gt;x&lt;/button&gt;&lt;/li&gt; Component의 delete() 메서드를 호출하는 것 외에도, 삭제 버튼의 클릭 핸들러 코드는 클릭 이벤트의 전파를 중지합니다. &lt;li&gt; 클릭 핸들러는 사용자가 삭제할 영웅을 선택하기 때문에 트리거되기를 원하지 않습니다. delete() 핸들러의 로직은 조금 복잡합니다. src/app/heroes.component.ts (delete)12345678delete(hero: Hero): void &#123; this.heroService .delete(hero.id) .then(() =&gt; &#123; this.heroes = this.heroes.filter(h =&gt; h !== hero); if (this.selectedHero === hero) &#123; this.selectedHero = null; &#125; &#125;);&#125; 물론 Hero Service에 Hero 삭제를 위임하지만 Component는 여전히 디스플레이 업데이트에 대한 책임이 있습니다. 삭제된 Hero를 배열에서 제거하고 필요한 경우 선택된 Hero를 재설정합니다. Hero 항목의 맨 오른쪽에 삭제 버튼을 배치하기 위해 다음 CSS를 추가합니다. src/app/heroes.component.css (additions)1234567button.delete &#123; float:right; margin-top: 2px; margin-right: .8em; background-color: gray !important; color:white;&#125; Hero Service에 delete() 메서드Hero Service delete() 메서드를 추가합니다. 이 메서드는 HTTP delete () 메서드를 사용하여 서버에서 Hero를 제거합니다. src/app/hero.service.ts (delete)1234567delete(id: number): Promise&lt;void&gt; &#123; const url = `$&#123;this.heroesUrl&#125;/$&#123;id&#125;`; return this.http.delete(url, &#123;headers: this.headers&#125;) .toPromise() .then(() =&gt; null) .catch(this.handleError);&#125; 브라우저를 새로 고치고 새로운 삭제 기능을 사용해보십시오. Observables각각의 Http Service 메소드는 HTTP Response 객체의 Observable을 반환합니다. HeroService는 Observable을 Promise로 변환하고 호출자에게 Promise를 리턴합니다. 이 절에서는 Observable을 언제, 어떻게, 왜 직접 리턴해야 하는지를 설명합니다. BackgroundObservable은 배열과 비슷한 연산자로 처리할 수있는 이벤트 스트림입니다. Angular core는 Observable를 기본적으로 지원합니다. 개발자는 RxJS library의 연산자 및 확장 프로그램을 사용하여 지원을 확대할 수 있습니다. 곧 보게 될 것입니다. HeroService는 toPromise 연산자를 http.get()의 Observable 결과에 연결 시켰습니다. 그 연산자는 Observable을 Promise로 변환했고 그 Promise를 호출자에게 다시 전달했습니다. Promise으로 전환하는 것은 종종 좋은 선택입니다. 일반적으로 http.get()을 호출하여 단일 데이터 덩어리를 가져옵니다. 데이터를 받으면 작업이 완료됩니다. 호출 Component는 Promise의 형태로 단일 결과를 쉽게 사용할 수 있습니다. 그러나 요청이 항상 한 번만 수행되는 것은 아닙니다. 서버가 첫 번째 요청에 응답하기 전에 하나의 요청을 시작하여 취소하고 다른 요청할 수 있습니다. request-cancel-new-request 순서는 Promise로 구현하기가 어렵지만 Observable에서는 쉽게 구현할 수 있습니다. 이름으로 검색하는 기능 추가Tour of Hero들에 영웅 검색 기능을 추가할 예정입니다. 사용자가 검색 상자에 이름을 입력하면 해당 이름으로 필터링된 Hero에 대한 반복적인 HTTP 요청을합니다. 우선 서버의 웹 API에 검색 쿼리를 보내는 HeroSearchService를 생성합니다. src/app/hero-search.service.ts12345678910111213141516171819import &#123; Injectable &#125; from '@angular/core';import &#123; Http &#125; from '@angular/http'; import &#123; Observable &#125; from 'rxjs/Observable';import 'rxjs/add/operator/map'; import &#123; Hero &#125; from './hero'; @Injectable()export class HeroSearchService &#123; constructor(private http: Http) &#123;&#125; search(term: string): Observable&lt;Hero[]&gt; &#123; return this.http .get(`api/heroes/?name=$&#123;term&#125;`) .map(response =&gt; response.json().data as Hero[]); &#125;&#125; HeroSearchService에 있는 http.get() 호출은 URL에 질의 문자열이 있는데 HeroService에 있는 것과 유사합니다. 더욱 중요한 것은 toPromise ()를 호출하지 않는다는 것입니다. 대신 http.get()에서 Observable을 다른 RxJS 연산자인 map ()에 연결 한 후 응답 데이터에서 Hero를 추출합니다. RxJS 연산자 체인은 응답 처리를 쉽고 읽기 쉽게 만듭니다. discussion below about operators를 참조하십시오. HeroSearchComponent새로운 HeroSearchService를 호출하는 HeroSearchComponent를 만듭니다. Component 템플릿은 단순한 텍스트 상자 및 일치하는 검색 결과 목록입니다. src/app/hero-search.component.html12345678910&lt;div id=\"search-component\"&gt; &lt;h4&gt;Hero Search&lt;/h4&gt; &lt;input #searchBox id=\"search-box\" (keyup)=\"search(searchBox.value)\" /&gt; &lt;div&gt; &lt;div *ngFor=\"let hero of heroes | async\" (click)=\"gotoDetail(hero)\" class=\"search-result\" &gt; &#123;&#123;hero.name&#125;&#125; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 또한 새로운 Component에 Style을 추가하십시오. src/app/hero-search.component.css1234567891011121314151617181920.search-result&#123; border-bottom: 1px solid gray; border-left: 1px solid gray; border-right: 1px solid gray; width:195px; height: 16px; padding: 5px; background-color: white; cursor: pointer;&#125; .search-result:hover &#123; color: #eee; background-color: #607D8B;&#125; #search-box&#123; width: 200px; height: 20px;&#125; 사용자가 검색 상자에 입력하면 keyup 이벤트 바인딩은 Component의 search() 메서드를 새 검색 상자 값으로 호출합니다. 예상대로 *ngFor는 Component의 heroes 프로퍼티에서 Hero들을 반복합니다. 그러나 곧 보게 되겠지만 heroes 프로퍼티는 이제 Hero 배열이 아니라 Hero 배열의 Observable 프로퍼티입니다. *ngFor는 async Pipe(AsyncPipe)를 통해 라우트할 때까지 Observable로 아무 것도 할 수 없습니다. async Pipe Observable을 Subscribe하고 Heroes들의 배열을 *ngFor로 Produces 합니다. HeroSearchComponent 클래스 및 메타 데이터를 만듭니다. src/app/hero-search.component.ts 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import &#123; Component, OnInit &#125; from '@angular/core';import &#123; Router &#125; from '@angular/router'; import &#123; Observable &#125; from 'rxjs/Observable';import &#123; Subject &#125; from 'rxjs/Subject'; // Observable class extensionsimport 'rxjs/add/observable/of'; // Observable operatorsimport 'rxjs/add/operator/catch';import 'rxjs/add/operator/debounceTime';import 'rxjs/add/operator/distinctUntilChanged'; import &#123; HeroSearchService &#125; from './hero-search.service';import &#123; Hero &#125; from './hero'; @Component(&#123; selector: 'hero-search', templateUrl: './hero-search.component.html', styleUrls: [ './hero-search.component.css' ], providers: [HeroSearchService]&#125;)export class HeroSearchComponent implements OnInit &#123; heroes: Observable&lt;Hero[]&gt;; private searchTerms = new Subject&lt;string&gt;(); constructor( private heroSearchService: HeroSearchService, private router: Router) &#123;&#125; // Push a search term into the observable stream. search(term: string): void &#123; this.searchTerms.next(term); &#125; ngOnInit(): void &#123; this.heroes = this.searchTerms .debounceTime(300) // wait 300ms after each keystroke before considering the term .distinctUntilChanged() // ignore if next search term is same as previous .switchMap(term =&gt; term // switch to new observable each time the term changes // return the http search observable ? this.heroSearchService.search(term) // or the observable of empty heroes if there was no search term : Observable.of&lt;Hero[]&gt;([])) .catch(error =&gt; &#123; // TODO: add real error handling console.log(error); return Observable.of&lt;Hero[]&gt;([]); &#125;); &#125; gotoDetail(hero: Hero): void &#123; let link = ['/detail', hero.id]; this.router.navigate(link); &#125;&#125; 검색어searchTerms에 중점을 둡니다. 123456private searchTerms = new Subject&lt;string&gt;();// Push a search term into the observable stream.search(term: string): void &#123; this.searchTerms.next(term);&#125; Subject는 Observable 이벤트 스트림의 생성자입니다. searchTerms는 이름 검색을 위한 필터 기준인 문자열 Observable을 생성합니다. search()를 호출할 때마다 next()를 호출하여 이 subject의 Observable 스트림에 새로운 문자열을 넣습니다. heroes property (ngOnInit) 초기화하기Subject는 또한 Observable입니다. 검색 용어의 스트림을 Hero 배열의 스트림으로 변환하고 그 결과를 heroes 프로퍼티에 지정할 수 있습니다. 1234567891011121314151617heroes: Observable&lt;Hero[]&gt;; ngOnInit(): void &#123; this.heroes = this.searchTerms .debounceTime(300) // wait 300ms after each keystroke before considering the term .distinctUntilChanged() // ignore if next search term is same as previous .switchMap(term =&gt; term // switch to new observable each time the term changes // return the http search observable ? this.heroSearchService.search(term) // or the observable of empty heroes if there was no search term : Observable.of&lt;Hero[]&gt;([])) .catch(error =&gt; &#123; // TODO: add real error handling console.log(error); return Observable.of&lt;Hero[]&gt;([]); &#125;);&#125; HeroSearchService에 직접 모든 사용자 키 스트로크를 전달하면 과도한 양의 HTTP 요청이 생성되어 서버 리소스를 부담시키거나 셀룰러 네트워크 데이터가 많아질 것입니다. 대신 Observable 연산자를 연결하여 Observable 문자열에 대한 요청 흐름을 줄일 수 있습니다. HeroSearchService에 대한 호출 횟수를 줄이고 적절한 시간에 결과를 얻습니다. 방법은 다음과 같습니다. debounceTime(300)은 새로운 문자열 이벤트의 흐름이 300 밀리초 동안 일시 중지 될 때까지 기다린 후 최신 문자열을 전달합니다. 300ms보다 자주 요청을하지 않습니다. distinctUntilChanged는 필터 텍스트가 변경된 경우에만 요청을 보냅니다. switchMap()은 debounce 및 distinctUntilChanged를 통해 검색하는 각 검색어에 대해 검색 서비스를 호출합니다. 이전 검색 관측 값을 취소하고 파기하며 Observable 최신 검색 서비스만 반환합니다. switchMap 연산자 (이전에는 flatMapLatest라고 함)를 사용하여 모든 규정 키 이벤트가 http() 메서드 호출을 트리거할 수 있습니다. 요청간에 300ms의 일시 중지가 있더라도 여러 개의 HTTP 요청을 보낼 수 있으며 전송된 순서대로 반환하지 않을 수 있습니다. switchMap()은 가장 최근의 http 메서드 호출에서 Observable만 리턴하면서 원래 요청 순서를 보존합니다. 이전 호출의 결과는 취소되고 폐기됩니다. 검색 텍스트가 비어 있으면 http() 메서드 호출도 일단락되고 빈 배열을 포함하는 Observable이 반환됩니다. 서비스가 해당 기능을 지원할 때까지 HeroSearchService Observable을 취소한다고 해서 보류중인 HTTP 요청이 실제로 중단되지는 않습니다. 지금은 원치 않는 결과는 무시됩니다. catch는 실패한 Observable 항목을 차단합니다. 간단한 예제는 콘솔에 오류를 인쇄합니다. 실제 응용 프로그램이 더 잘할 것입니다. 그런 다음 검색 결과를 지우려면 빈 배열을 포함하는 Observable 객체를 반환합니다. RxJS 연산자 Import대부분의 RxJS 연산자는 Angular 기반 Observable 구현에 포함되지 않습니다. 기본 구현에는 Angular 자체에서 필요한 것만 포함됩니다. 더 많은 RxJS 기능이 필요하면 정의된 라이브러리를 가져 와서 Observable을 확장하십시오. 이 Component에 필요한 모든 RxJS import는 다음과 같습니다. src/app/hero-search.component.ts (rxjs imports)12345678910import &#123; Observable &#125; from 'rxjs/Observable';import &#123; Subject &#125; from 'rxjs/Subject';// Observable class extensionsimport 'rxjs/add/observable/of';// Observable operatorsimport 'rxjs/add/operator/catch';import 'rxjs/add/operator/debounceTime';import 'rxjs/add/operator/distinctUntilChanged'; 가져 오기 rxjs/add/...구문이 익숙하지 않을 수 있습니다. 중괄호 사이에 일반적인 심볼 목록이 없습니다. {...}. 연산자 심볼 자체는 필요하지 않습니다. 각각의 경우에, 라이브러리를 임포트하는 단순한 행위는 라이브러리의 스크립트 파일을 로드하고 실행 시켜서, 연산자를 Observable 클래스에 추가합니다. Search Component를 Dashboard에 추가하기Hero 검색 HTML 엘리먼트를 DashboardComponent 템플리트의 맨 아래에 추가합니다. src/app/dashboard.component.html 123456789&lt;h3&gt;Top Heroes&lt;/h3&gt;&lt;div class=\"grid grid-pad\"&gt; &lt;a *ngFor=\"let hero of heroes\" [routerLink]=\"['/detail', hero.id]\" class=\"col-1-4\"&gt; &lt;div class=\"module hero\"&gt; &lt;h4&gt;&#123;&#123;hero.name&#125;&#125;&lt;/h4&gt; &lt;/div&gt; &lt;/a&gt;&lt;/div&gt;&lt;hero-search&gt;&lt;/hero-search&gt; 마지막으로 hero-search.component.ts에서 HeroSearchComponent를 import하고 declarations 배열에 추가합니다. src/app/app.module.ts (search)1234567declarations: [ AppComponent, DashboardComponent, HeroDetailComponent, HeroesComponent, HeroSearchComponent], 앱을 다시 실행합니다. 대시 보드에서 검색 상자에 텍스트를 입력합니다. 기존의 Hero 이름과 일치하는 문자를 입력하면 다음과 같은 메시지가 표시됩니다. 앱 구조와 코드이 예제 페이지의 라이브 예제/예제 다운로드에서 샘플 소스 코드를 확인하십시오. 그리고 다음과 같은 구조인지 확인하십시오. 123456789101112131415161718192021222324252627282930angular-tour-of-heroes ┣ src ┃ ┣ app ┃ ┃ ┣ app.component.ts ┃ ┃ ┣ app.component.css ┃ ┃ ┣ app.module.ts ┃ ┃ ┣ app-routing.module.ts ┃ ┃ ┣ dashboard.component.css ┃ ┃ ┣ dashboard.component.html ┃ ┃ ┣ dashboard.component.ts ┃ ┃ ┣ hero.ts ┃ ┃ ┣ hero-detail.component.css ┃ ┃ ┣ hero-detail.component.html ┃ ┃ ┣ hero-detail.component.ts ┃ ┃ ┣ hero-search.component.html (new) ┃ ┃ ┣ hero-search.component.css (new) ┃ ┃ ┣ hero-search.component.ts (new) ┃ ┃ ┣ hero-search.service.ts (new) ┃ ┃ ┣ hero.service.ts ┃ ┃ ┣ heroes.component.css ┃ ┃ ┣ heroes.component.html ┃ ┃ ┣ heroes.component.ts ┃ ┃ ┗ in-memory-data.service.ts (new) ┃ ┣ main.ts ┃ ┣ index.html ┃ ┣ styles.css ┃ ┣ systemjs.config.js ┃ ┗ tsconfig.json ┣ node_modules ... ┗ package.json Home Stretch당신의 여행이 끝나고 많은 것을 성취했습니다. 앱에서 HTTP를 사용하기 위해 필요한 의존성을 추가했습니다. HeroService를 리팩토링하여 웹 API에서 Hero를 로드했습니다. post(), put() 및 delete() 메소드를 지원하도록 HeroService를 확장했습니다. Hero를 추가, 편집 및 삭제할 수 있도록 Component를 업데이트했습니다. in-memory 웹 API를 구성했습니다. Observable 사용법을 배웠습니다. 이 페이지에서 추가하거나 변경 한 파일은 다음과 같습니다. https://angular.io/tutorial/toh-pt6#home-stretch 에서 확인하세요 Next step이것으로 “Tour of Heroes”튜토리얼을 마칩니다. 이제 Angular 개발에 대해 자세히 배울 준비가되었습니다. Architecture 가이드부터 시작하세요. 이 내용은 나중에 참고하기 위해 제가 공부하며 정리한 내용입니다.의역, 오역, 직역이 있을 수 있음을 알려드립니다.This post is a translation of this original article [https://angular.io/tutorial/toh-pt6] 참고 Angular 튜토리얼 - 소개 Angular 튜터리얼 - Hero 에디터 Angular 튜터리얼 - Master/Detail Angular 튜터리얼 - 다중 콤포넌트 Angular 튜터리얼 - 서비스 Angular 튜터리얼 - 라우팅 Angular HttpClient Angular 동적 컴포넌트 로딩","categories":[{"name":"Angular","slug":"Angular","permalink":"http://infoscis.github.io/categories/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://infoscis.github.io/tags/Angular/"}]},{"title":"Angular 튜터리얼 - 다중 콤포넌트","slug":"angular-tutorial-multiple-components","date":"2017-07-21T13:26:30.000Z","updated":"2018-01-27T15:20:38.033Z","comments":true,"path":"2017/07/21/angular-tutorial-multiple-components/","link":"","permalink":"http://infoscis.github.io/2017/07/21/angular-tutorial-multiple-components/","excerpt":"","text":"Multiple Components현재 AppComponent에서 모든 것을 하고 있습니다. 처음에는 하나의 Hero에 대한 상세 보기를 보여주었습니다. 그런 다음 Hero들 목록과 Hero 세부 정보가 모두 포함된 master/detail 형식이 되었습니다. 곧 새로운 요구 사항과 기능이 생길 것입니다. 한 Component에 모든 기능을 유지할 수는 없습니다. 특정 작업이나 워크 플로에 중점을 둔 하위 Component로 구성해야합니다. 결국 AppComponent는 이러한 하위 Component를 호스팅하는 단순한 shell이 될 수 있습니다. 이 페이지에서 Hero의 세부 사항을 별도의 재사용 가능한 Component로 쪼갬으로써 하위 Component로 만드는 첫 번째 단계를 수행하게됩니다. 모두 완료되면 응용 프로그램은 이 라이브 예제/예제 다운로드처럼 보일 것입니다. 어디까지 했나?이 페이지를 시작하기 전에 이전 페이지에서 작업했던 Tour of Heroes의 구조와 동일한지 확인하십시오. 그렇지 않은 경우 이전 페이지로 돌아가십시오. 123456789101112angular-tour-of-heroes ┣ src ┃ ┣ app ┃ ┃ ┣ app.component.ts ┃ ┃ ┗ app.module.ts ┃ ┣ main.ts ┃ ┣ index.html ┃ ┣ styles.css ┃ ┣ systemjs.config.js ┃ ┗ tsconfig.json ┣ node_modules ... ┗ package.json 이전처럼 터미널 창에 npm start 명령을 입력하여 Tour of Heroes를 빌드하는 동안 앱이 계속 transpiling과 실행을 계속하도록 합니다. Hero 상세 component 만들기hero-detail.component.ts라는 파일을 app/ 폴더에 추가합니다. 이 파일에 새로운 HeroDetailComponent를 저장할 것입니다. 파일 및 Component 이름은 Angular 스타일 안내서에 설명된 표준을 따릅니다. Component 클래스 이름은 upper camel case로 쓰여지고 “Component”라는 단어로 끝나야합니다. Hero 상세 Component 클래스는 HeroDetailComponent입니다. Component 파일 이름은 소문자로 입력해야하며, 각 단어는 대시로 구분하고 .component.ts로 끝나야합니다. HeroDetailComponent 클래스는 hero-detail.component.ts 파일에 들어갑니다. 다음과 같이 HeroDetailComponent 작성을 시작합니다. app/hero-detail.component.ts (initial version) 1234567import &#123; Component &#125; from '@angular/core';@Component(&#123; selector: 'hero-detail',&#125;)export class HeroDetailComponent &#123;&#125; Component를 정의하려면 항상 Component 심볼을 import 해야합니다. @Component Decorator는 Component의 Angular 메타 데이터를 제공합니다. CSS 선택자 이름인 hero-detail은 상위 Component의 템플릿 내에서 이 Component를 식별하는 엘리먼트 태그와 일치합니다. 이 튜토리얼 페이지의 끝 부분에서 &lt;hero-detail&gt; 엘리먼트를 AppComponent 템플릿에 추가할 것입니다. 항상 다른곳에서 import하기 때문에 컴포넌트 클래스는 언제나 export해야 합니다. Hero 상세 템플릿Hero 상세 보기를 HeroDetailComponent로 옮기려면, AppComponent 템플릿의 맨 아래에서 Hero 상세 내용을 잘라내서 @Component 메타 데이터의 새로운 template 프로퍼티에 붙여 넣으십시오. HeroDetailComponent에는 선택된 Hero가 아닌 그냥 Hero가 있습니다. 템플릿의 “hero”라는 단어로 “selectedHero”라는 단어를 대체하십시오. 완료되면 새 템플릿은 다음과 같이 표시됩니다. src/app/hero-detail.component.ts (template)12345678910111213@Component(&#123; selector: 'hero-detail', template: ` &lt;div *ngIf=\"hero\"&gt; &lt;h2&gt;&#123;&#123;hero.name&#125;&#125; details!&lt;/h2&gt; &lt;div&gt;&lt;label&gt;id: &lt;/label&gt;&#123;&#123;hero.id&#125;&#125;&lt;/div&gt; &lt;div&gt; &lt;label&gt;name: &lt;/label&gt; &lt;input [(ngModel)]=\"hero.name\" placeholder=\"name\"/&gt; &lt;/div&gt; &lt;/div&gt; `&#125;) hero 프로퍼티 추가HeroDetailComponent 템플릿은 컴포넌트의 hero 프로퍼티에 바인딩됩니다. 그 프로퍼티를 다음과 같이 HeroDetailComponent 클래스에 추가합니다. src/app/hero-detail.component.ts (hero property)1hero: Hero; hero 프로퍼티는 Hero의 인스턴스로 입력됩니다. Hero 클래스는 여전히 app.component.ts 파일에 있습니다. 이제 Hero 클래스를 참조해야하는 두 가지 Component가 존재합니다. Angular 스타일 가이드는 파일당 하나의 클래스를 권장합니다. Hero 클래스를 app.component.ts에서 자신의 hero.ts 파일로 옮깁니다. src/app/hero.ts1234export class Hero &#123; id: number; name: string;&#125; Hero 클래스가 자체 파일에 있기 때문에, AppComponent와 HeroDetailComponent는 import 해야합니다. app.component.ts 파일과 hero-detail.component.ts 파일의 상단에 다음 import 문을 추가합니다. src/app/hero-detail.component.ts1import &#123; Hero &#125; from './hero'; hero 프로퍼티는 input 프로퍼티입니다.이 문서의 뒤에 있는 부모인 AppComponent는 HeroDetailComponent의 hero 프로퍼티에 selectedHero를 바인딩하여 표시할 Hero를 자식 HeroDetailComponent에게 알려줍니다. 바인딩은 다음과 같습니다. src/app/app.component.html1&lt;hero-detail [hero]=\"selectedHero\"&gt;&lt;/hero-detail&gt; 등호(=)의 왼쪽에 있는 hero 프로퍼티 주위에 대괄호를 넣으면 프로퍼티 바인딩 표현식의 대상이됩니다. target 바인딩 프로퍼티를 input 프로퍼티로 선언 해야합니다. 그렇지 않으면 Angular가 바인딩을 거부하고 오류를 던집니다. 먼저 @angular/core import 문을 수정하여 Input 심볼을 포함시킵니다. src/app/hero-detail.component.ts (excerpt)1import &#123; Component, Input &#125; from '@angular/core'; 그런 다음 가져온 @Input Decorator를 추가하여 hero를 입력 프로퍼티라고 선언합니다. src/app/hero-detail.component.ts (excerpt)1@Input() hero: Hero; Attribute Directive 페이지에서 입력 프로퍼티에 대해 자세히 읽어보십시오. 이게 전부입니다. hero는 HeroDetailComponent 클래스의 유일한 프로퍼티입니다. src/src/app/hero-detail.component.ts123export class HeroDetailComponent &#123; @Input() hero: Hero;&#125; 하는 일은 hero 입력 프로퍼티를 통해 Hero 객체를 받은 다음 템플릿의 해당 프로퍼티에 바인딩하는 것입니다. 다음은 완전한 HeroDetailComponent입니다. src/app/hero-detail.component.ts12345678910111213141516171819import &#123; Component, Input &#125; from '@angular/core'; import &#123; Hero &#125; from './hero';@Component(&#123; selector: 'hero-detail', template: ` &lt;div *ngIf=\"hero\"&gt; &lt;h2&gt;&#123;&#123;hero.name&#125;&#125; details!&lt;/h2&gt; &lt;div&gt;&lt;label&gt;id: &lt;/label&gt;&#123;&#123;hero.id&#125;&#125;&lt;/div&gt; &lt;div&gt; &lt;label&gt;name: &lt;/label&gt; &lt;input [(ngModel)]=\"hero.name\" placeholder=\"name\"/&gt; &lt;/div&gt; &lt;/div&gt; `&#125;)export class HeroDetailComponent &#123; @Input() hero: Hero;&#125; AppModule에 HeroDetailComponent 선언모든 Component는 하나의(그리고 오직 한번만) Angular 모듈로 선언되어야합니다. 에디터에서 app.module.ts 파일을 열고 HeroDetailComponent 파일을 import해서 참조합니다. src/app/app.module.ts1import &#123; HeroDetailComponent &#125; from './hero-detail.component'; HeroDetailComponent를 모듈의 declarations 배열에 추가합니다. src/app/app.module.ts1234declarations: [ AppComponent, HeroDetailComponent], 일반적으로 declarations 배열은 모듈에 속한 Component, Pipe 및 Directive 응용 프로그램 목록을 포함합니다. 다른 Component가 참조하기 전에 Component를 모듈에서 선언해야합니다. 예제의 모듈은 AppComponent와 HeroDetailComponent라는 두 개의 어플리케이션 컴포넌트만을 선언합니다. NgModules 가이드에서 Angular 모듈에 대해 자세히 읽어보십시오. AppComponent에 HeroDetailComponent 추가AppComponent는 여전히 master/detail입니다. 템플릿의 해당 부분을 잘라내기 전에 Hero 상세 보기를 표시하는데 사용되었습니다. 이제 HeroDetailComponent에 위임할 것입니다. HeroDetailComponent 메타 데이터의 CSS selector인 hero-detail을 다시 보겠습니다. 이것은 HeroDetailComponent를 나타내는 엘리먼트의 태그 이름입니다. AppComponent 템플릿 밑에 &lt;hero-detail&gt; 엘리먼트를 추가합니다. 이 엘리먼트에 Hero 상세 보기가 보여집니다. AppComponent의 selectedHero 프로퍼티를 HeroDetailComponent의 hero 프로퍼티에 바인딩함으로써 master AppComponent를 HeroDetailComponent와 연결합니다. app.component.ts (excerpt)1&lt;hero-detail [hero]=\"selectedHero\"&gt;&lt;/hero-detail&gt; 이제 selectedHero가 바뀔 때마다 HeroDetailComponent는 새로운 Hero를 표시합니다. 수정된 AppComponent 템플릿은 다음과 같습니다. app.component.ts (excerpt)123456789101112template: ` &lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt; &lt;h2&gt;My Heroes&lt;/h2&gt; &lt;ul class=\"heroes\"&gt; &lt;li *ngFor=\"let hero of heroes\" [class.selected]=\"hero === selectedHero\" (click)=\"onSelect(hero)\"&gt; &lt;span class=\"badge\"&gt;&#123;&#123;hero.id&#125;&#125;&lt;/span&gt; &#123;&#123;hero.name&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;hero-detail [hero]=\"selectedHero\"&gt;&lt;/hero-detail&gt;`, 무엇이 바뀌었나?이전과 마찬가지로 사용자가 Hero 이름을 클릭할 때마다 Hero 상세 보기가 Heroes 목록 아래에 표시됩니다. 이제 HeroDetailView에서 이러한 상세 보기를 제공합니다. 원래의 AppComponent를 두 개의 컴포넌트로 리팩토링하면 현재와 미래 모두 혜택을 얻을 수 있습니다. AppComponent의 책임을 줄임으로써 AppComponent를 단순화했습니다. 부모 AppComponent를 건드리지 않고도 HeroDetailComponent를 풍부한 Rich Hero editor로 확장시킬 수 있습니다. Hero 상세보기를 건드리지 않고도 AppComponent를 확장시킬 수 있습니다. HeroDetailComponent는 미래의 상위 Component의 템플리트에서 다시 사용할 수 있습니다. Review the app structure다음과 같은 구조인지 확인하십시오. 1234567891011121314angular-tour-of-heroes ┣ src ┃ ┣ app ┃ ┃ ┣ app.component.ts ┃ ┃ ┣ app.module.ts ┃ ┃ ┣ hero.ts ┃ ┃ ┗ hero-detail.component.ts ┃ ┣ main.ts ┃ ┣ index.html ┃ ┣ styles.css ┃ ┣ systemjs.config.js ┃ ┗ tsconfig.json ┣ node_modules ... ┗ package.json 이 페이지에서 설명하는 코드 파일은 다음과 같습니다. src/app/hero-detail.component.ts12345678910111213141516171819import &#123; Component, Input &#125; from '@angular/core'; import &#123; Hero &#125; from './hero';@Component(&#123; selector: 'hero-detail', template: ` &lt;div *ngIf=\"hero\"&gt; &lt;h2&gt;&#123;&#123;hero.name&#125;&#125; details!&lt;/h2&gt; &lt;div&gt;&lt;label&gt;id: &lt;/label&gt;&#123;&#123;hero.id&#125;&#125;&lt;/div&gt; &lt;div&gt; &lt;label&gt;name: &lt;/label&gt; &lt;input [(ngModel)]=\"hero.name\" placeholder=\"name\"/&gt; &lt;/div&gt; &lt;/div&gt; `&#125;)export class HeroDetailComponent &#123; @Input() hero: Hero;&#125; src/app/app.component.ts123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import &#123; Component &#125; from '@angular/core'; import &#123; Hero &#125; from './hero'; const HEROES: Hero[] = [ &#123; id: 11, name: 'Mr. Nice' &#125;, &#123; id: 12, name: 'Narco' &#125;, &#123; id: 13, name: 'Bombasto' &#125;, &#123; id: 14, name: 'Celeritas' &#125;, &#123; id: 15, name: 'Magneta' &#125;, &#123; id: 16, name: 'RubberMan' &#125;, &#123; id: 17, name: 'Dynama' &#125;, &#123; id: 18, name: 'Dr IQ' &#125;, &#123; id: 19, name: 'Magma' &#125;, &#123; id: 20, name: 'Tornado' &#125;]; @Component(&#123; selector: 'my-app', template: ` &lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt; &lt;h2&gt;My Heroes&lt;/h2&gt; &lt;ul class=\"heroes\"&gt; &lt;li *ngFor=\"let hero of heroes\" [class.selected]=\"hero === selectedHero\" (click)=\"onSelect(hero)\"&gt; &lt;span class=\"badge\"&gt;&#123;&#123;hero.id&#125;&#125;&lt;/span&gt; &#123;&#123;hero.name&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;hero-detail [hero]=\"selectedHero\"&gt;&lt;/hero-detail&gt; `, styles: [` .selected &#123; background-color: #CFD8DC !important; color: white; &#125; .heroes &#123; margin: 0 0 2em 0; list-style-type: none; padding: 0; width: 15em; &#125; .heroes li &#123; cursor: pointer; position: relative; left: 0; background-color: #EEE; margin: .5em; padding: .3em 0; height: 1.6em; border-radius: 4px; &#125; .heroes li.selected:hover &#123; background-color: #BBD8DC !important; color: white; &#125; .heroes li:hover &#123; color: #607D8B; background-color: #DDD; left: .1em; &#125; .heroes .text &#123; position: relative; top: -3px; &#125; .heroes .badge &#123; display: inline-block; font-size: small; color: white; padding: 0.8em 0.7em 0 0.7em; background-color: #607D8B; line-height: 1em; position: relative; left: -1px; top: -4px; height: 1.8em; margin-right: .8em; border-radius: 4px 0 0 4px; &#125; `]&#125;)export class AppComponent &#123; title = 'Tour of Heroes'; heroes = HEROES; selectedHero: Hero; onSelect(hero: Hero): void &#123; this.selectedHero = hero; &#125;&#125; src/app/hero.ts1234export class Hero &#123; id: number; name: string;&#125; src/app/app.module.ts12345678910111213141516171819import &#123; NgModule &#125; from '@angular/core';import &#123; BrowserModule &#125; from '@angular/platform-browser';import &#123; FormsModule &#125; from '@angular/forms'; import &#123; AppComponent &#125; from './app.component';import &#123; HeroDetailComponent &#125; from './hero-detail.component'; @NgModule(&#123; imports: [ BrowserModule, FormsModule ], declarations: [ AppComponent, HeroDetailComponent ], bootstrap: [ AppComponent ]&#125;)export class AppModule &#123; &#125; 어디까지 했나?이 페이지에서 달성한 내용은 다음과 같습니다. 재사용 가능한 Component를 만들었습니다. Component가 입력을 허용하는 방법을 배웠습니다. Angular 모듈에서 필요한 애플리케이션 Directive를 선언하는 방법을 배웠습니다. NgModule Decorator의 declarations 배열에 Directive를 나열했습니다. 부모 Component를 하위 Component에 바인딩하는 방법을 배웠습니다. 앱은 이 라이브 예제/ 예제 다운로드와 비슷해야합니다. 앞으로의 여정Tour of Heroes 앱은 공유 Component로 재사용할 수 있지만 App (Mock) 데이터는 여전히 AppComponent 내에 하드 코딩되어 있습니다. 그것은 서스테이닝이 쉽지 않습니다. 데이터 액세스는 별도의 Service로 리팩토링 되어야하며 데이터가 필요한 Component간에 공유되어야합니다. 다음 튜토리얼 페이지에서 Service를 만드는 방법을 배웁니다. 이 내용은 나중에 참고하기 위해 제가 공부하며 정리한 내용입니다.의역, 오역, 직역이 있을 수 있음을 알려드립니다.This post is a translation of this original article [https://angular.io/tutorial/toh-pt3] 참고 Angular 튜토리얼 - 소개 Angular 튜터리얼 - Hero 에디터 Angular 튜터리얼 - Master/Detail Angular 튜터리얼 - 서비스 Angular 튜터리얼 - 라우팅 Angular 튜터리얼 - HTTP Angular HttpClient Angular 동적 컴포넌트 로딩","categories":[{"name":"Angular","slug":"Angular","permalink":"http://infoscis.github.io/categories/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://infoscis.github.io/tags/Angular/"}]},{"title":"Angular 튜터리얼 - Master/Detail","slug":"angular-tutorial-master-detail","date":"2017-07-21T13:26:30.000Z","updated":"2018-01-27T15:24:29.837Z","comments":true,"path":"2017/07/21/angular-tutorial-master-detail/","link":"","permalink":"http://infoscis.github.io/2017/07/21/angular-tutorial-master-detail/","excerpt":"","text":"Master/Detail이 페이지에서는 Tour of Heroes 앱을 확장하여 Heroes 목록을 표시하고 사용자가 Hero를 선택하고 Hero의 세부 정보를 표시하도록 합니다. 이 페이지를 끝내면 앱은 이 라이브 예제/예제 다운로드처럼 보일 것입니다. 어디까지 했나?Tour of Heroes 페이지를 계속하기 전에 The Hero Editor 이후에 아래와 같은 구조인지 확인하십시오. 구조가 일치하지 않으면 그 페이지로 돌아가서 무엇을 놓쳤는지 파악하십시오. 123456789101112angular-tour-of-heroes ┣ src ┃ ┣ app ┃ ┃ ┣ app.component.ts ┃ ┃ ┗ app.module.ts ┃ ┣ main.ts ┃ ┣ index.html ┃ ┣ styles.css ┃ ┣ systemjs.config.js ┃ ┗ tsconfig.json ┣ node_modules ... ┗ package.json 앱 실행과 트랜스파일을 유지하기터미널 창에서 다음 명령을 입력하십시오. 1npm start 이 명령은 TypeScript 컴파일러를 “watch mode”에서 실행하여 코드가 변경되면 자동으로 다시 컴파일 하도록합니다. 또한 이 명령은 앱이 브라우저에서 동시에 실행되고 코드가 변경되면 브라우저를 새로 고칩니다. 다시 컴파일하거나 새로 고치지 않고 브라우저를 일시 정지하지 않아 Tour of Heroes 앱을 계속 만들 수 있습니다. Hero들 표시하기Heroes의 목록을 표시하기 위해 Hero 템플릿 view를 추가합니다. Hero들 생성10 명의 Hero로 구성된 배열을 만듭니다. src/app/app.component.ts (hero array) 123456789101112const HEROES: Hero[] = [ &#123; id: 11, name: 'Mr. Nice' &#125;, &#123; id: 12, name: 'Narco' &#125;, &#123; id: 13, name: 'Bombasto' &#125;, &#123; id: 14, name: 'Celeritas' &#125;, &#123; id: 15, name: 'Magneta' &#125;, &#123; id: 16, name: 'RubberMan' &#125;, &#123; id: 17, name: 'Dynama' &#125;, &#123; id: 18, name: 'Dr IQ' &#125;, &#123; id: 19, name: 'Magma' &#125;, &#123; id: 20, name: 'Tornado' &#125;]; HEROES 배열은 이전 페이지에서 정의된 Hero 타입입니다. 나중에는 앱이 웹 서비스에서 Hero들의 목록을 가져 오지만 지금은 Mock Hero를 표시 합니다. Hero들 노출AppComponent에 Hero들을 노출하는 바인딩을 위해 public 프로퍼티를 만듭니다. app.component.ts (hero array property)1heroes = HEROES; TypeScript는 HEROES의 array에서 유추하기 때문에 heroes 타입은 따로 정의하지 않습니다. 궁극적으로 Hero의 이름은 데이터 서비스에서 나올 것이므로 Hero 데이터는 클래스 구현과 분리됩니다. Template에 Hero 이름 표시하기정렬되지 않은 목록에 Hero 이름을 표시하려면 title 아래, detail 위에 다음 HTML을 삽입합니다. app.component.ts (heroes template)123456&lt;h2&gt;My Heroes&lt;/h2&gt;&lt;ul class=\"heroes\"&gt; &lt;li&gt; &lt;!-- each hero goes here --&gt; &lt;/li&gt;&lt;/ul&gt; 이제 Hero 이름으로 템플릿을 채울 수 있습니다. ngFor를 이용한 Hero들 목록목표는 Component의 Hero 배열을 템플릿에 바인딩하고, 반복하여 개별적으로 표시하는 것입니다. 내장 Directive *ngFor를 추가하여 &lt;li&gt;태그를 수정합니다. app.component.ts (ngFor)1&lt;li *ngFor=\"let hero of heroes\"&gt; ngFor의 접두사(*)는 이 구문에서 중요한 부분입니다. &lt;li&gt; 요소와 그 하위 요소가 master 템플릿을 구성함을 나타냅니다. ngFor Directive는 Component의 heroes 배열을 반복하고 그 배열의 각 Hero에 대해 이 템플릿 인스턴스를 렌더링합니다. 표현식의 let hero 부분은 hero를 템플릿 입력 변수로 식별합니다. 이 변수는 각 반복마다 현재 Hero 아이템을 보유합니다. 템플릿내에서 이 변수를 참조하여 현재 Hero의 프로퍼티에 액세스할 수 있습니다. ngFor 및 템플릿 입력 변수에 대한 자세한 내용은 데이터 표시 페이지의 배열 속성 표시와 템플릿 구문 페이지의 *ngFor 섹션과, 템플릿 구문 페이지의 ngFor 섹션을 참조하십시오. &lt;li&gt;태그 안에 hero 템플릿 변수를 사용하여 Hero의 프로퍼티를 나타내는 내용을 추가합니다. app.component.ts (ngFor template)123&lt;li *ngFor=\"let hero of heroes\"&gt; &lt;span class=\"badge\"&gt;&#123;&#123;hero.id&#125;&#125;&lt;/span&gt; &#123;&#123;hero.name&#125;&#125;&lt;/li&gt; 브라우저가 새로 고침되면 Heroes의 목록이 나타납니다. Hero들 스타일사용자에게 그들이 Hovering하는 Hero와 선택한 Hero를 시각적으로 표현해야 합니다. Component에 스타일을 추가하기 위해 @Component Decorator의 styles 프로퍼티를 다음의 CSS 클래스로 설정합니다. src/app/app.component.ts (styles)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849styles: [` .selected &#123; background-color: #CFD8DC !important; color: white; &#125; .heroes &#123; margin: 0 0 2em 0; list-style-type: none; padding: 0; width: 15em; &#125; .heroes li &#123; cursor: pointer; position: relative; left: 0; background-color: #EEE; margin: .5em; padding: .3em 0; height: 1.6em; border-radius: 4px; &#125; .heroes li.selected:hover &#123; background-color: #BBD8DC !important; color: white; &#125; .heroes li:hover &#123; color: #607D8B; background-color: #DDD; left: .1em; &#125; .heroes .text &#123; position: relative; top: -3px; &#125; .heroes .badge &#123; display: inline-block; font-size: small; color: white; padding: 0.8em 0.7em 0 0.7em; background-color: #607D8B; line-height: 1em; position: relative; left: -1px; top: -4px; height: 1.8em; margin-right: .8em; border-radius: 4px 0 0 4px; &#125;`] 여러줄 문자열을 위해 백틱 표기법을 사용해야합니다. 이러한 스타일은 별도의 파일에 추가하여 사용하면 훨씬 유용합니다. 이후 페이지에서 스타일을 별도의 파일로 옮깁니다. Component에 스타일을 지정하면 특정 Component로 범위가 지정됩니다. 이 스타일은 AppComponent에만 적용되며 외부 HTML에는 영향을 미치지 않습니다. Hero들을 표시하기 위한 템플릿은 다음과 같습니다. src/app/app.component.ts (styled heroes)123456&lt;h2&gt;My Heroes&lt;/h2&gt;&lt;ul class=\"heroes\"&gt; &lt;li *ngFor=\"let hero of heroes\"&gt; &lt;span class=\"badge\"&gt;&#123;&#123;hero.id&#125;&#125;&lt;/span&gt; &#123;&#123;hero.name&#125;&#125; &lt;/li&gt;&lt;/ul&gt; Hero 선택하기이제 앱에서 Heroes 목록과 상세 보기에 한명의 Hero를 표시합니다. 하지만 목록과 세부정보 보기는 연결되어 있지 않습니다. 사용자가 목록에서 Hero를 선택하면 선택한 Hero가 세부정보 보기에 나타나야 합니다. 이 UI 패턴을 “master/detail”이라고 합니다. 이 경우, master는 Heroes 목록이고 detail은 선택된 Hero입니다. 다음으로 click 이벤트에 바인딩된 selectedHero Component 프로퍼티를 통해 마스터를 세부 정보에 연결합니다. Click 이벤트 핸들다음과 같이 &lt;li&gt; 클릭 이벤트 바인딩을 추가합니다. app.component.ts (template excerpt)123&lt;li *ngFor=\"let hero of heroes\" (click)=\"onSelect(hero)\"&gt; ...&lt;/li&gt; 괄호는 &lt;li&gt;요소의 클릭 이벤트를 대상으로 식별합니다. onSelect(hero) 표현식은 AppComponent 메소드인 onSelect()를 호출하여 템플릿 입력 변수 hero를 파라미터로 전달합니다. 이것은 이전에 ngFor Directive에서 정의한 것과 동일한 hero 변수입니다. 사용자 입력 페이지 및 템플릿 구문 페이지의 이벤트 바인딩 섹션에서 이벤트 바인딩에 대해 자세히 알수 있습니다. 선택된 Hero를 노출하는 Click 핸들러 추가더이상 한명의 Hero만 표시하지 않으므로 hero 프로퍼티가 필요하지 않습니다. 당신은 Hero들의 목록을 보여주고 있습니다. 그러나 사용자는 Hero중 하나를 클릭하여 선택할 수 있습니다. 그러므로 hero 프로퍼티를 다음과 같은 간단한 selectedHero 프로퍼티로 대체합니다. src/app/app.component.ts (selectedHero)1selectedHero: Hero; 사용자가 Hero를 선택하기 전에 Hero의 이름을 모두 선택 해제 해야하므로 hero와 마찬가지로 selectedHero도 초기화할 필요 없습니다. selectedHero 프로퍼티를 사용자가 클릭하는 hero로 설정하는 onSelect() 메서드를 추가합니다. src/app/app.component.ts (onSelect)123onSelect(hero: Hero): void &#123; this.selectedHero = hero;&#125; 템플릿은 여전히 오래된 hero 프로퍼티를 참조합니다. 다음과 같이 새로운 selectedHero 프로퍼티에 바인딩합니다. app.component.ts (template excerpt)123456&lt;h2&gt;&#123;&#123;selectedHero.name&#125;&#125; details!&lt;/h2&gt;&lt;div&gt;&lt;label&gt;id: &lt;/label&gt;&#123;&#123;selectedHero.id&#125;&#125;&lt;/div&gt;&lt;div&gt; &lt;label&gt;name: &lt;/label&gt; &lt;input [(ngModel)]=\"selectedHero.name\" placeholder=\"name\"/&gt;&lt;/div&gt; ngIf를 이용해 빈 상세보기 숨기기앱이 로드되면 selectedHero는 undefined입니다.. selectedHero는 사용자가 Hero의 이름을 클릭할 때 초기화됩니다. Angular는 undefined한 selectedHero의 프로퍼티를 표시할 수 없으며 다음 오류를 브라우저의 콘솔에 표시합니다. 1EXCEPTION: TypeError: Cannot read property &apos;name&apos; of undefined in [null] 템플릿에 selectedHero.name이 표시 되더라도 선택한 Hero가 있을 때까지 Hero 상세 보기를 DOM 밖에서 유지해야합니다. 템플릿의 HTML Hero 상세 보기를 &lt;div&gt;로 묶습니다. 그런 다음 내장 ngIf Directive를 추가하고 Component의 selectedHero 프로퍼티를 설정합니다. src/app/app.component.ts (ngIf)12345678&lt;div *ngIf=\"selectedHero\"&gt; &lt;h2&gt;&#123;&#123;selectedHero.name&#125;&#125; details!&lt;/h2&gt; &lt;div&gt;&lt;label&gt;id: &lt;/label&gt;&#123;&#123;selectedHero.id&#125;&#125;&lt;/div&gt; &lt;div&gt; &lt;label&gt;name: &lt;/label&gt; &lt;input [(ngModel)]=\"selectedHero.name\" placeholder=\"name\"/&gt; &lt;/div&gt;&lt;/div&gt; ngIf 앞에 별표 (*)를 잊지 마십시오. 앱은 더 이상 오류가 발생하지 않고 브라우저에 Hero들의 이름 목록이 다시 표시됩니다. 선택된 Hero가 없을 때 ngIf Directive는 Hero 상세 보기 HTML을 DOM에서 제거합니다. 문제가될 Hero 상세 보기나 바인딩이 없습니다. 사용자가 Hero를 선택하면 selectedHero가 정의되고 ngIf는 Hero 상세 보기 내용을 DOM에 넣고 중첩된 바인딩을 평가합니다. ngIf 및 ngFor에 대한 자세한 내용은 Directive 구조 페이지 및 템플릿 구문 페이지의 기본 제공 Directive 섹션을 참조하십시오. 선택된 Hero의 스타일선택한 Hero의 세부 정보가 목록 아래에 표시되지만 목록 내에서 선택한 Hero를 식별하는 것은 어렵습니다. 위에서 추가 한 styles 메타 데이터에는 selected라는 사용자 정의 CSS 클래스가 있습니다. 선택한 Hero를 더 잘 보이게 하려면 사용자가 Hero 이름을 클릭하면 이 선택된 클래스를 &lt;li&gt;에 적용합니다. 예를 들어, 사용자가 “Magneta”를 클릭하면 다음과 같이 독특하지만 미묘한 배경색으로 렌더링해야합니다. 템플릿에서 다음 [class.selected] 바인딩을 &lt;li&gt;에 추가합니다. app.component.ts (setting the CSS class)1[class.selected]=\"hero === selectedHero\" 표현식 (hero === selectedHero)가 true 일 때, Angular는 selected CSS 클래스를 추가합니다. 그리고 표현식이 false 일 때 Angular는 selected 클래스를 제거합니다. 템플릿 구문 가이드에서 [class] 바인딩에 대해 자세히 읽어보십시오. &lt;li&gt;의 최종 버전은 다음과 같습니다. app.component.ts (styling each hero)12345&lt;li *ngFor=\"let hero of heroes\" [class.selected]=\"hero === selectedHero\" (click)=\"onSelect(hero)\"&gt; &lt;span class=\"badge\"&gt;&#123;&#123;hero.id&#125;&#125;&lt;/span&gt; &#123;&#123;hero.name&#125;&#125;&lt;/li&gt; “Magneta”를 클릭하면 목록이 다음과 같이 표시됩니다. 다음은 현재의 app.component.ts입니다. src/app/app.component.ts 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100import &#123; Component &#125; from '@angular/core'; export class Hero &#123; id: number; name: string;&#125; const HEROES: Hero[] = [ &#123; id: 11, name: 'Mr. Nice' &#125;, &#123; id: 12, name: 'Narco' &#125;, &#123; id: 13, name: 'Bombasto' &#125;, &#123; id: 14, name: 'Celeritas' &#125;, &#123; id: 15, name: 'Magneta' &#125;, &#123; id: 16, name: 'RubberMan' &#125;, &#123; id: 17, name: 'Dynama' &#125;, &#123; id: 18, name: 'Dr IQ' &#125;, &#123; id: 19, name: 'Magma' &#125;, &#123; id: 20, name: 'Tornado' &#125;]; @Component(&#123; selector: 'my-app', template: ` &lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt; &lt;h2&gt;My Heroes&lt;/h2&gt; &lt;ul class=\"heroes\"&gt; &lt;li *ngFor=\"let hero of heroes\" [class.selected]=\"hero === selectedHero\" (click)=\"onSelect(hero)\"&gt; &lt;span class=\"badge\"&gt;&#123;&#123;hero.id&#125;&#125;&lt;/span&gt; &#123;&#123;hero.name&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;div *ngIf=\"selectedHero\"&gt; &lt;h2&gt;&#123;&#123;selectedHero.name&#125;&#125; details!&lt;/h2&gt; &lt;div&gt;&lt;label&gt;id: &lt;/label&gt;&#123;&#123;selectedHero.id&#125;&#125;&lt;/div&gt; &lt;div&gt; &lt;label&gt;name: &lt;/label&gt; &lt;input [(ngModel)]=\"selectedHero.name\" placeholder=\"name\"/&gt; &lt;/div&gt; &lt;/div&gt; `, styles: [` .selected &#123; background-color: #CFD8DC !important; color: white; &#125; .heroes &#123; margin: 0 0 2em 0; list-style-type: none; padding: 0; width: 15em; &#125; .heroes li &#123; cursor: pointer; position: relative; left: 0; background-color: #EEE; margin: .5em; padding: .3em 0; height: 1.6em; border-radius: 4px; &#125; .heroes li.selected:hover &#123; background-color: #BBD8DC !important; color: white; &#125; .heroes li:hover &#123; color: #607D8B; background-color: #DDD; left: .1em; &#125; .heroes .text &#123; position: relative; top: -3px; &#125; .heroes .badge &#123; display: inline-block; font-size: small; color: white; padding: 0.8em 0.7em 0 0.7em; background-color: #607D8B; line-height: 1em; position: relative; left: -1px; top: -4px; height: 1.8em; margin-right: .8em; border-radius: 4px 0 0 4px; &#125; `]&#125;)export class AppComponent &#123; title = 'Tour of Heroes'; heroes = HEROES; selectedHero: Hero; onSelect(hero: Hero): void &#123; this.selectedHero = hero; &#125;&#125; 어디까지 왔나?이 페이지에서 작업한 내용은 다음과 같습니다. Tour of Heroes 앱은 선택 가능한 Hero의 목록을 표시합니다. Hero를 선택하고 Hero의 상세 보기를 표시하는 기능을 추가했습니다. Component의 템플릿에서 ngIf 및 ngFor라는 기본 제공 Directive를 사용하는 방법을 배웠습니다. 앱은 이 라이브 예제/예제 다운로드와 비슷해야합니다. 앞으로의 여정Tour of Heroes 앱을 확장했지만 아직 완료되지 않았습니다. 일반적인 앱은 하나의 단독 Component를 사용하지 않습니다. 다음 페이지에서는 앱을 하위 Component로 분할하여 함께 사용하게됩니다. 이 내용은 나중에 참고하기 위해 제가 공부하며 정리한 내용입니다.의역, 오역, 직역이 있을 수 있음을 알려드립니다.This post is a translation of this original article [https://angular.io/tutorial/toh-pt2] 참고 Angular 튜토리얼 - 소개 Angular 튜터리얼 - Hero 에디터 Angular 튜터리얼 - 다중 콤포넌트 Angular 튜터리얼 - 서비스 Angular 튜터리얼 - 라우팅 Angular 튜터리얼 - HTTP Angular HttpClient Angular 동적 컴포넌트 로딩","categories":[{"name":"Angular","slug":"Angular","permalink":"http://infoscis.github.io/categories/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://infoscis.github.io/tags/Angular/"}]},{"title":"Angular 튜터리얼 - 소개","slug":"angular-tutorial-introduction","date":"2017-07-21T13:26:30.000Z","updated":"2018-01-27T15:19:54.445Z","comments":true,"path":"2017/07/21/angular-tutorial-introduction/","link":"","permalink":"http://infoscis.github.io/2017/07/21/angular-tutorial-introduction/","excerpt":"","text":"Tutorial: Tour of Heroes이글의 내용은 인력 관리 기관이 Hero들을 안정적으로 관리하는데 도움이 되는 앱을 제작하는 것입니다. Tour of Heroes 앱은 Angular의 기본 핵심 사항을 다룹니다. Hero들 목록을 얻어 표시하고, Hero의 세부 사항을 편집하고, Hero의 영웅적인 데이터를 다양한 관점에서 탐색하는 등, 본격적인 데이터 기반 앱에서 기대할 수 있는 많은 기능을 갖춘 앱을 구축하게됩니다. 기본 제공 Directive를 사용하여 요소를 표시하거나 숨기고, Hero들의 데이터 목록을 표시합니다. Hero의 세부 정보를 표시하고, Hero들의 배열을 표시하는 Component를 만들고, 읽기 전용 데이터에 단방향 데이터 바인딩을 사용하고, 편집 가능한 필드를 추가하여 양방향 데이터 바인딩으로 model을 업데이트합니다. 키스트로크 및 클릭과 같은 사용자 이벤트에 Component 메소드를 바인딩하고, 사용자는 마스터 목록에서 Hero를 선택하고 세부보기에서 Hero를 편집할 수 있습니다. 또한 Pipe로 데이터 서식을 지정할 수 있습니다. 그리고 Hero들을 모으기 위해 공유 서비스를 만들 것입니다. 또한 라우팅을 사용하여 다양한 View와 Component를 탐색합니다. 여러분은 Angular를 시작하기에 충분한 지식을 배울 수 있으며 필요한 모든 것을 할 수 있다는 확신을 얻을수 있습니다. 소개 수준에서 많은 부분을 다룰 것이며 더 깊이있는 페이지로의 많은 링크를 찾을 수 있습니다. 이 튜토리얼을 끝내면 앱은 이 라이브 예제/예제 다운로드 처럼 보일 것입니다. 무엇을 작성하나?다음은 “Dashboard” 보기와 가장 영웅적인 Hero들로 시작하는 이 앱에 대한 시각적 아이디어입니다. Dashboard 위의 두 링크(“Dashboard”및 “Heroes”)를 클릭하여 Dashboard 보기와 Hero들 보기를 탐색할 수 있습니다. Dashboard Hero “Magneta”를 클릭하면 라우터는 Hero의 이름을 변경할 수 있는 “Hero Details” View를 엽니다. “Back” 버튼을 클릭하면 “Dashboard”로 돌아갑니다. 상단의 링크는 주요 보기중 하나를 안내합니다. “Heroes”을 클릭하면 앱에 “Heroes” 마스터 목록이 표시됩니다. 다른 Hero 이름을 클릭하면 목록 아래의 읽기 전용 미니 디테일이 새로운 선택을 반영합니다. “View Details” 버튼을 클릭하면 선택한 Hero의 편집 가능한 세부 정보를 볼 수 있습니다. 다음 다이어그램은 모든 탐색 옵션을 보여줍니다. 실제로 사용중인 앱은 다음과 같습니다. 다음 내용Tour of Heroes앱을 단계별로 제작합니다. 각 단계는 많은 응용 프로그램에서 만날 가능성이 있는 요구 사항에 대한 내용을 포함합니다. 예제를 따라 하다 보면 Angular의 기본 핵심 사항에 대해 많이 알게 될 것입니다. 이제 간단한 Heroes editor를 작성해 보겠습니다. 이 내용은 나중에 참고하기 위해 제가 공부하며 정리한 내용입니다.의역, 오역, 직역이 있을 수 있음을 알려드립니다.This post is a translation of this original article [https://angular.io/tutorial] 참고 Angular 튜터리얼 - Hero 에디터 Angular 튜터리얼 - Master/Detail Angular 튜터리얼 - 다중 콤포넌트 Angular 튜터리얼 - 서비스 Angular 튜터리얼 - 라우팅 Angular 튜터리얼 - HTTP Angular HttpClient Angular 동적 컴포넌트 로딩","categories":[{"name":"Angular","slug":"Angular","permalink":"http://infoscis.github.io/categories/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://infoscis.github.io/tags/Angular/"}]},{"title":"Angular 튜터리얼 - 라우팅","slug":"angular-tutorial-routing","date":"2017-07-21T13:26:30.000Z","updated":"2018-01-27T15:21:46.136Z","comments":true,"path":"2017/07/21/angular-tutorial-routing/","link":"","permalink":"http://infoscis.github.io/2017/07/21/angular-tutorial-routing/","excerpt":"","text":"RoutingTour of Heroes 앱에 대한 새로운 요구 사항이 있습니다. Dashboard View를 추가합니다. Heroes와 대시보드 보기 사이를 Navigation할 수있는 기능을 추가합니다. 사용자가 Hero 이름을 클릭하면 선택한 Hero의 상세보기로 이동합니다. 사용자가 이메일에서 딥 링크를 클릭하면 특정 Hero의 상세 보기를 엽니다. 완료되면 사용자는 다음과 같이 앱을 Navigation할 수 있습니다. 요구 사항을 충족 시키기 위해 Angular의 Router를 앱에 추가합니다. Router에 대한 자세한 내용은 Routing and Navigation 페이지를 참조하십시오. 이 페이지를 끝내면 앱은 이 라이브 예제/예제 다운로드 처럼 보일 것입니다. 어디까지 했었나?Tour of Heroes를 계속하기 전에 다음과 같은 구조인지 확인하십시오. 12345678910111213141516angular-tour-of-heroes ┣ src ┃ ┣ app ┃ ┃ ┣ app.component.ts ┃ ┃ ┣ app.module.ts ┃ ┃ ┣ hero.ts ┃ ┃ ┣ hero-detail.component.ts ┃ ┃ ┣ hero.service.ts ┃ ┃ ┗ mock-heroes.ts ┃ ┣ main.ts ┃ ┣ index.html ┃ ┣ styles.css ┃ ┣ systemjs.config.js ┃ ┗ tsconfig.json ┣ node_modules ... ┗ package.json 앱 실행과 트랜스파일을 유지하기터미널 창에서 다음 명령을 입력하십시오. 1npm start 이 명령은 TypeScript 컴파일러를 “watch mode”에서 실행하여 코드가 변경되면 자동으로 다시 컴파일 하도록합니다. 또한 이 명령은 앱이 브라우저에서 동시에 실행되고 코드가 변경되면 브라우저를 새로 고칩니다. 다시 컴파일하거나 새로 고치지 않고 브라우저를 일시 정지하지 않아 Tour of Heroes 앱을 계속 만들 수 있습니다. Action plan계획은 다음과 같습니다. AppComponent를 Navigation만 처리하는 어플리케이션으로 변경합니다. 현재 AppComponent 내의 Hero들 관심사를 별도의 HeroesComponent로 재배치합니다. Router를 추가합니다. 새로운 DashboardComponent를 생성합니다. 대시보드를 Navigation 구조에 연결합니다. Routing은 Navigation의 또 다른 이름입니다. Router는 View 사이의 Navigation을 위한 메커니즘입니다. AppComponent 분할현재 앱은 AppComponent를 로드하고 즉시 Hero들의 목록을 표시합니다. 수정된 앱은 뷰(Dashboard 및 Heroes)중 하나를 선택하여 표시하고 그중 하나를 기본값으로 설정합니다. AppComponent는 Navigation만 처리 해야하므로, AppComponent에서 Hero들의 디스플레이를 자신의 HeroesComponent로 옮깁니다. HeroesComponentAppComponent는 이미 Hero들 전용입니다. AppComponent에서 코드를 이동하는 대신 HeroesComponent로 이름을 바꾸고 별도의 AppComponent을 만듭니다. 다음을 실행합니다. app.component.ts 파일의 이름을 heroes.component.ts로 변경합니다. AppComponent 클래스의 이름을 HeroesComponent로 변경합니다 (이 파일만). Selector my-app의 이름을 my-heroes로 변경합니다. src/app/heroes.component.ts (showing renamings only) 12345@Component(&#123; selector: 'my-heroes',&#125;)export class HeroesComponent implements OnInit &#123;&#125; AppComponent 생성새로운 AppComponent는 응용 프로그램 Shell입니다. 상단에는 Navigation 링크가 있고 아래에는 표시 영역이 있습니다. 아래 단계를 수행합니다. src/app/app.component.ts 파일을 생성합니다. export될 AppComponent 클래스를 정의합니다. my-app Selector를 사용하여 클래스 위에 @Component Decorator를 추가합니다. HeroesComponent에서 AppComponent로 다음을 이동합니다. title 클래스 프로퍼티 @Component 템플릿 &lt;h1&gt; 엘리먼트는 title의 바인딩을 포함합니다. 제목 바로 아래의 앱 템플릿에 &lt;my-heroes&gt; 엘리먼트를 추가하면 Hero가 계속 표시됩니다. HeroesComponent를 AppModule의 declarations 배열에 추가하여 Angular가 &lt;my-heroes&gt; 태그를 인식하도록합니다. 다른 모든 View에서 HeroService가 필요하기 때문에 HeroService를 AppModule의 providers 배열에 추가합니다. HeroesComponent의 providers 배열에서 HeroService를 제거합니다. AppComponent에 대한 import 문을 추가합니다. 첫 번째 초안은 다음과 같습니다. src/app/app.component.ts (v1)123456789101112import &#123; Component &#125; from '@angular/core'; @Component(&#123; selector: 'my-app', template: ` &lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt; &lt;my-heroes&gt;&lt;/my-heroes&gt; `&#125;)export class AppComponent &#123; title = 'Tour of Heroes';&#125; src/app/app.module.ts (v1)1234567891011121314151617181920212223242526import &#123; NgModule &#125; from '@angular/core';import &#123; BrowserModule &#125; from '@angular/platform-browser';import &#123; FormsModule &#125; from '@angular/forms'; import &#123; AppComponent &#125; from './app.component';import &#123; HeroDetailComponent &#125; from './hero-detail.component';import &#123; HeroesComponent &#125; from './heroes.component';import &#123; HeroService &#125; from './hero.service'; @NgModule(&#123; imports: [ BrowserModule, FormsModule ], declarations: [ AppComponent, HeroDetailComponent, HeroesComponent ], providers: [ HeroService ], bootstrap: [ AppComponent ]&#125;)export class AppModule &#123;&#125; 앱은 계속 실행되고 Hero를 표시할 것입니다. 라우팅 추가하기자동으로 표시하는 대신 사용자가 버튼을 클릭하면 Hero가 표시됩니다. 즉, 사용자는 Hero들의 목록을 Navigate할 수 있어야합니다. Angular Router를 사용하여 Navigation을 활성화합니다. Angular Router는 RouterModule이라고 하는 외부의 선택적 Angular NgModule입니다. Router는 여러개의 제공된 Service(RouterModule), 여러개의 Directive(RouterOutlet, RouterLink, RouterLinkActive) 및 Component(Routes)의 조합입니다. 먼저 라우트를 설정합니다. &lt;base href&gt;index.html을 열고 &lt;head href = &quot;... &quot;&gt; 엘리먼트 (또는 이 엘리먼트를 동적으로 설정하는 스크립트)가 &lt;head&gt;섹션 맨 위에 있는지 확인합니다. src/index.html (base-href) 12&lt;head&gt; &lt;base href=\"/\"&gt; base href는 필수입니다.자세한 내용은 Routing and Navigation 페이지의 base href 설정 섹션을 참조하십시오. 라우트 설정앱 라우트에 대한 설정 파일을 만듭니다. Routes는 사용자가 링크를 클릭하거나, URL을 브라우저 주소 표시 줄에 붙여 넣을 때, 표시할 View를 라우터에 알립니다. Hero들 Component에 대한 라우트를 첫 번째 라우트로 정의합니다. src/app/app.module.ts (heroes route)12345678import &#123; RouterModule &#125; from '@angular/router';RouterModule.forRoot([ &#123; path: 'heroes', component: HeroesComponent &#125;]) Routes는 라우트 정의 배열입니다. 이 라우트 정의에는 다음과 같은 부분이 포함됩니다. Path : Router가 이 라우트의 경로를 브라우저 주소 표시 줄의 URL과 일치시킵니다.(heroes) Component :이 라우트로 이동할 때 Router가 만들어야하는 Component입니다. (HeroesComponent) Routing &amp; Navigation 페이지에서 Routes를 사용하여 라우트를 정의하는 방법에 대해 자세히 알아보십시오. 사용가능한 라우터 만들기RouterModule을 import해서 AppModule의 imports 배열에 추가합니다. src/app/app.module.ts (app routing) 123456789101112131415161718192021222324252627282930313233import &#123; NgModule &#125; from '@angular/core';import &#123; BrowserModule &#125; from '@angular/platform-browser';import &#123; FormsModule &#125; from '@angular/forms';import &#123; RouterModule &#125; from '@angular/router'; import &#123; AppComponent &#125; from './app.component';import &#123; HeroDetailComponent &#125; from './hero-detail.component';import &#123; HeroesComponent &#125; from './heroes.component';import &#123; HeroService &#125; from './hero.service'; @NgModule(&#123; imports: [ BrowserModule, FormsModule, RouterModule.forRoot([ &#123; path: 'heroes', component: HeroesComponent &#125; ]) ], declarations: [ AppComponent, HeroDetailComponent, HeroesComponent ], providers: [ HeroService ], bootstrap: [ AppComponent ]&#125;)export class AppModule &#123;&#125; 설정된 Router가 앱의 루트에 제공되기 때문에 forRoot() 메서드를 호출합니다. forRoot() 메서드는 라우팅에 필요한 Router Service providers와 Directive를 제공하고 현재 브라우저 URL을 기반으로 초기 Navigation을 수행합니다. 라우터 아울렛/heroes Path를 URL의 끝에있는 브라우저 주소창에 추가하면 Router는 그것을 heroes Path와 일치시키고 HeroesComponent를 표시합니다. 하지만 Router에 Component를 표시할 위치를 알려줘야합니다. 이렇게 하기 위해 템플릿 끝에 &lt;router-outlet&gt; 엘리먼트를 추가 합니다. RouterOutlet은 RouterModule이 제공하는 Directive 중 하나입니다. Router는 사용자가 앱을 Navigate할 때 &lt;router-outlet&gt;바로 아래에 각 Component를 표시합니다. 라우터 링크들사용자는 주소 표시 줄에 라우트 URL을 붙여 넣을 필요가 없습니다. 대신 템플릿에 앵커 태그를 추가하여 클릭하면 HeroesComponent에 대한 Navigation이 시작됩니다. 수정된 템플릿은 다음과 같습니다. src/app/app.component.ts (template-v2) 12345template: ` &lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt; &lt;a routerLink=\"/heroes\"&gt;Heroes&lt;/a&gt; &lt;router-outlet&gt;&lt;/router-outlet&gt; ` 앵커 태그의 routerLink 바인딩에 주목하세요. RouterLink Directive (RouterModule의 다른 Directive)는 사용자가 링크를 클릭할 때 Navigate할 위치를 Router에 알려주는 문자열이 바인딩됩니다. 링크가 동적이 아니기 때문에, 라우팅 명령은 라우트 Path에 대한 1회 바인딩으로 정의됩니다. 라우트 설정을 살펴보면 /heroes가 HeroesComponent에 대한 라우트 Path임을 확인할 수 있습니다. Routing &amp; Navigation 페이지의 Appendix: Link Parameters Array 섹션에서 동적 라우터 링크 및 링크 파라미터 배열에 대해 자세히 읽어보십시오. 브라우저를 새로 고칩니다. 브라우저에는 앱 제목과 Hero 링크가 표시되지만 Hero들 목록은 표시되지 않습니다. 브라우저의 주소 표시 줄에 /가 표시됩니다. HeroesComponent 라우트 Path는 /가 아닌 /heroes입니다. 곧 라우트 /와 일치하는 Path를 추가합니다. Heroes Navigation 링크를 클릭하십시오. 주소 표시 줄이 /heroes로 업데이트되고 Heroes 목록이 표시됩니다. AppComponent는 이제 다음과 같습니다. src/app/app.component.ts (v2)12345678910111213import &#123; Component &#125; from '@angular/core'; @Component(&#123; selector: 'my-app', template: ` &lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt; &lt;a routerLink=\"/heroes\"&gt;Heroes&lt;/a&gt; &lt;router-outlet&gt;&lt;/router-outlet&gt; `&#125;)export class AppComponent &#123; title = 'Tour of Heroes';&#125; 이제 AppComponent가 Router에 연결되고 라우트된 View를 표시합니다. 이러한 이유로 다른 Component와 구별하기 위해 이 Component 타입을 Router component라고합니다. Dashboard 추가라우팅은 여러 뷰가 있을 때만 의미가 있습니다. 다른 View를 추가하기 위해 사용자가 Navigate할 수있는 Placeholder DashboardComponent를 만듭니다. src/app/dashboard.component.ts (v1)1234567import &#123; Component &#125; from '@angular/core';@Component(&#123; selector: 'my-dashboard', template: '&lt;h3&gt;My Dashboard&lt;/h3&gt;'&#125;)export class DashboardComponent &#123; &#125; 나중에 이 Component를 보다 유용하게 만들것입니다. Dashboard 라우트 설정app.module.ts를 수정하여 대시 보드로 Navigate 하려면 대시 보드 Component를 가져 와서 다음을 Routes 배열의 정의에 추가합니다. src/app/app.module.ts (Dashboard route)1234&#123; path: 'dashboard', component: DashboardComponent&#125;, 또한 DashboardComponent를 import하고 AppModule의 declarations에 추가합니다. src/app/app.module.ts (dashboard)123456declarations: [ AppComponent, DashboardComponent, HeroDetailComponent, HeroesComponent], Redirect 라우트 추가현재 브라우저는 주소 표시 줄에 /로 시작합니다. 앱이 시작되면 대시 보드가 표시되고 브라우저 주소 표시 줄에 /dashboard URL이 표시됩니다. 이를 가능하게 하기위해 redirect 라우트를 사용합니다. 라우트 정의 배열에 다음을 추가합니다. src/app/app.module.ts (redirect)12345&#123; path: '', redirectTo: '/dashboard', pathMatch: 'full'&#125;, Routing &amp; Navigation 페이지의 Redirecting routes 섹션에서 redirect에 대해 자세히 알아보십시오. Template으로 Navigation 추가Heroes 링크 바로 위의 템플릿에 대시 보드 Navigation 링크를 추가합니다. src/app/app.component.ts (template-v3)12345678template: ` &lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt; &lt;nav&gt; &lt;a routerLink=\"/dashboard\"&gt;Dashboard&lt;/a&gt; &lt;a routerLink=\"/heroes\"&gt;Heroes&lt;/a&gt; &lt;/nav&gt; &lt;router-outlet&gt;&lt;/router-outlet&gt; ` &lt;nav&gt; 태그는 아직 아무 것도하지 않지만 나중에 링크 Style을 지정하면 유용합니다. 브라우저에서 응용 프로그램 루트(/)로 가서 새로고침 합니다. 응용 프로그램은 대시 보드를 표시하고 Dashboard와 Heroes 사이를 Navigation할 수 있습니다. Hero들을 Dashboard에 추가하기대시 보드를 보다 재미있게 만들기 위해 상위 4명의 Heroes을 한눈에 볼 수 있게 수정합니다. template 메타 데이터를 새로운 템플릿 파일을 가리키는 templateUrl 프로퍼티로 변경합니다. src/app/dashboard.component.ts (metadata)1234@Component(&#123; selector: 'my-dashboard', templateUrl: './dashboard.component.html',&#125;) 다음 내용으로 파일을 만듭니다. src/app/dashboard.component.html12345678&lt;h3&gt;Top Heroes&lt;/h3&gt;&lt;div class=\"grid grid-pad\"&gt; &lt;div *ngFor=\"let hero of heroes\" class=\"col-1-4\"&gt; &lt;div class=\"module hero\"&gt; &lt;h4&gt;&#123;&#123;hero.name&#125;&#125;&lt;/h4&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; *ngFor는 Heroes 목록을 반복하고 이름을 표시하는데 다시 사용됩니다. 여분의 &lt;div&gt; 엘리먼트는 나중에 Style을 지정하는데 도움이 됩니다. HeroService 공유하기HeroService를 다시 사용하여 Component의 heroes 배열을 채울수 있습니다. 이전에 HeroesComponent의 providers 배열에서 HeroService를 삭제하고 AppModule의 providers 배열에 추가했습니다. 이 변경으로 앱의 모든 Component에서 사용할 수 있는 싱글톤 HeroService 인스턴스가 생성되었습니다. HeroService를 Angular에서 Injects하기 때문에 DashboardComponent에서 사용할 수 있습니다. Get heroesdashboard.component.ts에 다음 import 문을 추가합니다. src/app/dashboard.component.ts (imports)1234import &#123; Component, OnInit &#125; from '@angular/core';import &#123; Hero &#125; from './hero';import &#123; HeroService &#125; from './hero.service'; 다음과 같이 DashboardComponent 클래스를 만듭니다. src/app/dashboard.component.ts (class)1234567891011export class DashboardComponent implements OnInit &#123; heroes: Hero[] = []; constructor(private heroService: HeroService) &#123; &#125; ngOnInit(): void &#123; this.heroService.getHeroes() .then(heroes =&gt; this.heroes = heroes.slice(1, 5)); &#125;&#125; 이 로직은 HeroesComponent에서도 사용됩니다. heroes 배열 프로퍼티를 정의합니다. 생성자에서 HeroService를 주입받고 private heroService 필드에 할당합니다. Angular ngOnInit() 라이프 사이클 후크에서 Service를 호출하여 Heroes을 얻습니다. 이 Dashboard에서는 Array.slice 메서드로 4명의 Hero들(두 번째, 세 번째, 네 번째 및 다섯 번째)를 지정합니다. 브라우저를 새로 고침하면 새로운 대시 보드에 4명의 Hero 이름이 표시됩니다. Hero 상세보기로 Navigate 하기선택된 Hero의 상세 보기가 HeroesComponent의 하단에 표시되지만, 사용자는 다음과 같은 추가 방법으로 HeroDetailComponent를 Navigate할 수 있어야합니다. 대시 보드부터 선택한 Hero까지 Navigate. Heroes 목록부터 선택한 Hero까지 Navigate. 브라우저 주소창에 붙여 넣은 “딥 링크” URL부터 Navigate. Hero 상세보기로 라우팅 하기다른 라우트가 설정된 app.module.ts의 HeroDetailComponent에 라우트를 추가할 수 있습니다. 새로운 라우트는 어떤 Hero를 보여줘야 하는지 HeroDetailComponent에게 알려줘야 한다는 점에서 특이합니다. HeroesComponent나 DashboardComponent에는 아무것도 알려줄 필요가 없었습니다. 현재 부모 HeroesComponent는 다음과 같은 바인딩을 사용하여 Component의 hero 프로퍼티를 Hero 객체로 설정합니다. 1&lt;hero-detail [hero]=\"selectedHero\"&gt;&lt;/hero-detail&gt; 그러나 이 바인딩은 어떠한 라우팅 시나리오에서도 작동하지 않습니다. Parameterized routeHero의 아이디를 URL에 추가할 수 있습니다. id가 11인 Hero에게 라우팅할 때 다음과 같은 URL을 사용할 수 있습니다. 1/detail/11 URL의 /detail/ 부분은 상수입니다. 후행 숫자 id는 Hero에서 Hero로 바뀝니다. Hero의 id를 나타내는 파라미터 (또는 토큰)로 라우트의 변수 부분을 나타낼 필요가 있습니다. 파라미터를 이용한 라우트 설정다음 라우트 정의를 사용합니다. src/app/app.module.ts (hero detail)1234&#123; path: 'detail/:id', component: HeroDetailComponent&#125;, Path의 콜론(:)은 HeroDetailComponent로 Navigating할 때 :id가 특정 Hero id의 값임을 나타냅니다. 이 라우트를 생성하기 전에 HeroDetailComponent를 import 해야합니다. 앱 라우트가 완성되었습니다. 사용자가 특정 Hero을보기 위해 Navigation 링크를 클릭하지 않기 때문에 템플릿에 &#39;Hero Detail&#39;링크를 추가하지 않았습니다. 이름이 Dashboard에 표시되는지 또는 Hero들 목록에 표시되는지 여부와 관계없이 Hero 이름을 클릭합니다. HeroDetailComponent가 수정되어 Navigate할 준비가될 때까지는 Hero 클릭을 추가할 필요가 없습니다. HeroDetailComponent 변경다음은 HeroDetailComponent의 현재 모습입니다. src/app/hero-detail.component.ts (current)123456789101112131415161718192021import &#123; Component, Input &#125; from '@angular/core';import &#123; Hero &#125; from './hero'; @Component(&#123; selector: 'hero-detail', template: ` &lt;div *ngIf=\"hero\"&gt; &lt;h2&gt;&#123;&#123;hero.name&#125;&#125; details!&lt;/h2&gt; &lt;div&gt; &lt;label&gt;id: &lt;/label&gt;&#123;&#123;hero.id&#125;&#125; &lt;/div&gt; &lt;div&gt; &lt;label&gt;name: &lt;/label&gt; &lt;input [(ngModel)]=\"hero.name\" placeholder=\"name\"/&gt; &lt;/div&gt; &lt;/div&gt; `&#125;)export class HeroDetailComponent &#123; @Input() hero: Hero;&#125; 템플릿은 변경되지 않습니다. Hero 이름도 같은 방식으로 표시됩니다. 주요 변경 사항은 Hero 이름을 얻는 방법에 의해 결정됩니다. 부모 Component 프로퍼티 바인딩에서 Hero을 더이상 받지 않게됩니다. 새로운 HeroDetailComponent는 ActivatedRoute Service의 Observable paramMap에서 id 파라미터를 가져오고 HeroService를 사용하여 해당 id의 Hero을 가져와야합니다. 다음 import를 추가하십시오. src/app/hero-detail.component.ts123456// 지금은 Input import를 유지하지만 나중에는 제거합니다.import &#123; Component, Input, OnInit &#125; from '@angular/core';import &#123; ActivatedRoute, ParamMap &#125; from '@angular/router';import &#123; Location &#125; from '@angular/common';import &#123; HeroService &#125; from './hero.service'; ActivatedRoute, HeroService 및 Location Service를 생성자에서 주입받아 private 필드에 할당합니다. src/app/hero-detail.component.ts (constructor)12345constructor( private heroService: HeroService, private route: ActivatedRoute, private location: Location) &#123;&#125; switchMap 연산자를 가져 와서 나중에 Observable 매개 변수로 사용합니다. src/app/hero-detail.component.ts (switchMap import)1import 'rxjs/add/operator/switchMap'; 클래스에서 OnInit 인터페이스를 구현합니다. src/app/hero-detail.component.ts1export class HeroDetailComponent implements OnInit &#123; ngOnInit() 라이프 사이클 훅 내에서 paramMap Observable을 사용하여 ActivatedRoute 서비스에서 id 파라미터 값을 추출하고 HeroService를 사용하여 그 id를 가진 영웅을 가져옵니다. src/app/hero-detail.component.ts12345ngOnInit(): void &#123; this.route.paramMap .switchMap((params: ParamMap) =&gt; this.heroService.getHero(+params.get('id'))) .subscribe(hero =&gt; this.hero = hero);&#125; switchMap 연산자는 Observable 라우트 파라미터의id를 HeroService.getHero()메소드의 결과인 새로운 Observable에 매핑합니다. getHero 요청이 처리되는 동안 사용자가 이 Component를 다시 탐색하면 switchMap은 이전 요청을 취소한 다음 HeroService.getHero()를 다시 호출합니다. Hero id는 숫자입니다. 라우트 파라미터는 항상 문자열입니다. 따라서 라우트 파라미터는 JavaScript(+) 연산자를 사용하여 숫자로 변환됩니다. 구독 취소(unsubscribe)가 필요합니까?Routing &amp; Navigation 페이지의 라우트 정보에 대한 one-stop-shop인 ActivatedRoute에서 설명한대로 Router는 제공하는 Observable 정보를 관리하고 구독을 Localizes합니다. 구독은 Component가 소멸될 때 정리되어 메모리 누수를 방지하므로 paramMap Observable 라우트에서 구독을 취소할 필요가 없습니다. HeroService.getHero() 추가이전 코드에서 HeroService에는 getHero() 메서드가 없습니다. 이 문제를 해결하려면 HeroService를 열고 getHeroes()에서 Heroes 목록을 id로 필터링하는 getHero() 메서드를 추가합니다. src/app/hero.service.ts (getHero)1234getHero(id: number): Promise&lt;Hero&gt; &#123; return this.getHeroes() .then(heroes =&gt; heroes.find(hero =&gt; hero.id === id));&#125; 뒤로가기 방법 추가사용자는 여러 가지 방법으로 HeroDetailComponent로 Navigate할 수 있습니다. 다른 곳을 Navigate하기 위해, 사용자는 AppComponent의 두 링크 중 하나를 클릭하거나 브라우저의 뒤로 버튼을 클릭할 수 있습니다. 이제 이전에 삽입 한 Location Service를 사용하여 브라우저 히스토리 스택의 한 단계 뒤로 탐색하는goBack() 메서드를 추가합니다. src/app/hero-detail.component.ts (goBack)123goBack(): void &#123; this.location.back();&#125; 너무 멀리 되돌아 가면 사용자가 앱에서 빠져 나올 수 있습니다. 실제 앱에서는 CanDeactivate 가드로 이 문제를 방지할 수 있습니다. CanDeactivate 페이지에서 자세한 내용을 읽어보십시오. 이 메소드를 Component 템플릿에 추가할 Back 버튼에 대한 이벤트 바인딩으로 연결합니다. 1&lt;button (click)=\"goBack()\"&gt;Back&lt;/button&gt; 템플릿을 hero-detail.component.html 파일로 옮깁니다. src/app/hero-detail.component.html12345678910&lt;div *ngIf=\"hero\"&gt; &lt;h2&gt;&#123;&#123;hero.name&#125;&#125; details!&lt;/h2&gt; &lt;div&gt; &lt;label&gt;id: &lt;/label&gt;&#123;&#123;hero.id&#125;&#125;&lt;/div&gt; &lt;div&gt; &lt;label&gt;name: &lt;/label&gt; &lt;input [(ngModel)]=\"hero.name\" placeholder=\"name\" /&gt; &lt;/div&gt; &lt;button (click)=\"goBack()\"&gt;Back&lt;/button&gt;&lt;/div&gt; 방금 만든 템플릿 파일을 가리키는 templateUrl을 사용하여 Component 메타 데이터를 업데이트합니다. src/app/hero-detail.component.ts (metadata)1234@Component(&#123; selector: 'hero-detail', templateUrl: './hero-detail.component.html',&#125;) 브라우저를 새로 고치고 결과를 확인합니다. Dashboard Hero 선택사용자가 대시 보드에서 Hero을 선택하면 앱이 HeroDetailComponent로 이동하여 선택한 Hero을 보고 편집해야합니다. 대시 보드 Hero는 버튼과 같은 블록으로 표시되지만 앵커 태그처럼 행동해야합니다. Hero 블록 위로 마우스를 가져 가면 대상 URL이 브라우저 상태 표시 줄에 표시되고 사용자는 링크를 복사하거나 Hero 상세보기를 새 탭에 열 수 있습니다. 이 효과를 얻으려면 dashboard.component.html을 다시 열고 반복된 &lt;div * ngFor ...&gt;태그를 &lt;a&gt;태그로 수정합니다. 여는 &lt;a&gt;태그를 다음과 같이 변경합니다. src/app/dashboard.component.html (repeated tag)1&lt;a *ngFor=\"let hero of heroes\" [routerLink]=\"['/detail', hero.id]\" class=\"col-1-4\"&gt; [routerLink] 바인딩에 주목하십시오. 이 페이지의 Router 링크 섹션에서 설명했듯이, AppComponent 템플릿의 최상위 Navigation은 목적지 링크 &quot;/dashboard&quot;와 &quot;/heroes&quot;의 고정 경로로 설정된 라우터 링크를 가지고 있습니다. 이번에는 링크 파라미터 배열을 포함하는 표현식에 바인딩됩니다. 배열은 대상 라우트의 Path와 현재 Hero의 id 값으로 설정된 라우트 파라미터라는 두가지 요소를 가지고 있습니다. 두 개의 배열 항목은 이전에 app.module.ts에 추가한 Hero 세부 라우트 정의의 Path와 :id 토큰에 매핑됩니다. src/app/app.module.ts (hero detail)1234&#123; path: 'detail/:id', component: HeroDetailComponent&#125;, 브라우저를 새로 고치고 대시 보드에서 Hero을 선택합니다. 그리고 Hero의 세부 사항을 Navigate합니다. 라우트를 라우팅모듈로 리팩토링AppModule의 약 20개의 라인이 4개의 라우트 구성에 사용됩니다. 대부분의 응용 프로그램에는 더 많은 라우트가 있으며 원하지 않거나 권한이 없는 Navigation을 방지하기 위해 Guard Service가 추가됩니다. Routing &amp; Navigation 페이지의 Route Guards 섹션에서 Guard Service에 대해 자세히 알아보십시오. 라우팅은 모듈을 복잡하게 하고, Angular 컴파일러가 전체 앱에 대한 주요 내용을 판단하는 주된 목적을 불분명하게합니다. 라우팅 구성을 자체 클래스로 리팩토링하는 것이 좋습니다. 현재 RouterModule.forRoot()는 Angular ModuleWithProviders를 생성합니다. 라우팅 전용 클래스는 routing module이어야합니다. 자세한 내용은 Routing &amp; Navigation 페이지의 Milestone #2: Routing Module 섹션을 참조하십시오. 규칙에 따라 라우팅 모듈 이름에는 “Routing”이라는 단어가 포함되어 있으며 Navigate된 Component를 선언하는 모듈의 이름과 맞춰야합니다. app-routing.module.ts 파일을 app.module.ts와 같은 레벨로 만듭니다. AppModule 클래스에서 추출한 다음 내용을 포함합니다. src/app/app-routing.module.ts12345678910111213141516171819import &#123; NgModule &#125; from '@angular/core';import &#123; RouterModule, Routes &#125; from '@angular/router'; import &#123; DashboardComponent &#125; from './dashboard.component';import &#123; HeroesComponent &#125; from './heroes.component';import &#123; HeroDetailComponent &#125; from './hero-detail.component'; const routes: Routes = [ &#123; path: '', redirectTo: '/dashboard', pathMatch: 'full' &#125;, &#123; path: 'dashboard', component: DashboardComponent &#125;, &#123; path: 'detail/:id', component: HeroDetailComponent &#125;, &#123; path: 'heroes', component: HeroesComponent &#125;]; @NgModule(&#123; imports: [ RouterModule.forRoot(routes) ], exports: [ RouterModule ]&#125;)export class AppRoutingModule &#123;&#125; 라우팅 모듈의 일반적인 특징은 다음과 같습니다. 라우팅 모듈은 라우트(경로)를 변수로 가져옵니다. 변수는 나중에 모듈을 export할 경우 라우팅 모듈 패턴을 명확하게합니다. 라우팅 모듈은 import에 RouterModule.forRoot (routes)를 추가합니다. 라우팅 모듈은 RouterModule을 export에 추가하여 사용하는 모듈의 Component가 RouterLink 및 RouterOutlet과 같은 라우터 선언문에 액세스할 수 있도록합니다. declarations이 없습니다. declarations은 사용하는 모듈의 책임입니다. Guard Service가있는 경우 라우팅 모듈은 모듈 providers를 추가합니다. 이 예제에서는 아무 것도 없습니다. Update AppModuleAppModule에서 라우팅 설정을 삭제하고 AppRoutingModule에 가져옵니다. ES2015 import 문을 사용하여 NgModule.imports 목록에 추가합니다. 아래는 리팩토링 전의 상태와 비교한, 수정된 AppModule이 있습니다. src/app/app.module.ts (after)12345678910111213141516171819202122232425262728import &#123; NgModule &#125; from '@angular/core';import &#123; BrowserModule &#125; from '@angular/platform-browser';import &#123; FormsModule &#125; from '@angular/forms'; import &#123; AppComponent &#125; from './app.component';import &#123; DashboardComponent &#125; from './dashboard.component';import &#123; HeroDetailComponent &#125; from './hero-detail.component';import &#123; HeroesComponent &#125; from './heroes.component';import &#123; HeroService &#125; from './hero.service'; import &#123; AppRoutingModule &#125; from './app-routing.module'; @NgModule(&#123; imports: [ BrowserModule, FormsModule, AppRoutingModule ], declarations: [ AppComponent, DashboardComponent, HeroDetailComponent, HeroesComponent ], providers: [ HeroService ], bootstrap: [ AppComponent ]&#125;)export class AppModule &#123; &#125; src/app/app.module.ts (before)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import &#123; NgModule &#125; from '@angular/core';import &#123; BrowserModule &#125; from '@angular/platform-browser';import &#123; FormsModule &#125; from '@angular/forms';import &#123; RouterModule &#125; from '@angular/router'; import &#123; AppComponent &#125; from './app.component';import &#123; HeroDetailComponent &#125; from './hero-detail.component';import &#123; DashboardComponent &#125; from './dashboard.component';import &#123; HeroesComponent &#125; from './heroes.component';import &#123; HeroService &#125; from './hero.service'; @NgModule(&#123; imports: [ BrowserModule, FormsModule, RouterModule.forRoot([ &#123; path: '', redirectTo: '/dashboard', pathMatch: 'full' &#125;, &#123; path: 'dashboard', component: DashboardComponent &#125;, &#123; path: 'detail/:id', component: HeroDetailComponent &#125;, &#123; path: 'heroes', component: HeroesComponent &#125; ]) ], declarations: [ AppComponent, DashboardComponent, HeroDetailComponent, HeroesComponent ], providers: [ HeroService ], bootstrap: [ AppComponent ]&#125;)export class AppModule &#123;&#125; 수정 및 단순화된 AppModule은 앱의 주요 부분을 식별하는데 중점을 둡니다. HeroesComponent에서 Hero 선택HeroesComponent에서 현재 템플릿은 “master/detail” 스타일로 위에 Heroes 목록을 보여주고 아래에 선택된 Hero의 세부 사항을 보여줍니다. src/app/heroes.component.ts (current template)123456789101112template: ` &lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt; &lt;h2&gt;My Heroes&lt;/h2&gt; &lt;ul class=\"heroes\"&gt; &lt;li *ngFor=\"let hero of heroes\" [class.selected]=\"hero === selectedHero\" (click)=\"onSelect(hero)\"&gt; &lt;span class=\"badge\"&gt;&#123;&#123;hero.id&#125;&#125;&lt;/span&gt; &#123;&#123;hero.name&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;hero-detail [hero]=\"selectedHero\"&gt;&lt;/hero-detail&gt;`, 맨 위에있는 &lt;h1&gt;을 삭제합니다. 템플릿의 마지막줄에 있는 &lt;hero-detail&gt; 태그를 삭제합니다. 더 이상 HeroDetailComponent 전체를 표시하지 않습니다. 대신 자신의 페이지에 Hero 상세를 표시하고 대시 보드에서 했던것처럼 Hero 상세를 전달합니다. 그러나 사용자가 목록에서 Hero을 선택하면 상세 보기 페이지로 이동하지 않습니다. 대신이 페이지에서 상세 보기를 볼 수 있으며 전체 상세보기 페이지로 이동하려면 버튼을 클릭해야합니다. mini 상세보기 추가&lt;hero-detail&gt;을 사용되었던 템플릿의 맨 아래에 다음 HTML을 추가합니다. src/app/heroes.component.ts 123456&lt;div *ngIf=\"selectedHero\"&gt; &lt;h2&gt; &#123;&#123;selectedHero.name | uppercase&#125;&#125; is my hero &lt;/h2&gt; &lt;button (click)=\"gotoDetail()\"&gt;View Details&lt;/button&gt;&lt;/div&gt; Hero를 클릭하면 사용자는 Hero들 목록 아래에 다음과 같은 내용을 보게됩니다. uppercase Pipe를 이용한 서식Hero의 이름은 Pipe 연산자 (|) 바로 뒤에있는 uppercase Pipe 때문에 대문자로 표시됩니다. 1&#123;&#123;selectedHero.name | uppercase&#125;&#125; is my hero Pipe는 문자열, 통화 금액, 날짜 및 기타 디스플레이 데이터의 서식을 지정하는 좋은 방법입니다. Angular에서 제공하는 여러가지 Pipe를 사용하거나 직접 작성할 수 있습니다. Pipe에 대한 자세한 내용은 Pipe 페이지를 참조하십시오. Content를 Component 파일 밖으로 이동사용자가 View Details 버튼을 클릭할 때 HeroDetailComponent에 대한 Navigation을 지원하도록 Component 클래스를 업데이트 해야합니다. Component 파일은 큽니다. HTML과 CSS 속에서 컴포넌트 로직을 찾는 것은 어렵습니다. 더 변경하기 전에 템플릿과 Style을 자체 파일로 마이그레이션합니다. 먼저, 템플릿 컨텐츠를 heroes.component.ts에서 새로운 heroes.component.html 파일로 이동합니다. 그러나 백틱은 복사하지 않습니다. heroes.component.ts에 관해서는 잠시 후에 살펴보겠습니다. 다음으로, Style 내용을 새로운 heroes.component.css 파일로 이동합니다. 새로운 두개의 파일은 다음과 같아야합니다. src/app/heroes.component.html1234567891011121314&lt;h2&gt;My Heroes&lt;/h2&gt;&lt;ul class=\"heroes\"&gt; &lt;li *ngFor=\"let hero of heroes\" [class.selected]=\"hero === selectedHero\" (click)=\"onSelect(hero)\"&gt; &lt;span class=\"badge\"&gt;&#123;&#123;hero.id&#125;&#125;&lt;/span&gt; &#123;&#123;hero.name&#125;&#125; &lt;/li&gt;&lt;/ul&gt;&lt;div *ngIf=\"selectedHero\"&gt; &lt;h2&gt; &#123;&#123;selectedHero.name | uppercase&#125;&#125; is my hero &lt;/h2&gt; &lt;button (click)=\"gotoDetail()\"&gt;View Details&lt;/button&gt;&lt;/div&gt; src/app/heroes.component.css1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859.selected &#123; background-color: #CFD8DC !important; color: white;&#125;.heroes &#123; margin: 0 0 2em 0; list-style-type: none; padding: 0; width: 15em;&#125;.heroes li &#123; cursor: pointer; position: relative; left: 0; background-color: #EEE; margin: .5em; padding: .3em 0; height: 1.6em; border-radius: 4px;&#125;.heroes li:hover &#123; color: #607D8B; background-color: #DDD; left: .1em;&#125;.heroes li.selected:hover &#123; background-color: #BBD8DC !important; color: white;&#125;.heroes .text &#123; position: relative; top: -3px;&#125;.heroes .badge &#123; display: inline-block; font-size: small; color: white; padding: 0.8em 0.7em 0 0.7em; background-color: #607D8B; line-height: 1em; position: relative; left: -1px; top: -4px; height: 1.8em; margin-right: .8em; border-radius: 4px 0 0 4px;&#125;button &#123; font-family: Arial; background-color: #eee; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer; cursor: hand;&#125;button:hover &#123; background-color: #cfd8dc;&#125; 이제 heroes.component.ts에 대한 Component 메타 데이터로 돌아가 template과 styles을 삭제하고 각각을 templateUrl과 styleUrls로 수정합니다. 그리고 새로운 파일을 참조하도록 해당 프로퍼티를 변경합니다. src/app/heroes.component.ts (revised metadata)12345@Component(&#123; selector: 'my-heroes', templateUrl: './heroes.component.html', styleUrls: [ './heroes.component.css' ]&#125;) styleUrls 프로퍼티는 Style 파일 이름의 배열입니다 (경로 포함). 필요한 경우 다른 위치의 여러 Style 파일을 나열할 수 있습니다. HeroesComponent 클래스 업데이트HeroesComponent는 버튼 클릭에 대한 응답으로 HeroesDetailComponent로 Navigate합니다. 버튼의 클릭 이벤트는 라우터에게 어디로 가야 하는지를 알려줌으로써 명령형으로 Navigate하는 gotoDetail() 메서드에 묶여있습니다. 이 방법을 사용하려면 Component 클래스를 다음과 같이 변경해야합니다. Angular Router 라이브러리에서 Router를 import합니다. HeroService의 생성자에 Router를 주입합니다. Router의 navigate() 메서드에서 호출할 goDetail() 메서드를 구현합니다. src/app/heroes.component.ts (gotoDetail)123gotoDetail(): void &#123; this.router.navigate(['/detail', this.selectedHero.id]);&#125; DashboardComponent의 [routerLink] 바인딩에서 했던 것처럼 두개의 엘리먼트로된 링크 파라미터 배열 (Path와 라우트 파라미터)을 라우터의 navigate() 메서드에 전달한다는 것에 주의합니다. 아래는 수정된 HeroesComponent 클래스입니다. src/app/heroes.component.ts (class)123456789101112131415161718192021222324export class HeroesComponent implements OnInit &#123; heroes: Hero[]; selectedHero: Hero; constructor( private router: Router, private heroService: HeroService) &#123; &#125; getHeroes(): void &#123; this.heroService.getHeroes().then(heroes =&gt; this.heroes = heroes); &#125; ngOnInit(): void &#123; this.getHeroes(); &#125; onSelect(hero: Hero): void &#123; this.selectedHero = hero; &#125; gotoDetail(): void &#123; this.router.navigate(['/detail', this.selectedHero.id]); &#125;&#125; 브라우저를 새로 고침하고 클릭합니다. 사용자는 Dashboard에서 Hero 상세보기, Heroes 목록에서 상세보기, Hero 상세보기, 다시 Heroes 목록으로 돌아갈 수 있습니다. 이 페이지에서 추가한 모든 Navigation 요구 사항을 충족했습니다. 앱 Style앱은 기능적이지만 Style이 필요합니다. 대시 보드 Hero는 사각형 row로 표시되어야합니다. 반응형 디자인을 위한 간단한 미디어 쿼리를 포함하여 약 60 줄의 CSS를 이 용도로 사용했습니다. 알다시피, CSS를 styles 메타 데이터에 추가하면 Component 로직이 흐려집니다. 대신 CSS를 별도의 .css 파일로 저장합니다. dashboard.component.css 파일을 app 폴더에 추가하고 Component 메타 데이터의 styleUrls 배열 프로퍼티에서 다음과 같이 이 파일을 참조합니다. src/app/dashboard.component.ts (styleUrls)1styleUrls: [ './dashboard.component.css' ] Hero 상세보기에 Style 추가또한 HeroDetailComponent 용 CSS Style을 제공합니다. hero-detail.component.css를 app 폴더에 추가하고 styleUrls 배열 안에 DashboardComponent에서 했던 것처럼 참조를 추가합니다. 또한 hero-detail.component.ts에서 hero 프로퍼티의 @Input Decorator와 import를 제거합니다. 다음은 Component의 CSS 파일 내용입니다. src/app/hero-detail.component.css 1234567891011121314151617181920212223242526272829label &#123; display: inline-block; width: 3em; margin: .5em 0; color: #607D8B; font-weight: bold;&#125;input &#123; height: 2em; font-size: 1em; padding-left: .4em;&#125;button &#123; margin-top: 20px; font-family: Arial; background-color: #eee; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer; cursor: hand;&#125;button:hover &#123; background-color: #cfd8dc;&#125;button:disabled &#123; background-color: #eee; color: #ccc; cursor: auto;&#125; src/app/dashboard.component.css 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061[class*='col-'] &#123; float: left; padding-right: 20px; padding-bottom: 20px;&#125;[class*='col-']:last-of-type &#123; padding-right: 0;&#125;a &#123; text-decoration: none;&#125;*, *:after, *:before &#123; -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box;&#125;h3 &#123; text-align: center; margin-bottom: 0;&#125;h4 &#123; position: relative;&#125;.grid &#123; margin: 0;&#125;.col-1-4 &#123; width: 25%;&#125;.module &#123; padding: 20px; text-align: center; color: #eee; max-height: 120px; min-width: 120px; background-color: #607D8B; border-radius: 2px;&#125;.module:hover &#123; background-color: #EEE; cursor: pointer; color: #607d8b;&#125;.grid-pad &#123; padding: 10px 0;&#125;.grid-pad &gt; [class*='col-']:last-of-type &#123; padding-right: 20px;&#125;@media (max-width: 600px) &#123; .module &#123; font-size: 10px; max-height: 75px; &#125;&#125;@media (max-width: 1024px) &#123; .grid &#123; margin: 0; &#125; .module &#123; min-width: 60px; &#125;&#125; Navigation 링크들에 Style 적용제공된 CSS는 AppComponent의 Navigation 링크를 선택 가능한 버튼과 비슷하게 만듭니다. 이러한 링크는 &lt;nav&gt;태그로 감싸도록 하겠습니다. 다음 내용으로 app.component.css 파일을 app 폴더에 추가합니다. src/app/app.component.css (navigation styles) 12345678910111213141516171819202122232425262728h1 &#123; font-size: 1.2em; color: #999; margin-bottom: 0;&#125;h2 &#123; font-size: 2em; margin-top: 0; padding-top: 0;&#125;nav a &#123; padding: 5px 10px; text-decoration: none; margin-top: 10px; display: inline-block; background-color: #eee; border-radius: 4px;&#125;nav a:visited, a:link &#123; color: #607D8B;&#125;nav a:hover &#123; color: #039be5; background-color: #CFD8DC;&#125;nav a.active &#123; color: #039be5;&#125; The routerLinkActive directiveAngular Router는 routerLinkActive Directive를 사용하여 라우트가 활성 라우트와 일치하는 HTML 탐색 요소에 클래스를 추가할 수 있습니다. 해야할 일은 Style을 정의하는 것뿐입니다. src/app/app.component.ts (active router links)12345678template: ` &lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt; &lt;nav&gt; &lt;a routerLink=\"/dashboard\" routerLinkActive=\"active\"&gt;Dashboard&lt;/a&gt; &lt;a routerLink=\"/heroes\" routerLinkActive=\"active\"&gt;Heroes&lt;/a&gt; &lt;/nav&gt; &lt;router-outlet&gt;&lt;/router-outlet&gt;`, 다음과 같이 이 CSS 파일을 참조하는 styleUrls 프로퍼티를 추가합니다. src/app/app.component.ts1styleUrls: ['./app.component.css'], 전체 앱 StyleComponent에 Style을 추가하면 Component가 필요로하는 것을 HTML, CSS 및 코드 한 곳에 편리하게 보관할 수 있습니다. 패키지로 만들면 Component를 다른 곳에서 재사용하기 쉽습니다. Component 외부의 응용 프로그램 레벨에서 Style을 만들 수도 있습니다. 디자이너는 전체 앱의 엘리먼트에 적용할 수 있는 기본 Style을 제공합니다. 이는 setup 중 이전에 설치 한 전체 마스터 Style 세트에 해당합니다. 다음은 일부 발췌한 내용입니다. src/styles.css (excerpt)12345678910111213141516171819202122/* Master Styles */h1 &#123; color: #369; font-family: Arial, Helvetica, sans-serif; font-size: 250%;&#125;h2, h3 &#123; color: #444; font-family: Arial, Helvetica, sans-serif; font-weight: lighter;&#125;body &#123; margin: 2em;&#125;body, input[text], button &#123; color: #888; font-family: Cambria, Georgia;&#125;/* everywhere else */* &#123; font-family: Arial, Helvetica, sans-serif;&#125; styles.css 파일을 만듭니다. 파일에 여기에 제공된 마스터 Style을 포함합니다. 이 Style 시트를 참조하려면 index.html도 편집합니다. src/index.html (link ref)1&lt;link rel=\"stylesheet\" href=\"styles.css\"&gt; 지금 앱을 보면 대시 보드, Hero 및 Navigation 링크 Style이 지정되어 있습니다. Application 구조와 코드이 예제 페이지의 라이브 예제/예제 다운로드에서 샘플 소스 코드를 확인하십시오. 다음과 같은 구조인지 확인하십시오. 12345678910111213141516171819202122232425angular-tour-of-heroes ┣ src ┃ ┣ app ┃ ┃ ┣ app.component.ts ┃ ┃ ┣ app.module.ts ┃ ┃ ┣ app-routing.module.ts ┃ ┃ ┣ dashboard.component.css ┃ ┃ ┣ dashboard.component.html ┃ ┃ ┣ dashboard.component.ts ┃ ┃ ┣ hero.service.ts ┃ ┃ ┣ hero.ts ┃ ┃ ┣ hero-detail.component.css ┃ ┃ ┣ hero-detail.component.html ┃ ┃ ┣ hero-detail.component.ts ┃ ┃ ┣ heroes.component.css ┃ ┃ ┣ heroes.component.html ┃ ┃ ┣ heroes.component.ts ┃ ┃ ┗ mock-heroes.ts ┃ ┣ main.ts ┃ ┣ index.html ┃ ┣ styles.css ┃ ┣ systemjs.config.js ┃ ┗ tsconfig.json ┣ node_modules ... ┗ package.json 어디까지 했나?이 페이지에서 얻은 결과는 다음과 같습니다. 각기 다른 Component를 Navigate하기 위해 Angular Router를 추가했습니다. 탐색 메뉴 항목을 나타내는 라우터 링크를 만드는 방법을 배웠습니다. 라우터 링크 파라미터를 사용하여 사용자가 선택한 Hero의 상세보기를 탐색했습니다. 여러 Component간에 HeroService를 공유했습니다. HTML과 CSS를 컴포넌트 파일에서 자신의 파일로 옮겼습니다. 데이터 서식을 지정하기 위해 uppercase Pipe를 추가했습니다. 앱은 이 라이브 예제/예제 다운로드와 비슷해야합니다. 앞으로의 여정앱을 제작하는데 기초가 많이 필요합니다. 중요한 원격 데이터 액세스에 대한 부분이 빠져있습니다. 다음 튜토리얼 페이지에서 Mock 데이터를 http를 사용하여 서버에서 검색한 데이터로 바꿀것이다. 이 내용은 나중에 참고하기 위해 제가 공부하며 정리한 내용입니다.의역, 오역, 직역이 있을 수 있음을 알려드립니다.This post is a translation of this original article [https://angular.io/tutorial/toh-pt5] 참고 Angular 튜토리얼 - 소개 Angular 튜터리얼 - Hero 에디터 Angular 튜터리얼 - Master/Detail Angular 튜터리얼 - 다중 콤포넌트 Angular 튜터리얼 - 서비스 Angular 튜터리얼 - HTTP Angular HttpClient Angular 동적 컴포넌트 로딩","categories":[{"name":"Angular","slug":"Angular","permalink":"http://infoscis.github.io/categories/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://infoscis.github.io/tags/Angular/"}]},{"title":"Angular 튜터리얼 - 서비스","slug":"angular-tutorial-services","date":"2017-07-21T13:26:30.000Z","updated":"2018-01-27T15:22:51.340Z","comments":true,"path":"2017/07/21/angular-tutorial-services/","link":"","permalink":"http://infoscis.github.io/2017/07/21/angular-tutorial-services/","excerpt":"","text":"ServicesTour of Heroes 앱이 발전함에 따라 Hero 데이터에 액세스 해야하는 더 많은 Component가 추가됩니다. 동일한 코드를 반복해서 복사후 붙여 넣는 대신 재사용 가능한 단일 데이터 Service를 만들어 필요한 Component에 삽입합니다. 별도의 Service를 사용하면 Component를 간결하게 유지하고 View 지원에 주력할 수 있으며 Mock Service로 Component 테스트를 쉽게 수행할 수 있습니다. 데이터 Service는 언제나 비동기식이므로 Promise 기반 버전의 데이터 서비스로 페이지를 마무리합니다. 이 페이지를 끝내면 앱은 이 라이브 예제/예제 다운로드 처럼 보일 것입니다. 어디까지 했었나?Tour of Heroes를 계속하기 전에 다음과 같은 구조인지 확인하십시오. 그렇지 않은 경우 이전 페이지로 돌아갑니다. 1234567891011121314angular-tour-of-heroes ┣ src ┃ ┣ app ┃ ┃ ┣ app.component.ts ┃ ┃ ┣ app.module.ts ┃ ┃ ┣ hero.ts ┃ ┃ ┗ hero-detail.component.ts ┃ ┣ main.ts ┃ ┣ index.html ┃ ┣ styles.css ┃ ┣ systemjs.config.js ┃ ┗ tsconfig.json ┣ node_modules ... ┗ package.json 앱 실행과 트랜스파일을 유지하기터미널 창에서 다음 명령을 입력하십시오. 1npm start 이 명령은 TypeScript 컴파일러를 “watch mode”에서 실행하여 코드가 변경되면 자동으로 다시 컴파일 하도록합니다. 또한 이 명령은 앱이 브라우저에서 동시에 실행되고 코드가 변경되면 브라우저를 새로 고칩니다. 다시 컴파일하거나 새로 고치지 않고 브라우저를 일시 정지하지 않아 Tour of Heroes 앱을 계속 만들 수 있습니다. Hero service 생성하기이해 관계자들은 다양한 페이지에서 Hero들을 다양한 방식으로 보여주기를 원합니다. 사용자는 이미 목록에서 Hero를 선택할 수 있습니다. 조만간 최고 실적 Hero 들과 함께 Dashboard를 추가하고 Hero 세부 사항을 편집할 수 있는 별도의 보기를 만듭니다. 세 가지 모두 Hero 데이터가 필요합니다. 현재, AppComponent는 표시용 Mock Hero들을 정의합니다. 그러나 Hero들을 정의하는 것은 Component의 임무가 아니며 Hero들 목록을 다른 Component 및 View와 쉽게 공유할 수 없습니다. 이 페이지에서 Hero들 데이터 수집 비즈니스를 데이터를 제공하는 하나의 Service로 옮기고 해당 Service를 데이터가 필요한 모든 Component와 공유합니다. HeroService 생성app 폴더에 hero.service.ts라는 파일을 만듭니다. 서비스 파일의 명명 규칙은 소문자로된 Service 이름과 .service입니다. 다중 단어 Service 이름의 경우 대시 - 소문자를 사용합니다. 예를 들어, SpecialSuperHeroService의 파일 이름은 special-super-hero.service.ts입니다. 클래스 이름을 HeroService로 지정하고 다른 곳에서 import할 수 있도록 export 합니다. src/app/hero.service.ts (starting point)12345import &#123; Injectable &#125; from '@angular/core';@Injectable()export class HeroService &#123;&#125; Injectable 서비스Angular Injectable 함수를 가져 와서 이 함수에 @Injectable()` Decorator를 적용했습니다. 1괄호를 잊마세요. 괄호를 생략하면 진단하기 어려운 오류가 발생합니다. @Injectable() Decorator는 TypeScript가 Service에 대한 메타 데이터를 내보내도록 지시합니다. 메타 데이터는 Angular가 이 Service에 다른 종속성을 주입해야할 수도 있음을 나타냅니다. HeroService는 현재 종속성이 없지만 처음부터 @Injectable() Decorator를 적용하면 일관성이 있고 미래에 대한 보장이 됩니다. Hero 데이터 가져오기getHeroes () 메소드 스텁을 추가합니다. src/app/hero.service.ts (getHeroes stub)1234@Injectable()export class HeroService &#123; getHeroes(): void &#123;&#125; // stub&#125; HeroService는 웹 서비스, 로컬 스토리지 또는 Mock 데이터 소스와 같이 어디서나 Hero 데이터를 가져올 수 있습니다. Component에서 데이터 액세스를 제거하면 Hero 데이터가 필요한 Component를 건드리지 않고도 언제든지 implementation에 대한 생각을 바꿀 수 있습니다. Mock hero 데이터 이동app.component.ts에서 HEROES 배열을 잘라내어 mock-heroes.ts라는 app 폴더의 새로운 파일에 붙여 넣으십시오. 또한 Heroes 배열은 Hero 클래스를 사용하기 때문에 import {Hero} ...문을 복사하십시오. src/app/mock-heroes.ts 1234567891011121314import &#123; Hero &#125; from './hero'; export const HEROES: Hero[] = [ &#123; id: 11, name: 'Mr. Nice' &#125;, &#123; id: 12, name: 'Narco' &#125;, &#123; id: 13, name: 'Bombasto' &#125;, &#123; id: 14, name: 'Celeritas' &#125;, &#123; id: 15, name: 'Magneta' &#125;, &#123; id: 16, name: 'RubberMan' &#125;, &#123; id: 17, name: 'Dynama' &#125;, &#123; id: 18, name: 'Dr IQ' &#125;, &#123; id: 19, name: 'Magma' &#125;, &#123; id: 20, name: 'Tornado' &#125;]; HEROES 상수는 HeroService와 같이 다른 곳에서 import할 수 있도록 export됩니다. HEROES 배열을 잘라낸 app.component.ts에는 초기화되지 않은 heroes 프로퍼티를 추가합니다. src/app/app.component.ts (heroes property)1heroes: Hero[]; Mock hero 데이터 리턴HeroService로 돌아가서 Mock HEROES을 가져 와서 getHeroes() 메서드에서 리턴합니다. HeroService는 다음과 같습니다. src/app/hero.service.ts1234567891011import &#123; Injectable &#125; from '@angular/core';import &#123; Hero &#125; from './hero';import &#123; HEROES &#125; from './mock-heroes';@Injectable()export class HeroService &#123; getHeroes(): Hero[] &#123; return HEROES; &#125;&#125; Hero service import하기AppComponent로 시작하는 다른 Component에서 HeroService를 사용할 준비가 되었습니다. HeroService를 import해서 참조합니다. src/app/app.component.ts (hero-service-import)1import &#123; HeroService &#125; from './hero.service'; HeroService를 new로 사용하지 마세요AppComponent는 어떻게 런타임에 HeroService의 인스턴스를 획득할수 있을까요? 다음과 같이 HeroService의 새 인스턴스를 new로 만들 수 있습니다. src/app/app.component.ts1heroService = new HeroService(); // don't do this 그러나 이 옵션은 다음과 같은 이유로 이상적이지 않습니다. Component는 HeroService를 만드는 방법을 알아야합니다. HeroService 생성자를 변경하면 Service를 생성한 모든곳을 찾아서 업데이트해야합니다. 여러 곳에서 코드를 패치하는 것은 오류가 발생하기 쉽고 테스트 부담이 가중됩니다. new를 사용할 때마다 Service를 만듭니다. Service가 다른 곳에서 Hero를 cache되고 그렇게 cache되는 Hero가 공유된다면 어떨까요? new로 생성되는 Service는 그렇게 할 수 없습니다. AppComponent가 HeroService의 특정 구현에 고정되어 있기 때문에, 오프라인으로 작동하거나 테스트를 위해 다른 Mock 버전을 사용하는 것과 같은 다른 시나리오에 대한 구현을 전환하는 것은 어려울 수 있습니다. Inject the HeroServicenew를 사용하는 대신 아래의 내용을 추가합니다. private 프로퍼티를 정의하는 생성자를 추가합니다. Component의 providers 메타 데이터에 추가합니다. 생성자를 추가합니다. src/app/app.component.ts (constructor)1constructor(private heroService: HeroService) &#123; &#125; 생성자 자체는 아무 것도하지 않습니다. 파라미터는 private heroService 프로퍼티를 정의하고 HeroService 주입 대상으로 식별합니다. 이제 Angular는 AppComponent를 생성할 때 HeroService의 인스턴스를 제공하는 것을 알고 있습니다. 의존성 주입 페이지에서 의존성 주입에 대해 자세히 읽어보십시오. Injector HeroService를 만드는 방법을 아직 모릅니다. 이 코드를 지금 실행 하면 아래와 같은 오류로 인해 Angular가 실패합니다. 1EXCEPTION: No provider for HeroService! (AppComponent -&gt; HeroService) Injector에게 HeroService를 만드는 법을 알려주기 위해 @Component 호출의 Component 메타 데이터의 아래에 다음 providers 배열 프로퍼티를 추가합니다. src/app/app.component.ts (providers)1providers: [HeroService] providers 배열은 Angular에게 AppComponent를 생성할 때 HeroService의 새로운 인스턴스를 생성하도록 지시합니다. AppComponent와 그 자식 Component는 그 Service를 사용하여 Hero 데이터를 얻을 수 있습니다. AppComponent 안의 getHeroes() 함수Service는 private heroService 변수에 있습니다. 한 줄로 서비스를 호출하고 데이터를 가져올 수 있습니다. src/app/app.component.ts1this.heroes = this.heroService.getHeroes(); 실제로 한 줄을 감싸는 전용 메서드가 필요하지 않지만 작성합니다. src/app/app.component.ts (getHeroes)123getHeroes(): void &#123; this.heroes = this.heroService.getHeroes();&#125; ngOnInit lifecycle hookAppComponent는 Hero 데이터를 가져와 표시합니다. 생성자에서 getHeroes() 메서드를 호출하는 유혹을 받을 수도 있지만, 생성자는 복잡한 로직, 특히 데이터 액세스 메소드와 같이 서버를 호출하는 로직을 포함해서는 안됩니다. 생성자는 프로퍼티를 생성자 파라미터와 연결하는 것과 같은 간단한 초기화를 위한 것입니다. Angular에서 getHeroes()를 사용하게 하기위해 Angular ngOnInit 라이프 사이클 훅을 구현할 수 있습니다. Angular는 Component 라이프 사이클의 중요한 순간 즉, 생성, 변경, 최종 파괴시의 작업을 위한 인터페이스를 제공합니다. 각 인터페이스별로 하나의 메서드를 지원합니다. Component가 해당 메서드를 구현하면 적절한 시간에 Angular가 메서드를 호출합니다. Lifecycle Hooks 페이지에서 라이프 사이클 후크에 대해 자세히 읽어보십시오. 다음은 OnInit 인터페이스의 핵심 개요입니다(이것을 코드에 복사하지 마십시오). src/app/app.component.ts123456import &#123; OnInit &#125; from '@angular/core';export class AppComponent implements OnInit &#123; ngOnInit(): void &#123; &#125;&#125; OnInit 인터페이스에 대한 구현을 export 문에 추가합니다. 1export class AppComponent implements OnInit &#123;&#125; 내부에 초기화 로직을 가진 ngOnInit 메소드를 작성합니다. Angular는 적당한 시각에 getHeroes() 를 호출하여 초기화합니다. src/app/app.component.ts (ng-on-init)123ngOnInit(): void &#123; this.getHeroes();&#125; 앱이 실행되고 예상대로 Hero 이름을 클릭하면 Hero들 목록과 Hero 상세보기가 표시됩니다. Async services and PromisesHeroService는 Mock Heroes의 목록을 즉시 반환합니다; 그것의 getHeroes()가 동기식이기 때문입니다. src/app/app.component.ts1this.heroes = this.heroService.getHeroes(); 결국, Heroes 데이터는 원격 서버에서 가져옵니다. 원격 서버를 사용할 때 사용자는 서버가 응답할 때까지 기다릴 필요가 없습니다. 또한 대기 중에는 UI를 차단할 수 없습니다. 응답에 따라 View를 조정하기 위해 Promise를 사용할 수 있습니다. 이것은 getHeroes() 메서드를 변경하는 비동기 방법입니다. Hero 서비스를 Promise로 만들기Promise는 본질적으로 결과가 준비될 때 콜백할 것을 약속합니다. 비동기 Service에 작업을 수행하고 콜백 기능을 제공하도록 요청합니다. Service는 그 작업을 수행하고 결과 또는 오류 함수를 호출합니다. 이것은 간단한 설명입니다. Exploring ES6의 ES2015 비동기 프로그래밍 Promise 페이지에서 Promise에 대해 자세히 읽어보십시오. Promise를 반환하는 getHeroes() 메서드로 HeroService를 업데이트합니다. src/app/hero.service.ts (excerpt)123getHeroes(): Promise&lt;Hero[]&gt; &#123; return Promise.resolve(HEROES);&#125; 여전히 Mock 데이터를 사용하고 있습니다. 결과적으로 Mock Hero를 이용해 즉시 Resolve된 Promise를 반환하여 초고속, 제로 레이턴시 서버의 동작을 시뮬레이션합니다. Act on the PromiseHeroService를 수정하여 this.heroes는 이제 Heroes의 배열이 아닌 Promise로 설정되었습니다. src/app/app.component.ts (getHeroes - old) 123getHeroes(): void &#123; this.heroes = this.heroService.getHeroes();&#125; Resolve될 때 Promise에 맞춰 구현을 변경해야합니다. Promise가 성공적으로 Resolve되면, 여러분은 Heroes를 보여줄 수 있습니다. 콜백 함수를 Promise then() 메서드의 파라미터로 전달합니다. src/app/app.component.ts (getHeroes - revised)123getHeroes(): void &#123; this.heroService.getHeroes().then(heroes =&gt; this.heroes = heroes);&#125; Arrow 함수에서 설명한 것처럼 콜백의 ES2015 Arrow 함수는 동등한 다른 함수 표현식보다 간결하며 this를 정상적으로 처리합니다. 콜백은 Component의 heroes 프로퍼티를 Service가 반환한 heroes 배열에 설정합니다. 앱이 아직 여전히 실행 중입니다. Hero들 목록을 표시하고 이름을 선택할 경우 상세보기를 보여줍니다. 이 페이지의 끝에서 [부록 : 느린 속도]를 이용하면 연결 상태가 좋지 않은 응용 프로그램의 모습을 보여줍니다. 앱 구조 리뷰모든 리팩토링 후에 다음 구조를 가지고 있는지 확인합니다. 12345678910111213141516angular-tour-of-heroes ┣ src ┃ ┣ app ┃ ┃ ┣ app.component.ts ┃ ┃ ┣ app.module.ts ┃ ┃ ┣ hero.ts ┃ ┃ ┣ hero-detail.component.ts ┃ ┃ ┣ hero.service.ts ┃ ┃ ┗ mock-heroes.ts ┃ ┣ main.ts ┃ ┣ index.html ┃ ┣ styles.css ┃ ┣ systemjs.config.js ┃ ┗ tsconfig.json ┣ node_modules ... ┗ package.json 이 문서에서 설명하는 코드 파일은 다음과 같습니다. src/app/hero.service.ts1234567891011mport &#123; Injectable &#125; from '@angular/core';import &#123; Hero &#125; from './hero';import &#123; HEROES &#125; from './mock-heroes';@Injectable()export class HeroService &#123; getHeroes(): Promise&lt;Hero[]&gt; &#123; return Promise.resolve(HEROES); &#125;&#125; src/app/app.component.ts1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889import &#123; Component, OnInit &#125; from '@angular/core'; import &#123; Hero &#125; from './hero';import &#123; HeroService &#125; from './hero.service'; @Component(&#123; selector: 'my-app', template: ` &lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt; &lt;h2&gt;My Heroes&lt;/h2&gt; &lt;ul class=\"heroes\"&gt; &lt;li *ngFor=\"let hero of heroes\" [class.selected]=\"hero === selectedHero\" (click)=\"onSelect(hero)\"&gt; &lt;span class=\"badge\"&gt;&#123;&#123;hero.id&#125;&#125;&lt;/span&gt; &#123;&#123;hero.name&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;hero-detail [hero]=\"selectedHero\"&gt;&lt;/hero-detail&gt; `, styles: [` .selected &#123; background-color: #CFD8DC !important; color: white; &#125; .heroes &#123; margin: 0 0 2em 0; list-style-type: none; padding: 0; width: 15em; &#125; .heroes li &#123; cursor: pointer; position: relative; left: 0; background-color: #EEE; margin: .5em; padding: .3em 0; height: 1.6em; border-radius: 4px; &#125; .heroes li.selected:hover &#123; background-color: #BBD8DC !important; color: white; &#125; .heroes li:hover &#123; color: #607D8B; background-color: #DDD; left: .1em; &#125; .heroes .text &#123; position: relative; top: -3px; &#125; .heroes .badge &#123; display: inline-block; font-size: small; color: white; padding: 0.8em 0.7em 0 0.7em; background-color: #607D8B; line-height: 1em; position: relative; left: -1px; top: -4px; height: 1.8em; margin-right: .8em; border-radius: 4px 0 0 4px; &#125; `], providers: [HeroService]&#125;)export class AppComponent implements OnInit &#123; title = 'Tour of Heroes'; heroes: Hero[]; selectedHero: Hero; constructor(private heroService: HeroService) &#123; &#125; getHeroes(): void &#123; this.heroService.getHeroes().then(heroes =&gt; this.heroes = heroes); &#125; ngOnInit(): void &#123; this.getHeroes(); &#125; onSelect(hero: Hero): void &#123; this.selectedHero = hero; &#125;&#125; src/app/mock-heroes.ts1234567891011121314import &#123; Hero &#125; from './hero'; export const HEROES: Hero[] = [ &#123; id: 11, name: 'Mr. Nice' &#125;, &#123; id: 12, name: 'Narco' &#125;, &#123; id: 13, name: 'Bombasto' &#125;, &#123; id: 14, name: 'Celeritas' &#125;, &#123; id: 15, name: 'Magneta' &#125;, &#123; id: 16, name: 'RubberMan' &#125;, &#123; id: 17, name: 'Dynama' &#125;, &#123; id: 18, name: 'Dr IQ' &#125;, &#123; id: 19, name: 'Magma' &#125;, &#123; id: 20, name: 'Tornado' &#125;]; 어디까지 했나?이 문서에서 공부한 내용은 다음과 같습니다. 여러 Component가 공유할 수있는 Service 클래스를 만들었습니다. AppComponent가 활성화될 때 ngOnInit 라이프 사이클 후크를 사용하여 Hero 데이터를 가져 왔습니다. HeroService를 AppComponent의 providers로 정의했습니다. Mock Hero들 데이터를 생성하여 Service로 가져 왔습니다. Service가 Promise를 리턴하도록 설계했으며, Component는 Promise에서 데이터를 가져오도록 했습니다. 앱은 이 라이브 예제/예제 다운로드와 비슷해야합니다. 앞으로의 여정Tour of Heroes는 Component 및 공유 Service를 사용하여 재사용이 편하게 되었습니다. 다음 목표는 대시 보드를 작성하고, View 사이에 라우트하는 메뉴의 링크를 추가하고, 템플릿에서 데이터를 규격화하는 것입니다. 앱이 발전함에 따라 앱을 쉽게 디자인하여 확장 및 유지 관리하는 방법을 발견하게됩니다. 다음 튜토리얼 페이지에서 Angular Component Router 및 View 사이의 탐색에 대해 읽어보십시오. Appendix: 천천히 가져오기느린 연결을 시뮬레이트하려면 Hero 심볼을 가져 와서 HeroService에 getHeroesSlowly() 메서드를 추가하십시오. app/hero.service.ts (getHeroesSlowly) 123456getHeroesSlowly(): Promise&lt;Hero[]&gt; &#123; return new Promise(resolve =&gt; &#123; // Simulate server latency with 2 second delay setTimeout(() =&gt; resolve(this.getHeroes()), 2000); &#125;);&#125; getHeroes()처럼 Promise를 리턴합니다. 하지만 이 Promise는 Mock Heroes에서 Promise를 해결하기 전에 2초를 기다립니다. AppComponent로 돌아가서, getHeroes()를 getHeroesSlowly()로 대체하고 어떻게 동작하는지보십시오. 이 내용은 나중에 참고하기 위해 제가 공부하며 정리한 내용입니다.의역, 오역, 직역이 있을 수 있음을 알려드립니다.This post is a translation of this original article [https://angular.io/tutorial/toh-pt4] 참고 Angular 튜토리얼 - 소개 Angular 튜터리얼 - Hero 에디터 Angular 튜터리얼 - Master/Detail Angular 튜터리얼 - 다중 콤포넌트 Angular 튜터리얼 - 라우팅 Angular 튜터리얼 - HTTP Angular HttpClient Angular 동적 컴포넌트 로딩","categories":[{"name":"Angular","slug":"Angular","permalink":"http://infoscis.github.io/categories/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://infoscis.github.io/tags/Angular/"}]},{"title":"Angular 튜터리얼 - Hero 에디터","slug":"angular-tutorial-the-hero-editor","date":"2017-07-21T13:26:30.000Z","updated":"2018-01-27T15:22:49.083Z","comments":true,"path":"2017/07/21/angular-tutorial-the-hero-editor/","link":"","permalink":"http://infoscis.github.io/2017/07/21/angular-tutorial-the-hero-editor/","excerpt":"","text":"The Hero EditorLocal 개발환경 설치설치 안내에 따라 angle-tour-of-heroes라는 새 프로젝트를 만듭니다. 파일 구조는 다음과 같아야합니다. 123456789101112angular-tour-of-heroes ┣ src ┃ ┣ app ┃ ┃ ┣ app.component.ts ┃ ┃ ┗ app.module.ts ┃ ┣ main.ts ┃ ┣ index.html ┃ ┣ styles.css ┃ ┣ systemjs.config.js ┃ ┗ tsconfig.json ┣ node_modules ... ┗ package.json 이 페이지를 끝내면 앱은 이 라이브 예제/다운로드 예제처럼 보일 것입니다. 앱 실행과 트랜스파일 유지하기터미널 창에서 다음 명령을 입력하십시오. 1npm start 이 명령은 TypeScript 컴파일러를 “watch mode”에서 실행하여 코드가 변경되면 자동으로 다시 컴파일 하도록합니다. 또한 이 명령은 앱이 브라우저에서 동시에 실행되고 코드가 변경되면 브라우저를 새로 고칩니다. 다시 컴파일하거나 새로 고치지 않고 브라우저를 일시 정지하지 않아 Tour of Heroes 앱을 계속 만들 수 있습니다. Hero 보여주기AppComponent에 두 개의 프로퍼티를 추가합니다. 앱 이름의 title 프로퍼티와 Windstorm이라는 영웅의 hero 프로퍼티입니다. app.component.ts (AppComponent class)1234export class AppComponent &#123; title = 'Tour of Heroes'; hero = 'Windstorm';&#125; 이제 @Component Decorator 템플릿을 새로운 프로퍼티에 대한 데이터 바인딩으로 업데이트합니다. app.component.ts (@Component)1template: `&lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt;&lt;h2&gt;&#123;&#123;hero&#125;&#125; details!&lt;/h2&gt;` 브라우저가 새로 고침되고 title과 hero 이름이 표시됩니다. 이중 중괄호는 Angular의 Interpolation 바인딩 구문입니다. 이러한 Interpolation 바인딩은 HTML &lt;h1&gt; 태그 안에 Component의 title 및 hero 프로퍼티를 문자열로 표시합니다. Interpolation 바인딩에 대한 자세한 내용은 데이터 표시하기 페이지를 참조하십시오. Hero 객체hero는 더 많은 프로퍼티가 필요합니다. hero를 문자열에서 클래스로 변환합니다. id 및 name 프로퍼티를 사용하여 Hero 클래스를 만듭니다. app.component.ts 파일의 맨 위에있는 import 문 바로 아래에 이러한 프로퍼티를 추가합니다. src/app/app.component.ts (Hero class)1234export class Hero &#123; id: number; name: string;&#125; AppComponent 클래스에서, Component의 hero 프로퍼티가 Hero 타입으로 리팩토링된 다음 id는 1로 name은 Windstorm 으로 초기화합니다. src/app/app.component.ts (hero property)1234hero: Hero = &#123; id: 1, name: 'Windstorm'&#125;; hero를 문자열에서 객체로 변경했기 때문에 hero의 name 프로퍼티를 참조하도록 템플릿의 바인딩을 업데이트합니다. src/app/app.component.ts1template: `&lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt;&lt;h2&gt;&#123;&#123;hero.name&#125;&#125; details!&lt;/h2&gt;` 브라우저가 새로 고쳐지고 Hero의 이름이 계속 표시됩니다. Multi-line template string으로 HTML 추가하기Hero의 모든 프로퍼티를 표시하려면 Hero의 id 프로퍼티에 &lt;div&gt;를 추가하고 Hero의 name에 다른 &lt;div&gt;를 추가합니다. 그리고 템플릿을 읽기 좋게 유지하려면 각각의 &lt;div&gt;를 각 라인에 배치합니다. ES2015와 TypeScript의 템플릿 리터럴 (template literals) 기능 덕분에 Component의 template에 백틱을 사용하면 &lt;h1&gt;, &lt;h2&gt;, &lt;div&gt; 요소를 각 라인에 넣을 수 있습니다. 자세한 내용은 템플릿 리터럴을 참조하십시오. app.component.ts (AppComponent’s template)123456template: ` &lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt; &lt;h2&gt;&#123;&#123;hero.name&#125;&#125; details!&lt;/h2&gt; &lt;div&gt;&lt;label&gt;id: &lt;/label&gt;&#123;&#123;hero.id&#125;&#125;&lt;/div&gt; &lt;div&gt;&lt;label&gt;name: &lt;/label&gt;&#123;&#123;hero.name&#125;&#125;&lt;/div&gt; ` Hero name 수정사용자는 &lt;input&gt; 텍스트 상자에서 Hero 이름을 편집할 수 있어야합니다. 텍스트 상자는 Hero의 name 프로퍼티을 표시하고 사용자가 입력할 때 해당 프로퍼티를 업데이트 해야합니다. &lt;input&gt; form 요소와 hero.name 프로퍼티 사이에는 양방향 데이터 바인딩이 필요합니다. 양방향 바인딩템플릿에서 Hero 이름을 리팩토링하여 다음과 같이 표시합니다. src/app/app.component.ts1234&lt;div&gt; &lt;label&gt;name: &lt;/label&gt; &lt;input [(ngModel)]=\"hero.name\" placeholder=\"name\"&gt;&lt;/div&gt; [(ngModel)]은 hero.name 프로퍼티를 텍스트 상자에 바인딩하는 Angular 구문입니다. 데이터는 프로퍼티에서 텍스트 상자로, 텍스트 상자에서 프로퍼티로으로 양 방향으로 흐릅니다. 유감스럽게도 이 변경 직후 응용 프로그램이 중단됩니다. 브라우저 콘솔에서 보면 Angular가 “ngModel … isn’t a known property of input.”라는 메시지을 출력합니다. NgModel은 유효한 Angular Directive이지만 Default로 사용할 수 없습니다. 선택적 FormsModule에 속합니다. 해당 모듈을 사용하도록 import 해야합니다. FormsModule 포함(Import) 하기app.module.ts 파일을 열고 @angular/forms 라이브러리에서 FormsModule 심볼을 import 합니다. 그런 다음 @NgModule 메타 데이터의 import 배열에 FormsModule을 추가합니다. 이 배열에는 앱이 사용하는 외부 모듈 목록이 들어 있습니다. 업데이트된 AppModule은 다음과 같습니다. app.module.ts (FormsModule import) 1234567891011121314151617import &#123; NgModule &#125; from '@angular/core';import &#123; BrowserModule &#125; from '@angular/platform-browser';import &#123; FormsModule &#125; from '@angular/forms'; // &lt;-- NgModel lives here import &#123; AppComponent &#125; from './app.component'; @NgModule(&#123; imports: [ BrowserModule, FormsModule // &lt;-- import the FormsModule before binding with [(ngModel)] ], declarations: [ AppComponent ], bootstrap: [ AppComponent ]&#125;)export class AppModule &#123; &#125; Forms 가이드의 FormsModule 및 Two-way data binding with ngModel 섹션의 ngModel, 그리고 Template Syntax 가이드의 Two-way binding with NgModel에 대해 자세히 읽어보십시오. 브라우저가 새로 고침되면 앱이 다시 작동합니다. Hero의 이름을 편집하고 텍스트 상자 위의 &lt;h2&gt;에 반영된 변경 사항을 확인할 수 있습니다. 어디까지 왔나?아래는 여러분이 작업했던 내용입니다. Tour of Heroes 앱의 제목과 Hero 객체의 프로퍼티를 표시하는 이중 중괄호 Interpolation (단방향 데이터 바인딩 유형)을 사용했습니다. ES2015의 템플릿 리터럴을 사용하여 여러줄 템플릿을 작성하여 템플릿을 읽기 쉽게 만들었습니다. 내장 ngModel Directive를 사용하여 &lt;input&gt; 요소에 양방향 데이터 바인딩을 추가했습니다. 이 바인딩은 Hero의 이름을 표시하고 사용자가 변경할 수 있도록합니다. ngModel Directive은 hero.name의 다른 모든 바인딩에 변경 사항을 전파합니다. 앱은 이 라이브 예제/예제 다운로드와 비슷해야합니다. 아래 코드는 완전한 app.component.ts입니다. src/app/app.component.ts1234567891011121314151617181920212223242526import &#123; Component &#125; from '@angular/core'; export class Hero &#123; id: number; name: string;&#125; @Component(&#123; selector: 'my-app', template: ` &lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt; &lt;h2&gt;&#123;&#123;hero.name&#125;&#125; details!&lt;/h2&gt; &lt;div&gt;&lt;label&gt;id: &lt;/label&gt;&#123;&#123;hero.id&#125;&#125;&lt;/div&gt; &lt;div&gt; &lt;label&gt;name: &lt;/label&gt; &lt;input [(ngModel)]=\"hero.name\" placeholder=\"name\"&gt; &lt;/div&gt; `&#125;)export class AppComponent &#123; title = 'Tour of Heroes'; hero: Hero = &#123; id: 1, name: 'Windstorm' &#125;;&#125; 앞으로의 여정다음 튜토리얼 페이지에서는 Tour of Heroes 앱을 기반으로 Heroes 목록을 표시합니다. 사용자가 Hero를 선택하고 세부 정보를 표시할 수도 있습니다. 목록을 검색하는 방법과 템플릿에 바인딩하는 방법에 대해 자세히 배웁니다. 이 내용은 나중에 참고하기 위해 제가 공부하며 정리한 내용입니다.의역, 오역, 직역이 있을 수 있음을 알려드립니다.This post is a translation of this original article [https://angular.io/tutorial/toh-pt1] 참고 Angular 튜토리얼 - 소개 Angular 튜터리얼 - Master/Detail Angular 튜터리얼 - 다중 콤포넌트 Angular 튜터리얼 - 서비스 Angular 튜터리얼 - 라우팅 Angular 튜터리얼 - HTTP Angular HttpClient Angular 동적 컴포넌트 로딩","categories":[{"name":"Angular","slug":"Angular","permalink":"http://infoscis.github.io/categories/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://infoscis.github.io/tags/Angular/"}]},{"title":"TypeScript 핸드북 12 - Iterator와 Generator","slug":"TypeScript-handbook-iterators-and-generators","date":"2017-06-19T14:27:56.000Z","updated":"2018-01-27T15:16:29.680Z","comments":true,"path":"2017/06/19/TypeScript-handbook-iterators-and-generators/","link":"","permalink":"http://infoscis.github.io/2017/06/19/TypeScript-handbook-iterators-and-generators/","excerpt":"","text":"Iterator와 GeneratorIterables객체가 Symbol.iterator 프로퍼티에 대한 구현을 가지고 있다면 Iterable로 간주됩니다. Array, Map, Set, String, Int32Array, Uint32Array 등과 같은 몇몇 내장 타입은 이미 구현된 Symbol.iterator 프로퍼티를 가지고 있습니다. 객체의 Symbol.iterator 함수는 반복할 값 목록을 반환합니다. for..of 명령문for..of는 Iterable 객체를 반복하며, 객체의 Symbol.iterator 프로퍼티를 호출합니다. 다음은 배열에서 간단한 for..of 루프입니다. 12345let someArray = [1, \"string\", false];for (let entry of someArray) &#123; console.log(entry); // 1, \"string\", false&#125; for..of vs. for..in 명령문for..of와 for..in 명령문 모두 리스트를 반복합니다. 반복되는 값은 다르지만 for..in은 반복되는 객체의 key 목록을 반환합니다. 반면 for..of는 반복되는 객체의 숫자 프로퍼티 값 목록을 반환합니다. 다음 코드는 이 차이를 보여줍니다. 123456789let list = [4, 5, 6];for (let i in list) &#123; console.log(i); // \"0\", \"1\", \"2\",&#125;for (let i of list) &#123; console.log(i); // \"4\", \"5\", \"6\"&#125; 또 다른 차이점은 for..in은 어떤 객체에서도 작동한다는 것입니다. 그리고 객체의 프로퍼티를 검사하는 방법으로 사용됩니다. for..of는 주로 반복 가능한 객체의 값에 관심이 있습니다. Map과 Set 같은 내장 객체는 저장된 값에 접근할 수있는 Symbol.iterator 속성이 있습니다. 12345678910let pets = new Set([\"Cat\", \"Dog\", \"Hamster\"]);pets[\"species\"] = \"mammals\";for (let pet in pets) &#123; console.log(pet); // \"species\"&#125;for (let pet of pets) &#123; console.log(pet); // \"Cat\", \"Dog\", \"Hamster\"&#125; Code generationES5와 ES3 타겟팅ES5 나 ES3를 대상으로 할 때, Iterator는 Array 타입의 값에만 허용됩니다. 이러한 배열이 아닌 객체에 Symbol.iterator 프로퍼티를 구현하는 경우에도, for..of 루프를 사용하는 것은 오류 입니다. 컴파일러는 for..of 루프를 위한 간단한 for 루프를 생성합니다, 예를 들면 : 1234let numbers = [1, 2, 3];for (let num of numbers) &#123; console.log(num);&#125; 다음과 같이 생성됩니다. 12345var numbers = [1, 2, 3];for (var _i = 0; _i &lt; numbers.length; _i++) &#123; var num = numbers[_i]; console.log(num);&#125; ECMAScript 2015 이상 타겟팅ECMAScipt 2015 호환 엔진을 대상으로 할 때, 컴파일러는 엔진에 내장된 Iterator 구현을 타겟으로하는 for..of 루프를 생성할 것입니다. 이 내용은 나중에 참고하기 위해 제가 공부하며 정리한 내용입니다.의역, 오역, 직역이 있을 수 있음을 알려드립니다.This post is a translation of this original article [https://www.typescriptlang.org/docs/handbook/iterators-and-generators.html] 참고 TypeScript 핸드북 1 - 기본 타입 TypeScript 핸드북 2 - 변수 선언 TypeScript 핸드북 3 - 인터페이스 TypeScript 핸드북 4 - 클래스 TypeScript 핸드북 5 - 함수 TypeScript 핸드북 6 - Generic TypeScript 핸드북 7 - Enum TypeScript 핸드북 8 - 타입 유추 TypeScript 핸드북 9 - 타입 호환성 TypeScript 핸드북 10 - 고급 타입 TypeScript 핸드북 11 - Symbol TypeScript 핸드북 12 - Iterator와 Generator","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://infoscis.github.io/categories/TypeScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://infoscis.github.io/tags/JavaScript/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://infoscis.github.io/tags/TypeScript/"}]},{"title":"TypeScript 핸드북 11 - Symbol","slug":"TypeScript-handbook-symbols","date":"2017-06-19T14:27:36.000Z","updated":"2018-01-27T15:16:46.742Z","comments":true,"path":"2017/06/19/TypeScript-handbook-symbols/","link":"","permalink":"http://infoscis.github.io/2017/06/19/TypeScript-handbook-symbols/","excerpt":"","text":"Symbols소개ECMAScript 2015부터 symbol은 number와 string처럼 Primitive 데이터 타입입니다. symbol 값은 Symbol 생성자를 호출하여 생성됩니다. 123let sym1 = Symbol();let sym2 = Symbol(\"key\"); // string \"key\"는 optional입니다. Symbol은 변경 불가능하며 고유합니다. 1234let sym2 = Symbol(\"key\");let sym3 = Symbol(\"key\");sym2 === sym3; // false, symbols are unique string과 마찬가지로 symbol을 객체 프로퍼티의 키로 사용할 수 있습니다. 1234567let sym = Symbol();let obj = &#123; [sym]: \"value\"&#125;; console.log(obj[sym]); // \"value\" Symbol을 계산된 프로퍼티 선언과 결합하여 객체 프로퍼티와 클래스 멤버를 선언할 수도 있습니다. 12345678910const getClassNameSymbol = Symbol();class C &#123; [getClassNameSymbol]()&#123; return \"C\"; &#125;&#125;let c = new C();let className = c[getClassNameSymbol](); // \"C\" 잘 알려진 Symbol사용자 정의 Symbol 외에도 잘 알려진 내장 Symbol이 있습니다. 내장 Symbol는 언어 내부 동작을 나타내는 데 사용됩니다. 다음은 잘 알려진 Symbol 목록입니다. Symbol.hasInstance생성자 객체가 생성자의 인스턴스 중 하나로서 객체를 인식하는지 여부를 결정하는 메서드입니다. instanceof 연산자의 의미에 의해 호출됩니다. Symbol.isConcatSpreadable객체가 Array.prototype.concat에 의해 배열 요소로 병합되어야 함을 나타내는 부울 값입니다. Symbol.iterator객체의 기본 반복자를 반환하는 메서드입니다. for-of 구문의 의미에 의해 호출됩니다. Symbol.match문자열과 비교하는 정규 표현식 메서드입니다. String.prototype.match 메서드에 의해 호출됩니다. Symbol.replace일치하는 문자열의 부분 문자열을 대체하는 정규 표현식 메서드입니다. String.prototype.replace 메서드에 의해 호출됩니다. Symbol.search일치하는 문자열 내에서 인덱스를 반환하는 정규 표현식 메서드입니다. String.prototype.search 메서드에 의해 호출됩니다. Symbol.species파생된 객체를 만드는 데 사용되는 생성자 함수의 함수값을 갖는 프로퍼티입니다. Symbol.split일치하는 인덱스에서 문자열을 분할하는 정규 표현식 메서드입니다. String.prototype.split 메서드에 의해 호출됩니다. Symbol.toPrimitive객체에 대응하는 Primitive로 변환하는 메소드입니다. ToPrimitive 추상 동작에 의해 호출됩니다. Symbol.toStringTag객체의 기본 문자열 Tag를 만드는데 사용되는 String 값입니다. 내장 메소드 Object.prototype.toString에 의해 호출됩니다. Symbol.unscopables자신의 프로퍼티 명을 가지는 객체는 관련된 객체의 ‘with’ 환경 바인딩에서 제외되는 속성 이름입니다. 이 내용은 나중에 참고하기 위해 제가 공부하며 정리한 내용입니다.의역, 오역, 직역이 있을 수 있음을 알려드립니다.This post is a translation of this original article [https://www.typescriptlang.org/docs/handbook/symbols.html] 참고 TypeScript 핸드북 1 - 기본 타입 TypeScript 핸드북 2 - 변수 선언 TypeScript 핸드북 3 - 인터페이스 TypeScript 핸드북 4 - 클래스 TypeScript 핸드북 5 - 함수 TypeScript 핸드북 6 - Generic TypeScript 핸드북 7 - Enum TypeScript 핸드북 8 - 타입 유추 TypeScript 핸드북 9 - 타입 호환성 TypeScript 핸드북 10 - 고급 타입 TypeScript 핸드북 11 - Symbol TypeScript 핸드북 12 - Iterator와 Generator","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://infoscis.github.io/categories/TypeScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://infoscis.github.io/tags/JavaScript/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://infoscis.github.io/tags/TypeScript/"}]},{"title":"TypeScript 핸드북 10 - 고급 타입","slug":"TypeScript-handbook-advanced-types","date":"2017-06-19T14:27:16.000Z","updated":"2018-01-27T15:19:31.579Z","comments":true,"path":"2017/06/19/TypeScript-handbook-advanced-types/","link":"","permalink":"http://infoscis.github.io/2017/06/19/TypeScript-handbook-advanced-types/","excerpt":"","text":"고급 타입(Advanced Type)Intersection TypesIntersection 타입은 여러 타입을 하나로 결합합니다. 이렇게하면 기존 타입을 모두 추가하여 필요한 모든 기능을 갖춘 단일 타입을 얻을 수 있습니다. 예를 들어, Person &amp; Serializable &amp; Loggable은 Person과 Serializable이며 Loggable입니다. 즉, 이 타입의 객체는 세 가지 타입의 모든 멤버를 갖게됩니다. Intersection 타입의 대부분은 mixin과 고전적인 객체 지향 모습에 맞지 않는 형태에서 보게 됩니다.(JavaScript에는 이런 것들이 많이 있습니다!) 다음은 mixin을 만드는 방법을 보여주는 간단한 예제입니다. 123456789101112131415161718192021222324252627function extend&lt;T, U&gt;(first: T, second: U): T &amp; U &#123; let result = &lt;T &amp; U&gt;&#123;&#125;; for (let id in first) &#123; (&lt;any&gt;result)[id] = (&lt;any&gt;first)[id]; &#125; for (let id in second) &#123; if (!result.hasOwnProperty(id)) &#123; (&lt;any&gt;result)[id] = (&lt;any&gt;second)[id]; &#125; &#125; return result;&#125;class Person &#123; constructor(public name: string) &#123; &#125;&#125;interface Loggable &#123; log(): void;&#125;class ConsoleLogger implements Loggable &#123; log() &#123; // ... &#125;&#125;var jim = extend(new Person(\"Jim\"), new ConsoleLogger());var n = jim.name;jim.log(); Union TypesUnion 타입은 Intersection 타입과 밀접한 관련이 있지만 매우 다르게 사용됩니다. 때로는 파라미터가 number 또는 string이 될 것으로 기대하는 라이브러리를 실행하게 될때도 있습니다. 예를 들어, 다음과 같은 함수를 살펴보겠습니다. 12345678910111213141516/** * 문자열을 가져 와서 왼쪽에 'padding'을 추가합니다. * 'padding'이 문자열이면 'padding'이 왼쪽에 추가됩니다. * 'padding'이 숫자 인 경우 해당 개수의 공백이 왼쪽에 추가됩니다. */function padLeft(value: string, padding: any) &#123; if (typeof padding === \"number\") &#123; return Array(padding + 1).join(\" \") + value; &#125; if (typeof padding === \"string\") &#123; return padding + value; &#125; throw new Error(`Expected string or number, got '$&#123;padding&#125;'.`);&#125;padLeft(\"Hello world\", 4); // returns \" Hello world\" padLeft의 문제점은 padding 파라미터가 any로 입력된다는 것입니다. 즉, number나 string이 아닌 파라미터를 사용하여 호출할 수 있지만 TypeScript는 해당 파라미터를 수용합니다. 1let indentedString = padLeft(\"Hello world\", true); // 컴파일 타임에는 통과 하지만 runtime에 실패가 발생합니다. 전통적인 객체 지향 코드에서는 타입의 계층 구조를 만들어 두가지 타입을 추상화할 수 있습니다. 이것이 훨씬 더 명확하지만, 그것은 또한 약간 과잉대응입니다. 이러한 접근법은 이미 다른 곳에있는 함수를 사용하려는 경우에도 도움이되지 않습니다. padLeft의 원래 버전에 대한 좋은 점 중 하나는 우리가 Primitive를 전달할 수 있다는 것이었습니다. 이는 사용법이 간단하고 간결하다는 것을 의미합니다. any 대신에 padding 파라미터에 Union 타입을 사용할 수 있습니다. 12345678910/** * 문자열을 가져 와서 왼쪽에 \"패딩\"을 추가합니다. * 'padding'이 문자열이면 'padding'이 왼쪽에 추가됩니다. * 'padding'이 숫자 인 경우 해당 개수의 공백이 왼쪽에 추가됩니다. */function padLeft(value: string, padding: string | number) &#123; // ...&#125;let indentedString = padLeft(\"Hello world\", true); // errors during compilation Union 타입은 여러 타입 중 하나 일 수 있는 값을 나타냅니다. 수직 막대 (|)를 사용하여 각 타입을 구분하므로 number | string | boolean은 number,string 또는boolean 일 수있는 값의 타입입니다. 만일 우리가 Union 타입을 가진 값을 가지고 있다면, Union의 모든 타입에 공통적인 멤버들만 접근할 수 있습니다. 1234567891011121314151617interface Bird &#123; fly(); layEggs();&#125;interface Fish &#123; swim(); layEggs();&#125;function getSmallPet(): Fish | Bird &#123; // ...&#125;let pet = getSmallPet();pet.layEggs(); // okaypet.swim(); // errors Union 타입은 약간 까다로울 수 있지만 익숙해지기 위해서는 약간의 직감이 필요합니다. 타입이 A|B인 값을 가지고 있다면, 우리는 A와 B 둘 다 특정 멤버가 있음을 확실히 알 수 있습니다. 이 예제에서 Bird에는 fly라는 멤버가 있습니다. 그리고 Bird | Fish 타입에는 fly 메서드가 있음을 확신할 수 없습니다. 그렇기 때문에 런타임에 변수가 실제로 Fish 인 경우 pet.fly()를 호출하면 실패할 수 있습니다. 타입 가드와 차별 타입 (Type Guards and Differentiating Types)Union 타입은 값들이 겹쳐 질 수있는 상황을 모델링하는데 유용합니다. 우리가 Fish를 가지고 있는지 여부를 구체적으로 알아야할 때 어떻게 해야 할까요? 두가지 값을 구별하는 JavaScript의 일반적인 방법은 멤버의 존재 여부를 확인하는 것입니다. 위에서 언급했듯이, Union 타입은 모든 구성 요소에 포함될 수 있는 멤버만 액세스할 수 있습니다. 123456789let pet = getSmallPet();// 이러한 각 프로퍼티의 액세스는 오류를 발생시킵니다.if (pet.swim) &#123; pet.swim();&#125;else if (pet.fly) &#123; pet.fly();&#125; 위 코드가 작동하도록 하려면 타입 어설션을 사용해야합니다. 12345678let pet = getSmallPet();if ((&lt;Fish&gt;pet).swim) &#123; (&lt;Fish&gt;pet).swim();&#125;else &#123; (&lt;Bird&gt;pet).fly();&#125; 사용자 정의 타입 가드(User-Defined Type Guard)타입 어설션을 여러번 사용해야 한다는 점에 주목하십시오. 일단 우리가 체크를 수행할때 각 지점 내에서 pet의 타입을 알 수 있으면 훨씬 더 좋을 것입니다. TypeScript에는 타입 가드(Type guard)가 있습니다. 타입 가드(Type guard)는 어떤 Scope에서 타입을 보증하는 런타임 체크를 수행하는 몇 가지 표현식입니다. 타입 가드를 정의하기 위해서, 리턴 타입이 Type predicate인 함수를 정의할 필요가 있습니다. 123function isFish(pet: Fish | Bird): pet is Fish &#123; return (&lt;Fish&gt;pet).swim !== undefined;&#125; pet is Fish는 위 예에서 Type predicate입니다. Predicate는 parameterName is Type의 형식을 취합니다. 여기서 parameterName은 현재 함수 Signature의 파라미터 이름이어야 합니다. isFish가 어떤 변수와 함께 호출될 때마다, 원래 타입이 호환 가능하다면 TypeScript은 그 변수를 그 특정 타입으로 추정할 것입니다. 12345678// 'swim'과 'fly'에 대한 호출은 이제 모두 괜찮습니다.if (isFish(pet)) &#123; pet.swim();&#125;else &#123; pet.fly();&#125; TypeScript는 pet이 if문에서 Fish라는 것을 알고 있을뿐만 아니라, else에서는 Fish가 아니기 때문에 Bird가 있어야합니다. 타입 가드의 typeof뒤로 돌아가서 Union 타입을 사용하는 padLeft 버전의 코드를 작성해 보겠습니다. 다음과 같이 Type predicates를 써서 쓸 수 있습니다. 1234567891011121314151617function isNumber(x: any): x is number &#123; return typeof x === \"number\";&#125;function isString(x: any): x is string &#123; return typeof x === \"string\";&#125;function padLeft(value: string, padding: string | number) &#123; if (isNumber(padding)) &#123; return Array(padding + 1).join(\" \") + value; &#125; if (isString(padding)) &#123; return padding + value; &#125; throw new Error(`Expected string or number, got '$&#123;padding&#125;'.`);&#125; 그러나 타입이 Primitive 인지 알아내는 함수를 정의하는 것은 고통입니다. 다행스럽게도, TypeScript가 인식하기 때문에, typeof x === &quot;number&quot;를 자신의 함수로 추상화할 필요가 없습니다. 즉, 이 체크를 인라인으로 작성할 수 있음을 의미합니다. 123456789function padLeft(value: string, padding: string | number) &#123; if (typeof padding === \"number\") &#123; return Array(padding + 1).join(\" \") + value; &#125; if (typeof padding === \"string\") &#123; return padding + value; &#125; throw new Error(`Expected string or number, got '$&#123;padding&#125;'.`);&#125; 이 typeof 타입 가드는 typeof v === &quot;typename&quot;과 typeof v !== &quot;typename&quot; 두 가지 형태로 인식됩니다. 여기서 &quot;typename&quot;은 &quot;number&quot;, &quot;string&quot;, &quot;boolean&quot;, 또는 &quot;symbol&quot;이어야 합니다. TypeScript는 여러분이 다른 문자열과 비교하는 것을 못하게 하지 않지만 TypeScript는 해당 표현을 타입 가드로 인식하지 않습니다. 타입 가드의 instanceoftypeof 타입 가드를 읽었고 JavaScript에서 instanceof 연산자에 익숙하다면 아마 여기서 설명하는 내용이 익숙할 것입니다. instanceof 타입 가드는 생성자 함수를 사용하여 타입을 좁히는 방법입니다. 예를 들어, 이전의 문자열 padding 예제를 살펴보겠습니다. 123456789101112131415161718192021222324252627282930313233interface Padder &#123; getPaddingString(): string&#125;class SpaceRepeatingPadder implements Padder &#123; constructor(private numSpaces: number) &#123; &#125; getPaddingString() &#123; return Array(this.numSpaces + 1).join(\" \"); &#125;&#125;class StringPadder implements Padder &#123; constructor(private value: string) &#123; &#125; getPaddingString() &#123; return this.value; &#125;&#125;function getRandomPadder() &#123; return Math.random() &lt; 0.5 ? new SpaceRepeatingPadder(4) : new StringPadder(\" \");&#125;// 'SpaceRepeatingPadder | StringPadder' 타입입니다.let padder: Padder = getRandomPadder();if (padder instanceof SpaceRepeatingPadder) &#123; padder; // 타입이 'SpaceRepeatingPadder'로 좁혀졌습니다.&#125;if (padder instanceof StringPadder) &#123; padder; // 타입이 'StringPadder'로 좁혀졌습니다.&#125; instanceof의 오른쪽은 생성자 함수여야하며, TypeScript는 다음으로 순서로 범위를 좁힙니다. 타입이 any가 아닌 경우 함수의 prototype 프로퍼티 타입 그 타입의 생성자 Signatures 의해 리턴되는 타입의 Union 타입 Nullable typesTypeScript에는 null과 undefined 값을 가질수 있는 두 가지 특별한 타입인 null과 undefined 타입이 있습니다.Basic Types에서 간단히 언급했습니다. 기본적으로 타입 checker는 null및 undefined를 어떤것이든 할당할수 있다고 간주합니다. 그리고,null과 undefined는 모든 타입의 유효한 값입니다. 즉, 이 값의 할당을 막고 싶을 때조차도 any 타입에 할당되는 것을 막을 수 없다는 것을 의미합니다. null의 고안자인 토니 호아레 (Tony Hoare)는 이것을 “billion dollar mistake” 라고 부르기도 했습니다. --strictNullChecks 플래그는 이 문제를 해결할 수 있습니다. 변수를 선언하면 null 또는 undefined가 자동으로 포함되지 않습니다. 하지만 Union 타입을 사용하여 명시적으로 포함 시킬수 있습니다. 123456let s = \"foo\";s = null; // error, 'null' is not assignable to 'string'let sn: string | null = \"bar\";sn = null; // oksn = undefined; // error, 'undefined' is not assignable to 'string | null' TypeScript는 JavaScript 의미와 일치시키기 위해 null과 undefined를 다르게 취급합니다. string | null은 string | undefined와string | undefined | null과 다른 타입입니다. Optional 파라미터와 프로퍼티--strictNullChecks 옵션은 자동으로 | undefined를 포함 시킵니다. 1234567function f(x: number, y?: number) &#123; return x + (y || 0);&#125;f(1, 2);f(1);f(1, undefined);f(1, null); // error, 'null'은 'number | undefined' 타입에 할당할 수 없습니다. Optional 프로퍼티에 대해서도 마찬가지입니다. 12345678910class C &#123; a: number; b?: number;&#125;let c = new C();c.a = 12;c.a = undefined; // error, 'undefined' is not assignable to 'number'c.b = 13;c.b = undefined; // okc.b = null; // error, 'null' is not assignable to 'number | undefined' 타입 가드와 타입 어설션 (Type guards and type assertions)Nullable 타입은 Union으로 구현 되었기 때문에 타입 가드를 사용하여 null을 제거해야합니다. 다행히도 JavaScript에서 작성하는 코드와 똑같습니다. 12345678function f(sn: string | null): string &#123; if (sn == null) &#123; return \"default\"; &#125; else &#123; return sn; &#125;&#125; 위 코드에서 null 제거 코드는 명확하지만 더 간단한 연산자를 사용할 수 있습니다. 123function f(sn: string | null): string &#123; return sn || \"default\";&#125; 컴파일러가 null 또는 undefined를 제거할 수없는 경우, 타입 선언 연산자를 사용하여 수동으로 제거할 수 있습니다. 구문은 변수 뒤에 !를 붙이는 것입니다. identifier!는 식별자의 타입에서 null과 undefined를 제거합니다. 123456789101112131415function broken(name: string | null): string &#123; function postfix(epithet: string) &#123; return name.charAt(0) + '. the ' + epithet; // error, 'name' is possibly null &#125; name = name || \"Bob\"; return postfix(\"great\");&#125;function fixed(name: string | null): string &#123; function postfix(epithet: string) &#123; return name!.charAt(0) + '. the ' + epithet; // ok &#125; name = name || \"Bob\"; return postfix(\"great\");&#125; 컴파일러가 중첩 함수 내에서 null을 제거할 수 없으므로 (즉시 함수 호출 표현식 제외) 이 예제에서는 중첩 함수를 사용합니다. 중첩된 함수에 대한 모든 호출을 추적할 수 없기 때문입니다. 특히 외부 함수에서 반환하는 경우가 그렇습니다. 함수가 호출되는 위치를 알지 못하면 본문이 실행될 때 name의 타입이 무엇인지 알 수 없습니다. Type Aliases타입 Alias는 타입의 새이름을 작성합니다. 타입 Alias는 때때로 인터페이스와 비슷하지만, Primitive, Union, Tuple, 그리고 여러분이 직접 작성한 타입에 이름을 붙일 수 있습니다. 1234567891011type Name = string;type NameResolver = () =&gt; string;type NameOrResolver = Name | NameResolver;function getName(n: NameOrResolver): Name &#123; if (typeof n === \"string\") &#123; return n; &#125; else &#123; return n(); &#125;&#125; 타입 Alias는 실제로 새 타입을 작성하지 않으며 해당 타입을 참조하는 새 이름을 작성합니다. Primitive의 Alias는 사용될 수 있지만 딱히 유용성은 없습니다. 인터페이스와 마찬가지로 타입 Alias도 Generic을 사용할 수 있습니다. 타입 파라미터를 추가하고 Alias 선언의 오른쪽에 사용할 수 있습니다. 1type Container&lt;T&gt; = &#123; value: T &#125;; 또한 프로퍼티에서 타입 Alias를 참조할 수 있습니다. 12345type Tree&lt;T&gt; = &#123; value: T; left: Tree&lt;T&gt;; right: Tree&lt;T&gt;;&#125; Intersection 타입과 함께 우리는 Mind-bending 타입도 만들 수 있습니다. 1234567891011type LinkedList&lt;T&gt; = T &amp; &#123; next: LinkedList&lt;T&gt; &#125;;interface Person &#123; name: string;&#125;var people: LinkedList&lt;Person&gt;;var s = people.name;var s = people.next.name;var s = people.next.next.name;var s = people.next.next.next.name; 그러나 타입 Alias가 선언의 오른쪽에 있는 곳은 사용할 수 없습니다. 1type Yikes = Array&lt;Yikes&gt;; // error Interfaces vs. Type Aliases앞서 언급했듯이 타입 Alias는 인터페이스와 비슷한 일을할 수 있습니다. 그러나 약간의 차이가 있습니다. 한가지 차이점은 인터페이스는 어디에서나 사용되는 새로운 이름을 생성한다는 것입니다. 하지만 타입 Alias는 새 이름을 만들지 않습니다. 예를 들어 오류 메시지는 Alias를 사용하지 않습니다. 아래의 코드는 편집기에서 interfaced 위로 마우스를 가져 가면 Interface 를 반환한다고 나오지만 aliased는 객체 리터럴 타입을 반환한다는 것을 보여줄 것입니다. 123456type Alias = &#123; num: number &#125;interface Interface &#123; num: number;&#125;declare function aliased(arg: Alias): Alias;declare function interfaced(arg: Interface): Interface; 두번째로 중요한 차이점은 타입 Aliase를 확장하거나 구현할 수 없습니다. (다른 타입을 확장/구현할 수도 없습니다).소프트웨어의 이상적인 특성은 확장에 열려 있기 때문에 가능한 경우 항상 타입 Alias 대신 인터페이스를 사용해야합니다. 반면에, 인터페이스로 어떤 모양을 표현할 수 없고 Union이나 Tuple 타입을 사용해야 한다면, 일반적으로 타입 Aliase를 사용할 수 있습니다. 문자열 리터럴 타입문자열 리터럴 타입을 사용하면 문자열에 있어야하는 정확한 값을 지정할 수 있습니다. 실제로 문자열 리터럴 타입은 Union 타입, 타입 가드 및 타입 Alias와 잘 결합됩니다. 이러한 기능을 함께 사용하여 문자열에서 Enum 타입과 같이 작동할 수 있습니다. 12345678910111213141516171819type Easing = \"ease-in\" | \"ease-out\" | \"ease-in-out\";class UIElement &#123; animate(dx: number, dy: number, easing: Easing) &#123; if (easing === \"ease-in\") &#123; // ... &#125; else if (easing === \"ease-out\") &#123; &#125; else if (easing === \"ease-in-out\") &#123; &#125; else &#123; // error! null 또는 undefined를 넘겨서는 안됩니다. &#125; &#125;&#125;let button = new UIElement();button.animate(0, 0, \"ease-in\");button.animate(0, 0, \"uneasy\"); // error: \"uneasy\"는 여기에 사용할 수 없습니다. 세가지 허용되는 문자열 중 하나는 전달할 수 있지만 다른 문자열은 오류가 발생합니다. 1Argument of type &apos;&quot;uneasy&quot;&apos; is not assignable to parameter of type &apos;&quot;ease-in&quot; | &quot;ease-out&quot; | &quot;ease-in-out&quot;&apos; 오버로드를 구별하기 위해 동일한 방법으로 문자열 리터럴 타입을 사용할 수 있습니다. 123456function createElement(tagName: \"img\"): HTMLImageElement;function createElement(tagName: \"input\"): HTMLInputElement;// ... more overloads ...function createElement(tagName: string): Element &#123; // ... code goes here ...&#125; Discriminated Union문자열 리터럴 타입, Union 타입, 타입 가드 및 타입 Alias을 결합하여 Tagged union 또는 Algebraic 데이터 타입이라 불리는 Discriminated union이라는 고급 패턴을 빌드할 수 있습니다. Discriminated union은 함수형 프로그래밍에 유용합니다. 일부 언어는 자동으로 Discriminated union을 사용합니다. TypeScript는 현재 존재하는 JavaScript 패턴을 기반으로 합니다. 세가지 형식이 있습니다. 일반적인 문자열 리터럴 프로퍼티가 있는 타입 - Discriminated 타입의 합집합을 취하는 타입 Alias - Union 공통 프로퍼티의 타입 가드. 12345678910111213interface Square &#123; kind: \"square\"; size: number;&#125;interface Rectangle &#123; kind: \"rectangle\"; width: number; height: number;&#125;interface Circle &#123; kind: \"circle\"; radius: number;&#125; 먼저 우리가 결합할 인터페이스를 선언합니다. 각 인터페이스는 다른 문자열 리터럴 타입을 가진 kind 프로퍼티을 가지고 있습니다. kind 프로퍼티는 Discriminant 또는 Tag라고 불립니다. 다른 프로퍼티는 각 인터페이스에 고유합니다. 인터페이스는 현재 서로 관련이 없습니다. 이제 그들을 결합 하겠습니다. 1type Shape = Square | Rectangle | Circle; 이제 Discriminated union을 사용합니다. 1234567function area(s: Shape) &#123; switch (s.kind) &#123; case \"square\": return s.size * s.size; case \"rectangle\": return s.height * s.width; case \"circle\": return Math.PI * s.radius ** 2; &#125;&#125; 철저한 검사(Exhaustiveness checking)컴파일러가 Discriminated union의 모든 변종을 커버하지 않을 때 우리에게 알려주고 싶습니다. 예를 들어 Shape에 Triangle을 추가하면area도 업데이트 해야합니다. 123456789type Shape = Square | Rectangle | Circle | Triangle;function area(s: Shape) &#123; switch (s.kind) &#123; case \"square\": return s.size * s.size; case \"rectangle\": return s.height * s.width; case \"circle\": return Math.PI * s.radius ** 2; &#125; // should error here - we didn't handle case \"triangle\"&#125; 두 가지 방법이 있습니다. 첫 번째는 --strictNullChecks를 켜고 리턴 타입을 지정하는 것입니다. 1234567function area(s: Shape): number &#123; // error: returns number | undefined switch (s.kind) &#123; case \"square\": return s.size * s.size; case \"rectangle\": return s.height * s.width; case \"circle\": return Math.PI * s.radius ** 2; &#125;&#125; switch가 더 이상 철저하지 않기 때문에, TypeScript는 함수가 때때로 undefined를 리턴할 수 있다는 것을 알고 있습니다. 명시적 리턴 타입number를 가지고 있다면 리턴 타입이 실제로 number | undefined입니다. 그러나 이 방법은 조금 미묘하며, 게다가 --strictNullChecks가 오래된 코드에서 항상 작동하는 것은 아닙니다. 두번째 방법은 컴파일러가 철저히 검사하기 위해 사용하는 never 타입을 사용합니다. 1234567891011function assertNever(x: never): never &#123; throw new Error(\"Unexpected object: \" + x);&#125;function area(s: Shape) &#123; switch (s.kind) &#123; case \"square\": return s.size * s.size; case \"rectangle\": return s.height * s.width; case \"circle\": return Math.PI * s.radius ** 2; default: return assertNever(s); // error here if there are missing cases &#125;&#125; 여기서 assertNever는 s가 never 타입인지 검사합니다 - 다른 모든 케이스가 제거된 후에 남아있는 타입입니다. 여러분이 case를 잊어 버리면 s는 실제 타입을 가지게되고 타입 에러가 발생합니다. 이 방법을 사용하려면 추가 기능을 정의해야하지만 잊어 버렸을 때 훨씬 더 확실히 알수 있습니다. this 타입의 다형성this 타입의 다형성은 포함하는 클래스 또는 인터페이스의 subtype을 나타냅니다. 이를 F-바운드 다형성 (F-bounded polymorphism)이라고합니다. 따라서 계층적 인터페이스를 훨씬 쉽게 표현할 수 있습니다. 각 연산 후에 this를 반환하는 간단한 계산기가 있습니다. 1234567891011121314151617181920class BasicCalculator &#123; public constructor(protected value: number = 0) &#123; &#125; public currentValue(): number &#123; return this.value; &#125; public add(operand: number): this &#123; this.value += operand; return this; &#125; public multiply(operand: number): this &#123; this.value *= operand; return this; &#125; // ... other operations go here ...&#125;let v = new BasicCalculator(2) .multiply(5) .add(1) .currentValue(); 클래스는 this 타입을 사용하기 때문에 클래스를 확장할 수 있고 새로운 클래스는 변경없이 이전 메서드를 사용할 수 있습니다. 12345678910111213141516class ScientificCalculator extends BasicCalculator &#123; public constructor(value = 0) &#123; super(value); &#125; public sin() &#123; this.value = Math.sin(this.value); return this; &#125; // ... other operations go here ...&#125;let v = new ScientificCalculator(2) .multiply(5) .sin() .add(1) .currentValue(); this 타입이 없으면 ScientificCalculator는 BasicCalculator를 확장하고 인터페이스를 유지할 수 없었을 것입니다. multiply는 sin 메서드가 없는 BasicCalculator를 리턴했을 것입니다. 그러나, this 타입을 사용하면 multiply는 this를 반환하는데, 이것은 ScientificCalculator입니다. 인덱스 타입인덱스 타입을 사용하면 컴파일러에서 동적 프로퍼티 이름을 사용하는 코드를 확인하도록 할 수 있습니다. 예를 들어 아래의 코드는 일반적인 JavaScript 패턴에서 객체 프로퍼티의 하위 집합을 선택하는 것입니다. 123function pluck(o, names) &#123; return names.map(n =&gt; o[n]);&#125; 다음은 인덱스 타입 쿼리 및 인덱싱된 액세스 연산자를 사용하여 TypeScript에서 이 함수를 작성하고 사용하는 방법입니다. 12345678910111213function pluck&lt;T, K extends keyof T&gt;(o: T, names: K[]): T[K][] &#123; return names.map(n =&gt; o[n]);&#125;interface Person &#123; name: string; age: number;&#125;let person: Person = &#123; name: 'Jarid', age: 35&#125;;let strings: string[] = pluck(person, ['name']); // ok, string[] 컴파일러는 실제로 그 이름이 Person의 프로퍼티인지 확인합니다. 이 예제는 몇 가지 새로운 타입 연산자를 도입합니다. 첫 번째는 인덱스 타입 쿼리 연산자인 keyof T입니다. 어떤 타입의 T에 대해서, keyof T는 T의 알려진 공개 프로퍼티 이름들의 합집합입니다. 1let personProps: keyof Person; // 'name' | 'age' keyof Person은 &#39;name&#39; | &#39;age&#39;와 완벽하게 호환됩니다. 차이점은 Person에 또 다른 프로퍼티 address : string를 추가하면 keyof Person이 자동으로 &#39;name&#39; | &#39;age&#39; | &#39;address&#39;로 업데이트 된다는 것입니다. 그리고 pluck과 같은 generic 문장에서 keyof를 사용할 수 있습니다. 여기서 pluck는 그 이전에 프로퍼티 이름을 알 수 없습니다. 즉, 컴파일러는 올바른 프라퍼티 집합을 pluck에 전달했는지 확인합니다. 1pluck(person, ['age', 'unknown']); // error, 'unknown' is not in 'name' | 'age' 두 번째 연산자는 인덱싱된 액세스 연산자인 T[K]입니다. 여기에서 type syntax는 expression syntax를 반영합니다. 즉, person[&#39;name&#39;]은 Person[&#39;name&#39;] 타입을 가지고 있습니다. 이 예제에서는 단지 문자열입니다. 그리고 인덱스 타입의 질의와 마찬가지로 T[K]를 generic 문장에서 사용할 수 있습니다. 이 문장이 실제로 힘이 생기는 곳입니다. 타입 변수 K extends keyof T를 확실히 해야합니다. 다음은 getProperty라는 함수를 가진 또 다른 예제입니다. 123function getProperty&lt;T, K extends keyof T&gt;(o: T, name: K): T[K] &#123; return o[name]; // o[name] is of type T[K]&#125; getProperty에서 o:T 그리고 name:K은 o[name]:T[K]를 의미합니다. T[K] 결과를 반환하면 컴파일러는 실제 키 타입을 인스턴스화 할 것이므로 getProperty의 리턴 타입은 요청한 프로퍼티에 따라 달라집니다. 123let name: string = getProperty(person, 'name');let age: number = getProperty(person, 'age');let unknown = getProperty(person, 'unknown'); // error, 'unknown' is not in 'name' | 'age' 인덱스 타입 및 문자열 인덱스 시그니처keyof와 T[K]는 문자열 인덱스 시그니처와 상호 작용합니다. 문자열 인덱스 시그니처를 가진 타입을 가지고 있다면, keyof T는 단지 문자열일 것입니다. 그리고 T[string]은 단지 인덱스 시그니처 타입입니다. 12345interface Map&lt;T&gt; &#123; [key: string]: T;&#125;let keys: keyof Map&lt;number&gt;; // stringlet value: Map&lt;number&gt;['foo']; // number Mapped type일반적인 작업은 기존 타입을 가져 와서 각 프로퍼티를 선택적으로 만드는 것입니다. 1234interface PersonPartial &#123; name?: string; age?: number;&#125; 또는 읽기 전용 버전을 원할 수도 있습니다. 1234interface PersonReadonly &#123; readonly name: string; readonly age: number;&#125; 이것은 JavaScript에서 종종 자주 발생합니다. TypeScript는 이전 타입의 Mapped type을 기반으로 새로운 타입을 생성할 수 있는 방법을 제공합니다. Mapped type에서 새 타입은 이전 타입의 각 특성을 동일한 방식으로 변환합니다. 예를 들어 readonly 또는 optional타입의 모든 프로퍼티를 만들 수 있습니다. 다음은 몇 가지 예입니다. 123456type Readonly&lt;T&gt; = &#123; readonly [P in keyof T]: T[P];&#125;type Partial&lt;T&gt; = &#123; [P in keyof T]?: T[P];&#125; 그리고 사용하려면 12type PersonPartial = Partial&lt;Person&gt;;type ReadonlyPerson = Readonly&lt;Person&gt;; 가장 단순한 Mapped type과 그 부분을 살펴 보겠습니다. 12type Keys = 'option1' | 'option2';type Flags = &#123; [K in Keys]: boolean &#125;; 구문은 내부에 for..in이 있는 인덱스 시그니처의 구문과 유사합니다. 세 부분으로 나뉩니다. 타입 변수 K는 차례대로 각 프로퍼티에 바인딩됩니다. 반복 처리할 프로퍼티의 이름이 들어있는 문자열 리터럴 Union Keys입니다. 프로퍼티의 결과 타입 이 간단한 예제에서 Keys는 하드코딩된 프로퍼티 이름 목록이고 프로퍼티 타입은 항상 boolean이므로 이 Mapped type은 다음과 같습니다. 1234type Flags = &#123; option1: boolean; option2: boolean;&#125; 그러나 실제 응용 프로그램은 위의 Readonly 또는 Partial 처럼 보입니다. 그들은 기존의 타입을 기반으로하며, 어떤 방식으로든 필드를 변형합니다. 그것은 keyof와 indexed access type이 들어있는 곳입니다. 12type NullablePerson = &#123; [P in keyof Person]: Person[P] | null &#125;type PartialPerson = &#123; [P in keyof Person]?: Person[P] &#125; 그러나 일반적인 버전을 사용하는 것이 더 유용할 수도 있습니다. 12type Nullable&lt;T&gt; = &#123; [P in keyof T]: T[P] | null &#125;type Partial&lt;T&gt; = &#123; [P in keyof T]?: T[P] &#125; 이 예제들에서, 프로퍼티 리스트는 keyof T이고 결과 타입은 T[P]의 변형입니다. 이것은 Mapped type의 일반적인 사용을 위한 좋은 템플릿입니다. 왜냐하면 이러한 종류의 변환은 Homomorphic이기 때문에 매핑은 T의 프로퍼티에만 적용되고 다른 프로퍼티는 적용되지 않습니다. 컴파일러는 새로운 프로퍼티를 추가하기 전에 모든 기존 프로퍼티 modifier를 복사할 수 있음을 알고 있습니다. 예를 들어, Person.name이 읽기 전용이면, Partial&lt;Person&gt;.name은 읽기 전용이고 선택적입니다. 다음은 T [P]가 Proxy &lt;T&gt;클래스에 싸여있는 또 하나의 예입니다. 1234567891011type Proxy&lt;T&gt; = &#123; get(): T; set(value: T): void;&#125;type Proxify&lt;T&gt; = &#123; [P in keyof T]: Proxy&lt;T[P]&gt;;&#125;function proxify&lt;T&gt;(o: T): Proxify&lt;T&gt; &#123; // ... wrap proxies ...&#125;let proxyProps = proxify(props); Readonly &lt;T&gt;와 Partial &lt;T&gt;는 매우 유용하며, Pick와 Record와 함께 TypeScript의 표준 라이브러리에 포함되어 있습니다. 123456type Pick&lt;T, K extends keyof T&gt; = &#123; [P in K]: T[P];&#125;type Record&lt;K extends string | number, T&gt; = &#123; [P in K]: T;&#125; Readonly, Partial과 Pick은 Homomorphic이고 Record는 그렇지 않습니다. Record가 Homomorphic이 아닌 이유는 프로퍼티를 복사하는 입력 타입을 취하지 않는다는 것입니다. 1type ThreeStringProps = Record&lt;'prop1' | 'prop2' | 'prop3', string&gt; Non-homomorphic 타입은 본질적으로 새로운 속성을 생성하므로 아무 곳에서나 프로퍼티 modifier를 복사할 수 없습니다. Mapped type의 추론이제 타입의 프로퍼티를 Wrapping하는 방법을 알았으므로 다음으로해야 할 일은 Unwrapping하는 것입니다. 다행히도, 그것은 꽤 쉽습니다. 123456789function unproxify&lt;T&gt;(t: Proxify&lt;T&gt;): T &#123; let result = &#123;&#125; as T; for (const k in t) &#123; result[k] = t[k].get(); &#125; return result;&#125;let originalProps = unproxify(proxyProps); 이 Unwrapping 추론은 Homomorphic Mapped type에서만 작동합니다. Wrapping된 타입이 Homomorphic이 아닌 경우에는 Unwrapping 함수에 명시적 타입 파라미터를 지정해야합니다. 이 내용은 나중에 참고하기 위해 제가 공부하며 정리한 내용입니다.의역, 오역, 직역이 있을 수 있음을 알려드립니다.This post is a translation of this original article [https://www.typescriptlang.org/docs/handbook/advanced-types.html] 참고 TypeScript 핸드북 1 - 기본 타입 TypeScript 핸드북 2 - 변수 선언 TypeScript 핸드북 3 - 인터페이스 TypeScript 핸드북 4 - 클래스 TypeScript 핸드북 5 - 함수 TypeScript 핸드북 6 - Generic TypeScript 핸드북 7 - Enum TypeScript 핸드북 8 - 타입 유추 TypeScript 핸드북 9 - 타입 호환성 TypeScript 핸드북 10 - 고급 타입 TypeScript 핸드북 11 - Symbol TypeScript 핸드북 12 - Iterator와 Generator","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://infoscis.github.io/categories/TypeScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://infoscis.github.io/tags/JavaScript/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://infoscis.github.io/tags/TypeScript/"}]},{"title":"Angular Webpack 설정","slug":"angular-webpack-configuration","date":"2017-06-14T15:05:38.000Z","updated":"2018-02-13T15:09:45.834Z","comments":true,"path":"2017/06/15/angular-webpack-configuration/","link":"","permalink":"http://infoscis.github.io/2017/06/15/angular-webpack-configuration/","excerpt":"","text":"소개Webpack은 응용 프로그램 소스 코드를 chunk로 묶어 브라우저에서 로드하도록 하는 도구이며 인기있는 모듈 번들러입니다. 이 문서는 다른 문서에서 설명한 SystemJS 접근법에 대한 훌륭한 대안입니다. 이 포스트는 Webpack을 소개하고 Angular 응용 프로그램에서 Webpack을 사용하는 방법을 설명합니다. 코드의 최종 결과를 다운로드 할 수도 있습니다. Webpack이란?Webpack은 강력한 모듈 번들러입니다. Bundle은 함께 포함된 Asset을 통합하는 JavaScript 파일입니다. 그리고 하나의 파일 요청으로 클라이언트에 제공되어야 합니다. Bundle에는 JavaScript, CSS style, HTML 및 거의 모든 종류의 파일이 포함될 수 있습니다. Webpack은 응용 프로그램 소스 코드를 훑어서, import 문을 찾아 의존성 그래프를 작성하고, 하나 이상의 Bundle을 제공합니다. Webpack은 플러그인과 Rule을 통해 TypeScript, SASS, LESS 파일과 같은 JavaScript 파일이 아닌 파일을 사전 처리 및 축약이 가능합니다. Webpack이 해야할 일과 그 일을 어떻게 해야하는지 JavaScript 구성 파일 인 webpack.config.js를 사용하여 정의합니다. Entry와 output하나 이상의 Entry 파일을 Webpack에 제공하고 발견되는 종속성을 찾아 통합시킵니다. 아래 예제에서 Entry 파일은 응용 프로그램의 루트 파일인 src/main.ts입니다. webpack.config.js (single entry)12345webpack.config.js (single entry) content_copyentry: &#123; 'app': './src/main.ts'&#125;, Webpack은 파일을 검사하고 import 의존성을 재귀적으로 확인합니다. src/main.ts12345678import &#123; Component &#125; from '@angular/core';@Component(&#123; selector: 'my-app', templateUrl: './app.component.html', styleUrls: ['./app.component.css']&#125;)export class AppComponent &#123; &#125; 위 예제에서 Webpack이 @angular/core를 import 하는 것을 발견했습니다. 그래서 번들에 포함될 잠재적인 의존성 리스트에 추가합니다. 그리고 @angular/core 파일을 열어 main.ts에서 완전한 종속성 그래프를 작성할 때까지 import 명령문을 계속 찾습니다. 그런 다음 이 파일을 설정에서 지정된 app.js 번들 파일로 통합합니다. 123output: &#123; filename: 'app.js'&#125; 이 app.js 결과 Bundle은 애플리케이션 소스와 그 의존성을 포함하는 단일 JavaScript 파일입니다. 나중에 &amp;lt;script&amp;gt;태그를 사용하여index.html에 로드 할 것입니다. Multiple bundles여러분은 아마도 모든 파일을 하나의 거대한 Bundle로 만들고 싶지 않을 수도 있습니다. 휘발성 응용 프로그램 코드와 비교적 안정적인 vendor 코드 모듈을 분리하는 것이 좋습니다. main.ts와 vendor.ts 두 Entry 포인트를 갖도록 설정을 변경할 수 있습니다. 12345678entry: &#123; app: 'src/app.ts', vendor: 'src/vendor.ts'&#125;,output: &#123; filename: '[name].js'&#125; Webpack은 두개의 독립된 의존성 그래프를 만들고 두개의 Bundle 파일을 생성합니다. 하나는 애플리케이션 코드만 포함하고 있는 app.js이고, 다른 하나는 모든 vendor 의존성을 가진 vendor.js 파일입니다. 결과 이름의 [name]은 Webpack 플러그인이 항목 이름인 app과 vendor로 대체하는 placeholder입니다. 플러그인에 대해서는 나중에 다룹니다. src/vendor.ts 12345678910111213// Angularimport '@angular/platform-browser';import '@angular/platform-browser-dynamic';import '@angular/core';import '@angular/common';import '@angular/http';import '@angular/router';// RxJSimport 'rxjs';// Other vendors for example jQuery, Lodash or Bootstrap// You can import js, ts, css, sass, ... LoadersWebpack은 JavaScript, TypeScript, CSS, SASS, LESS, 이미지, HTML, 글꼴 등 어떤 종류의 파일도 Bundle로 묶을 수 있습니다. Webpack 자체는 JavaScript 파일만 인식합니다. JavaScript 파일이 아닌 파일은 loader를 사용하여 JavaScript로 변환할 수 있습니다. 다음과 같이 TypeScript 및 CSS용 loader를 구성할 수 있습니다. 12345678910rules: [ &#123; test: /\\.ts$/, loader: 'awesome-typescript-loader' &#125;, &#123; test: /\\.css$/, loaders: 'style-loader!css-loader' &#125;] Webpack은 다음과 같은 import 문을 만나면 test RegEx 패턴을 적용합니다. 123import &#123; AppComponent &#125; from './app.component.ts';import 'uiframework/dist/uiframework.css'; 패턴이 파일이름과 일치하면 Webpack은 연관된 loader로 파일을 처리합니다. 첫번째 import 파일은 .ts 패턴과 일치합니다. 그래서 Webpack은 awesome-typescript-loader로 그 파일을 처리합니다. 그리고 파일이 두번째 패턴과 일치하지 않으므로 두번째 loader는 무시됩니다. 두번째 import는 두번째로 .css 패턴과 일치합니다. 두개의 loader가 (!) 문자로 묶여 있습니다. Webpack은 체인 연결된 loader를 오른쪽에서 왼쪽으로 적용합니다. 그래서 css loader를 적용하여 CSS @import와 url(...)문장을 flat하게 만듭니다. 그런 다음 CSS 스타일을 페이지에 &lt;style&lt; 요소 안에 추가하기 위해 style 로더를 적용합니다. 플러그인Webpack에는 잘 정의 된 빌드 파이프 라인이 있습니다. uglify 축약 플러그인과 같은 플러그인으로 그 파이프 라인에 연결할 수 있습니다. 123plugins: [ new webpack.optimize.UglifyJsPlugin()] Webpack 구성간단한 설명이 끝났으니 Angular 응용 프로그램에 대한 Webpack 구성을 직접 작성해 보겠습니다. 개발 환경을 설정하는 것으로 시작하겠습니다. 새 프로젝트 폴더를 만듭니다. 12mkdir angular-webpackcd angular-webpack 아래 파일들을 생성합니다. package.json 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&#123; \"name\": \"angular2-webpack\", \"version\": \"1.0.0\", \"description\": \"A webpack starter for Angular\", \"scripts\": &#123; \"start\": \"webpack-dev-server --inline --progress --port 8080\", \"test\": \"karma start\", \"build\": \"rimraf dist &amp;&amp; webpack --config config/webpack.prod.js --progress --profile --bail\" &#125;, \"license\": \"MIT\", \"dependencies\": &#123; \"@angular/common\": \"~4.2.0\", \"@angular/compiler\": \"~4.2.0\", \"@angular/core\": \"~4.2.0\", \"@angular/forms\": \"~4.2.0\", \"@angular/http\": \"~4.2.0\", \"@angular/platform-browser\": \"~4.2.0\", \"@angular/platform-browser-dynamic\": \"~4.2.0\", \"@angular/router\": \"~4.2.0\", \"core-js\": \"^2.4.1\", \"rxjs\": \"5.0.1\", \"zone.js\": \"^0.8.4\" &#125;, \"devDependencies\": &#123; \"@types/node\": \"^6.0.45\", \"@types/jasmine\": \"2.5.36\", \"angular2-template-loader\": \"^0.6.0\", \"awesome-typescript-loader\": \"^3.0.4\", \"css-loader\": \"^0.26.1\", \"extract-text-webpack-plugin\": \"2.0.0-beta.5\", \"file-loader\": \"^0.9.0\", \"html-loader\": \"^0.4.3\", \"html-webpack-plugin\": \"^2.16.1\", \"jasmine-core\": \"^2.4.1\", \"karma\": \"^1.2.0\", \"karma-chrome-launcher\": \"^2.0.0\", \"karma-jasmine\": \"^1.0.2\", \"karma-sourcemap-loader\": \"^0.3.7\", \"karma-webpack\": \"^2.0.1\", \"null-loader\": \"^0.1.1\", \"raw-loader\": \"^0.5.1\", \"rimraf\": \"^2.5.2\", \"style-loader\": \"^0.13.1\", \"typescript\": \"~2.0.10\", \"webpack\": \"2.2.1\", \"webpack-dev-server\": \"2.4.1\", \"webpack-merge\": \"^3.0.0\" &#125;&#125; src/tsconfig.json 12345678910111213&#123; \"compilerOptions\": &#123; \"target\": \"es5\", \"module\": \"commonjs\", \"moduleResolution\": \"node\", \"sourceMap\": true, \"emitDecoratorMetadata\": true, \"experimentalDecorators\": true, \"lib\": [\"es2015\", \"dom\"], \"noImplicitAny\": true, \"suppressImplicitAnyIndexErrors\": true &#125;&#125; webpack.config.js 1module.exports = require('./config/webpack.dev.js'); karma.conf.js 1module.exports = require('./config/karma.conf.js'); config/helpers.js 12345678910var path = require('path');var _root = path.resolve(__dirname, '..');function root(args) &#123; args = Array.prototype.slice.call(arguments, 0); return path.join.apply(path, [_root].concat(args));&#125;exports.root = root; 이 파일들 중 상당수는 다른 Angular 문서 가이드, 특히 Typescript 구성 및 npm 패키지 포스트와 비슷합니다. Webpack, 플러그인 및 loader는 패키지로도 설치 가능합니다. 그것들은 업데이트 된 packages.json에 나열되어 있습니다. 터미널 창을 열고 npm 패키지를 설치하십시오. 1npm install Polyfills대부분의 브라우저에서 Angular 응용 프로그램을 실행하려면 Polyfill이 필요합니다(브라우저 지원 설명서 참조). Polyfill은 응용 프로그램 및 vendor Bundle과 별도의 Bundle로 제공되어야합니다. 아래의 코드 polyfills.ts를 src/ 폴더에 추가하십시오. src/polyfills.ts 1234567891011import 'core-js/es6';import 'core-js/es7/reflect';require('zone.js/dist/zone');if (process.env.ENV === 'production') &#123; // Production&#125; else &#123; // Development and test Error['stackTraceLimit'] = Infinity; require('zone.js/dist/long-stack-trace-zone');&#125; LOADING POLYFILLS 다른 ES6 및 메타 데이터 shim 직후에 polyfills.ts에서 zone.js를 로드하십시오. polyfills.ts Bundle 파일이 먼저 로드되기 때문에 제작 환경이나 개발 환경에 맞는 브라우저 환경을 구성하기에 좋은 곳입니다. 공통 구성개발자는 일반적으로 개발, 프로덕션 및 테스트 환경에 대해 별도의 구성을 가지고 있습니다. 그리고 세가지 모두 공통된 구성이 있을수 있습니다. webpack.common.js라는 파일에 공통 구성을 모아두겠습니다. config/webpack.common.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566var webpack = require('webpack');var HtmlWebpackPlugin = require('html-webpack-plugin');var ExtractTextPlugin = require('extract-text-webpack-plugin');var helpers = require('./helpers');module.exports = &#123; entry: &#123; 'polyfills': './src/polyfills.ts', 'vendor': './src/vendor.ts', 'app': './src/main.ts' &#125;, resolve: &#123; extensions: ['.ts', '.js'] &#125;, module: &#123; rules: [ &#123; test: /\\.ts$/, loaders: [ &#123; loader: 'awesome-typescript-loader', options: &#123; configFileName: helpers.root('src', 'tsconfig.json') &#125; &#125; , 'angular2-template-loader' ] &#125;, &#123; test: /\\.html$/, loader: 'html-loader' &#125;, &#123; test: /\\.(png|jpe?g|gif|svg|woff|woff2|ttf|eot|ico)$/, loader: 'file-loader?name=assets/[name].[hash].[ext]' &#125;, &#123; test: /\\.css$/, exclude: helpers.root('src', 'app'), loader: ExtractTextPlugin.extract(&#123; fallbackLoader: 'style-loader', loader: 'css-loader?sourceMap' &#125;) &#125;, &#123; test: /\\.css$/, include: helpers.root('src', 'app'), loader: 'raw-loader' &#125; ] &#125;, plugins: [ // Workaround for angular/angular#11580 new webpack.ContextReplacementPlugin( // The (\\\\|\\/) piece accounts for path separators in *nix and Windows /angular(\\\\|\\/)core(\\\\|\\/)@angular/, helpers.root('./src'), // location of your src &#123;&#125; // a map of your routes ), new webpack.optimize.CommonsChunkPlugin(&#123; name: ['app', 'vendor', 'polyfills'] &#125;), new HtmlWebpackPlugin(&#123; template: 'src/index.html' &#125;) ]&#125;; webpack.common.js 살펴 보기Webpack은 JavaScript commonjs 모듈 파일에서 설정을 읽는 NodeJS 기반 도구입니다. 이 설정은 의존성을 require 문으로 가져오고 여러 객체를 module.exports 객체의 프로퍼티로 내 보냅니다. entry - 번들을 정의하는 진입 파일. resolve - 확장자가 없을 때 파일 이름을 확인하는 방법. module.rules - module은 파일들이 로딩되는 방법을 결정하기위한 rules를 가진 객체입니다. plugins - 플러그인의 인스턴스를 만듭니다. entry첫번째는 entry 객체입니다. config/webpack.common.js 12345entry: &#123; 'polyfills': './src/polyfills.ts', 'vendor': './src/vendor.ts', 'app': './src/main.ts'&#125;, 이 entry 객체는 세개의 Bundle을 정의합니다. polyfills - 대부분의 최신 브라우저에서 Angular 응용 프로그램을 실행하는 데 필요. vendor - Angular, lodash 및 bootstrap.css와 같은 타사 의존 라이브러리. app - 응용 프로그램 코드. resolve - 확장자가 없는 import 파일 처리애플리케이션은 많은 수의 JavaScript 파일 또는 TypeScript 파일을 import할 것입니다. 다음 예와 같이 명시적 확장자를 가진 import 문을 쓸 수도 있습니다. 1import &#123; AppComponent &#125; from './app.component.ts'; 그러나 대부분의 import 문은 확장자를 전혀 언급하지 않습니다. Webpack에게 .ts 확장자 또는 .js 확장자 (정규 자바 스크립트 파일과 미리 컴파일 된 TypeScript 파일용)로 일치하는 파일을 찾게 함으로써 확장자가 없는 파일 요청을 해석 하도록합니다. config/webpack.common.js 123resolve: &#123; extensions: ['.ts', '.js']&#125;, Webpack이 스타일과 HTML에 대한 확장자가없는 파일을 읽어야 한다면 .css와 .html을 목록에 추가하십시오. module.rulesmodule.rules는 Webpack에게 각 파일이나 모듈에 사용할 로더를 알려줍니다 config/webpack.common.js 12345678910111213141516171819202122232425262728293031module: &#123; rules: [ &#123; test: /\\.ts$/, loaders: [ &#123; loader: 'awesome-typescript-loader', options: &#123; configFileName: helpers.root('src', 'tsconfig.json') &#125; &#125; , 'angular2-template-loader' ] &#125;, &#123; test: /\\.html$/, loader: 'html-loader' &#125;, &#123; test: /\\.(png|jpe?g|gif|svg|woff|woff2|ttf|eot|ico)$/, loader: 'file-loader?name=assets/[name].[hash].[ext]' &#125;, &#123; test: /\\.css$/, exclude: helpers.root('src', 'app'), loader: ExtractTextPlugin.extract(&#123; fallbackLoader: 'style-loader', loader: 'css-loader?sourceMap' &#125;) &#125;, &#123; test: /\\.css$/, include: helpers.root('src', 'app'), loader: 'raw-loader' &#125; ]&#125;, awesome-typescript-loader - tsconfig.json 파일에 따라 Typescript 코드를 ES5로 변환하는 로더입니다. angular2-template-loader - 각 구성 요소의 템플릿과 스타일을 로드합니다. html-loader - html 템플릿 컴포넌트 이미지/글꼴 - 이미지와 글꼴도 번들로 제공됩니다. CSS - 첫 번째 패턴은 application-wide 스타일과 일치합니다. 두 번째 요소는 component-scoped 스타일(구성 요소의 styleUrls 메타 데이터 프로퍼티에 지정된 스타일)을 처리합니다. 첫번째 패턴은 application-wide 스타일을 위한 것입이다. 이것은 src/app 디렉토리에서 component-scoped 스타일이 있는 .css 파일을 제외시킵니다. ExtractTextPlugin(아래에 설명 됨)은 style과 css loader를 이 파일들에 적용합니다. 두번째 패턴은 component-scoped 스타일을 필터링하고 raw-loader를 통해 문자열로 로드합니다. 이는 Angular가 styleUrls 메타 데이터 프로퍼티에 지정된 스타일을 사용하여 수행하는 작업입니다. 배열 표기법을 사용하여 여러 로더를 연결할 수 있습니다. plugins마지막으로 세개의 플러그인 인스턴스를 만듭니다. config/webpack.common.js 1234567891011121314151617plugins: [ // Workaround for angular/angular#11580 new webpack.ContextReplacementPlugin( // The (\\\\|\\/) piece accounts for path separators in *nix and Windows /angular(\\\\|\\/)core(\\\\|\\/)@angular/, helpers.root('./src'), // location of your src &#123;&#125; // a map of your routes ), new webpack.optimize.CommonsChunkPlugin(&#123; name: ['app', 'vendor', 'polyfills'] &#125;), new HtmlWebpackPlugin(&#123; template: 'src/index.html' &#125;)] CommonsChunkPluginapp.js Bundle은 애플리케이션 코드 만 포함해야합니다. 모든 vendor 코드는 vendor.js Bundle에 들어 있습니다. 물론 응용 프로그램 코드에서 vendor 코드를 가져옵니다. 자체적으로, Webpack은 app.js 번들에서 vendor 코드를 유지할 만큼 똑똑하지 않습니다. 그래서 CommonsChunkPlugin이 그러한 작업을 합니다. CommonsChunkPlugin은 app-&gt;vendor-&gt;polyfills의 3 개의 청크들 사이의 계층을 식별합니다. Webpack은 app이 vendor와 의존성을 공유했다는 것을 발견하면 app에서 공유 의존성을 제거합니다. 그리고 의존하지 않는 의존성을 공유했다면 polyfills를 vendor에서제거 할 수 있습니다. HtmlWebpackPluginWebpack은 많은 js 및 CSS 파일을 생성합니다. 그 파일들을 수동으로 index.html에 삽입 할 수 있습니다. 하지만 지루하고 오류가 발생하기 쉽습니다. 그래서 Webpack은 HtmlWebpackPlugin을 사용하여 스크립트와 링크를 삽입 할 수 있습니다. 특정 환경 구성webpack.common.js 설정 파일에서 대부분의 어려운 작업을 수행합니다. 대상 환경과 관련된 특성을 병합하여 webpack.common에 빌드된 환경별 구성 파일을 별도로 작성할 수 있습니다. 이 파일들은 짧고 단순한 경향이 있습니다. 개발 환경 구성다음은 webpack.dev.js 개발 설정 파일입니다. config/webpack.dev.js 123456789101112131415161718192021222324var webpackMerge = require('webpack-merge');var ExtractTextPlugin = require('extract-text-webpack-plugin');var commonConfig = require('./webpack.common.js');var helpers = require('./helpers');module.exports = webpackMerge(commonConfig, &#123; devtool: 'cheap-module-eval-source-map', output: &#123; path: helpers.root('dist'), publicPath: '/', filename: '[name].js', chunkFilename: '[id].chunk.js' &#125;, plugins: [ new ExtractTextPlugin('[name].css') ], devServer: &#123; historyApiFallback: true, stats: 'minimal' &#125;&#125;); 개발 빌드는 파일 맨 아래에 구성된 Webpack 개발 서버에 의존합니다. Webpack이 output Bundle을 dist 폴더에 넣도록 지시하더라도, dev 서버는 모든 Bundle을 메모리에 유지합니다. 디스크에 기록하지 않습니다. 적어도 이 개발 빌드에서 생성된 파일은 dist 폴더에 없습니다. webpack.common.js에 추가 된 HtmlWebpackPlugin은 publicPath와 파일 이름 설정을 사용하여 적절한 &lt;script&gt;와 &lt;link&gt;태그를 index.html에 생성합니다. CSS 스타일은 기본적으로 Javascript Bundle 안에 있습니다. ExtractTextPlugin은 그것들을 HtmlWebpackPlugin이 &lt;link&gt;태그로 index.html에 넣을수 있는 외부 .css 파일들로 추출합니다. 이 파일의 이러한 구성 옵션 및 기타 구성 옵션에 대한 자세한 내용은 Webpack 문서를 참조하십시오. 이 가이드의 끝 부분에 있는 코드를 가지고 시도해 보세요. 1npm start 프로덕션 환경 구성프로덕션 빌드의 구성은 몇 가지 주요 변경 사항을 포함하며 개발 환경 구성과 유사합니다. config/webpack.prod.js 1234567891011121314151617181920212223242526272829303132333435363738var webpack = require('webpack');var webpackMerge = require('webpack-merge');var ExtractTextPlugin = require('extract-text-webpack-plugin');var commonConfig = require('./webpack.common.js');var helpers = require('./helpers');const ENV = process.env.NODE_ENV = process.env.ENV = 'production';module.exports = webpackMerge(commonConfig, &#123; devtool: 'source-map', output: &#123; path: helpers.root('dist'), publicPath: '/', filename: '[name].[hash].js', chunkFilename: '[id].[hash].chunk.js' &#125;, plugins: [ new webpack.NoEmitOnErrorsPlugin(), new webpack.optimize.UglifyJsPlugin(&#123; // https://github.com/angular/angular/issues/10618 mangle: &#123; keep_fnames: true &#125; &#125;), new ExtractTextPlugin('[name].[hash].css'), new webpack.DefinePlugin(&#123; 'process.env': &#123; 'ENV': JSON.stringify(ENV) &#125; &#125;), new webpack.LoaderOptionsPlugin(&#123; htmlLoader: &#123; minimize: false // workaround for ng2 &#125; &#125;) ]&#125;); 응용 프로그램과 그 의존 라이브러리를 실제 프로덕션 서버에 배포합니다. 하지만 개발에만 필요한 라이브러리는 배포하지 않습니다. 결과 Bundle 파일은 dist 폴더에 생성합니다. Webpack은 cache-busting 해시로 파일 이름을 생성합니다. HtmlWebpackPlugin 덕분에 해시가 변경 될 때 index.html 파일을 업데이트 할 필요가 없습니다. 추가 플러그인이 있습니다. NoEmitOnErrorsPlugin - 오류가 있으면 빌드를 중지합니다. UglifyJsPlugin - 번들을 축약합니다. ExtractTextPlugin - 내장 된 CSS를 외부 파일로 추출하여 파일 이름에 캐시 해싱 해시를 추가합니다. DefinePlugin - 응용 프로그램에서 참조할 수 있는 환경 변수를 정의하는 데 사용됩니다. LoaderOptionsPlugins - 특정 loader의 옵션을 대체합니다. DefinePlugin과 맨 위에 정의 된 ENV 변수 덕분에 Angular 프로덕션 모드를 다음과 같이 설정할 수 있습니다. src/main.ts 123if (process.env.ENV === 'production') &#123; enableProdMode();&#125; 이 가이드의 끝 부분에 있는 코드를 가지고 시도해 보세요. 1npm run build 테스트 환경 구성단위 테스트를 실행하는 데 많은 구성이 필요하지 않습니다. 개발 및 프로덕션 빌드를 위해 선언한 loader 및 플러그인은 필요하지 않습니다. 단위 테스트를 위해 application-wide 스타일 파일을 로드하고 처리 할 필요가 없으므로 속도가 느려지지 않습니다. 그래서 CSS 파일에 null 로더를 사용할 것이다. 테스트 설정을 webpack.common 설정으로 합치고 싶지 않거나 필요하지 않은 부분을 무시할 수 있습니다. 완전히 새로운 구성으로 다시 시작하는 것이 더 간단 할 수 있습니다. config/webpack.test.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152var webpack = require('webpack');var helpers = require('./helpers');module.exports = &#123; devtool: 'inline-source-map', resolve: &#123; extensions: ['.ts', '.js'] &#125;, module: &#123; rules: [ &#123; test: /\\.ts$/, loaders: [ &#123; loader: 'awesome-typescript-loader', options: &#123; configFileName: helpers.root('src', 'tsconfig.json') &#125; &#125; , 'angular2-template-loader' ] &#125;, &#123; test: /\\.html$/, loader: 'html-loader' &#125;, &#123; test: /\\.(png|jpe?g|gif|svg|woff|woff2|ttf|eot|ico)$/, loader: 'null-loader' &#125;, &#123; test: /\\.css$/, exclude: helpers.root('src', 'app'), loader: 'null-loader' &#125;, &#123; test: /\\.css$/, include: helpers.root('src', 'app'), loader: 'raw-loader' &#125; ] &#125;, plugins: [ new webpack.ContextReplacementPlugin( // The (\\\\|\\/) piece accounts for path separators in *nix and Windows /angular(\\\\|\\/)core(\\\\|\\/)@angular/, helpers.root('./src'), // location of your src &#123;&#125; // a map of your routes ) ]&#125; Karma를 재구성하여 Webpack을 사용하여 테스트를 실행할 수 있습니다. config/karma.conf.js 12345678910111213141516171819202122232425262728293031323334353637var webpackConfig = require('./webpack.test');module.exports = function (config) &#123; var _config = &#123; basePath: '', frameworks: ['jasmine'], files: [ &#123;pattern: './config/karma-test-shim.js', watched: false&#125; ], preprocessors: &#123; './config/karma-test-shim.js': ['webpack', 'sourcemap'] &#125;, webpack: webpackConfig, webpackMiddleware: &#123; stats: 'errors-only' &#125;, webpackServer: &#123; noInfo: true &#125;, reporters: ['progress', 'kjhtml'], port: 9876, colors: true, logLevel: config.LOG_INFO, autoWatch: false, browsers: ['Chrome'], singleRun: true &#125;; config.set(_config);&#125;; TypeScript를 프리컴파일 파일하지 않습니다. Webpack은 Typescript 파일을 메모리에 저장하고 생성된 JS를 카르마에 직접 공급합니다. 디스크에 임시 파일이 없습니다. karma-test-shim은 Karma에게 미리 로드 될 것으로 예상되는 provider의 테스트 버전으로 Angular 테스트 프레임 워크를 미리 로드하고 준비 할 파일을 알려줍니다. config/karma-test-shim.js 123456789101112131415161718192021Error.stackTraceLimit = Infinity;require('core-js/es6');require('core-js/es7/reflect');require('zone.js/dist/zone');require('zone.js/dist/long-stack-trace-zone');require('zone.js/dist/proxy');require('zone.js/dist/sync-test');require('zone.js/dist/jasmine-patch');require('zone.js/dist/async-test');require('zone.js/dist/fake-async-test');var appContext = require.context('../src', true, /\\.spec\\.ts/);appContext.keys().forEach(appContext);var testing = require('@angular/core/testing');var browser = require('@angular/platform-browser-dynamic/testing');testing.TestBed.initTestEnvironment(browser.BrowserDynamicTestingModule, browser.platformBrowserDynamicTesting()); 응용 프로그램 코드를 명시 적으로 로드하지 않습니다. Webpack에게 테스트 파일 (.spec.ts로 끝나는 파일)을 찾아서 로드하라고 지시합니다. 각 spec 파일은 테스트하는 모든 응용 프로그램 소스 코드만 가져옵니다. Webpack은 특정 응용 프로그램 파일만 로드하고, 테스트하지 않는 다른 파일은 무시합니다. 이 가이드의 끝 부분에 있는 코드를 가지고 시도해 보세요. 1npm test 따라해보기이 포스트에서 다루는 Webpack으로 Bundle을 묶을수 있는 간단한 응용 프로그램의 소스 코드입니다. src/index.html 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;base href=\"/\"&gt; &lt;title&gt;Angular With Webpack&lt;/title&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;/head&gt; &lt;body&gt; &lt;my-app&gt;Loading...&lt;/my-app&gt; &lt;/body&gt;&lt;/html&gt; src/main.ts 12345678910import &#123; platformBrowserDynamic &#125; from '@angular/platform-browser-dynamic';import &#123; enableProdMode &#125; from '@angular/core';import &#123; AppModule &#125; from './app/app.module';if (process.env.ENV === 'production') &#123; enableProdMode();&#125;platformBrowserDynamic().bootstrapModule(AppModule); src/assets/css/styles.css 1234body &#123; background: #0147A7; color: #fff;&#125; src/app/app.component.ts 12345678910import &#123; Component &#125; from '@angular/core';import '../assets/css/styles.css';@Component(&#123; selector: 'my-app', templateUrl: './app.component.html', styleUrls: ['./app.component.css']&#125;)export class AppComponent &#123; &#125; src/app/app.component.html 12345&lt;main&gt; &lt;h1&gt;Hello from Angular App with Webpack&lt;/h1&gt; &lt;img src=\"../assets/images/angular.png\"&gt;&lt;/main&gt; src/app/app.component.css 1234567main &#123; padding: 1em; font-family: Arial, Helvetica, sans-serif; text-align: center; margin-top: 50px; display: block;&#125; src/app/app.component.spec.ts 1234567891011121314import &#123; TestBed &#125; from '@angular/core/testing'; import &#123; AppComponent &#125; from './app.component'; describe('App', () =&gt; &#123; beforeEach(() =&gt; &#123; TestBed.configureTestingModule(&#123; declarations: [AppComponent]&#125;); &#125;); it ('should work', () =&gt; &#123; let fixture = TestBed.createComponent(AppComponent); expect(fixture.componentInstance instanceof AppComponent).toBe(true, 'should create AppComponent'); &#125;);&#125;); src/app/app.module.ts 123456789101112131415import &#123; NgModule &#125; from '@angular/core';import &#123; BrowserModule &#125; from '@angular/platform-browser'; import &#123; AppComponent &#125; from './app.component'; @NgModule(&#123; imports: [ BrowserModule ], declarations: [ AppComponent ], bootstrap: [ AppComponent ]&#125;)export class AppModule &#123; &#125; app.component.html은 다운로드 할 수있는 Angular 로고를 표시합니다. 프로젝트의 assets 폴더 아래에 images라는 폴더를 생성한 다음 이미지를 마우스 오른쪽 버튼으로 클릭하고 (Mac에서는 Cmd + 클릭) 다운로드 하십시오. 아래에 polyfills와 vendor Bundle을 정의하는 TypeScript Entry 파일이 있습니다. src/polyfills.ts 1234567891011import 'core-js/es6';import 'core-js/es7/reflect';require('zone.js/dist/zone');if (process.env.ENV === 'production') &#123; // Production&#125; else &#123; // Development and test Error['stackTraceLimit'] = Infinity; require('zone.js/dist/long-stack-trace-zone');&#125; src/vendor.ts 12345678910111213// Angularimport '@angular/platform-browser';import '@angular/platform-browser-dynamic';import '@angular/core';import '@angular/common';import '@angular/http';import '@angular/router'; // RxJSimport 'rxjs'; // Other vendors for example jQuery, Lodash or Bootstrap// You can import js, ts, css, sass, ... 하이라이트 &lt;script&gt;또는 &lt;link&gt;태그는 index.html에 없습니다. HtmlWebpackPlugin은 그것들을 런타임에 동적으로 삽입합니다. appComponent.ts에있는 AppComponent는 간단한 import 문으로 application-wide css를 가져옵니다. AppComponent 자체는 자체 html 템플릿과 css 파일을 가지고 있습니다. WebPack은 require()를 호출하여 이를 로드합니다. Webpack은 app.js Bundle에 있는 component-scoped 파일도 숨깁니다. 소스 코드에서 이러한 호출을 볼 수 없습니다. 그들은 angular2-template-loader 플러그인으로 뒤에 추가됩니다. vendor.ts는 vendor.js Bundle을 구동시키는 vendor import 문으로 구성됩니다. 응용 프로그램은 이러한 모듈도 가져올 수 있습니다. CommonsChunkPlugin이 겹침을 감지하지 못하고 app.js에서 제거한 경우 app.js 번들에 중복될 수 있습니다. 결론간단한 Angular 애플리케이션을 위한 개발, 테스트 및 프로덕션 빌드를 구성하기에 충분한 Webpack을 배웠습니다. 여러분은 더 많은 것을 할 수 있습니다. 웹에서 전문가 조언을 검색하고 Webpack 지식을 확장하십시오. 이 내용은 나중에 참고하기 위해 제가 공부하며 정리한 내용입니다.의역, 오역, 직역이 있을 수 있음을 알려드립니다.This post is a translation of this original article [https://angular.io/guide/webpack]","categories":[{"name":"Angular","slug":"Angular","permalink":"http://infoscis.github.io/categories/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://infoscis.github.io/tags/Angular/"}]},{"title":"Webpack을 이용한 TDD 방식의 Angular 2 개발 환경 설정","slug":"setting-up-angular-2-with-webpack","date":"2017-06-13T14:22:46.000Z","updated":"2018-02-13T15:10:58.923Z","comments":true,"path":"2017/06/13/setting-up-angular-2-with-webpack/","link":"","permalink":"http://infoscis.github.io/2017/06/13/setting-up-angular-2-with-webpack/","excerpt":"","text":"Webpack을 이용한 TDD 방식의 Angular 개발 환경 구축하기Webpack 및 TypeScript를 사용하여 테스트 주도의 Angular 프로젝트를 설정하는 데 필요한 단계를 살펴보겠습니다. Angular 1 버전은 AngularJS로 호칭하고, Angular 2 이상 버전은 Angular로 호칭합니다. 소개이 포스트에서는 단위 테스트로 Angular 프로젝트를 생성하는 데 필요한 구성을 살펴 보겠습니다. 다양한 필수 기술과 각 설정을 작성하는 방법에 대해 다룰 것입니다. 선행 조건시작하기 전에 다음 사항을 가정합니다. CommonJS 모듈의 개념을 포함하여 JavaScript에 대한 중급이상의 이해. AngularJS에 대한 대략적인 이해. 화살표 함수, 모듈, 클래스 및 Block-level 변수와 같은 ES6/ES2015 개념의 이해. Git Bash, iTerm 또는 운영 체제의 내장 터미널과 같은 명령행 또는 터미널 사용에 대한 이해. Node &gt;= v4 및 NPM &gt;= v2이상 설치된 환경. Angular란?Angular는 JavaScript 응용 프로그램을 개발하기위한 프레임 워크이고 매우 인기있는 Google Angular 프레임 워크의 두 번째 주요 버전입니다. 현대적이고 강력한 개발 경험을 제공하기 위해 TypeScript를 사용하여 처음부터 작성되었습니다. TypeScript는 Angular로 개발할 때 선호되는 언어이지만 ES5 및 일반 ES2015를 통해 개발할 수 있습니다. 하지만 이 포스트에서는 TypeScript를 사용합니다. AngularJS와 차이점Angular 커뮤니티에는 Angular 팀 구성원 인 Igor Minar와 Tobias Bosch가 Angulr 개발자에게 익숙한 많은 개념이 버려지는 것을 알리는 잘 알려진 동영상 (슬라이드)이 있습니다. 이러한 개념은 다음과 같습니다. Controllers, Directive Definition Objects $scope angular.module(…) jqLite 이러한 변경 사항 중 상당수는 개발자가 머리 속에서 추적해야하는 개념을 단순화했습니다. 이는 Angular를 사용한 개발이 간소화 된다는 것을 의미합니다. AngularJS 개념을 Angular에 매핑하는 방법을 보려면 이 내용을 읽으십시오. TypeScript 사용하기위에서 언급했듯이 Angular는 TypeScript 없이 개발할 수 있지만 TypeScript는 ES2015 위에 추가 기능을 제공하므로 개발 프로세스가 더 풍부 해집니다. 이 섹션에서는 TypeScript에 대해 간단히 살펴보도록 하겠습니다. TypeScript는 Javascript의 상위 집합입니다. 그게 무슨 뜻일까요?. 이미 JavaScript가 TypeScript에 의해 해석 가능하다는 것을 의미합니다. 여러분이 가지고 있는 JavaScript 파일을 가져 와서 확장자를 .ts로 변경하고, TypeScript 파서를 통해 이를 실행할 수 있으며, TypeScript는 이를 모두 이해할 수 있습니다. 그리고 컴파일러가 출력하는 것은 JavaScript 코드입니다. 그 코드는 원래코드보다 낫거나 더 잘 작성됩니다. 가장 눈에 띄는 TypeScript 기능 중 하나는 Optional 타이핑 시스템입니다. 하지만 이것은 선택 사항입니다. 그러나 타입을 사용하면 코드에 대한 추론이 쉬워집니다. 그리고 많은 편집기가 TypeScript의 코드 완성 기능을 사용할 수있게 지원합니다. 또 다른 기능은 인터페이스를 정의하는 기능으로, 코드 전체에서 타입으로 사용할 수 있습니다. 이는 코드 전체의 데이터 구조가 일관성을 유지해야 할 때 도움이됩니다. 123456789101112131415// note this code is available in the repo // at ./examples/introduction/types-and-interfaces.ts// MyType is a custom interfaceinterface MyType &#123; id: number; name: string; active?: boolean; // the \"?\" makes this an optional field&#125;// someFunction takes three parameters, the third of which is an// optional callbackfunction someFunction(id: string, value: MyType, callback?: Function) &#123; // ...&#125; 이제 someFunction을 코딩하고 호출한다면 TypeScript를 지원하는 에디터는 파라미터에 대한 자세한 정의를 제공합니다. 또한 변수가 MyType으로 정의되어 있다면, 코드 완성 기능은 MyType에서 사용할 수있는 속성과 그 속성의 타입을 보여줍니다. TypeScript는 컴파일러를 통해 코드를 실행하는 일종의 빌드 프로세스가 필요합니다. 이후 섹션에서는 TypeScript 컴파일러의 구성을 설정합니다. Webpack이란?Webpack 웹 사이트에는 “webpack은 모듈 로더”이며 “종속성이있는 모듈을 가져 와서 static asset을 생성”하는 것으로 설명합니다. 또한 플러그인 시스템과 파일 처리 방법을 제공합니다. 모듈 로딩(Module Loading)모듈 로딩이란 무슨 의미일까요? 아주 간단한 예를 살펴 보겠습니다. 우리는 app.js, child1.js, child2.js 및 grandchild.js의 4 개 파일로 된 프로젝트를 가정해 보겠습니다. app.js는 child1.js 및 child2.js에 의존합니다. child2.js는 grandchild.js에 의존합니다. 우리는 app.js를 Webpack에서 돌아가도록 명령할 수 있으며, 모든 파일이 포함되는 파일을 컴파일합니다. app.js에서 import 또는 require와 같이 의존성을 나타내는 모든 문장을 찾아내어 이를 수행합니다. app.js에는 다음과 같은 것들이 있습니다. 12const child1 = require('./child1.js');const child2 = require('./child2.js'); Webpack은 child1.js, child2.js를 찾아, 읽고, 또 의존성을 찾습니다. child1.js와 같이 종속성이 없는 파일에 도달 할 때까지 반복합니다. 하지만 child2.js의 경우에는 종속성이 또 있습니다. 1const grandchild = require('./grandchild.js'); 따라서 Webpack은 grandchild.js를 찾아서 읽고, 의존성을 확인하지만 더이상 의존성이 없어 처리를 완료합니다. 결국 4 개의 파일이 모두 컴파일되어 브라우저에서 사용할 수있게됩니다. 간단히 말해, 이것이 모듈 로딩이 하는 일입니다. 파일 처리 (File Processing)Webpack은 종속성을 기반으로 모듈을 로드하는 것 외에도 loader라는 처리 메커니즘을 제공합니다. loader가 무엇을하는지 보기위해 다른 예제를 살펴 보겠습니다. TypeScript 파일이 있다고 가정하겠습니다. 위에서 언급했듯이 TypeScript 파일을 JavaScript로 컴파일하려면 TypeScript 컴파일러를 통해 실행해야 합니다. 그러한 역할을 Webpack loader가 합니다. 우리는 Webpack에게 .ts 파일을 만나면 TypeScript 컴파일러를 통해 파일을 실행해야 한다고 말할 수 있습니다. 거의 모든 파일 유형 (SASS, LESS, HTML, Jade, JavaScript와 유사한 파일이 아닌 파일)에서도 동일한 작업을 수행 할 수 있습니다. 이 개념은 Webpack을 일종의 빌드 시스템으로 사용하여 Angular를 브라우저 나 테스트 환경에 사용하는 데 필요한 많은 작업을 수행 할 수있게 해주기 때문에 유용합니다. 왜 단위 테스트를 해야 하는가? (Why Should We Unit Test?)우리가 어플리케이션을 개발할 때 우리가 할 수있는 가장 중요한 일은 코드를 가능한 한 빨리 버그없는 상태로 개발하는 것입니다. 테스트는 이러한 목표를 달성하는 데 도움이됩니다. 단위 테스트를 수행하지 않는 개발자의 가장 큰 불만은 시간이 너무 많이 걸린다는 것입니다. 개발 과정에서 단위 테스트를 처음 사용할 때 익숙해지는 시간보다 오래 걸릴 수 있습니다. 그러나 장기적인 이점은 초기 투자보다 훨씬 큽니다. 특히 응용 프로그램 코드를 작성하기 전에 테스트 코드를 먼저 작성하면 더욱 좋습니다. 이를 테스트 주도 개발 (TDD)이라고합니다. 테스트 주도 개발 (Test-driven Development)우리는 isPrimary라는 JavaScript 함수를 작성해야 한다고 가정해 보겠습니다. 이 함수의 주요 목적은 숫자가 소수이면 true를 반환하고 그렇지 않으면 false를 반환하는 것입니다. 과거에는 머리를 먼저 짚어 보았을 것입니다. 아마도 Google에서 소수가 무었인지, 또는 문제를 풀수 있는 알고리즘을 찾았을 것이지만 이제 TDD를 사용해 보겠습니다. 우리는 궁극적 인 목표가 숫자가 소수인지 아닌지에 대한 true/false를 출력하는 것을 알고 있지만 버그없는 함수를 얻기 위해 해결해야 할 몇 가지 다른 주요사항이 있습니다. 함수는 어떤 파라미터를 가져야 할까요? 그리고 입력 되지 않으면 어떻게 처리 할까요? 사용자가 숫자가 아닌 값을 전달하면 어떻게 처리 할까요? 정수가 아니면 어떻게 처리 할까요? 우리가 TDD의 관점에서 접근할 때, 우리의 첫번째 단계는 무엇이 잘못 될 수 있는지를 스스로에게 물어보고 그 문제를 해결하는 방법을 찾아내는 것입니다. 이러한 과정이 없다면, 이러한 문제의 경우에 대해 생각하지 않을 수도 있고, 그 부분을 놓칠수도 있습니다. 그러한 경우 코드를 완전히 새로 수정해야할 수도 있고, 또 그 수정의 과정에서 새로운 버그를 유발할 수 있습니다. TDD의 핵심 중 하나는 테스트 통과를 위한 충분한 코드를 작성하는 것입니다. 그리고 이 목표를 달성하기 위해 red-green-refactor 사이클이라는 프로세스를 사용합니다. 단계는 다음과 같습니다. 목표 달성을 위해 필요한 테스트에 대해 생각해보십시오. 테스트 작성, 테스트 실행, 테스트 실패 감시 (red) 패스(green) 할수 있는 코드를 작성 잠시 시간을 내어 나쁜 냄새가 나는 코드를 찾아 봅니다. 코드를 찾으면 리팩토링 하십시오. 코드를 변경할 때마다 테스트를 실행하여 실패가 나는지 확인하십시오. 반복. 1 단계는 TDD 및 단위 테스트를 처음 접하는 개발자에게 가장 힘든 단계 일 것입니다. 하지만 시간이 지남에 따라 점점 더 편안 해지고 테스트 방법의 패턴을 인식하게 될 것입니다. 단위 테스트와 TDD의 장점단위 테스트의 몇 가지 장점을 이미 보았지만 여기에 더 많은 예가 있습니다. 코드의 버그 수준을 줄입니다. 우리가 목표를 달성하기에 충분한 코드를 작성하기 때문에 애플리케이션 코드가 줄어듭니다. 코드를 리팩터링하는 것이 더 쉽습니다. 함수를 사용하는 방법에 대한 샘플 코드를 제공합니다. low-level regression 테스트 suite를 얻습니다. 코드 작성 속도를 높입니다. 단위 테스트와 TDD의 단점단위 테스트는 완벽한 코드를 작성하는 데 큰 영향을 주지 않습니다. TDD에는 단점이 있습니다. 다음은 이러한 단점 중 일부입니다. 잘못된 품질 감각을 줄 수 있습니다. 시간이 많이 걸릴 수 있습니다. 코드베이스에 복잡성을 추가할 수 있습니다. mock 객체 및 stubbed-out 코드가 필요함. 특히 외부의 코드들 (예: 서드 파티 코드) 대규모 코드베이스의 경우 데이터 구조와 응용 프로그램의 일부분을 수정하면 테스트가 크게 변경 될 수 있습니다. 이러한 단점이 존재 하지만 만약 테스트 주도 방식에 부지런하고 신중할 경우 테스트 및 TDD의 장점이 단점보다 더 중요합니다. NPM을 Task Runner로 사용하기이전 내용에서 Webpack을 사용하여 빌드 프로세스 기능 중 많은 부분을 수행 할 수 있지만 호출하는 방법은 알 수 없었습니다. 지금까지 많은 수의 Task Runner에 대해 알고 있었을 것입니다(예를 들어 Grunt, Gulp, Broccoli 등). 프로젝트 의존 라이브러리를 설치하기 위해 이미 사용하고있는 NPM은 Task를 실행하기 위한 간단한 시스템을 제공합니다. 아시다시피 NPM을 사용하는 각 프로젝트에는 package.json 파일이 필요합니다. package.json 섹션 중 하나는 scripts 섹션입니다. 이 섹션의 키는 Task의 이름이고, 값은 Task가 승인되면 실행될 스크립트가 지정되는 JSON 객체입니다. 그러므로, 우리가 package.json에 다음과 같이하면 : 1234567... \"scripts\": &#123; \"foo\": \"node ./scripts/foo.js\", \"bar\": \"node node_modules/bar\", \"baz\": \"baz some/config.file\" &#125;... 이러한 Task를 실행하려면 npm run [task name]이라고 하면됩니다. foo를 실행하려면 다음과 같이 하면됩니다. 1npm run foo 그러면 node ./scripts/foo.js가 실행됩니다. npm run baz를 실행하면 node_modules/.bin을 통해 baz 노드 모듈을 찾은 다음 some/config.file을 사용해 실행합니다. 우리는 이미 이 Task Runner 기능을 가지고 있기 때문에 단위 테스트 실행과 같은 작업을 수행하는데 사용할 수 있습니다. scripts 섹션 사용에 대한 자세한 내용은 공식 NPM 문서를 참조하십시오. 의존 라이브러리 설치이제 프로젝트를 실제로 설정해 보겠습니다. 첫 번째 단계는 필요한 모든 의존 라이브러리를 확보하는 것입니다. Angular, TypeScript, Webpack 및 단위 테스트를 가져올 것입니다. NPM Project 생성하기우리가 해야 할 첫 번째 일은 NPM 프로젝트를 만드는 것입니다. 다음 단계를 수행합니다. 디렉토리를 만듭니다. 이름은 중요하지 않지만 설명하기 쉽도록하는 것이 유용합니다. 예를 들어 ng2-webpack-test cd ng2-webpack-test 또는 디렉토리 이름을 무엇이든 상관없이 그 디렉토리로 이동하십시오. npm init -f를 실행하십시오. 여러분의 프로젝트를 위한 package.json 파일을 생성 할 것입니다. 명령어 실행은 위의 1 단계에서 작성한 디렉토리에서 모두 실행해야합니다. Angular 의존 라이브러리Angular는 NPM의 @angular Organization에 많은 패키지로 나뉩니다. Angular를 설치하고 RxJS, Zone.js 및 일부 shim을 가져와야합니다. 이 작업은 단일 설치 작업을 통해 수행 할 수 있습니다. 1npm i -S @angular/common @angular/compiler @angular/core @angular/platform-browser @angular/platform-browser-dynamic es6-shim reflect-metadata rxjs@5.0.0-beta.6 zone.js i는 install의 단축 옵션이고 -S는 --save의 단축 옵션입니다. 각 프로젝트가 무엇인지 확인하려면 Angular 문서를 살펴보십시오. 이러한 패키지 중 일부는 단위 테스트를 수행하는 데 즉시 필요한 것은 아니지만 브라우저에서 응용 프로그램을 실행하는데 필요합니다. TypeScript 의존 라이브러리TypeScript는 이 프로젝트에서 사용할 것이기 때문에 우리는 의존성 (dependency)으로 그것을 끌어올 필요가 있습니다. 그리로 코드의 실수를 줄이고 코딩 표준을 유지하기 위해 TypeScript linter 인 tslint를 통해 코드 linting을 사용할 것입니다. 1npm i -D typescript tslint typings -D는 --save-dev의 단축 옵션입니다. typings은 TypeScript 정의 파일을 가져 와서 타사 라이브러리를 이해하고 해당 라이브러리에 대한 코드 완성 기능을 제공 할 수있는 방법입니다. 나중에 이 방법에 대해 설명하도록 하겠습니다. Webpack 의존 라이브러리또한 Webpack을 사용하기 위해 모든 의존 라이브러리를 가져와야 합니다. 여기에는 Webpack 자체뿐만 아니라 Angular, TypeScript 및 단위 테스트에 필요한 loader 그리고 플러그인 목록이 포함됩니다. 다음은 실행할 명령입니다. 1npm i -D webpack webpack-dev-server html-webpack-plugin raw-loader ts-loader tslint-loader 웹 브라우저에서 응용 프로그램을 실행할 때 html-webpack-plugin과 webpack-dev-server가 도움이 될 것입니다. 그리고 raw-loader는 응용 프로그램을 개발할때 무엇을 하는지 살펴 보겠습니다. 단위 테스트 의존 라이브러리단위 테스트를 위해 우리는 Jasmine을 테스트 프레임 워크로 사용하는 Test Runner로 Karma를 사용할 것입니다. Mocha와 Chai처럼 사용할 수있는 테스트 라이브러리가 많이 있지만, 기본적으로 Angular는 Jasmine을 사용하고 Karma는 Webpack에서 잘 작동합니다. 1npm i -D karma karma-jasmine jasmine-core karma-chrome-launcher karma-phantomjs-launcher phantomjs-prebuilt karma-sourcemap-loader karma-webpack Chrome과 Phantom 런처는 Karma가 테스트를 실행할 수 있는 환경을 제공합니다. Phantom은 기본적으로 GUI가없는 “헤드리스 (headless)”브라우저입니다. Firefox, Internet Explorer, Safari, 그리고 다른 런처도 있습니다. karma-sourcemap-loader는 다른 단계에서 생성한 소스맵을 가져와서 테스트 중에 사용하기 위해 로드할 수 있습니다. 이 기능은 Chrome에서 테스트를 실행할 때 유용하므로 디버거에 중단점을 배치하여 코드에 문제가있는 부분을 쉽게 파악할 수 있습니다. 환경 설정다음 섹션에서는 테스트를 실행하기 위해 프로젝트를 설정하고 브라우저에서 애플리케이션을 실행하는 방법을 설명합니다. 다음에 대한 설정을 구성해야합니다. TypeScript Unit Testing Webpack NPM Scripts 많은 작업이 필요해 보일지 모르지만 각 라이브러리의 개발자들이 이해하기 쉽게 구성을 설정했음을 알 수 있습니다. examples/introduction/ng2-webpack-test에 있는 예제 파일들을 따라할 수 있습니다. 하지만 모든 노드 모듈이 설치되도록 이 저장소를 복제 한 경우 npm i을 실행 해야합니다. TypeScript 구성하기TypeScript 활용에 필요한 부분은 타입 정의, linting 및 TypeScript 컴파일러의 구성입니다. 먼저 타입 정의를 살펴 보겠습니다. 타입 정의 (Type Definition)먼저 우리 프로젝트의 루트에서 다음 명령을 실행하여typings.json 파일을 만들어야합니다. 1./node_modules/.bin/typings init 이 명령은 node_modules 디렉토리에서 typings을 실행하고 init 명령을 사용합니다. typings.json 파일은 프로젝트의 루트에 위치 할 것입니다. 프로젝트의 이름과 빈 의존성 객체를 포함합니다. 설치 명령을 사용하여 해당 객체를 채 웁니다. 설치할 파일은 세 가지가 있지만 두 가지 명령이 필요합니다. 1./node_modules/.bin/typings install dt~jasmine env~node --save --global 다시 한 번, typings을 사용하여 jasmine과 node에 대한 타입 정의를 설치합니다. 두 번째 플래그 인 --global은 typings에게 설치 될 정의가 전역 Scope에 위치한 라이브러리, 즉 window.&lt;var&gt;에 있음을 알려줍니다. 라이브러리의 각 라이브러리 앞에는 ~ 글자가 붙어 있습니다. 이러한 문자는 타입 정의 파일을 찾을 다른 저장소를 나타냅니다. 이러한 저장소에 대한 정보는 Typings의 Github 페이지중 “Sources” 섹션을 보십시오. es6-promise shim은 window.&lt;var&gt; 라이브러리가 아니기 때문에 두번째 설치 명령을 실행할 것입니다. 접두어가 필요하지 않다는 것을 명심하세요. 1./node_modules/.bin/typings install es6-promise --save 이제 타입 정의가 설치 되었습니다. Linting우리는 또한 프로젝트를 위해 코드 linting을 설치할 것입니다. 이렇게하면 코드가 가능한 한 오류없이 유지되지만 오류가 발생하는 것을 완전히 막지는 못합니다. 위에서 언급했듯이, 우리는 이 목표를 달성하기 위해 tslint 라이브러리를 사용할 것입니다. tslint.json 파일을 사용하여 코드 linting이 어떻게 동작 해야하는지에 대한 규칙을 설명합니다. 한번에 한섹션씩 보겠습니다. 12&#123; \"class-name\": true, 이렇게하면 모든 클래스 이름이 Pascal-case (LikeThis)인지 확인할 수 있습니다. 1234\"comment-format\": [ true, \"check-space\"], 주석에는 슬래시와 주석 자체 사이에 공백이 있어야 합니다 (// like this). 1234\"indent\": [ true, \"spaces\"], 공백 대 탭의 위대한 전쟁에서, 우리는 공백 캠프에 참여할 것입니다. 탭 팬이라면 언제든지 &quot;spaces&quot;를 &quot;tabs&quot;으로 변경할 수 있습니다. 1\"no-duplicate-variable\": true, 이렇게하면 동일한 Scope에서 변수를 다시 선언 할 수 없게 됩니다. 1\"no-eval\": true, 이렇게하면 eval을 사용할 수 없게 됩니다. 1\"no-internal-module\": true, TypeScript의 module 키워드는 과거에 혼란을 일으키는 것으로 알려져 왔기 때문에 namespace를 사용하는 것을 막을 것입니다. 1\"no-trailing-whitespace\": true, 이렇게하면 줄 끝에 공백이나 탭을 남기지 않을 것입니다. 1\"no-var-keyword\": true, ES2015는 const와let을 사용하여 block-scope 변수를 선언할 수 있습니다. TypeScript는 ES2015의 상위 집합이기 때문에 block-scope 변수도 지원합니다. 이 새로운 변수 선언 키워드는 var가 하지않는 코드에 명확성을 제공합니다. 왜냐하면 let과 const 변수는hoisting 되지 않기 때문입니다. 이 명료함을 돕기 위해, 이 속성은 tslint에게 우리가 var 키워드를 사용할 때 알려 달라고 설정합니다. 12345\"one-line\": [ true, \"check-open-brace\", \"check-whitespace\"], 이 규칙은 여는 중괄호가 앞에있는 문장과 같은 줄에 있어야하며 앞에 공백이 있어야한다고 말합니다. 1234\"quotemark\": [ true, \"single\"], 모든 문자열을 작은 따옴표로 묶습니다. double을 사용하려면 “single”을 “double”로 변경하십시오. 1\"semicolon\": true, 이렇게하면 라인의 끝을 세미콜론으로 강제합니다. 1234\"triple-equals\": [ true, \"allow-null-check\"], 이것은 triple equal을 사용하도록 알려줍니다. &quot;allow-null-check&quot;는 null 체크를 하기위해 ==와 !=을 허용합니다. 12345678910\"typedef-whitespace\": [ true, &#123; \"call-signature\": \"nospace\", \"index-signature\": \"nospace\", \"parameter\": \"nospace\", \"property-declaration\": \"nospace\", \"variable-declaration\": \"nospace\" &#125;], 이 규칙은 타입을 정의 할 때 콜론의 왼쪽에 공백이 없어야 한다고 말합니다. 그리고 이규칙은 함수의 리턴 타입, 인덱스 타입, 함수 파라미터, 프로퍼티 또는 변수에 적용됩니다. 12345\"variable-name\": [ true, \"ban-keywords\", \"check-format\"], 우리는 우발적으로 TypeScript 키워드를 사용하지 말아야하며 변수 이름은 camelCase (likeThis) 또는 상수의 경우 모두 대문자 (LIKE_THIS) 인 경우에만 사용해야합니다. 12345678\"whitespace\": [ true, \"check-branch\", \"check-decl\", \"check-operator\", \"check-separator\", \"check-type\"] 우리는 마지막 규칙에서 좀 더 공백에 대한 검사를 할 것입니다. 이것은 분기 명령문, 변수 선언의 등호, 연산자, 분리자 (,/;) 및 타입 정의를 점검하여 이들 주위에 적절한 간격이 있는지 확인합니다. TypeScript 구성TypeScript 컴파일러에는 구성 파일인 tsconfig.json이 필요합니다. 이 파일은 compilerOptions와 exclude 두 부분으로 나뉩니다. 스키마에는 다른 속성이 있지만 이 두 가지에 중점을 둘 것입니다. 컴파일러 옵션 섹션은 더 많은 규칙으로 구성됩니다. 123\"compilerOptions\": &#123; \"emitDecoratorMetadata\": true, \"experimentalDecorators\": true, Angular는 데코레이터(decorators, 예: @Component)에 크게 의존합니다. 그리고 위에 정의한 규칙에 따라 TypeScript에서 사용할 수 있음을 알 수 있습니다. 위에서 설치한 reflect-metadata 라이브러리는 이 규칙들과 함께 사용되어 데코레이터를 적절하게 활용됩니다.12\"module\": \"commonjs\",\"moduleResolution\": \"node\", 이 두 가지 규칙을 통해 컴파일러는 CommonJS 모듈을 사용할 것이며 노드가 모듈을 해석하는 방식으로 알고 있습니다. 비 상대 경로에 포함 된 모듈에 대한 node_modules 디렉토리를 보면됩니다. 우리는 moduleResolution에 &quot;es2015&quot;를 선택할 수 있었지만 ES5로 컴파일 할 것이기 때문에 사용할 수 없습니다. 12\"noImplicitAny\": true,\"suppressImplicitAnyIndexErrors\": true, 타이핑 시스템에서는 any를 타입으로 지정할 수 있습니다. 위의 첫 번째 애트리뷰트는 이 타입을 지정하지 못하게합니다. 타입이 무엇인지 모르는 경우에만 any를 사용하십시오. 타입을 지정하지 않고 오류를 피하고자 하는 한 가지 방법은 배열과 같은 객체를 색인화하는 것입니다. 타이핑 시스템이 이해 할 것이기 때문입니다. 1\"removeComments\": false, TypeScript가 코드를 컴파일 할 때 우리가 작성한 주석을 보존합니다. 123 \"sourceMap\": true, \"target\": \"es5\"&#125;, 위에서 언급했듯이 우리는 ES5로 컴파일 할 것입니다. 우리는 우리가 작성한 코드를 브라우저 디버깅 도구에서 볼 수 있도록 TypeScript에서 소스맵을 생성하도록 할 것입니다. exclude 섹션은 컴파일하는 동안 무시할 섹션을 알려줍니다. files 섹션이 있지만, globbing을 지원하지 않기 때문에, 우리는 TypeScript가 필요한 모든 파일을 입력하게 될 것입니다. 이것은 몇개의 파일이 추가된 이후에 심각한 문제가 될수 있습니다. 12345\"exclude\": [ \"node_modules\", \"typings/main\", \"typings/main.d.ts\"] 이것은 node_modules 디렉토리와 typings의 main.d.ts 파일뿐만 아니라 main 디렉토리에있는 타입 정의의 사용을 배제 할 것입니다. Karma 구성하기다음으로, 우리는 Webpack과 함께 사용할 Karma를 설정해 보겠습니다. 이전에 Karma를 사용해 본 적이 있다면 설정이 쉽지 않다는 것을 알고 있을것입니다. Karma는 테스트 할 파일과 방법을 지정하는 구성 파일을 사용합니다. 일반적으로 karma.conf.js라는 이름의 파일이 필요합니다. 하지만 우리의 설정에서 두 번째 파일인 karma.entry.js를 생성할 것입니다. 이 파일에는 Angular와 Webpack에서 사용할 추가 설정이 포함되어 있습니다. 우리는 폴더 구조를 좀 더 발전 시켜서 진행하면서 깨끗하게 유지할 것입니다. 프로젝트 루트에karma라는 디렉토리를 만듭니다. 이 디렉토리 안에 다음 두 절에 설명 된 파일을 저장하십시오. karma.conf.js 셋업123'use strict';module.exports = (config) =&gt; &#123; 카르마 구성 파일은 모두 카르마 구성 오브젝트를 파라미터로 취하는 단일 함수를 export 합니다. 이 객체가 제공하는 프로퍼티 중 일부를 아래에 표시합니다. 123config.set(&#123; autoWatch: true, browsers: ['Chrome', 'PhantomJS'], 첫번째 프로퍼티 config는 .set 메소드를 제공합니다. 이것이 Karma가 JSON 객체를 파라미터로 설정하는 방법입니다. 해당 설정 객체의 처음 두 속성은 autoWatch와 browsers입니다. autoWatch 프로퍼티는 Karma에게 우리가 나중에 제공 할 파일 목록을 보아야 하는지를 알려주고 그 파일들이 변경 될 때 테스트를 다시로드하는 값입니다. 이것은 우리가 red-green-refactor 루프를 실행할 때 사용할 필수 기능입니다. 두번째 프로퍼티 browsers는 Karma에게 어떤 브라우저에서 테스트를 실행 해야하는지 알려줍니다. 이것은 이전에 설치 한 karma-chrome-launcher와 karma-phantomjs-launcher 의존성을 사용하여 브라우저에서 테스트하도록 합니다. 1234files: [ '../node_modules/es6-shim/es6-shim.min.js', 'karma.entry.js'], 여기서 우리는 Karma에게 추적 할 파일을 설명합니다. 과거에 Karma를 사용한 적이 있다면 이 목록은 아주 작게 보일 수 있습니다. 우리는 TypeScript와 Webpack을 활용하여 파일을 실제로 추적 할 것입니다. 첫번째 파일은 우리가 이전에 설치 한 ES2015/ES6 shim으로, PhantomJS에서는 아직 히트하지 않은 기능을 추가했습니다. 그러면 다음 섹션에서 개발 될 karma.entry.js 파일이 필요합니다. 12frameworks: ['jasmine'],logLevel: config.LOG_INFO, 여기서 우리는 Karma에게 Jasmine을 사용할 것이며 출력 메시지는 console.info 레벨 이상이어야 한다고 말합니다. 메시지의 우선 순위는 다음과 같습니다. LOG_DISABLE — 메시지를 표시하지 않습니다., LOG_ERROR LOG_WARN LOG_INFO LOG_DEBUG LOG_INFO를 실행하면 console.info,console.warn,console.error의 출력을 볼 수 있습니다. 하지만 console.debug 메시지는 나타나지 않습니다. 123phantomJsLauncher: &#123; exitOnResourceError: true&#125;, Karma가 ResourceError를 던지면 PhantomJS가 종료하도록 하는 특정한 설정 항목입니다. 설정하지 않으면 PhantomJS가 종료되지 않을 수도 있습니다. 그러면 PhantomJS가 시스템 리소스를 먹어 치울 것입니다. 123preprocessors: &#123; 'karma.entry.js': ['webpack', 'sourcemap']&#125;, Karma에게 우리의 karma.entry.js 파일에 전처리 프로세서 목록을 실행하라고 명령합니다. 이러한 전처리기는 이전에 karma-webpack으로 설치 한 Webpack 전처리기와 karma-sourcemap-loader로 설치한 sourcemap 전처리기입니다. Karma와 Webpack은 함께 작동하여 karma.conf.js로 시작하는 종속성 체인을 찾고 실행되는 소스맵을 로드합니다. 12reporters: ['dots'],singleRun: false, 첫번째 줄은 Karma에게 테스트가 성공한 경우 각 테스트에 대한 설명을 출력하는 대신 단 하나의 점만 출력한다는 점을 알려주며, 실패하는 경우 설명 메시지가 나타나도록 합니다. 두 번째 라인은 우리가 테스트를 재실행 할 것이라는 것을 알려주며, 카르마는 모든 테스트를 완료 한 후에 다시 계속 실행합니다. 123456 webpack: require('../webpack/webpack.test'), webpackServer: &#123; noInfo: true &#125; &#125;);&#125;; 우리 설정의 마지막 두줄은 Karma와 함께 사용하기 위해 Webpack을 설정합니다. 첫번째는 karma-webpack 플러그인에 Webpack 설정 파일이 webpack.test.js라는 이름으로 루트 디렉토리의 webpack 디렉토리에 있음을 알려줍니다. Webpack은 많은 메시지를 출력하므로 콘솔에서 테스트를 실행할 때 번거로울 수 있습니다. 이를 극복하기 위해 noInfo를 true로 설정하여 Webpack 서버의 출력을 최소화 하도록 설정합니다. 이것이 전체 karma.conf.js입니다. 이제 형제 파일인 karma.entry.js를 살펴 보겠습니다. karma.entry.js 셋업이전 섹션에서 언급했듯이 karma.entry.js 파일은 Karma를 사용할 때 테스트 파일과 애플리케이션 파일을 가져오기 위한 시작점 역할을 합니다. Webpack은 파일을 진입점으로 하나 제공하고 다음 종속성을 찾고 파일별로 로드합니다. TypeScript의 모듈 기능을 사용하여 Webpack에 테스트 파일을 보도록 지시 할 수 있습니다.이 파일은 모두 .spec.js 접미사가 붙습니다. 테스트 파일에서 테스트 할 것이므로 필요한 모든 파일을 로드 할 것입니다. 또한 사소한 Angular 및 Jasmine 설정을 수행합니다. 이 파일은 루트 프로젝트 디렉토리 아래 Karma디렉토리에 있어야합니다. 12345678require('es6-shim');require('reflect-metadata');require('zone.js/dist/zone');require('zone.js/dist/long-stack-trace-zone');require('zone.js/dist/jasmine-patch');require('zone.js/dist/async-test');require('zone.js/dist/fake-async-test');require('zone.js/dist/sync-test'); 우리가 할 첫번째 일은 몇가지 의존 라이브러리를 가져오는 것입니다. 여러분이 잘 알지 못하는 것들은 zone.js에서 온 것들입니다. Zone은 변경 감지를 수행하는 라이브러리입니다. Angular 팀 소유의 라이브러리이지만 Angular와 별도로 가져와야 합니다. 더 자세히 알고 싶다면 ng-conf 2014에서 Angie 팀원이었던 Brian Ford가했던 이야기를 들어 보십시오. 1234567const browserTesting = require('@angular/platform-browser-dynamic/testing');const coreTesting = require('@angular/core/testing');coreTesting.setBaseTestProviders( browserTesting.TEST_BROWSER_DYNAMIC_PLATFORM_PROVIDERS, browserTesting.TEST_BROWSER_DYNAMIC_APPLICATION_PROVIDERS); 다음으로, 우리는 더 많은 의존 라이브러리를 가져오고 저장할 것입니다. 처음 두 가지는 Angular가 제공 한 테스트에 필요한 라이브러리입니다. 응용 프로그램을 실행하는 데 필요한 기본 Angular Provider를 설정하게합니다. 그런 다음 가져온 라이브러리를 사용하여 기본 테스트 Provider를 설정합니다. 123const context = require.context('../src/', true, /\\.spec\\.ts$/);context.keys().forEach(context); 이 두 줄은 src 디렉토리에서 .spec.ts 파일을 가져 오도록 합니다. .context 메서드는 Webpack에서 온것입니다. 첫 번째 행의 두 번째 파라미터는 Webpack에게 하위 디렉토리에서 더 많은 파일을 찾도록 지시합니다. 그 다음에 우리는 규칙적인 require 문을 사용하는 것처럼 우리가 만든 context를 사용할 것입니다. 이 context는 발견된 모든 파일의 맵을 가지고 있으며, 각 키는 발견된 파일의 이름입니다. 그러므로, 키의 배열에 대해 .forEach를 실행하고 각각에 대해 function을 호출함으로써, 우리는 각각의 .spec.ts 파일을 읽고, 결과적으로 실행을 위해 필요한 모든 코드를 읽습니다. 12Error.stackTraceLimit = Infinity;jasmine.DEFAULT_TIMEOUT_INTERVAL = 2000; 이 라인은 위에서 언급한 Jasmine 설정입니다. 문제가 생겼을 때 스택 추적을 완전히 했는지 확인하고, Jasmine은 기본 timeout으로 2 초를 사용합니다. timeout은 비동기 프로세스를 테스트 할 때 사용됩니다. 우리가 제대로 설정하지 않으면 일부 테스트가 영원히 중단 되지 않습니다. 이 두 파일을 통해 Karma를 실행하도록 구성했습니다. 이 파일들을 다시 만질 필요는 결코 없을 것입니다. Webpack 구성하기이제 Webpack이 역할을 수행하도록 Webpack을 설정합니다. webpack.test.js, webpack.dev.js, webpack.prod.js가 있다면 기능상 오버랩이 될 것입니다. 일부 프로젝트는 SurviveJS의 webpack-merge를 사용하여 구성의 일부를 복제하지 못하게 합니다. 우리는 설정 파일이 우리에게 제공하는 것을 완전히 이해하기 위해 이 방법을 사용하지 않을 것입니다. 우리의 목적을 위해서 우리는 단지 webpack.dev.js와 webpack.test.js만 가질 것입니다. 웹 패키지 개발 서버를 돌릴 때 .dev 설정이 사용되어 브라우저에서 애플리케이션을 볼 수 있습니다. 프로젝트 디렉토리에서 두 파일을 모두 저장할 webpack이라는 하위 디렉토리를 만듭니다. webpack.test.js 셋업이 파일은 몇 번 언급되었습니다. 이제 우리는 마침내 이 파일이 무엇에 관한지를 볼 것입니다. 1234'use strict';const path = require('path');const webpack = require('webpack'); 여기에 우리가 필요로하는 몇 가지 의존 라이브러리가 필요합니다. path 라이브러리는 Node 핵심 라이브러리입니다. 우리는 주로 전체 파일 경로를 찾기위해 이 라이브러리를 사용합니다. 그리고 Webpack이 필요합니다. 12module.exports = &#123; devtool: 'inline-source-map', Webpack 설정은 노드의 module.exports 메카니즘을 사용하여 Webpack에 제공되는 JSON 객체입니다. 설정의 첫번째 특성은 inline source map을 디버깅 도우미로 사용할 것임을 정의합니다. devtool 옵션에 대한 자세한 내용은 Webpack 사이트의 설명서를 참조하십시오. 123456789module: &#123; preLoaders: [ &#123; exclude: /node_modules/, loader: 'tslint', test: /\\.ts$/ &#125; ], loaders: [ &#123; loader: 'raw', test: /\\.(css|html)$/ &#125;, &#123; exclude: /node_modules/, loader: 'ts', test: /\\.ts$/ &#125; ]&#125;, 이전에 loader에 대해 논의했는데, 실제로 여기서 loader를 볼 수 있습니다. 정규 loader 앞에 실행되는 preLoaders도 지정할 수 있습니다. 이 loader를 다른 “일반” loader와 함께 배치 할 수 있지만 응용 프로그램이 커질수록 컴파일이 느려지는 것을 방지 하기 위해 분리 할 수 있습니다. 첫번째 “실제” loader는 .css 및 .html 원본 파일을 따로 처리하지는 않지만 JavaScript 모듈로 가져옵니다. 그리고 이전에 설치한 ts-loader를 사용하여 모든 .ts 파일을 로드 할 것입니다. 이 파일은 TypeScript 컴파일러를 통해 JavaScript 파일을 생성할 것입니다. exclude 특성을 사용하면 타사 TypeScript 파일을 컴파일하지 않아도됩니다. 이 경우 node_modules 디렉토리에서 TypeScript 파일을 가져 오는 것을 피할 수 있습니다. CSS로 SASS를 사용하거나, HTML로 Jade를 사용하고 싶다면 sass-loader 나 pug-loader를 각각 설치해서 ts-loader를 사용하는 것과 비슷한 방식으로 사용할 수 있습니다. 12345resolve: &#123; extensions: ['', '.js', '.ts'], modulesDirectories: ['node_modules'], root: path.resolve('.', 'src')&#125;, 이 섹션에서는 Webpack이 로드 해야하는 파일 확장명 타입을 알 수 있습니다. 빈 문자열은 확장을 제공 할 필요가없는 노드 모듈을 가져 오기 위해 필요합니다.예를 들어 이전에 path를 어떻게 가져 왔는지 등입니다. Webpack에 우리 모듈의 루트 디렉토리가 src 디렉토리이고 모든 외부 모듈이 node_modules 디렉토리에 있음을 알립니다. 1234 tslint: &#123; emitErrors: true &#125;&#125;; 이 설정의 마지막 부분은 tslint-loader를 설정하여 콘솔에 발견된 오류를 표시합니다. 이전에 생성 된 두 개의 Karma 파일과 함께 이 파일은 모든 단위 테스트를 수행합니다. webpack.dev.js 셋업주의 :이 튜토리얼을 따라갈 때 webpack-dev-server 사용에 관심이 없다면 이 섹션을 건너 뛸 수 있습니다. 또한, webpack.test.js 섹션에서 논의된 설정의 어떤 부분도 아래에서 다시 설명하지 않을 것입니다. 12345678'use strict';const HtmlWebpack = require('html-webpack-plugin');const path = require('path');const webpack = require('webpack');const ChunkWebpack = webpack.optimize.CommonsChunkPlugin;const rootDir = path.resolve(__dirname, '..'); 두 개의 새로운 Webpack 의존 라이브러리는 HtmlWebpack과 ChunkWebpack 플러그인입니다. 이 코드의 마지막 줄은 path 라이브러리를 사용하므로 프로젝트 디렉토리를 시작점으로 항상 파일을 참조 할 수 있습니다. 1234567module.exports = &#123; debug: true, devServer: &#123; contentBase: path.resolve(rootDir, 'dist'), port: 9000 &#125;, devtool: 'source-map', 첫 번째 속성은 debug이며, true로 설정하면 Webpack이 모든 로더를 디버그 모드로 전환 할 수 있음을 알립니다. 디버그 모드는 상황이 잘못 될 때 더 많은 정보를 제공합니다. devServer 속성은 webpack-dev-server 설정 방법을 설명합니다. 이것은 파일이 제공되는 위치가 프로젝트의 dist 디렉토리가 될 것이며 우리는 포트 9000을 사용할 것이라고 말합니다. dev 서버가 메모리에서 모든 파일을 제공하기 때문에 dist 디렉토리를 만드는 것에 대해 걱정하지 마십시오. 실제 dist 디렉토리는 메모리에서 제공되기 때문에 실제로 생성되지 않습니다. 1234entry: &#123; app: [ path.resolve(rootDir, 'src', 'bootstrap') ], vendor: [ path.resolve(rootDir, 'src', 'vendor') ]&#125;, 여기서는 Webpack에 코드에 대한 두 가지 진입 점이 있음을 알리고 있습니다. 하나는 src/bootstrap.ts이고 다른 하나는 src/vendor.ts입니다. vendor.ts파일은 Angular와 같은 써드 파티 코드를 로드 하기위한 항목일 것이고, bootstrap.ts는 애플리케이션 코드가 시작될 곳입니다. 파일에 확장자 .ts를 제공 할 필요가 없음을 알 수 있습니다. 우리는 이것을 잠시 후에 설명 할 것입니다. 또한, karma.entry.js 파일이 그 프로세스에 대한 일종의 인위적 진입 점으로 작용했기 때문에 webpack.test.js에서 이것을 필요로하지 않았습니다. 12345678910module: &#123; loaders: [ &#123; loader: 'raw', test: /\\.(css|html)$/ &#125;, &#123; exclude: /node_modules/, loader: 'ts', test: /\\.ts$/ &#125; ]&#125;,output: &#123; filename: '[name].bundle.js', path: path.resolve(rootDir, 'dist')&#125;, 우리가 로더를 어떻게 사용했는지 기억하지 못한다면, 더 자세한 정보는 webpack.test.js 섹션을 보십시오. 앞에서 언급했듯이, 파일은 dist 디렉토리에서 제공 될 것이고, 여기에서 정의 할 것입니다. 각 파일의 이름은 .bundle.js 접미사가있는 입력 섹션의 키가됩니다. 그래서 우리는 app.bundle.js와 vendor.bundle.js를 제공하게 될 것입니다. 123456789101112plugins: [ new ChunkWebpack(&#123; filename: 'vendor.bundle.js', minChunks: Infinity, name: 'vendor' &#125;), new HtmlWebpack(&#123; filename: 'index.html', inject: 'body', template: path.resolve(rootDir, 'src', 'app', 'index.html') &#125;)] 우리가 이전에 설치한 두개의 플러그인, ChunkWebpack과 HtmlWebpack은 플러그인 섹션에서 사용됩니다. ChunkWebpack은 Webpack이 여러 번 참조하는 파일을 한 번만 가져옵니다. HtmlWebpack 플러그인은 &lt;script&gt; 태그를 index.html에 추가하지 않아도됩니다. 출력 섹션에서 만든 번들을 가져 와서 index.html의 &lt;body&gt;에 삽입합니다. 1234 resolve: &#123; extensions: [ '', '.js', '.ts' ] &#125;&#125;; 이전에 엔트리 포인트에 .ts를 지정하지 않았을 때,이 섹션은 .ts 또는 .js를 가진 파일이 있고 그 파일 경로와 일치한다면, 그것은 안으로 읽혀 야한다. Webpack의 개발 환경 설정이 완료되었습니다. NPM을 이용한 Task 실행 구성임의의 스레드를 실행하기 위해 다음과 같이 노드 명령을 실행할 수 있습니다. 1node ./node_modules/.bin/webpack --config webpack/webpack.dev.js 그 명령을 실행하고 계속 생각하고 있는 것은 꽤 귀찮은 일입니다. 이를 극복하기 위해 위에서 언급한 package.json의 scripts 섹션을 우리의 Task Runner로 활용할 것입니다. 다음과 같은 작업을 수행합니다. Manual linting dev server 실행 In-browser (Chrome) 테스트하기 Headless browser (PhantomJS) 테스트하기 이 작업은 매우 간단합니다. 설치된 노드 모듈을 활용하여 위의 작업을 수행합니다. package.json의scripts 섹션에 다음을 추가 할 수 있습니다 : 1234\"lint\": \"tslint ./src/**/*.ts\",\"start\": \"webpack-dev-server --config ./webpack/webpack.dev.js\",\"test\": \"karma start ./karma/karma.conf.js\",\"test:headless\": \"karma start ./karma/karma.conf.js --browsers PhantomJS\" node ./node_modules/tslint/bin/tslint.js를 사용하는 대신, karma 또는tslint 처럼 단지 패키지 이름을 사용할 수 있습니다. 이는 NPM이 패키지를 실행하는 데 사용할 수있는 이 파일에 ./node_modules/.bin에 심볼릭 링크가 있기 때문입니다. 테스트 작업은 Chrome과 PhantomJS에서 단위 테스트를 실행하며, test:headless 태스크는 브라우저 플래그로 지정된 PhantomJS에서 단위 테스트를 실행합니다. NPM 작업 실행에 익숙하지 않은 경우 NPM 작업을 실행하는 데는 두가지 방법이 있습니다. 첫번째 작업은 npm run [task name]을 수행하여 원하는 작업을 실행하는 것입니다. npm run lint를 사용했다면 lint 태스크를 실행할 것입니다. NPM에는 또한 생명주기 이벤트의 개념이 있으며, 각 이벤트는 npm [event]를 통해 실행될 수 있습니다. 우리의 목록에 있는 이벤트는 start와 test는 있지만 test:headless는 없습니다. 다른 이벤트들도 있으며, NPM 문서의 scripts 섹션에서 확인 할 수 있습니다. 이제 테스트를 실행하는 데 필요한 구성의 99 %를 완료했습니다. NPM은 Karma를 실행하게됩니다. Karma는 Webpack을 사용하여 모든 테스트 및 응용 프로그램 파일을로드합니다. 테스트 모듈과 어플리케이션 모듈이 모두 로드되면 Karma는 테스트를 실행하고 성공한 모듈과 실패한 모듈을 알려줍니다. 지금 우리가 npm test 나 npm run test:headless를 실행하려고하면, Webpack에서 src 디렉토리가 없다는 오류가 발생합니다. 그 외에, 우리는 .spec.ts 파일이 없기 때문에 Webpack은 로드 할 것이 없습니다. 결론우리는 여기서 많은 토대를 다루었습니다. 우리의 어플리케이션은 단위 테스팅과 red-green-refactor 사이클을 실행하기 위해 완전히 구성되었습니다. 우리는 TypeScript, Karma, Webpack 및 매우 적은 양의 코드로 실행되는 테스트를 설정할 수있었습니다. 최종 코드를 보고 싶다면 이 저장소를 살펴보십시오. 이 시리즈의 두번째 파트에서는 단위 테스트를 통해 샘플 Angular 응용 프로그램을 작성하기 전에 테스트 할 대상을 살펴 보겠습니다. 아래 섹션에서 의견이나 질문을 자유롭게 남겨주십시오. 이 내용은 나중에 참고하기 위해 제가 공부하며 정리한 내용입니다.의역, 오역, 직역이 있을 수 있음을 알려드립니다.This post is a translation of this original article [https://semaphoreci.com/community/tutorials/setting-up-angular-2-with-webpack] 참고 https://semaphoreci.com/community/tutorials/setting-up-angular-2-with-webpack https://semaphoreci.com/community/tutorials/testing-components-in-angular-2-with-jasmine https://semaphoreci.com/community/tutorials/testing-services-in-angular-2 https://semaphoreci.com/community/tutorials/testing-routes-in-angular-2","categories":[{"name":"Angular","slug":"Angular","permalink":"http://infoscis.github.io/categories/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://infoscis.github.io/tags/Angular/"}]},{"title":"Spring Framework 4.2에서 애플리케이션 이벤트","slug":"better-application-events-in-spring-framework-4-2","date":"2017-06-07T13:28:40.000Z","updated":"2017-06-19T14:37:08.704Z","comments":true,"path":"2017/06/07/better-application-events-in-spring-framework-4-2/","link":"","permalink":"http://infoscis.github.io/2017/06/07/better-application-events-in-spring-framework-4-2/","excerpt":"","text":"애플리케이션 이벤트는 느슨하게 결합 된 구성 요소 사이의 정보를 교환하는 수단으로서 Spring Framework의 맨 처음부터 사용할 수 있었습니다. 애플리케이션 이벤트의 가장 잘 알려진 사용법 중 하나는 다음과 같습니다. 12345678@Componentpublic class MyListener implements ApplicationListener&lt;ContextRefreshedEvent&gt; &#123; public void onApplicationEvent(ContextRefreshedEvent event) &#123; ... &#125;&#125; 이렇게하면 컨텍스트가 refresh 될때 MyListener가 통보되고 응용 프로그램 컨텍스트가 완전히 시작될 때 코드를 실행할 수 있습니다. Spring Framework 4.2에서는 세가지 주요 영역에서 이벤트 인프라를 다시 살펴 보았습니다. Generic 지원다음과 같이 이벤트 타입에 중첩 된 Generic 정보로 ApplicationListener 구현을 정의 할 수 있습니다. 12public class MyListener implements ApplicationListener&lt;MyEvent&lt;Order&gt;&gt; &#123; ... &#125; 이벤트를 전달할 때 Listener의 Signature를 사용하여 들어오는 이벤트와 일치하는지 확인합니다. MyOrderEvent extends MyEvent&lt;Order&gt;와 같이 타입 소거(Type erasure)로 인해 필터링 할 Generic 파라미터를 해결하는 이벤트를 publish 해야합니다.다른 해결 방법이있을 수 있고, 커뮤니티에서 가치 있다고 생각하는 경우 Signature 일치 알고리즘(matching algorithm)을 다시 재검토할 수 있습니다. Annotation 기반 이벤트 Listener가장 큰 새로운 기능은 Spring Framework 4.1의 JMS 및 AMQP endpoint에 대한 최근 작업과 유사한 Annotation 기반 이벤트 Listener의 지원입니다. 메소드의 Signature와 일치하는 ApplicationListener를 자동으로 등록하기 위해 관리 Bean의 메소드에 @EventListener를 사용하여 Annotation을 붙일 수 있습니다. 위의 예는 다음과 같이 다시 작성할 수 있습니다. 12345678@Componentpublic class MyListener &#123; @EventListener public void handleContextRefresh(ContextRefreshedEvent event) &#123; ... &#125;&#125; @EventListener는 @Autowired 및 다른것과 비슷한 방식으로 처리되는 핵심 Annotation입니다. Java 구성에서는 추가 구성이 필요하지 않으며 기존 &lt;context:annotation-driven/&gt; 요소로 완벽하게 지원할 수 있습니다. 메서드 Signature는 관심있는 이벤트 타입을 정의합니다. 이벤트를 처리하기 위해 SpEL 표현식을 정의 할 수도 있습니다. 예를 들어, 다음 이벤트를 생각해 보겠습니다. 1234567public class OrderCreatedEvent implements CreationEvent&lt;Order&gt; &#123; ... &#125; private boolean awesome; public boolean isAwesome() &#123; return this.awesome; &#125; ....&#125; 다음 예제는 awesome의 CreationEvent Order (즉,awesome 플래그가 true)에 대해서만 호출 될 이벤트 Listener를 보여줍니다. 123456789@Componentpublic class MyComponent &#123; @EventListener(condition = \"#creationEvent.awesome\") public void handleOrderCreatedEvent(CreationEvent&lt;Order&gt; creationEvent) &#123; ... &#125;&#125; 위의 예제에서 볼 수 있듯이 메서드 파라미터는 해당 정보를 발견 할 수있는 이름을 통해 표시됩니다. 조건식은 raw ApplicationEvent(#root.event) 및 실제 메서드 파라미터 (#root.args)가 있는 “root” 변수도 표시합니다. Event Publish 하기@EventListener로 Annotation이 붙은 모든 메소드에 대해 리턴 타입이 void가 아닌 타입을 정의 할 수 있습니다. 특정 이벤트를 처리 한 결과로 null값을 반환하지 않으면 해당 결과가 새로운 이벤트로 전송됩니다 여러분은 OrderCreatedEvent가 ApplicationEvent를 상속하지 않는다는 것을 알아 차렸을 것입니다. Spring Framework는 임의의 이벤트를 공개하고 ApplicationEvent를 상속하도록 강요하지 않는 유연성을 줄 때가되었다고 느꼈습니다. ApplicationEventPublisher 인터페이스가 확장되어 모든 객체를 Publish 할 수 있습니다. 객체가 ApplicationEvent가 아닌 경우 PayloadApplicationEvent로 래핑합니다. 일반적인 ApplicationListener 구현을 사용하여 이러한 임의의 이벤트를 수신하려는 경우 이 내용을 기억해야 합니다. 다음 예제는 ApplicationEventPublisher를 사용하여 OrderCreatedEvent를 보내는 방법을 보여줍니다. 1234567891011121314@Componentpublic class MyComponent &#123; private final ApplicationEventPublisher publisher; @Autowired public MyComponent(ApplicationEventPublisher publisher) &#123; ... &#125; public void createOrder(Order order) &#123; // .... this.publisher.publishEvent(new OrderCreatedEvent(order)); &#125;&#125; Transaction bound events또 다른 인기있는 개선사항은 이벤트 Listener를 트랜잭션 단계에 바인드하는 기능입니다. 일반적인 예는 트랜잭션이 성공적으로 완료되면 이벤트를 처리하는 것입니다. 이렇게하면 현재 트랜잭션의 결과가 Listener에게 중요한 경우 이벤트를 보다 유연하게 사용할 수 있습니다. Spring Framework는 컨텍스트가 트랜잭션 지원을 인식하지 못하도록하는 방식으로 구조화되어 있으며, 우리는 분명히 그 원칙에서 벗어나고 싶지 않았습니다. 그래서 추가 구성 요소를 등록하고 이벤트 리스너가 생성되는 방식의 개방형 인프라를 구축했습니다. 트랜잭션 모듈은 새로운 @TransactionalEventListener Annotation을 찾는 EventListenerFactory를 구현합니다. 이 값이 있으면 트랜잭션을 인식하는 확장 이벤트 리스너가 기본값 대신 등록됩니다. 위 예제를 다시 사용하여 Producer가 실행중인 트랜잭션이 성공적으로 완료 될 때만 주문 생성 이벤트를 처리되도록 다음과 같이 다시 작성해 보겠습니다. 123456789@Componentpublic class MyComponent &#123; @TransactionalEventListener(condition = \"#creationEvent.awesome\") public void handleOrderCreatedEvent(CreationEvent&lt;Order&gt; creationEvent) &#123; ... &#125;&#125; @TransactionalEventListener는 일반 @EventListener이며, 기본값은 AFTER_COMMIT 인 TransactionPhase를 나타냅니다. 트랜잭션의 다른 단계 (BEFORE_COMMIT, AFTER_ROLLBACK, AFTER_COMMIT, AFTER_ROLLBACK의 별명 인AFTER_COMPLETION)를 연결할 수도 있습니다. 기본적으로 트랜잭션이 실행되고 있지 않으면 요청한 단계를 지키지 못하기 때문에 이벤트가 전혀 전송되지 않습니다. 그러나 @TransactionalEventListener에 fallbackExecution 속성이 있습니다. 이 어트리뷰트는 트랜잭션이 없으면 즉시 리스너를 호출하도록 Spring에 지시합니다. 작성해보기4.2의 첫 번째 마일스톤 릴리스 전에 이 기능을 사용하려면 스냅 샷 저장소를 통해 야간 SNAPSHOT 빌드를 작성하십시오. 최신 스프링 부트 스냅 샷 빌드를 사용하여 start.spring.io를 사용하여 샘플 프로젝트를 만들 수도 있습니다. 또는 매우 게으른 경우 셸에서 이 프로젝트를 복사/붙여 넣기 할 수 있습니다. 12$ curl https://start.spring.io/starter.tgz -d artifactId=events-demo \\ -d baseDir=events-demo -d bootVersion=1.2.2.BUILD-SNAPSHOT | tar -xzvf - Spring Framework 4.2.0.BUILD-SNAPSHOT을 사용하도록 프로젝트를 업데이트하십시오. 1234&lt;properties&gt; ... &lt;spring.version&gt;4.2.0.BUILD-SNAPSHOT&lt;/spring.version&gt;&lt;/properties&gt; 언제나처럼, 우리는 커뮤니티 의견을 환영합니다. 이 기능을 사용해보고 문제가 생기면 알려주십시오. 이 내용은 나중에 참고하기 위해 제가 공부하며 정리한 내용입니다.의역, 오역, 직역이 있을 수 있음을 알려드립니다.This post is a translation of this original article [https://spring.io/blog/2015/02/11/better-application-events-in-spring-framework-4-2]","categories":[{"name":"Java","slug":"Java","permalink":"http://infoscis.github.io/categories/Java/"},{"name":"Spring","slug":"Java/Spring","permalink":"http://infoscis.github.io/categories/Java/Spring/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://infoscis.github.io/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"http://infoscis.github.io/tags/Spring/"},{"name":"Event","slug":"Event","permalink":"http://infoscis.github.io/tags/Event/"}]},{"title":"TypeScript 핸드북 9 - 타입 호환성","slug":"TypeScript-handbook-type-compatibility","date":"2017-05-31T15:05:31.000Z","updated":"2018-01-27T15:13:40.568Z","comments":true,"path":"2017/06/01/TypeScript-handbook-type-compatibility/","link":"","permalink":"http://infoscis.github.io/2017/06/01/TypeScript-handbook-type-compatibility/","excerpt":"","text":"타입 호환성 (Type Compatibility)소개TypeScript의 타입 호환성은 구조적인 하위 타입을 기반으로 합니다. 구조적 타이핑(Structural typing)은 멤버에게만 의존하여 타입을 연관시키는 방법입니다. 이는 Nominal typing과는 대조적입니다. 다음 코드를 살펴보겠습니다. 1234567891011interface Named &#123; name: string;&#125;class Person &#123; name: string;&#125;let p: Named;// OK, because of structural typingp = new Person(); Person 클래스가 Named 인터페이스의 구현체라고 명시적으로 기술하지 않았기 때문에 C#이나 Java와 같은 명목적 선언 언어에서는 위와 같은 코드는 오류가 발생합니다. TypeScript의 Structural 타입 시스템은 일반적으로 JavaScript 코드가 작성된 방식에 따라 설계되었습니다. JavaScript는 함수 표현식 및 객체 리터럴과 같은 익명 객체를 광범위하게 사용하기 때문에 Nominal 타입 시스템 대신에 Structural 타입 시스템을 사용하여 JavaScript 라이브러리에서 발견되는 관계(Relationship)의 종류를 표현하는 것이 훨씬 자연 스럽습니다. 명목상의 Structural 타입 시스템 대신 JavaScript 라이브러리에서 발견되는 관련성(Relationship)를 표현하는 것이 훨씬 자연스럽습니다. 건전성에 대한 메모 (Note on Soundness)TypeScript의 타입 시스템을 사용하면 컴파일 타임에 알 수없는 특정 작업을 수행할 수 있습니다. 하지만 타입 시스템에 이 프로퍼티가 있으면 건전하지 않습니다. TypeScript는 건전하지 않는 동작을 허용하는 장소를 신중하게 고려했으며, 이 문서 전체에서 이러한 상황이 발생하는 곳과 그 뒤에있는 동기 부여 시나리오에 대해 설명합니다. 시작하기TypeScript Structural 타입 시스템의 기본 규칙은 y가 적어도 x와 같은 멤버를 가지고 있다면 x는 y와 호환된다는 것입니다. 12345678interface Named &#123; name: string;&#125;let x: Named;// y's inferred type is &#123; name: string; location: string; &#125;let y = &#123; name: \"Alice\", location: \"Seattle\" &#125;;x = y; y가 x에 할당 될 수 있는지를 검사하기 위해, 컴파일러는 x의 각 프로퍼티을 검사하여 y에서 호환되는 대응 프로퍼티를 찾습니다. 이 경우y는 문자열인 name 멤버를 가져야합니다. 그렇기 때문에 위 코드는 할당이 허용됩니다. 함수 호출 파라미터를 검사할 때도 동일한 할당 규칙이 사용됩니다. 1234function greet(n: Named) &#123; alert(\"Hello, \" + n.name);&#125;greet(y); // OK y는 여분의 location 속성을 가지고 있지만 위 코드는 오류를 발생하지 않습니다. 호환성을 검사할 때 대상 타입(이 경우 Named)의 멤버만 고려됩니다. 이러한 비교 프로세스는 재귀적으로 진행되어 각 구성원 및 하위 구성원의 타입을 탐색합니다. 두 함수의 비교Primitive 타입과 객체 타입을 비교하는 것은 비교적 간단하지만, 어떤 종류의 함수가 호환 가능하다고 판단해야 하는지에 대한 질문은 좀더 복잡합니다. 파라미터 목록이 다른 함수의 두개의 기본 예제부터 살펴 보겠습니다. 12345let x = (a: number) =&gt; 0;let y = (b: number, s: string) =&gt; 0;y = x; // OKx = y; // Error x가 y에 할당 가능한지 검사하기 위해 먼저 파라미터 목록을 봅니다. x의 각 파라미터 변수는 호환 가능한 타입을 가진 y에서 상응하는 파라미터 변수를 가져야합니다. 또한 파라미터의 이름을 고려하지 않고 타입만 고려해야합니다. 이 경우 x의 모든 파라미터 변수는 y에 상응하는 호환 파라미터 변수를 가지므로 할당이 허용됩니다. 두번째 할당은 에러입니다. 왜냐하면 y에는 x에 없는 두번째 파라미터가 필요하기 때문에 할당이 허용되지 않습니다. 위의 y = x 예제에서 처럼 폐기(discarding) 파라미터를 허용하는 이유가 궁금할 수 있습니다. 이 할당이 허용되는 이유는 JavaScript에서 함수의 추가 파라미터를 무시하는 것이 실제로 매우 일반적이기 때문입니다. 예를 들어, Array#forEach는 콜백 함수에 세개의 파라미터, 즉 배열 요소, 해당 인덱스, 포함 배열을 제공합니다. 그럼에도 불구하고 첫 번째 파라미터만 사용하는 콜백을 제공하는 것은 매우 일반적입니다. 1234567let items = [1, 2, 3];// 이러한 추가 매개 변수를 강제로 사용하지 마십시오.items.forEach((item, index, array) =&gt; console.log(item));// 괜찮습니다.items.forEach(item =&gt; console.log(item)); 이제 리턴 타입만 다른 두 함수를 사용하여 리턴 타입을 처리하는 방법을 살펴 보겠습니다. 12345let x = () =&gt; (&#123;name: \"Alice\"&#125;);let y = () =&gt; (&#123;name: \"Alice\", location: \"Seattle\"&#125;);x = y; // OKy = x; // x()에 location 프로퍼티가 없기 때문에 오류가 발생합니다. 타입 시스템은 원본 함수의 리턴 타입이 대상 함수 리턴 타입의 서브 타입이 되도록 강제합니다. 함수 파라미터의 Bivariance함수 파라미터의 타입을 비교할 때 원본 파라미터가 대상 파라미터에 할당 가능하거나 그 반대인 경우 할당이 성공합니다. 호출자가 더 특수화된 타입을 취하는 함수를 제공하게 될 수도 있기는 하지만 덜 특수화된 타입의 함수를 호출할 수 있기 때문에 이것은 불리합니다. 실제로 이러한 종류의 오류는 거의 발생하지 않으며 이를 통해 많은 일반적인 JavaScript 패턴을 사용할 수 있습니다. 간단한 예를 살펴보겠습니다. 12345678910111213141516171819enum EventType &#123; Mouse, Keyboard &#125;interface Event &#123; timestamp: number; &#125;interface MouseEvent extends Event &#123; x: number; y: number &#125;interface KeyEvent extends Event &#123; keyCode: number &#125;function listenEvent(eventType: EventType, handler: (n: Event) =&gt; void) &#123; /* ... */&#125;// 정상적이지 않지만 유용하고 일반적입니다.listenEvent(EventType.Mouse, (e: MouseEvent) =&gt; console.log(e.x + \",\" + e.y));// 정상적인 상태에서 원하지 않는 대안listenEvent(EventType.Mouse, (e: Event) =&gt; console.log((&lt;MouseEvent&gt;e).x + \",\" + (&lt;MouseEvent&gt;e).y));listenEvent(EventType.Mouse, &lt;(e: Event) =&gt; void&gt;((e: MouseEvent) =&gt; console.log(e.x + \",\" + e.y)));// 여전히 허락되지 않습니다. (명백한 에러). 모든 호환 타입에 대해 타입의 안정성을 강제합니다.listenEvent(EventType.Mouse, (e: number) =&gt; console.log(e)); Optional 파라미터와 Rest 파라미터호환성을 위해 함수를 비교할 때 Optional과 Required 파라미터는 서로 바꿔서 사용할 수 있습니다. 원본 타입의 Extra optional 파라미터는 오류가 아니고, 원본 타입의 해당 파라미터가 없는 대상 타입의 Optional 파라미터는 오류가 아닙니다. 함수가 Rest 파라미터를 가지면 무한한 일련의 Optional 파라미터인 것처럼 취급됩니다. 이것은 타입 시스템의 관점에서 볼 때 불만족 스럽지만, 런타임 관점에서 Optional 파라미터의 개념은 일반적으로 잘 시행되지 않습니다. 그자리에 undefined를 전달하는 것은 대부분의 함수들이 일반적이기 때문입니다. 이러한 동기를 부여하는 예제는 콜백을 가져 와서 (프로그래머는) 예상할 수 있지만 (타입 시스템은) 알 수없는 파라미터의 개수로 호출하는 함수의 일반적인 패턴입니다. 123456789function invokeLater(args: any[], callback: (...args: any[]) =&gt; void) &#123; /* ... Invoke callback with 'args' ... */&#125;// Unsound - invokeLater \"might\"는 여러 가지 파라미터를 제공합니다.invokeLater([1, 2], (x, y) =&gt; console.log(x + \", \" + y));// 혼란 스럽고 (x와 y는 실제로 필요합니다) 발견할수 없음invokeLater([1, 2], (x?, y?) =&gt; console.log(x + \", \" + y)); 함수의 Overload함수에 Overload가 있는 경우 원본 타입의 각 Overload는 대상 타입의 호환 가능한 Signature와 일치 해야합니다. 이렇게 하면 원본 함수와 동일한 모든 상황에서 대상 함수를 호출할 수 있습니다. Enumenum은 number와 호환되며 number는 enum과 호환됩니다. 다른 enum에서 가져온 값은 호환되지 않는 것으로 간주됩니다. 12345enum Status &#123; Ready, Waiting &#125;;enum Color &#123; Red, Blue, Green &#125;;let status = Status.Ready;status = Color.Green; //error 클래스클래스는 객체 리터럴 타입 및 인터페이스와 유사하게 작동하지만 한 가지 예외는 정적 및 인스턴스 유형을 모두 포함한다는 것입니다. 클래스 타입의 두 객체를 비교할 때 인스턴스의 멤버만 비교됩니다. 정적 멤버 및 생성자는 호환성에 영향을주지 않습니다. 123456789101112131415class Animal &#123; feet: number; constructor(name: string, numFeet: number) &#123; &#125;&#125;class Size &#123; feet: number; constructor(numFeet: number) &#123; &#125;&#125;let a: Animal;let s: Size;a = s; //OKs = a; //OK 클래스의 Private과 protected 멤버클래스의 private및 protected 멤버는 호환성에 영향을 줍니다. 클래스의 인스턴스가 호환성을 검사할 때 대상 타입에 private 멤버가 포함되어 있으면 원본 타입에 동일한 클래스에서 생성된 private 멤버가 포함되어야 합니다. 마찬가지로 protected 멤버가있는 인스턴스에도 동일하게 적용됩니다. 클래스는 슈퍼 클래스에 할당이 가능하지만 다른 상속 계층 구조의 클래스에서는 할당이 안됩니다. GenericTypeScript는 Structural 타입 시스템이므로 Type 파라미터는 멤버 타입의 일부로 소비될 때 결과 타입에만 영향을줍니다. 123456interface Empty&lt;T&gt; &#123;&#125;let x: Empty&lt;number&gt;;let y: Empty&lt;string&gt;;x = y; // okay, y matches structure of x 위의 경우, x와 y의 구조는 Type 파라미터를 차별화된 방식으로 사용하지 않기 때문에 호환 가능합니다. Empty&lt;T&gt;에 멤버를 추가하여 이 예제를 변경하면 어떻게 동작하는지 살펴 보겠습니다. 1234567interface NotEmpty&lt;T&gt; &#123; data: T;&#125;let x: NotEmpty&lt;number&gt;;let y: NotEmpty&lt;string&gt;;x = y; // error, x and y are not compatible 이런 식으로 Type 파라미터가 지정된 Generic 타입은 Non-generic 타입처럼 동작합니다. Type 파라미터가 지정되지 않은 Generic 타입의 경우, 지정되지 않은 모든 Type 파라미터 대신에 any를 지정하여 호환성을 검사합니다. 그 결과 생성된 타입은 Non-generic 경우와 마찬가지로 호환성을 검사합니다. 123456789let identity = function&lt;T&gt;(x: T): T &#123; // ...&#125;let reverse = function&lt;U&gt;(y: U): U &#123; // ...&#125;identity = reverse; // Okay because (x: any)=&gt;any matches (y: any)=&gt;any 고급 주제Subtype vs Assignment지금까지는 ‘호환 가능성(compatible)’이라는 단어를 사용했습니다. 이는 TypeScript의 사양에 정의된 용어가 아닙니다. TypeScript에는 하위 타입과 할당이라는 두 가지 종류의 호환성이 있습니다. 이것들은 할당이 subtype 호환성의 규칙을 확장하여 any 부터 enum 까지 또는 그 반대에 상응하는 숫자값과 함께 할당할 수 있도록합니다. TypeScript의 다른 측면은 상황에 따라 두 가지 호환 메커니즘 중 하나를 사용합니다. 실제적인 목적을 위해 타입 호환성은 implements 및 extend 절의 경우에도 할당 호환성에 따라 결정됩니다. 자세한 내용은 TypeScript 사양을 참조하십시오. 이 내용은 나중에 참고하기 위해 제가 공부하며 정리한 내용입니다.의역, 오역, 직역이 있을 수 있음을 알려드립니다.This post is a translation of this original article [https://www.typescriptlang.org/docs/handbook/type-compatibility.html] 참고 TypeScript 핸드북 1 - 기본 타입 TypeScript 핸드북 2 - 변수 선언 TypeScript 핸드북 3 - 인터페이스 TypeScript 핸드북 4 - 클래스 TypeScript 핸드북 5 - 함수 TypeScript 핸드북 6 - Generic TypeScript 핸드북 7 - Enum TypeScript 핸드북 8 - 타입 유추 TypeScript 핸드북 9 - 타입 호환성 TypeScript 핸드북 10 - 고급 타입 TypeScript 핸드북 11 - Symbol TypeScript 핸드북 12 - Iterator와 Generator","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://infoscis.github.io/categories/TypeScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://infoscis.github.io/tags/JavaScript/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://infoscis.github.io/tags/TypeScript/"}]},{"title":"TypeScript 핸드북 8 - 타입 유추","slug":"TypeScript-handbook-type-inference","date":"2017-05-31T15:04:09.000Z","updated":"2018-01-27T15:13:56.649Z","comments":true,"path":"2017/06/01/TypeScript-handbook-type-inference/","link":"","permalink":"http://infoscis.github.io/2017/06/01/TypeScript-handbook-type-inference/","excerpt":"","text":"타입 유추 (Type Inference)소개이 절에서는 TypeScript의 타입 유추에 대해 다룹니다. 즉, 우리는 타입의 유추가 일어나는 곳과 방법에 대해 논의할 것입니다. 기본사항TypeScript에는 명시적 타입 표현이 아닌 경우 타입 유추를 사용하여 타입 정보를 제공하는 여러 부분이 있습니다. 예를 들어, 아래 코드에서 1let x = 3; 변수 x의 타입은 number라고 유추할 수 있습니다. 이러한 종류의 유추는 변수와 멤버를 초기화하고, 파라미터 Default 값을 설정하고, 함수 리턴 타입을 결정할 때 발생합니다. 대부분의 경우 타입 유추는 간단합니다. 하지만 다음 섹션에서는 타입 유추의 미묘한 차이에 대해 살펴 보겠습니다. 가장 공통적인 타입여러 가지 표현식에서 타입 유추가 이루어지면 그 표현식의 타입이 “가장 공통적인 타입(Best common type)”을 계산하는데 사용합니다. 1let x = [0, 1, null]; 위의 예제에서 x의 타입을 추론하기 위해서는 배열 각 요소 타입을 고려해야 합니다. 여기에서는 배열의 타입에 대한 두 가지 선택 사항인 number와 null이 있습니다. 가장 공통적인 타입 알고리즘은 각 후보 타입을 고려하고 다른 모든 후보와 호환되는 타입을 선택합니다. 제공되는 후보 타입 중에서 가장 공통적인 타입을 선택해야 하기 때문에 타입이 공통 구조를 공유하지만, 아래의 예제 처럼 모든 타입의 수퍼 타입이 하나도없는 경우가 있습니다. 1let zoo = [new Rhino(), new Elephant(), new Snake()]; 이상적으로, 우리는 zoo가 Animal[]로 유추되기를 원할 수 있습니다. 하지만, 배열에 정확히 Animal 타입의 객체가 없습니다. 그리고 TypeScript는 배열 요소 타입에 대한 추측은 하지않습니다. 이 문제를 해결하려면, 어떤 타입도 다른 모든 후보자의 수퍼 타입이 아닌 경우 명시적으로 타입을 제공해야 합니다. 1let zoo: Animal[] = [new Rhino(), new Elephant(), new Snake()]; 가장 공통 타입이 발견되지 않으면, 타입 유추의 결과는 빈 객체 타입 {}입니다. 이 타입은 멤버가 없으므로 any 프로퍼티을 사용하려고 하면 에러가 발생합니다. 이 결과는 객체의 타입을 암묵적으로 결정할 수 없는 경우에 타입 안전성을 제공하면서 여전히 Type-agnostic 수단으로 객체를 사용할 수 있습니다. 컨텍스트 타입타입 유추는 TypeScript의 “다른 측면(Other direction)”에서도 작동합니다. 이를 “컨텍스트 타이핑(Contextual typing)”이라고 합니다. 컨텍스트 타입 지정은 표현식 타입의 위치에 의해 암시될 때 발생합니다. 123window.onmousedown = function(mouseEvent) &#123; console.log(mouseEvent.buton); //&lt;- Error&#125;; 위의 코드에서 TypeScript의 Type checker는 타입 에러를 발생 하기위해 Window.onmousedown 함수의 타입을 사용하여 할당의 오른쪽에 있는 함수 표현식의 타입을 추론했습니다. 그렇게 해서 mouseEvent 파라미터의 타입을 유추할 수 있었습니다. 하지만 이 함수 표현식이 문맥적으로 입력된 위치에 있지 않으면 mouseEvent 매개 변수는 any 타입을 가지며 오류는 발생하지 않습니다. 컨텍스트 타입 지정 표현식에 명시적 타입 정보가 들어있는 경우, 컨텍스트 타입은 무시됩니다. 위의 예를 수정하면 아래와 같습니다. 123window.onmousedown = function(mouseEvent: any) &#123; console.log(mouseEvent.buton); //&lt;- 이제 에러가 발생하지 않습니다.&#125;; 파라미터에 명시적 타입 Annotation이 있는 함수 표현식은 컨텍스트 타입을 대체합니다. 일단 그렇게 되면 컨텍스트 타입이 적용되지 않으므로 오류가 발생하지 않습니다. 컨텍스트 타이핑은 많은 경우 적용됩니다. 일반적인 경우 함수 호출에 대한 파라미터, 할당의 오른쪽 부분, 타입 어설션, 객체 및 배열 리터럴의 멤버, return 문이 포함됩니다. 컨텍스트 타입은 또한 가장 공통 타입의 후보 타입으로도 작용합니다. 123function createZoo(): Animal[] &#123; return [new Rhino(), new Elephant(), new Snake()];&#125; 이 예에서 가장 공통 타입은 Animal, Rhino, Elephant, 그리고 Snake의 네 가지 집합으로 이루어져 있습니다. 이 중에서 Animal을 가장 공통 타입의 알고리즘으로 선택할 수 있습니다. 이 내용은 나중에 참고하기 위해 제가 공부하며 정리한 내용입니다.의역, 오역, 직역이 있을 수 있음을 알려드립니다.This post is a translation of this original article [https://www.typescriptlang.org/docs/handbook/type-inference.html] 참고 TypeScript 핸드북 1 - 기본 타입 TypeScript 핸드북 2 - 변수 선언 TypeScript 핸드북 3 - 인터페이스 TypeScript 핸드북 4 - 클래스 TypeScript 핸드북 5 - 함수 TypeScript 핸드북 6 - Generic TypeScript 핸드북 7 - Enum TypeScript 핸드북 8 - 타입 유추 TypeScript 핸드북 9 - 타입 호환성 TypeScript 핸드북 10 - 고급 타입 TypeScript 핸드북 11 - Symbol TypeScript 핸드북 12 - Iterator와 Generator","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://infoscis.github.io/categories/TypeScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://infoscis.github.io/tags/JavaScript/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://infoscis.github.io/tags/TypeScript/"}]},{"title":"TypeScript 핸드북 7 - Enum","slug":"TypeScript-handbook-enum","date":"2017-05-24T15:01:18.000Z","updated":"2018-01-27T15:11:19.279Z","comments":true,"path":"2017/05/25/TypeScript-handbook-enum/","link":"","permalink":"http://infoscis.github.io/2017/05/25/TypeScript-handbook-enum/","excerpt":"","text":"Enumsenum을 사용하면 이름이 부여된 상수 집합을 정의할 수 있습니다. enum 타입은 enum 키워드를 사용하여 정의할 수 있습니다. 123456enum Direction &#123; Up = 1, Down, Left, Right&#125; enum의 본문은 0개 이상의 enum 멤버로 구성됩니다. enum 멤버는 관련된 숫자 값을 가지며 상수 또는 계산된 값 일 수 있습니다. enum 멤버는 다음과 같은 경우 상수로 간주됩니다. 초기화 코드가 없고 앞의 enum 멤버가 상수입니다. 이 경우 현재 enum 멤버의 값은 이전 멤버의 값에 1을 더한 값이 됩니다. 이 규칙의 한 가지 예외는 enum의 첫 번째 요소입니다. 초기화가 없으면 값 0이 지정됩니다. enum 멤버는 상수 enum expression으로 초기화됩니다. 상수 enum은 컴파일 타임에 완전히 평가할 수 있는 TypeScript expression의 하위 집합입니다. Expression이 다음 중 하나 일 경우 상수 enum 입니다. 숫자 리터럴 이전에 정의된 상수 enum 멤버 (다른 enum에서 정의할 수 있음)에 대한 참조. member가 동일한 enum에 정의된 경우 규정되지 않은 이름을 사용하여 참조할 수 있습니다. 괄호로 묶인 상수 열거 expression 상수 enum expression에 적용된 단항 연산자+,-,~ 이진 연산자 +, -, *, /, %, &lt;&lt;, &gt;&gt;, &gt;&gt;&gt;, &amp;, |, ^이 상수 enum expression의 피연산자로 사용되는 경우 NaN 또는 Infinity로 평가되면 컴파일 타임 오류입니다. 다른 모든 경우에 enum 멤버는 계산된 것으로 간주됩니다. 123456789enum FileAccess &#123; // constant members None, Read = 1 &lt;&lt; 1, Write = 1 &lt;&lt; 2, ReadWrite = Read | Write, // computed member G = \"123\".length&#125; enum은 런타임에 존재하는 실제 객체입니다. 그리고 enum 값에서 enum 이름으로 역 매핑을 유지하는 기능이 있습니다. 12345enum Enum &#123; A&#125;let a = Enum.A;let nameOfA = Enum[Enum.A]; // \"A\" 위 코드는 아래와 같이 컴파일 됩니다. 123456var Enum;(function (Enum) &#123; Enum[Enum[\"A\"] = 0] = \"A\";&#125;)(Enum || (Enum = &#123;&#125;));var a = Enum.A;var nameOfA = Enum[Enum.A]; // \"A\" 생성된 코드에서 enum은 forward (name -&gt;value) 매핑과 reverse (value -&gt;name) 매핑을 모두 저장하는 객체로 컴파일됩니다. enum 멤버에 대한 참조는 항상 프로퍼티 접근으로 Emit되고 결코 Inline 되지 않습니다. 이러한 방법은 많은 경우에 완벽하게 유효한 해결책이 됩니다. 그러나 때로는 요구 사항이 더 엄격할 수 있습니다. enum 값에 액세스할 때 여분의 생성된 코드 및 추가 간접 비용을 지불하지 않으려면 상수 enum을 사용할 수 있습니다. 상수 enum은 enum 키워드 앞에 const 한정자를 사용하여 정의됩니다. 1234const enum Enum &#123; A = 1, B = A * 2&#125; const enum은 상수 enum Expression만 사용할 수 있고 일반 enum과 달리 컴파일 중에 완전히 제거됩니다. const enum 멤버는 사용 사이트에서 Inline됩니다. 이것은 상수 enum이 계산된 멤버들을 가질 수 없기 때문에 가능합니다. 12345678const enum Directions &#123; Up, Down, Left, Right&#125;let directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right] 생성된 코드는 아래와 같습니다. 1var directions = [0 /* Up */, 1 /* Down */, 2 /* Left */, 3 /* Right */]; Ambient enumsAmbient enum은 이미 존재하는 enum 타입의 형태를 기술하기 위해 사용됩니다. 12345declare enum Enum &#123; A = 1, B, C = 2&#125; Ambient와 Non-ambient enum 사이의 중요한 차이점 중 하나는 일반적인 enum에서 초기화 코드가 없는 멤버는 상수 멤버로 간주된다는 것입니다. 상수 Ambient enum이 아닌경우, 초기화 코드를 가지지 않은 멤버는 계산된 것으로 간주됩니다. 이 내용은 나중에 참고하기 위해 제가 공부하며 정리한 내용입니다.의역, 오역, 직역이 있을 수 있음을 알려드립니다.This post is a translation of this original article [https://www.typescriptlang.org/docs/handbook/enums.html] 참고 TypeScript 핸드북 1 - 기본 타입 TypeScript 핸드북 2 - 변수 선언 TypeScript 핸드북 3 - 인터페이스 TypeScript 핸드북 4 - 클래스 TypeScript 핸드북 5 - 함수 TypeScript 핸드북 6 - Generic TypeScript 핸드북 7 - Enum TypeScript 핸드북 8 - 타입 유추 TypeScript 핸드북 9 - 타입 호환성 TypeScript 핸드북 10 - 고급 타입 TypeScript 핸드북 11 - Symbol TypeScript 핸드북 12 - Iterator와 Generator","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://infoscis.github.io/categories/TypeScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://infoscis.github.io/tags/JavaScript/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://infoscis.github.io/tags/TypeScript/"}]},{"title":"TypeScript 핸드북 6 - Generic","slug":"TypeScript-handbook-generic","date":"2017-05-24T15:01:04.000Z","updated":"2018-01-27T15:12:28.255Z","comments":true,"path":"2017/05/25/TypeScript-handbook-generic/","link":"","permalink":"http://infoscis.github.io/2017/05/25/TypeScript-handbook-generic/","excerpt":"","text":"Generics소개소프트웨어 엔지니어링의 주요한 부분은, 일관되고 잘 정의된 API를 보유할 뿐만 아니라 재사용 가능한 구성 요소를 구축하는 것입니다. 내일의 데이터뿐만 아니라 오늘의 데이터를 처리할 수있는 구성 요소는 대형 소프트웨어 시스템 구축에 높은 유연성을 부여합니다. C# 및 Java와 같은 언어에서 재사용 가능한 구성 요소를 작성하기 위한 기본 도구 중 하나는 Generic입니다. 즉, 하나가 아닌 다양한 타입에서 작동할 수있는 구성 요소를 만들 수 있어야합니다. 사용자는 이를 통해 다양한 구성 요소를 사용하고 또한 자신만의 타입을 사용할 수도 있습니다. Hello World of Generics우선, Generic의 “hello world”(identity 함수)를 작성해 보겠습니다. identity 함수는 전달된 모든 것을 되돌리는 함수입니다. 이 함수는 echo 명령과 비슷한 방식으로 작동합니다. Generic이 없다면 identity 함수에 특정 타입을 부여해야합니다. 123function identity(arg: number): number &#123; return arg;&#125; 또는 any 타입을 사용하여 Identity 함수를 작성할 수 있습니다 : 123function identity(arg: any): any &#123; return arg;&#125; any를 사용하는 것은 arg의 타입이 모든 타입을 수용하게 하는 확실한 방법 이지만, 실제로 함수가 리턴할 때 그 타입이 무엇인지에 대한 정보를 잃어 버립니다. number가 입력 됐지만, any 타입이 리턴 될 수 있다는 것입니다. 대신, 우리는 리턴되는 값을 나타내는 데 사용할 수있는 방식으로 파라미터 타입을 Capture하는 방법이 필요합니다. 여기서 Type 변수 을 사용합니다. Type 변수는 값이 아닌 타입에서 작동하는 특별한 종류의 변수입니다. 123function identity&lt;T&gt;(arg: T): T &#123; return arg;&#125; 이제 identity 함수에 Type 변수 T를 추가했습니다. 이 T는 사용자가 제공 한 타입 (예 :number)을 Capture하여 나중에 해당 정보를 사용할 수 있도록합니다. 그리고 리턴 타입으로 T를 다시 사용합니다. 인수와 리턴 타입에 동일한 타입이 사용된 것을 볼 수 있습니다. 이를 통해 우리는 함수의 한쪽에서 다른쪽으로 타입 정보를 트래핑할 수 있습니다. 이 버전의 identity 함수는 Generic 타입이라고 말합니다. any를 사용하는 것과는 달리, 파라미터와 리턴 값에 숫자를 사용하는 첫 번째identity 함수로서 정확합니다 (즉, 어떤 정보도 잃지 않습니다). Generic identity 함수를 작성한 후에는 두 가지 방법 중 하나로 호출할 수 있습니다. 첫 번째 방법은 Type 파라미터를 포함한 모든 파라미터를 함수에 전달하는 것입니다. 1let output = identity&lt;string&gt;(\"myString\"); // 리턴 타입은 'string'입니다. 위 코드에서는 함수 호출에 대한 파라미터 중 하나 인 T를 string으로 명시적으로 설정했습니다. ()보다는 파라미터를 중심으로 &lt;&gt;를 사용했습니다. 두 번째 방법은 가장 일반적인 방법이기도 합니다. 파라미터 타입 추론을 사용합니다. 즉, 컴파일러가 전달하는 파라미터의 타입에 따라 자동으로 T의 값을 설정합니다. 1let output = identity(\"myString\"); // 아웃풋 타입은 'string' 타입일 것입니다. 꺽쇠 괄호 (&lt;&gt;)에 명시적으로 타입을 전달할 필요가 없음을 명심하세요. 컴파일러는 단지 &quot;myString&quot; 값을보고, T를 그 타입으로 설정합니다. 파라미터 타입 추론은 코드를 더 짧고 가독성있게 유지하는 유용한 툴이 될 수 있지만, 복잡한 예제에서는 컴파일러가 타입을 추론하지 못했을 때 이전 예제에서 했던 것처럼 타입 파라미터를 명시 적으로 전달해야할 수도 있습니다 . Generic Type 변수로 작업하기Generic을 사용하여 identity와 같은 Generic 함수를 만들면 컴파일러는 함수의 몸체에 일반적으로 타입이 지정된 파라미터를 올바르게 적용하도록 강제합니다. 즉, 실제로 이러한 파라미터 변수를 모든 타입이 될 수있는 것처럼 취급합니다. 앞에서 우리의 identity 함수를 보겠습니다. 123function identity&lt;T&gt;(arg: T): T &#123; return arg;&#125; 각 호출과 함께 콘솔에 파라미터 arg의 길이를 기록하고 싶다면 어떻게해야할까요? 1234function loggingIdentity&lt;T&gt;(arg: T): T &#123; console.log(arg.length); // Error: T는 .length를 가지고 있지 않습니다. return arg;&#125; 컴파일러는 “arg의 .length 멤버를 사용하고 있지만 arg에는 이 멤버가 있다고는 말할 수 없다”는 오류를 출력합니다. 이러한 Type 변수에 모든 타입이 사용될수 있으므로 이전에 이 함수를 사용했던 사람이 number를 전달할 수 있지만 .length 멤버가 없는 것으로 나타납니다. 실제로 이 함수가 T 대신 T 배열로 직접 작업한다고 가정 해 봅시다. 우리는 배열을 다루기 때문에 .length 멤버를 사용할 수 있어야 합니다. 우리는 다른 타입의 배열을 생성하는 것처럼 똑같이 설명할 수 있습니다. 1234function loggingIdentity&lt;T&gt;(arg: T[]): T[] &#123; console.log(arg.length); // Array는 .length를 가지고 있으므로 더이상 error가 아닙니다. return arg;&#125; loggingIdentity의 타입을 다음과 같이 읽을 수 있습니다 : “Generic 함수 loggingIdentity는 타입 파라미터 변수 T를 취하고 파라미터 arg는 T의 배열이며, T의 배열을 반환합니다.” 숫자 배열을 건네 주면, T가 number에 묶이기 때문에 숫자 배열을 리턴할 것입니다. 이렇게 하면 전체 타입보다는 일반 타입 변수 T를 사용중인 타입의 일부로 사용할 수 있으므로 유연성이 향상됩니다. 우리는 다른 대안으로 샘플 예제를 다음과 같이 작성할 수 있습니다. 1234function loggingIdentity&lt;T&gt;(arg: Array&lt;T&gt;): Array&lt;T&gt; &#123; console.log(arg.length); // Array는 .length를 가지고 있으므로 더이상 error가 아닙니다. return arg;&#125; 이런 방식에 대해 다른 언어로 된 비슷한 스타일을 잘 알고있을 수 있습니다. 다음 섹션에서는 Array&lt;T&gt;와 같이 자신 만의 Generic 타입을 만드는 방법에 대해 다룰 것입니다. Generic 타입이전 섹션에서는 다양한 타입의 함수를 처리하는 Generic identity 함수를 만들었습니다. 이 섹션에서는 Generic 함수 타입과 Generic 인터페이스를 만드는 방법을 살펴 보겠습니다. Generic 함수 타입은 함수 선언과 마찬가지로 타입 파라미터가 먼저 나열된 Non-generic 함수의 형식과 같습니다. 12345function identity&lt;T&gt;(arg: T): T &#123; return arg;&#125;let myIdentity: &lt;T&gt;(arg: T) =&gt; T = identity; 타입의 수와 타입 변수의 사용법이 일치 하면, 타입에서 Generic Type 파라미터에 다른 이름을 사용할 수도 있습니다. 12345function identity&lt;T&gt;(arg: T): T &#123; return arg;&#125;let myIdentity: &lt;U&gt;(arg: U) =&gt; U = identity; Generic 타입을 객체 리터럴 형식의 Call signature로 쓸 수도 있습니다. 12345function identity&lt;T&gt;(arg: T): T &#123; return arg;&#125;let myIdentity: &#123;&lt;T&gt;(arg: T): T&#125; = identity; 첫 번째 Generic 인터페이스를 작성해 보겠습니다. 앞의 예제에서 객체 리터럴을 가져 와서 인터페이스로 옮깁니다. 123456789interface GenericIdentityFn &#123; &lt;T&gt;(arg: T): T;&#125;function identity&lt;T&gt;(arg: T): T &#123; return arg;&#125;let myIdentity: GenericIdentityFn = identity; 비슷한 예를 들어, Generic 파라미터를 전체 인터페이스의 파라미터로 이동할 수 있습니다. 이렇게 하면 Generic이 어떤 타입인지를 알 수 있습니다 (예 :Dictionary가 아닌 Dictionary&lt;string&gt;). 이것은 인터페이스의 다른 모든 구성원이 Type 파라미터를 볼 수 있다는 의미입니다. 123456789interface GenericIdentityFn&lt;T&gt; &#123; (arg: T): T;&#125;function identity&lt;T&gt;(arg: T): T &#123; return arg;&#125;let myIdentity: GenericIdentityFn&lt;number&gt; = identity; 예제가 약간 다른 것으로 변경되었습니다. Generic 함수를 설명하는 대신 Generic 타입의 일부인 Non-generic 함수 Signature를 갖게 되었습니다. GenericIdentityFn을 사용할 때 해당 타입 파라미터 (여기서는 number)를 지정 해야하며 기본 Call signature가 사용할 항목을 효과적으로 잠글 수 있습니다. 타입 파라미터를 Call signature에 직접 적용할 시기와 인터페이스 자체에 넣을 시기를 이해하면 타입의 어떤 측면이 Generic 인지 설명하는 데 도움이됩니다. Generic 인터페이스 외에도 Generic 클래스를 만들 수도 있습니다. 하지만 Generic Enum 및 네임 스페이스는 만들수 없다는것을 유의하세요. Generic 클래스Generic 클래스는 Generic 인터페이스와 모양이 비슷합니다. Generic 클래스는 클래스 이름 다음에 꺾쇠 괄호 (&lt;&gt;)로 묶인 Generic Type 파라미터 목록을 갖습니다. 12345678class GenericNumber&lt;T&gt; &#123; zeroValue: T; add: (x: T, y: T) =&gt; T;&#125;let myGenericNumber = new GenericNumber&lt;number&gt;();myGenericNumber.zeroValue = 0;myGenericNumber.add = function(x, y) &#123; return x + y; &#125;; 이 예제는 GenericNumber 클래스를 그대로 사용 하지만, number 타입만 사용하도록 하는 제한이 없다는 것을 눈치 챘을 것입니다. 대신에 string 또는 더 복잡한 객체를 사용할 수 있습니다. 12345let stringNumeric = new GenericNumber&lt;string&gt;();stringNumeric.zeroValue = \"\";stringNumeric.add = function(x, y) &#123; return x + y; &#125;;alert(stringNumeric.add(stringNumeric.zeroValue, \"test\")); 인터페이스와 마찬가지로 Type 파라미터를 클래스 자체에 두면 클래스의 모든 프로퍼티가 동일한 타입으로 작동하는지 확인할 수 있습니다. 클래스에 대한 섹션에서 다뤘 듯이 클래스에는 Static 측면과 Instance 측면의 두 가지 유형이 있습니다. Generic 클래스는 Static 측면보다는 Instance 측면에서 Generic 하기 때문에 클래스로 작업할 때 Static 멤버는 클래스의 Type 파라미터를 사용할 수 없습니다. Generic Constraint처음 예제에서 타입의 집합에 어떤 메서드가 있는지에 대해 이미 알고 있고, 타입의 집합에서 작동하는 Generic 함수를 작성하는 경우가 있었습니다. loggingIdentity 예제에서 arg의 .length 프로퍼티에 접근할 수 있기를 원했지만 컴파일러는 모든 타입이 .length 프로퍼티을 가지고 있음을 증명할 수 없기 때문에 이러한 가정을 할 수 없다고 경고 했습니다. 1234function loggingIdentity&lt;T&gt;(arg: T): T &#123; console.log(arg.length); // Error: T 는 .length를 가지고 있지 않습니다. return arg;&#125; 이 함수가 임의의 모든 타입으로 작업하는 대신에, .length 프로퍼티을 가진 모든 타입과 함께 동작하도록 제한하고 싶습니다. T가 될 수있는 것에 대한 제약사항으로 우리의 요구 사항을 나열하여 이 프로퍼티가 있는 타입을 허용할 수 있습니다. 그렇게 하기 위해 우리는 제약 조건을 설명하는 인터페이스를 만들 것입니다. 여기서는 하나의 .length 프로퍼티를 가진 인터페이스를 만들고 우리는 우리의 제약을 나타 내기 위해 이 인터페이스와 extends 키워드를 사용할 것입니다. 12345678interface Lengthwise &#123; length: number;&#125;function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T &#123; console.log(arg.length); // Now we know it has a .length property, so no more error return arg;&#125; Generic 함수는 이제 제한되어 있으므로 더 이상 모든 타입에서 작동하지 않습니다. 1loggingIdentity(3); // Error, number는 .length 프로퍼티를 가지고 있지 않습니다. 대신, 필수 프로퍼티가 있는 타입 값을 전달해야합니다. 1loggingIdentity(&#123;length: 10, value: 3&#125;); Generic Constraint에서 Type 파라미터 사용하기다른 Type 파라미터에 의해 제한되는 Type 파라미터를 선언할 수 있습니다. 예를 들어, 이름이 있는 객체로부터 프로퍼티를 얻고 싶을 수 있습니다. 우리는 obj에 존재하지 않는 프로퍼티를 우연히 잡아 내지 않도록하기 위해 두 가지 타입 사이에 제약 조건을 적용할 것입니다. 12345678function getProperty&lt;T, K extends keyof T&gt;(obj: T, key: K) &#123; return obj[key];&#125;let x = &#123; a: 1, b: 2, c: 3, d: 4 &#125;;getProperty(x, \"a\"); // okaygetProperty(x, \"m\"); // error: Argument of type 'm' isn't assignable to 'a' | 'b' | 'c' | 'd'. Generic에서 클래스 타입 사용하기TypeScript에서 Generic을 사용하여 팩토리를 생성할 때, 생성자 함수를 사용하여 클래스의 타입을 참조 해야합니다. 예를 들어, 123function create&lt;T&gt;(c: &#123;new(): T; &#125;): T &#123; return new c();&#125; 고급 예제는 프로토 타입 속성을 사용하여 생성자 함수와 클래스 유형의 인스턴스 사이의 관계를 추론하고 제한합니다. 1234567891011121314151617181920212223242526class BeeKeeper &#123; hasMask: boolean;&#125;class ZooKeeper &#123; nametag: string;&#125;class Animal &#123; numLegs: number;&#125;class Bee extends Animal &#123; keeper: BeeKeeper;&#125;class Lion extends Animal &#123; keeper: ZooKeeper;&#125;function createInstance&lt;A extends Animal&gt;(c: new () =&gt; A): A &#123; return new c();&#125;createInstance(Lion).keeper.nametag; // typechecks!createInstance(Bee).keeper.hasMask; // typechecks! 이 내용은 나중에 참고하기 위해 제가 공부하며 정리한 내용입니다.의역, 오역, 직역이 있을 수 있음을 알려드립니다.This post is a translation of this original article [https://www.typescriptlang.org/docs/handbook/generics.html] 참고 TypeScript 핸드북 1 - 기본 타입 TypeScript 핸드북 2 - 변수 선언 TypeScript 핸드북 3 - 인터페이스 TypeScript 핸드북 4 - 클래스 TypeScript 핸드북 5 - 함수 TypeScript 핸드북 6 - Generic TypeScript 핸드북 7 - Enum TypeScript 핸드북 8 - 타입 유추 TypeScript 핸드북 9 - 타입 호환성 TypeScript 핸드북 10 - 고급 타입 TypeScript 핸드북 11 - Symbol TypeScript 핸드북 12 - Iterator와 Generator","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://infoscis.github.io/categories/TypeScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://infoscis.github.io/tags/JavaScript/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://infoscis.github.io/tags/TypeScript/"}]},{"title":"TypeScript 핸드북 5 - 함수","slug":"TypeScript-handbook-functions","date":"2017-05-20T14:20:38.000Z","updated":"2018-01-27T15:08:39.151Z","comments":true,"path":"2017/05/20/TypeScript-handbook-functions/","link":"","permalink":"http://infoscis.github.io/2017/05/20/TypeScript-handbook-functions/","excerpt":"","text":"함수 (Function)소개함수는 JavaScript의 응용 프로그램을 구성하는 기본 요소입니다. 그리고 함수는 추상화 계층, 클래스, 정보 숨기기, 모듈을 모방하는 방법입니다. TypeScript에서는 클래스, 네임 스페이스 및 모듈이 있지만 함수는 여전히 작업 수행 방법을 설명하는 데 중요한 역할을합니다. 또한 TypeScript는 표준 JavaScript 함수에 몇 가지 새로운 기능을 추가하여 보다 쉽게 작업할 수 있도록합니다. 함수JavaScript와 마찬가지로, 명명 함수(Named function) 또는 익명 함수(Anonymous function)로 TypeScript 함수를 생성할 수 있습니다. 이를 통해 애플리케이션에 가장 적합한 방법을 선택할 수 있으며, API에서 기능 목록을 작성하든, 다른 기능으로 이전할 수있는 일회성 기능을 사용하든 상관 없습니다. JavaScript에서 이러한 두 가지 접근 방식은 아래의 예제를 보면 쉽게 이해할 수 있습니다. 1234567// Named functionfunction add(x, y) &#123; return x + y;&#125;// Anonymous functionlet myAdd = function(x, y) &#123; return x+y; &#125;; JavaScript와 마찬가지로 TypeScript 함수는 함수 본문 외부의 변수를 참조할 수 있습니다. 이런 행위를 보통 변수를 Capture 한다고 합니다. 이것이 어떻게 작동하는지 이해하는 것과, 사용에 대한 trade-off는 이 문서의 범위를 벗어납니다. 하지만 이러한 메커니즘이 JavaScript와 TypeScript에서 아주 중요한 요소라는 것을 이해하고 있어야 합니다. 12345let z = 100;function addToZ(x, y) &#123; return x + y + z;&#125; 함수 타입함수 작성하기우선 이전의 간단한 예제에 타입을 추가해 보겠습니다. 12345function add(x: number, y: number): number &#123; return x + y;&#125;let myAdd = function(x: number, y: number): number &#123; return x+y; &#125;; 각 파라미터에 타입을 추가 하고, 리턴 타입을 추가하여 함수에 타입을 부여할 수 있습니다. TypeScript는 return 문을 보고 리턴 타입을 파악할 수 있으므로 많은 경우에 선택적으로 리턴 타입을 생략할 수도 있습니다. 함수 타입 작성함수를 작성 했으니 함수의 각 타입을 살펴보고 함수의 전체 타입을 작성해 보겠습니다. 12let myAdd: (x: number, y: number)=&gt;number = function(x: number, y: number): number &#123; return x+y; &#125;; 위 코드의 함수 형식은 파라미터의 타입과 리턴 타입의 두 부분이 동일합니다. 전체 함수 타입을 작성할 때 두 부분이 필요합니다. 우리는 파라미터 목록과 마찬가지로 파라미터 타입을 작성하여 각 파라미터에 이름과 타입을 제공합니다. 이름은 가독성을 돕기위한 것입니다. 다음과 같이 작성할 수 있습니다. 12let myAdd: (baseValue:number, increment:number) =&gt; number = function(x: number, y: number): number &#123; return x + y; &#125;; 파라미터 타입이 있으면 함수 타입에 파라미터를 지정하는 이름에 상관없이 함수의 유효한 타입으로 간주됩니다. 두 번째 부분은 리턴 타입입니다. 파라미터와 리턴 타입 사이에 굵은 화살표 (=&gt;)를 사용하여 리턴 타입을 명확하게 합니다. 앞에서 언급했듯이, 이것은 함수 타입의 필수 부분이므로, 함수가 값을 반환하지 않는다면 그 값을 그대로 두는 대신에 void를 사용할 수 있습니다. 파라미터와 리턴 타입만 함수 타입을 구성합니다. Capture된 변수는 타입에 반영되지 않습니다. 실제로 Capture된 변수는 함수의 “숨겨진 상태”의 일부이며 해당 API를 구성하지 않습니다. 타입 추정아래의 예제에서 한쪽에 타입있고 다른쪽에 타입이 없는 경우 TypeScript 컴파일러에서 타입을 알아낼 수 있습니다. 123456// myAdd has the full function typelet myAdd = function(x: number, y: number): number &#123; return x + y; &#125;;// The parameters 'x' and 'y' have the type numberlet myAdd: (baseValue:number, increment:number) =&gt; number = function(x, y) &#123; return x + y; &#125;; 이를 타입추론의 한 형태 인 “컨텍스트 타입 지정”이라고 합니다. 이렇게하면 프로그램 입력을 위한 노력이 줄어들수 있습니다. Optional 과 Default 파라미터TypeScript에서는 모든 파라미터가 함수에 필요하다고 가정합니다. 이것은 여러분이 null 또는 undefined를 제공할 수 없다는 것을 의미하는 것이 아니라, 컴파일러는 함수가 호출 될 때 사용자가 각 파라미터에 값을 입력했는지 확인한다는 의미입니다. 컴파일러는 또한 이 파라미터들이 함수에만 전달되는 파라미터라고 가정합니다. 즉, 함수에 주어진 파라미터의 수는 함수가 예상하는 파라미터의 수와 일치해야합니다. 1234567function buildName(firstName: string, lastName: string) &#123; return firstName + \" \" + lastName;&#125;let result1 = buildName(\"Bob\"); // error, 파라미터 수가 너무 적습니다.let result2 = buildName(\"Bob\", \"Adams\", \"Sr.\"); // error, 파라미터 수가 너무 많습니다.let result3 = buildName(\"Bob\", \"Adams\"); // 맞습니다. JavaScript에서 모든 파라미터는 선택 사항이며 사용자가 적합하다고 생각되는 파라미터를 그대로 둘 수 있습니다. 그렇게할때 그 파라미터는 undefined입니다. TypeScript에서 이러한 Optional 파라미터는 파라미터 끝에 ?를 추가하면 가능합니다. 예를 들어 위의 lastName 파라미터를 Optional로 사용 하고자 한다고 가정해 보겠습니다. 12345678910function buildName(firstName: string, lastName?: string) &#123; if (lastName) return firstName + \" \" + lastName; else return firstName;&#125;let result1 = buildName(\"Bob\"); // 올바르게 실행 됩니다.let result2 = buildName(\"Bob\", \"Adams\", \"Sr.\"); // error, 파라미터 수가 너무 많습니다.let result3 = buildName(\"Bob\", \"Adams\"); // 맞습니다. 모든 Optional 파라미터는 Required 파라미터 다음에 나와야 합니다. lastName보다는 firstName을 Optional 파라미터로 변경하려고 한다면 함수에서 파라미터의 순서를 변경해야 하며, 목록의 firstName을 마지막으로 이동해야 합니다. TypeScript에서 사용자가 파라미터를 입력하지 않거나 파라미터 값 대신 undefined를 전달해도 파라미터가 할당 될 값을 Default 값으로 설정할 수 있습니다. 이를 Default-initialized 파라미터라고 합니다. 그렇기 때문에 아래 코드와 같이 lastName의 Default 값을 &quot;Smith&quot;로 설정할 수 있습니다. 12345678function buildName(firstName: string, lastName = \"Smith\") &#123; return firstName + \" \" + lastName;&#125;let result1 = buildName(\"Bob\"); // works correctly now, returns \"Bob Smith\"let result2 = buildName(\"Bob\", undefined); // still works, also returns \"Bob Smith\"let result3 = buildName(\"Bob\", \"Adams\", \"Sr.\"); // error, too many parameterslet result4 = buildName(\"Bob\", \"Adams\"); // ah, just right Required 파라미터 다음에 오는 Default-initialized 파라미터는 Optional 파라미터처럼 취급되며 Optional 파라미터처럼 해당 함수를 호출할 때 생략할 수 있습니다. 이것이 Default-initialized 파라미터가 Optional 파라미터와 공유하는 특성입니다. 123function buildName(firstName: string, lastName?: string) &#123; // ...&#125; 그리고 123function buildName(firstName: string, lastName = \"Smith\") &#123; // ...&#125; (firstName: string, lastName?: string) =&gt; string 같은 타입을 공유합니다. lastName의 Default 값은 파라미터가 Optional 이라는 사실만 남겨두고 타입이 사라집니다. 일반 Optional 파라미터와 달리 Default-initialized 파라미터는 Required 파라미터 다음에 올 필요가 없습니다. Default-initialized 파라미터가 Required 파라미터 앞에 오는 경우 사용자는 명시적으로 undefined를 전달하여 Default-initialized된 값을 가져 오도록 해야합니다. 예를 들어, 우리는 firstName의 기본 초기화(Default initializer)만 사용하여 마지막 예제를 작성할 수 있습니다. 12345678function buildName(firstName = \"Will\", lastName: string) &#123; return firstName + \" \" + lastName;&#125;let result1 = buildName(\"Bob\"); // error, too few parameterslet result2 = buildName(\"Bob\", \"Adams\", \"Sr.\"); // error, too many parameterslet result3 = buildName(\"Bob\", \"Adams\"); // okay and returns \"Bob Adams\"let result4 = buildName(undefined, \"Adams\"); // okay and returns \"Will Adams\" 나머지(Rest) 파라미터Required 파라미터, Optional 파라미터 및 Default-initialized 파라미터는 모두 한 가지 공통점이 있습니다. 즉, 한 번에 하나의 파라미터에 대한 지정입니다. 때로는 여러 파라미터를 그룹으로 사용하거나 함수가 궁극적으로 취할 파라미터의 수를 모를 수 있습니다. JavaScript에서는 모든 함수 본문에서 볼 수있는 arguments 변수를 사용하여 파라미터를 직접 사용할 수 있습니다. TypeScript에서는 이러한 파라미터들을 모아서 함께 변수로 대입할수 있습니다. 12345function buildName(firstName: string, ...restOfName: string[]) &#123; return firstName + \" \" + restOfName.join(\" \");&#125;let employeeName = buildName(\"Joseph\", \"Samuel\", \"Lucas\", \"MacKinzie\"); Rest 파라미터는 무한한 개수의 Optional 파라미터로 취급됩니다. Rest 파라미터에 인수를 전달할 때 원하는 만큼의 파라미터를 입력할수 있습니다. 그리고 또한 아무것도 입력하지 않아도 됩니다. 컴파일러는 줄임표 (...)로 입력된 이름에 나머지 파라미터들을 배열로 만들어 입력합니다. 이 배열 파라미터는 함수 내부에서 사용할 수 있습니다. 줄임표(...) 부호는 Rest 파라미터가있는 함수의 타입에도 사용됩니다. 12345function buildName(firstName: string, ...restOfName: string[]) &#123; return firstName + \" \" + restOfName.join(\" \");&#125;let buildNameFun: (fname: string, ...rest: string[]) =&gt; string = buildName; thisJavaScript에서 this를 사용하는 법을 배우는 것은 기본 통과 의례중 하나입니다. TypeScript는 JavaScript의 상위 집합이기 때문에 TypeScript 개발자는 this를 사용하는 방법과, 올바르게 사용되지 않는 지점을 찾는 방법을 배워야합니다. 다행히 TypeScript를 사용하면 두 가지 기술을 사용하여 잘못된 용도를 잡을 수 있습니다. this가 JavaScript에서 어떻게 작동하는지 알아야 할 필요가 있다면, Yehuda Katz의 JavaScript 함수 호출및 “this”의 이해를 먼저 읽으십시오. Yehuda의 포스트는 this의 내부 동작을 잘 설명하므로 여기서는 기본 내용만 다룰 것입니다. this와 화살표 함수(Arrow function)JavaScript에서 this는 함수가 호출 될 때 설정된 변수입니다. 이것은 매우 강력하고 유연한 기능이지만 함수가 실행될 때 항상 알 필요는 없습니다. 이것은 특히 함수를 반환하거나 함수를 인수로 전달할 때 혼란스러울 수 있습니다. 예제를 살펴 보겠습니다. 1234567891011121314151617let deck = &#123; suits: [\"hearts\", \"spades\", \"clubs\", \"diamonds\"], cards: Array(52), createCardPicker: function() &#123; return function() &#123; let pickedCard = Math.floor(Math.random() * 52); let pickedSuit = Math.floor(pickedCard / 13); return &#123;suit: this.suits[pickedSuit], card: pickedCard % 13&#125;; &#125; &#125;&#125;let cardPicker = deck.createCardPicker();let pickedCard = cardPicker();alert(\"card: \" + pickedCard.card + \" of \" + pickedCard.suit); createCardPicker는 그 자체로 함수를 반환하는 함수입니다. 예제를 실행하려고 하면 예상되는 경고 상자 대신 오류가 발생합니다. 이것은createCardPicker에 의해 생성된 함수에서 사용되는 this가 deck 객체 대신에 window로 설정되기 때문입니다. 왜냐하면 우리는cardPicker() 자신을 호출하기 때문입니다. 이와 같은 최상위 비 메소드 호출 구문은 this가 window를 사용합니다. (주의 : 엄격 모드에서 this는 window보다는undefined가 될 것입니다). 사용할 함수를 반환하기 전에 함수가 올바른 this에 바인딩되어 있는지 확인하면 이 문제를 해결할 수 있습니다. 이렇게하면 나중에 함수가 사용되는 방법에 관계없이 원래의 deck 객체를 바라보게 됩니다. 이를 위해 함수 표현식을 변경하여 ECMAScript 6 Arrow 함수 구문을 사용합니다. Arrow 함수는 호출된 곳이 아닌 함수가 생성된 곳의 this를 사용합니다. 123456789101112131415161718let deck = &#123; suits: [\"hearts\", \"spades\", \"clubs\", \"diamonds\"], cards: Array(52), createCardPicker: function() &#123; // NOTE: the line below is now an arrow function, allowing us to capture 'this' right here return () =&gt; &#123; let pickedCard = Math.floor(Math.random() * 52); let pickedSuit = Math.floor(pickedCard / 13); return &#123;suit: this.suits[pickedSuit], card: pickedCard % 13&#125;; &#125; &#125;&#125;let cardPicker = deck.createCardPicker();let pickedCard = cardPicker();alert(\"card: \" + pickedCard.card + \" of \" + pickedCard.suit); 더 좋은 점은 컴파일러에 --noImplicitThis 플래그를 넘겨 주면 실수 했을 때 경고를 합니다. 이것은 this.suits[pickedSuit]의this가 any 타입이라는 것을 나타냅니다. this 파라미터불행히도,this.suits[pickedSuit]의 타입은 여전히 any입니다. 왜냐하면 this는 객체 리터럴 내부의 함수 표현식에서 나온 것이기 때문입니다. 이 문제를 해결하기 위해 명시 적으로 this 파라미터를 제공할 수 있습니다. this 파라미터는 함수의 파라미터 목록에서 처음 나오는 가짜 파라미터입니다. 123function f(this: void) &#123; // 이 Standalone 함수에서 'this'를 사용할 수 없는지 확인하십시오.&#125; 위의 예제 인 Card와 Deck에 몇 가지 인터페이스를 추가하여 타입을 더 명확하고 쉽게 재사용할 수있게 해보겠습니다. 123456789101112131415161718192021222324252627interface Card &#123; suit: string; card: number;&#125;interface Deck &#123; suits: string[]; cards: number[]; createCardPicker(this: Deck): () =&gt; Card;&#125;let deck: Deck = &#123; suits: [\"hearts\", \"spades\", \"clubs\", \"diamonds\"], cards: Array(52), // NOTE: The function now explicitly specifies that its callee must be of type Deck createCardPicker: function(this: Deck) &#123; return () =&gt; &#123; let pickedCard = Math.floor(Math.random() * 52); let pickedSuit = Math.floor(pickedCard / 13); return &#123;suit: this.suits[pickedSuit], card: pickedCard % 13&#125;; &#125; &#125;&#125;let cardPicker = deck.createCardPicker();let pickedCard = cardPicker();alert(\"card: \" + pickedCard.card + \" of \" + pickedCard.suit); 이제 TypeScript는 createCardPicker가 Deck 객체에서 호출 될 것으로 예상합니다. 즉,this는 any가 아닌 Deck 타입입니다. 따라서 --noImplicitThis는 에러를 발생시키지 않습니다. 콜백에서의 this 파라미터나중에 호출 하는 함수를 라이브러리에 전달할 때 콜백에서 this를 사용하면 오류가 발생할 수도 있습니다. 콜백을 호출하는 라이브러리가 정상 함수처럼 호출하기 때문에 this는 undefined가 됩니다. 어떤 작업으로 콜백 에러를 막기 위해 this 파라미터를 사용할 수 있습니다. 먼저 라이브러리 작성자가 콜백 유형에 this를 사용하여 annotate를 추가해야합니다. 123interface UIElement &#123; addClickListener(onclick: (this: void, e: Event) =&gt; void): void;&#125; this: void는 addClickListener가 onclick이 this 타입을 필요로하지 않는 함수라는 것을 의미합니다. 둘째, this를 사용하여 호출 코드에 annotate를 달아야 합니다. 123456789class Handler &#123; info: string; onClickBad(this: Handler, e: Event) &#123; // oops, used this here. using this callback would crash at runtime this.info = e.message; &#125;&#125;let h = new Handler();uiElement.addClickListener(h.onClickBad); // error! this가 annotate 처리되어 있으면, onClickBad는 반드시 Handler의 인스턴스에서 호출되어야 한다는 것을 기술해야 합니다. 그러면 TypeScript는 addClickListener에 this: void가 있는 함수가 필요하다는 것을 탐지합니다. 오류를 수정하려면 this의 타입을 아래와 같이 변경해야 합니다. 123456789class Handler &#123; info: string; onClickGood(this: void, e: Event) &#123; // can't use this here because it's of type void! console.log('clicked!'); &#125;&#125;let h = new Handler();uiElement.addClickListener(h.onClickGood); onClickGood는 this 타입을 void로 지정했기 때문에 addClickListener로 넘겨 줄 수 있습니다. 그것은 this와 this.info를 사용할 수 없다는 것을 의미합니다. 둘 다 원한다면 Arrow 함수를 사용해야합니다. 1234class Handler &#123; info: string; onClickGood = (e: Event) =&gt; &#123; this.info = e.message &#125;&#125; 이것은 Arrow 함수는 this를 Capture하지 않기 때문에 효과적입니다. 그래서 항상 this: void를 기대하는 것으로 넘겨 줄 수 있습니다. 단점은 타입 핸들러의 객체별로 하나의 Arrow 함수가 생성된다는 것입니다. 메소드는 한번 작성되어 Handler의 프로토 타입에 Attach 됩니다. 그리고 핸들러 타입의 모든 객체에 공유됩니다. OverloadsJavaScript는 본질적으로 매우 동적인 언어입니다. 단일 JavaScript 함수가 전달된 파라미터의 모양을 기반으로 여러 타입의 객체를 반환하는 경우는 일반적인 방법입니다. 12345678910111213141516171819202122let suits = [\"hearts\", \"spades\", \"clubs\", \"diamonds\"];function pickCard(x): any &#123; // Check to see if we're working with an object/array // if so, they gave us the deck and we'll pick the card if (typeof x == \"object\") &#123; let pickedCard = Math.floor(Math.random() * x.length); return pickedCard; &#125; // Otherwise just let them pick the card else if (typeof x == \"number\") &#123; let pickedSuit = Math.floor(x / 13); return &#123; suit: suits[pickedSuit], card: x % 13 &#125;; &#125;&#125;let myDeck = [&#123; suit: \"diamonds\", card: 2 &#125;, &#123; suit: \"spades\", card: 10 &#125;, &#123; suit: \"hearts\", card: 4 &#125;];let pickedCard1 = myDeck[pickCard(myDeck)];alert(\"card: \" + pickedCard1.card + \" of \" + pickedCard1.suit);let pickedCard2 = pickCard(15);alert(\"card: \" + pickedCard2.card + \" of \" + pickedCard2.suit); 여기서 pickCard 함수는 사용자가 무엇을 전달했는지에 따라 두 가지 다른 것을 반환합니다. 사용자가 Deck를 나타내는 객체를 전달하면 함수가 Card를 선택합니다. 사용자가 Card를 선택하면 우리는 그들이 선택한 Card를 알려줍니다. 이것을 타입 시스템에 어떻게 설명해야 할까요? 대답은 Overload 목록과 동일한 함수에 대해 여러 함수 타입을 제공하는 것입니다. 이 목록은 컴파일러가 함수 호출을 해결하는 데 사용할 것입니다. pickCard가 받아들이는 것과 그것이 반환하는 것을 설명하는 Overload 리스트를 생성해 보겠습니다. 123456789101112131415161718192021222324let suits = [\"hearts\", \"spades\", \"clubs\", \"diamonds\"];function pickCard(x: &#123;suit: string; card: number; &#125;[]): number;function pickCard(x: number): &#123;suit: string; card: number; &#125;;function pickCard(x): any &#123; // Check to see if we're working with an object/array // if so, they gave us the deck and we'll pick the card if (typeof x == \"object\") &#123; let pickedCard = Math.floor(Math.random() * x.length); return pickedCard; &#125; // Otherwise just let them pick the card else if (typeof x == \"number\") &#123; let pickedSuit = Math.floor(x / 13); return &#123; suit: suits[pickedSuit], card: x % 13 &#125;; &#125;&#125;let myDeck = [&#123; suit: \"diamonds\", card: 2 &#125;, &#123; suit: \"spades\", card: 10 &#125;, &#123; suit: \"hearts\", card: 4 &#125;];let pickedCard1 = myDeck[pickCard(myDeck)];alert(\"card: \" + pickedCard1.card + \" of \" + pickedCard1.suit);let pickedCard2 = pickCard(15);alert(\"card: \" + pickedCard2.card + \" of \" + pickedCard2.suit); 위와 같은 변경으로 Overload는 이제 pickCard 함수에 대한 타입이 체크된 호출을 제공합니다. 컴파일러가 올바른 타입 체크를 선택하도록 하기 위해 기본 JavaScript와 비슷한 과정을 거칩니다. Overload 목록을 보고 제공된 파라미터로 함수를 호출하는 첫 번째 Overload 시도를 계속합니다. 일치하는 항목이 있으면 이 Overload를 올바른 Overload로 선택합니다. 이런 이유 때문에 Overload 요청에 따라 가장 구체적인 것에서 덜 구체적인 것 순으로 넘어갑니다. function pickCard(x): any는 오버로드 리스트의 일부가 아니므로 객체가 있는 Overload, 숫자가 있는 Overload 두 가지 Overload만 있습니다. pickCard를 다른 파라미터 유형과 함께 호출하면 오류가 발생합니다. 이 내용은 나중에 참고하기 위해 제가 공부하며 정리한 내용입니다.의역, 오역, 직역이 있을 수 있음을 알려드립니다.This post is a translation of this original article [https://www.typescriptlang.org/docs/handbook/functions.html] 참고 TypeScript 핸드북 1 - 기본 타입 TypeScript 핸드북 2 - 변수 선언 TypeScript 핸드북 3 - 인터페이스 TypeScript 핸드북 4 - 클래스 TypeScript 핸드북 5 - 함수 TypeScript 핸드북 6 - Generic TypeScript 핸드북 7 - Enum TypeScript 핸드북 8 - 타입 유추 TypeScript 핸드북 9 - 타입 호환성 TypeScript 핸드북 10 - 고급 타입 TypeScript 핸드북 11 - Symbol TypeScript 핸드북 12 - Iterator와 Generator","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://infoscis.github.io/categories/TypeScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://infoscis.github.io/tags/JavaScript/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://infoscis.github.io/tags/TypeScript/"}]},{"title":"TypeScript 핸드북 4 - 클래스","slug":"TypeScript-handbook-classes","date":"2017-05-20T14:20:15.000Z","updated":"2018-01-27T15:07:34.119Z","comments":true,"path":"2017/05/20/TypeScript-handbook-classes/","link":"","permalink":"http://infoscis.github.io/2017/05/20/TypeScript-handbook-classes/","excerpt":"","text":"클래스 (Class)소개JavaScript는 전통적으로 재사용 가능한 컴포넌트를 만들기 위해 함수와 프로토 타입 기반 상속을 사용하지만, 클래스가 기능을 상속하고 객체가 이러한 클래스에서 빌드되는 객체 지향 접근 방식에 익숙하지 않은 프로그래머에게는 다소 생소합니다. ECMAScript 2015 (ECMAScript 6)로 시작하는 JavaScript 프로그래머는 이러한 객체 지향 클래스 기반 접근 방식을 사용하여 응용 프로그램을 빌드할 수 있습니다. 하지만 TypeScript 개발자는 클래스의 기능을 모든 주요 브라우저와 플랫폼에서 작동하는 JavaScript로 컴파일할 수 있습니다. 클래스간단한 클래스 기반 예제를 살펴 보겠습니다. 1234567891011class Greeter &#123; greeting: string; constructor(message: string) &#123; this.greeting = message; &#125; greet() &#123; return \"Hello, \" + this.greeting; &#125;&#125;console.log (new Greeter(\"world\").greet()); 이전에 C#이나 Java를 사용했다면 구문이 익숙할듯 합니다. 새로운 클래스 Greeter를 선언 했습니다. 이 클래스에는 세 가지 멤버가 있습니다. (greeting이라는 프로퍼티, 생성자, greet 메서드) 클래스의 멤버 중 하나를 참조할 때 클래스에서 this.를 앞에 둡니다. 이는 클래스 멤버에 대한 액세스임을 나타냅니다. 마지막 줄에서는 new를 사용하여 Greeter 클래스의 인스턴스를 만듭니다. 이것은 앞서 정의한 생성자를 호출하여 Greeter 타입의 새로운 객체를 생성하고 초기화합니다. 상속TypeScript에서는 일반적인 객체 지향 패턴을 사용할 수 있습니다. 그중에 클래스 기반 프로그래밍에서 가장 기본적인 패턴 중 하나인 상속을 사용하여 기존 클래스를 확장하여 새로운 클래스를 생성할 수 있다는 것입니다. 예제를 살펴 보겠습니다. 1234567891011121314151617181920212223242526272829class Animal &#123; name: string; constructor(theName: string) &#123; this.name = theName; &#125; move(distanceInMeters: number = 0) &#123; console.log(`$&#123;this.name&#125; moved $&#123;distanceInMeters&#125;m.`); &#125;&#125;class Snake extends Animal &#123; constructor(name: string) &#123; super(name); &#125; move(distanceInMeters = 5) &#123; console.log(\"Slithering...\"); super.move(distanceInMeters); &#125;&#125;class Horse extends Animal &#123; constructor(name: string) &#123; super(name); &#125; move(distanceInMeters = 45) &#123; console.log(\"Galloping...\"); super.move(distanceInMeters); &#125;&#125;let sam = new Snake(\"Sammy the Python\");let tom: Animal = new Horse(\"Tommy the Palomino\");sam.move();tom.move(34); 이 예제는 다른 언어에서 공통적으로 사용하는 상속기능을 TypeScript에서 설명합니다. 하위 클래스를 만들때 extends 키워드를 사용합니다. Horse와 Snake가 기본 클래스 인 Animal의 하위 클래스로 분류되고 그 기능을 액세스할 수있습니다. 생성자 함수를 포함하는 파생 클래스는 기본 클래스에서 생성자 함수를 실행할 무조건 super()를 호출해야 합니다. 또한 이 예제의 기본 클래스는 메서드를 하위 클래스에 특화된 메서드로 재정의하는 방법을 보여줍니다. 여기서 Snake와 Horse는Animal의 move 메소드를 오버라이드하는 move 메소드를 생성하여 각 클래스별로 기능을 부여했습니다. tom은 Animal로 선언되었지만,tom.move (34)가Horse에서 재정의 메소드를 호출할 때, 그 값은 Horse입니다. 1234Slithering...Sammy the Python moved 5m.Galloping...Tommy the Palomino moved 34m. public, private, and protected기본은 public위의 예제에서 프로그램을 통해 선언 한 멤버들은 자유롭게 접근할 수있었습니다. 다른 언어에 익숙하다면, 위의 예에서 public이라는 키워드를 사용하지 않아도 된다는 것을 알았을 것입니다. 예를 들어, C#에서는 각 멤버가 명시적으로 public으로 표시되도록 해야합니다. TypeScript에서는 기본적으로 각 멤버가 public입니다. 하지만 public멤버를 명시 적으로 표시할 수 있습니다. 이전 예제를 다음과 같은 방식으로 작성할 수도 있습니다. 1234567class Animal &#123; public name: string; public constructor(theName: string) &#123; this.name = theName; &#125; public move(distanceInMeters: number) &#123; console.log(`$&#123;this.name&#125; moved $&#123;distanceInMeters&#125;m.`); &#125;&#125; private 이해하기멤버가 private으로 표시되면 클래스 외부에서 액세스할 수 없습니다. 123456class Animal &#123; private name: string; constructor(theName: string) &#123; this.name = theName; &#125;&#125;new Animal(\"Cat\").name; // Error: 'name' is private; TypeScript는 구조형 시스템입니다. 만약 두 가지 타입을 비교할 때, 그들이 어디서 왔는지에 관계없이, 모든 구성원의 타입이 호환 가능하다면 타입 자체가 호환 가능하다고 말합니다. 그러나 private및 protected 멤버가 있는 타입을 비교할 때 이러한 타입을 다르게 처리합니다. 만약 두 가지 타입이 호환 가능한 경우는 그 중 하나가 private 멤버라면 다른 멤버도 동일한 선언에서 비롯된 private 멤버를 가져야합니다. protected 멤버에게도 동일하게 적용됩니다. 실제로 어떻게 실행되는지 더 잘 보도록 예제를 보겠습니다. 1234567891011121314151617181920class Animal &#123; private name: string; constructor(theName: string) &#123; this.name = theName; &#125;&#125;class Rhino extends Animal &#123; constructor() &#123; super(\"Rhino\"); &#125;&#125;class Employee &#123; private name: string; constructor(theName: string) &#123; this.name = theName; &#125;&#125;let animal = new Animal(\"Goat\");let rhino = new Rhino();let employee = new Employee(\"Bob\");animal = rhino;animal = employee; // Error: 'Animal' and 'Employee' are not compatible 이 예제에서는 Animal과 Rhino를 가지고 있는데 Rhino는 Animal의 하위 클래스입니다. 또한 Animal과 모양이 똑같은 Employee라는 새로운 클래스도 가지고 있습니다. 이러한 클래스의 인스턴스를 생성 한 다음 서로를 할당하여 어떤 일이 발생하는지 봅니다. Animal과 Rhino는 Animal의 private name : string과 같은 선언으로부터 같은 형태의 private 부분을 공유하기 때문에 호환됩니다. 그러나 Employee의 경우는 그렇지 않습니다. Employee에서 Animal에 할당하려고 할 때, 우리는이 타입들이 호환되지 않는다는 에러를 얻습니다. Employee도 name이라는 private 멤버를 가지고 있지만 Animal로 선언 한 멤버는 아닙니다. protected 이해하기protected 키워드는 private과 매우 유사하게 동작합니다. 단, protected로 선언된 멤버는 파생 클래스의 인스턴스에서 액세스할 수 있습니다. 예를 들어, 123456789101112131415161718192021class Person &#123; protected name: string; constructor(name: string) &#123; this.name = name; &#125;&#125;class Employee extends Person &#123; private department: string; constructor(name: string, department: string) &#123; super(name); this.department = department; &#125; public getElevatorPitch() &#123; return `Hello, my name is $&#123;this.name&#125; and I work in $&#123;this.department&#125;.`; &#125;&#125;let howard = new Employee(\"Howard\", \"Sales\");console.log(howard.getElevatorPitch());console.log(howard.name); // error Person의 외부에서 name을 사용할 수는 없지만 Employee의 인스턴스 메소드에서 사용할 수 있습니다. 왜냐하면 Employee는Person에서 파생되었기 때문입니다. 생성자는 protected로 표시 될 수도 있습니다. 즉, 클래스 외부에서 클래스를 인스턴스화 할 수는 없지만 확장할 수는 있습니다. 예를 들어, 123456789101112131415161718192021class Person &#123; protected name: string; protected constructor(theName: string) &#123; this.name = theName; &#125;&#125;// Employee can extend Personclass Employee extends Person &#123; private department: string; constructor(name: string, department: string) &#123; super(name); this.department = department; &#125; public getElevatorPitch() &#123; return `Hello, my name is $&#123;this.name&#125; and I work in $&#123;this.department&#125;.`; &#125;&#125;let howard = new Employee(\"Howard\", \"Sales\");let john = new Person(\"John\"); // Error: The 'Person' constructor is protected readonlyreadonly 키워드를 사용하여 읽기 전용 속성을 만들 수 있습니다. readonly 속성은 선언 또는 생성자에서 초기화해야합니다. 123456789class Octopus &#123; readonly name: string; readonly numberOfLegs: number = 8; constructor (theName: string) &#123; this.name = theName; &#125;&#125;let dad = new Octopus(\"Man with the 8 strong legs\");dad.name = \"Man with the 3-piece suit\"; // error! name is readonly. 파라미터 프로퍼티위의 예제에서 우리는 Octopus 클래스에서 읽기 전용 멤버 name과 생성자 파라미터 theName을 선언 했습니다. 그런 다음 바로name을 theName으로 설정했습니다. 이것은 매우 일반적인 방법입니다. Parameter property을 사용하면 한 곳에서 멤버를 만들고 초기화할 수 있습니다. 다음은 Parameter property를 사용하는 이전의Octopus 클래스의 수정 버전입니다. 12345class Octopus &#123; readonly numberOfLegs: number = 8; constructor(readonly name: string) &#123; &#125;&#125; theName을 어떻게 버렸고, name 멤버를 생성하고 초기화하기 위해 생성자에 readonly name : string 파라미터를 사용했는지에 주목하십시오. 선언과 할당을 하나의 위치로 통합했습니다. Parameter property는 접근자 (Accessibility Modifier) 또는 readonly 또는 둘 모두로 생성자 파라미터 앞에 접두어를 붙임으로써 선언됩니다. Parameter property에 private을 사용하면 private 멤버를 선언하고 초기화합니다. public, protected, readonly도 마찬가지입니다. Getter/Setter(Accessor)TypeScript는 객체의 멤버에 대한 액세스를 지원하는 Getter/Setter 메서드가 있습니다. 이 메서드를 이용하여 객체의 멤버 프로퍼티가 액세스되는 방식을 세밀하게 제어할 수 있습니다. 간단한 클래스를 작성하고 변환하여 get와 set을 사용해 보겠습니다. 우선 getter 및 setter가 없는 예제부터 시작해 보겠습니다. 123456789class Employee &#123; fullName: string;&#125;let employee = new Employee();employee.fullName = \"Bob Smith\";if (employee.fullName) &#123; console.log(employee.fullName);&#125; 사람들이 fullName을 설정하도록 허용하는 것은 매우 편리할 수 있지만 무작위 사람들이 이름을 바꿀 수 있다면 문제가 발생할 수 있습니다. 아래 코드에서는 직원 수정을 허용하기 전에 사용자가 비밀 암호 코드를 사용할 수 있는지 확인합니다. 우리는 fullName에 대한 직접 접근을 패스 코드를 검사할 set으로 대체함으로써 이것이 가능합니다. 앞의 예제가 계속해서 원활하게 작동할 수있게하기 위해 상응하는 get도 추가합니다. 123456789101112131415161718192021222324let passcode = \"secret passcode\";class Employee &#123; private _fullName: string; get fullName(): string &#123; return this._fullName; &#125; set fullName(newName: string) &#123; if (passcode &amp;&amp; passcode == \"secret passcode\") &#123; this._fullName = newName; &#125; else &#123; console.log(\"Error: Unauthorized update of employee!\"); &#125; &#125;&#125;let employee = new Employee();employee.fullName = \"Bob Smith\";if (employee.fullName) &#123; console.log(employee.fullName);&#125; Setter에서 암호를 수정할수 있는 권한이 있는지 비밀코드를 확인하여 일치하면해 암호를 수정하고, 일치하지 않을 때 직원에게 업데이트 할 수있는 권한이 없다는 경고 메시지를받습니다. 우리가 Getter/Setter(Accessor)에 대해 알아야 할 몇 가지 사항은 다음과 같습니다. 첫째, Getter/Setter는 ECMAScript 5 이상을 사용하도록 컴파일러를 설정해야합니다. ECMAScript 3에 대한 하위 레벨링은 지원되지 않습니다. 둘째, get과 set이 없는 프로퍼티는 자동으로 읽기 전용으로 추정됩니다. 이것은 여러분의 코드에서 .d.ts 파일을 생성할 때 유용합니다. 왜냐하면 여러분의 프로퍼티 사용자가 그것을 변경할 수 없다는 것을 알 수 있기 때문입니다. static 프로퍼티지금까지는 클래스의 인스턴스 멤버에 대해서만 설명했습니다. 인스턴스가 아닌 클래스 자체에서 볼 수있는 클래스의 정적 멤버를 만들 수도 있습니다. 아래 예제에서는 static을 사용합니다. 모든 Grid의 일반 값이기 때문입니다. 각 인스턴스는 클래스의 이름을 선행하여 이 값에 액세스합니다. 인스턴스 액세스 앞에 this.를 추가하는 것과 마찬가지로 정적 액세스 앞에 Grid.를 추가합니다. 123456789101112131415class Grid &#123; static origin = &#123;x: 0, y: 0&#125;; calculateDistanceFromOrigin(point: &#123;x: number; y: number;&#125;) &#123; let xDist = (point.x - Grid.origin.x); let yDist = (point.y - Grid.origin.y); return Math.sqrt(xDist * xDist + yDist * yDist) / this.scale; &#125; constructor (public scale: number) &#123; &#125;&#125;let grid1 = new Grid(1.0); // 1x scalelet grid2 = new Grid(5.0); // 5x scaleconsole.log(grid1.calculateDistanceFromOrigin(&#123;x: 10, y: 10&#125;));console.log(grid2.calculateDistanceFromOrigin(&#123;x: 10, y: 10&#125;)); 추상 클래스(Abstract Class)추상 클래스는 다른 클래스를 파생시킬 수 있는 기본 클래스입니다. 하지만 직접 인스턴스화 할 수 없습니다. 인터페이스와 달리 추상 클래스는 멤버에 대한 Implementation 세부 정보를 포함할 수 있습니다. abstract 키워드는 추상 클래스 내 추상 메서드뿐만 아니라 추상 클래스를 정의하는데 사용됩니다. 123456abstract class Animal &#123; abstract makeSound(): void; move(): void &#123; console.log(\"roaming the earth...\"); &#125;&#125; abstract로 표시된 추상 클래스 내의 메소드에는 Implementation이 포함되어 있지 않으므로 파생 클래스에서 구현해야합니다. 추상 메소드는 인터페이스 메소드와 유사한 구문을 사용합니다. 둘 다 메소드 본문을 포함하지 않고 Method signature를 정의합니다. 그러나 추상 메소드는abstract 키워드를 포함해야 하며 선택적으로 Getter/Setter를 포함할 수 있습니다. 123456789101112131415161718192021222324252627282930313233abstract class Department &#123; constructor(public name: string) &#123; &#125; printName(): void &#123; console.log(\"Department name: \" + this.name); &#125; abstract printMeeting(): void; // must be implemented in derived classes&#125;class AccountingDepartment extends Department &#123; constructor() &#123; super(\"Accounting and Auditing\"); // constructors in derived classes must call super() &#125; printMeeting(): void &#123; console.log(\"The Accounting Department meets each Monday at 10am.\"); &#125; generateReports(): void &#123; console.log(\"Generating accounting reports...\"); &#125;&#125;let department: Department; // ok to create a reference to an abstract typedepartment = new Department(); // error: cannot create an instance of an abstract classdepartment = new AccountingDepartment(); // ok to create and assign a non-abstract subclassdepartment.printName();department.printMeeting();department.generateReports(); // error: method doesn't exist on declared abstract type 고급 기술생성자 함수TypeScript에서 클래스를 선언하면 실제로 동시에 여러 선언이 만들어집니다. 아래 예제는 첫 번째 클래스의 Instance 타입입니다. 12345678910111213class Greeter &#123; greeting: string; constructor(message: string) &#123; this.greeting = message; &#125; greet() &#123; return \"Hello, \" + this.greeting; &#125;&#125;let greeter: Greeter;greeter = new Greeter(\"world\");console.log(greeter.greet()); 여기서 greeter : Greeter라고 할 때 우리는 Greeter 클래스의 인스턴스 타입으로 Greeter를 사용합니다. 이것은 프로그램에서 클래스를 사용하는 두가지 방법중 하나입니다. 또한 생성자 함수(Constructor function)이라고 하는 또 다른 함수가 있습니다. 이것은 클래스의 인스턴스를 새로 만들 때 호출되는 함수입니다. 실제로 어떤 모습인지 보려면 위의 TypeScript로 생성한 JavaScript를 살펴 보겠습니다. 12345678910111213let Greeter = (function () &#123; function Greeter(message) &#123; this.greeting = message; &#125; Greeter.prototype.greet = function () &#123; return \"Hello, \" + this.greeting; &#125;; return Greeter;&#125;)();let greeter;greeter = new Greeter(\"world\");console.log(greeter.greet()); 여기서 let Greeter는 생성자 함수를 할당 받게 될 것입니다. new를 호출하고 이 함수를 실행하면 우리는 클래스의 인스턴스를 얻습니다. 생성자 함수에는 클래스의 모든 정적 멤버도 포함됩니다. 클래스를 생각하는 또 다른 방법은 instance 측면과 static 측면이 있다는 것입니다. 이 차이를 보여주기 위해 예제를 약간 수정 해 봅시다. 12345678910111213141516171819202122class Greeter &#123; static standardGreeting = \"Hello, there\"; greeting: string; greet() &#123; if (this.greeting) &#123; return \"Hello, \" + this.greeting; &#125; else &#123; return Greeter.standardGreeting; &#125; &#125;&#125;let greeter1: Greeter;greeter1 = new Greeter();console.log(greeter1.greet());let greeterMaker: typeof Greeter = Greeter;greeterMaker.standardGreeting = \"Hey there!\";let greeter2: Greeter = new greeterMaker();console.log(greeter2.greet()); 이 예에서greeter1은 이전과 비슷하게 작동합니다. 우리는 Greeter 클래스를 인스턴스화하고 이 객체를 사용합니다. 이것은 우리가 전에 보았습니다. 그런 다음 클래스를 직접 사용합니다. 여기서 우리는 greeterMaker 라는 새로운 변수를 생성합니다. 이 변수는 클래스 자체를 보유하거나 다른 방법으로 생성자 함수를 나타냅니다. 여기서 우리는 typeof Greeter를 사용합니다. 즉, 인스턴스 유형이 아닌 “Greeter 클래스 자체의 타입”을 사용합니다. 또는 더 정확하게 얘기하면 생성자 함수의 유형 (“Greeter”라는 심볼의 타입)입니다. 이 타입은 Greeter 클래스의 인스턴스를 생성하는 생성자와 함께 Greeter의 모든 정적 멤버를 포함합니다. 우리는 greeterMaker에 new를 사용하여 이것을 보여 주며, Greeter의 새로운 인스턴스를 생성하고 이전과 같이 호출합니다. 클래스를 인터페이스로 사용하기이전 섹션에서 말한 것처럼, 클래스 선언은 클래스의 인스턴스를 나타내는 타입과 생성자 함수 두 가지를 작성 해야합니다. 클래스는 타입을 생성하기 때문에 인터페이스를 사용할 수있는 동일한 장소에서 이 타입을 사용할 수 있습니다. 12345678910class Point &#123; x: number; y: number;&#125;interface Point3d extends Point &#123; z: number;&#125;let point3d: Point3d = &#123;x: 1, y: 2, z: 3&#125;; 이 내용은 나중에 참고하기 위해 제가 공부하며 정리한 내용입니다.의역, 오역, 직역이 있을 수 있음을 알려드립니다.This post is a translation of this original article [https://www.typescriptlang.org/docs/handbook/classes.html] 참고 TypeScript 핸드북 1 - 기본 타입 TypeScript 핸드북 2 - 변수 선언 TypeScript 핸드북 3 - 인터페이스 TypeScript 핸드북 4 - 클래스 TypeScript 핸드북 5 - 함수 TypeScript 핸드북 6 - Generic TypeScript 핸드북 7 - Enum TypeScript 핸드북 8 - 타입 유추 TypeScript 핸드북 9 - 타입 호환성 TypeScript 핸드북 10 - 고급 타입 TypeScript 핸드북 11 - Symbol TypeScript 핸드북 12 - Iterator와 Generator","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://infoscis.github.io/categories/TypeScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://infoscis.github.io/tags/JavaScript/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://infoscis.github.io/tags/TypeScript/"}]},{"title":"TypeScript 핸드북 3 - 인터페이스","slug":"TypeScript-handbook-interfaces","date":"2017-05-20T14:20:06.000Z","updated":"2018-01-27T15:10:31.650Z","comments":true,"path":"2017/05/20/TypeScript-handbook-interfaces/","link":"","permalink":"http://infoscis.github.io/2017/05/20/TypeScript-handbook-interfaces/","excerpt":"","text":"인터페이스 (Interface)소개TypeScript의 핵심 원리 중 하나는 type-checking이 값의 형태(shape)에 초점을 맞춘다는 것입니다. 이것은 때때로 “duck typing“또는 “structural subtyping“라고도 합니다. TypeScript에서 인터페이스는 이러한 타입의 이름을 지정하는 역할을 하며 외부의 코드와 여러분의 코드의 약속을 정의하는 강력한 방법입니다. 첫번째 인터페이스인터페이스의 작동 원리를 이해하기위해 간단한 예제를 보겠습니다. 123456function printLabel(labelledObj: &#123; label: string &#125;) &#123; console.log(labelledObj.label);&#125;let myObj = &#123;size: 10, label: \"Size 10 Object\"&#125;;printLabel(myObj); type-checker는 printLabel에 대한 호출을 확인합니다. printLabel 함수에 전달된 객체는 string 타입의 label이라는 프로퍼티가 하나 있습니다. 객체는 실제로 이것보다 더 많은 프로퍼티를 가지고 있을수 있지만 컴파일러는 적어도 필요한 것들이 있는지와 타입만 일치하는지 확인합니다. 하지만 TypeScript가 관대하지 않는 경우도 있습니다. 이번에는 인터페이스를 사용하여 label 프로퍼티가 문자열을 가져야 한다는 요구 사항을 설명하는, 동일한 예제를 다시 작성해 보겠습니다. 12345678910interface LabelledValue &#123; label: string;&#125;function printLabel(labelledObj: LabelledValue) &#123; console.log(labelledObj.label);&#125;let myObj = &#123;size: 10, label: \"Size 10 Object\"&#125;;printLabel(myObj); LabelledValue 인터페이스는 이전 예제의 요구 사항을 충족하는 이름입니다. 여전히 string 타입의 label 이라는 하나의 프로퍼티가 있다는 것을 보여줍니다. printLabel에 전달한 객체가 다른 언어와 같이 이 인터페이스를 구현한다고 명시 적으로 말할 필요가 없었습니다. 여기서 중요 것은 형태일 뿐입니다. 함수에 전달된 객체가 요구 사항을 충족하면 됩니다. Type-checker는 프로퍼티가 어떤 순서로든 상관하지 않으며 인터페이스에 필요한 프로퍼티가 있고 정확한 타입이 필요하다는 점을 지적한다는 것이 중요합니다. 선택적 프로퍼티인터페이스의 모든 프로퍼티가 필수일 필요는 없습니다. 일부는 특정 조건 하에서 존재하거나 전혀 존재하지 않을 수도 있습니다. 이러한 Optional propery는 “option bags”와 같이 두개의 프로퍼티가 있는 객체를 함수에 전달하는 패턴을 생성할때 많이 사용됩니다. 아래의 예제는 이러한 패턴의 일반적인 형태입니다. 1234567891011121314151617interface SquareConfig &#123; color?: string; width?: number;&#125;function createSquare(config: SquareConfig): &#123;color: string; area: number&#125; &#123; let newSquare = &#123;color: \"white\", area: 100&#125;; if (config.color) &#123; newSquare.color = config.color; &#125; if (config.width) &#123; newSquare.area = config.width * config.width; &#125; return newSquare;&#125;let mySquare = createSquare(&#123;color: \"black\"&#125;); Optional propery를 가지는 인터페이스는 다른 인터페이스와 비슷하게 작성되며, 단지 프로퍼티 선언의 이름 끝에 ?가 추가 됩니다. Optional propery의 장점은 인터페이스의 일부가 아닌 프로퍼티의 사용을 방지하고 사용 가능한 프로퍼티을 열거할 수 있다는 것입니다. 예를 들어 createSquare에서 color 프로퍼티의 이름을 잘못 입력했다면 다음과 같은 오류 메시지가 표시됩니다. 123456789101112131415161718interface SquareConfig &#123; color?: string; width?: number;&#125;function createSquare(config: SquareConfig): &#123; color: string; area: number &#125; &#123; let newSquare = &#123;color: \"white\", area: 100&#125;; if (config.color) &#123; // Error: Property 'clor' does not exist on type 'SquareConfig' newSquare.color = config.clor; &#125; if (config.width) &#123; newSquare.area = config.width * config.width; &#125; return newSquare;&#125;let mySquare = createSquare(&#123;color: \"black\"&#125;); 읽기전용 프로퍼티일부 프로퍼티는 객체를 처음 만들 때만 수정할 수 있어야 할 수 있습니다. 프로퍼티 이름 앞에 readonly를 두어 읽기전용으로 지정할 수 있습니다. 1234interface Point &#123; readonly x: number; readonly y: number;&#125; 객체 리터럴을 할당하여 Point를 생성할 수 있습니다. 할당 후에 x와 y는 바꿀 수 없습니다. 12let p1: Point = &#123; x: 10, y: 20 &#125;;p1.x = 5; // error! TypeScript에는 Array&lt;T&gt;와 동일하지만 모든 수정가능한 메서드가 제거된 ReadonlyArray&lt;T&gt; 타입이 있으므로 배열 생성 후 배열을 변경하지 않도록 할 수 있습니다. 123456let a: number[] = [1, 2, 3, 4];let ro: ReadonlyArray&lt;number&gt; = a;ro[0] = 12; // error!ro.push(5); // error!ro.length = 100; // error!a = ro; // error! 위 코드의 마지막 줄을 보면 ReadonlyArray ro를 일반 배열로 다시 할당하는 것조차도 에러가 발생하는 것을 볼수 있습니다. 하지만 아래와 같이 Type assertion으로 Override 할 수 있습니다. 1a = ro as number[]; readonly vs constreadonly 와 const중에 어떤걸 사용할지 결정하는 가장 쉬운 방법은 변수 또는 프로퍼티 중 어떤 형태를 사용하느냐에 따라 결정합니다. 변수는 const를 사용하고 프로퍼티는 readonly를 사용합니다. 프로퍼티 접근 체크첫번째 예제는 단지 {label : string; }가 필요한 상황에서 {size: number; label: string; }이 같은 객체를 함수의 파라미터로 넘기는 것을 보았습니다. 그리고 Optional Property에 대해서도 알게 되었고 “option bags” 패턴에 유용하다는 것을 설명 했습니다. 그러나 두 가지를 순수하게 결합하여 JavaScript에서와 같은 방법으로 사용할 수 있습니다. 예를 들어, createSquare를 사용한 마지막 예제를 보겠습니다. 12345678910interface SquareConfig &#123; color?: string; width?: number;&#125;function createSquare(config: SquareConfig): &#123; color: string; area: number &#125; &#123; // ...&#125;let mySquare = createSquare(&#123; colour: \"red\", width: 100 &#125;); createSquare에 주어진 파라미터는 color 대신 colour라고 쓰여 있습니다. 입력한 파라미터의 width 속성은 호환 가능하고 color 속성은 없으며, 여분의 colour 속성은 중요하지 않으므로 이 프로그램이 올바르게 작성되었다고 주장할 수 있습니다. 그러나 TypeScript는 이 코드에 버그가 있음을 알수 있습니다. 객체 리터럴은 다른 변수에 할당하거나 파라미터로 전달될 때 특별한 처리를 받아 프로퍼티 접근 Checking을 받습니다. 객체 리터럴에 “대상 타입”에 없는 속성이 있으면 오류가 발생합니다. 12// error: 'colour' not expected in type 'SquareConfig'let mySquare = createSquare(&#123; colour: \"red\", width: 100 &#125;); 이 *Check를 피하는 방법은 아주 간단합니다. 가장 쉬운 방법은 Type assertion을 사용하는 것입니다. 1let mySquare = createSquare(&#123; width: 100, opacity: 0.5 &#125; as SquareConfig); 그러나 객체에 다른 용도로 사용되는 몇 가지 추가 속성이 있다고 확신하는 경우 string에 대한 Index signature을 추가하는 것이 더 나은 방법 일 수 있습니다. SquareConfigs가 위의 타입과 함께 color와width 속성을 가질 수 있지만 다른 속성도 가질 수 있다면 다음과 같이 정의할 수 있습니다. 12345interface SquareConfig &#123; color?: string; width?: number; [propName: string]: any;&#125; Index signature에 대해서는 나중에 설명 하겠지만 여기서는 SquareConfig가 여러 속성을 가질 수 있으며 color또는 width가 아닌 다른 프로퍼티들의 타입은 중요하지 않습니다. 조금 놀랍게도 Check를 피하는 마지막 방법은 다른 변수에 객체를 할당하는 것입니다. 아래 코드의 squareOptions는 초과된 프로퍼티를 Check 하지 않기 때문에 컴파일러는 에러를 발생하지 않습니다. 12let squareOptions = &#123; colour: \"red\", width: 100 &#125;;let mySquare = createSquare(squareOptions); 하지만 위의 코드와 같이 이러한 Check를 피하는 시도를 하지 않아야 합니다. 메서드와 상태를 유지하는 더 복잡한 객체 리터럴의 경우 이러한 기법을 염두에 두어야할 수도 있지만 대부분의 초과 프로퍼티 오류는 실제로 버그입니다. 즉, Option bag 과 같은 것에 대해 초과 속성 검사 문제가 발생한다면, 타입 선언의 일부를 수정해야할 수도 있습니다. 이 경우, color 또는 colour 속성을 가진 객체를createSquare에 전달하면, 그것을 반영하기 위해SquareConfig의 정의를 수정해야합니다. 함수 타입인터페이스는 JavaScript 객체가 취할 수있는 다양한 형태로 설명할 수 있습니다. 프로퍼티을 가진 객체를 설명하는 것 외에도 인터페이스는 함수 타입을 정의할 수 있습니다. TypeScript는 인터페이스에 있는 함수 타입을 정의하기 위해 Call signature 인터페이스를 제공합니다. 이것은 주어진 파라미터 목록과 리턴 타입만 있는 함수 선언과 같습니다. 파라미터 목록의 각 파라미터는 이름과 타입이 모두 필요합니다. 123interface SearchFunc &#123; (source: string, subString: string): boolean;&#125; 일단 정의되면 우리는 다른 인터페이스 처럼 이 함수 타입 인터페이스를 사용할 수 있습니다. 아래 코드는 함수 타입의 변수를 만들고 같은 타입의 함수를 할당하는 방법을 보여줍니다. 12345let mySearch: SearchFunc;mySearch = function(source: string, subString: string) &#123; let result = source.search(subString); return result &gt; -1;&#125; 함수 타입이 올바른지 확인하기 위해 파라미터의 이름이 같을 필요는 없습니다. 예를 들어 위의 예제를 다음과 같이 작성할 수 있습니다. 12345let mySearch: SearchFunc;mySearch = function(src: string, sub: string): boolean &#123; let result = src.search(sub); return result &gt; -1;&#125; 함수 파라미터는 한 번에 하나씩 , 서로 대응하는 각 해당 파라미터의 위치와 타입이 Check됩니다. 타입을 전혀 지정하지 않은 경우 TypeScript의 Contextual typing이 함수 SearchFunc 타입의 파라미터에 직접 지정되므로 파라미터 타입을 유추할 수 있습니다. 또한 함수 표현식의 리턴 타입은 반환하는 값 (여기에는 false 및 true)에 의해 암묵적으로 유추됩니다. 함수 표현식이 숫자나 문자열을 반환했다면, Type-checker는 리턴 타입이 SearchFunc 인터페이스에서 기술된 리턴 타입과 일치하지 않는다고 경고했을 것입니다. 12345let mySearch: SearchFunc;mySearch = function(src, sub) &#123; let result = src.search(sub); return result &gt; -1;&#125; Indexable 타입함수 타입을 설명하기 위해 인터페이스를 사용하는 방법과 마찬가지로, [10], 또는 ageMap[ &quot;daniel&quot;] 처럼 “인덱스”할 수있는 타입을 정의할 수 있습니다. 인덱싱 가능 유형에는 인덱싱할 때 대응되는 리턴 타입과 함께 객체에 대해 인덱싱하는 데 사용할 수있는 타입을 설명하는 Index signature가 있습니다. 예를 들어 보겠습니다. 12345678interface StringArray &#123; [index: number]: string;&#125;let myArray: StringArray;myArray = [\"Bob\", \"Fred\"];let myStr: string = myArray[0]; 위에서 Index signature를 갖는 StringArray 인터페이스가 있습니다. 이 Index signature는 StringArray가 number로 인덱스 될 때 string을 리턴한다는 것을 나타냅니다. 지원되는 Index signature에는 문자열과 숫자의 두 가지 타입이 있습니다. 두 가지 타입의 인덱서를 모두 지원하는 경우에는 숫자 인덱서에서 반환된 형태는 문자열 인덱서에서 반환된 형태의 하위 형태이어야 합니다. 이는 number를 사용하여 색인을 생성할 때 JavaScript가 객체로 색인하기 전에 실제로 JavaScript를 문자열로 변환하기 때문입니다. 즉, 100 (number)로 인덱싱하는 것은 &quot;100&quot; (string)으로 인덱싱하는 것과 동일하므로 두 가지가 일관성이 있어야합니다. 123456789101112class Animal &#123; name: string;&#125;class Dog extends Animal &#123; breed: string;&#125;// Error: \"문자열\"로 색인을 생성하면 가끔 \"Dog\"가 생깁니다.interface NotOkay &#123; [x: number]: Animal; [x: string]: Dog;&#125; 문자열 Index signature은 “Dictionary” 패턴을 설명하는 강력한 방법이지만 모든 프로퍼티가 리턴 타입과 일치 해야 합니다. 이것은 문자열 인덱스 obj.property가 obj[&quot;property&quot;]로 사용 가능하다는 것을 선언되기 때문입니다. 다음 예제에서 name의 형식은 문자열 인덱스의 형식과 일치하지 않으며 Type-checker에서 오류가 발생합니다. 12345interface NumberDictionary &#123; [index: string]: number; length: number; // ok, length is a number name: string; // error, 'name'의 타입은 인덱서의 하위 타입이 아닙니다.&#125; 마지막으로 인덱스에 할당하지 못하도록 Index signature을 읽기 전용으로 만들 수 있습니다. 12345interface ReadonlyStringArray &#123; readonly [index: number]: string;&#125;let myArray: ReadonlyStringArray = [\"Alice\", \"Bob\"];myArray[2] = \"Mallory\"; // error! Index signature이 읽기 전용이기 때문에 myArray[2]에 값을 설정할 수 없습니다. 클래스 타입Interface 구현C# 및 Java와 같은 언어로 인터페이스를 사용하는 가장 일반적인 방법 중 하나는 클래스가 특정 계약을 준수하도록 명시적으로 적용하는 것입니다. TypeScript에서도 가능합니다. 12345678interface ClockInterface &#123; currentTime: Date;&#125;class Clock implements ClockInterface &#123; currentTime: Date; constructor(h: number, m: number) &#123; &#125;&#125; 아래 예제에서 setTime과 마찬가지로 클래스에 구현된 인터페이스의 메소드를 설명할 수도 있습니다. 123456789101112interface ClockInterface &#123; currentTime: Date; setTime(d: Date);&#125;class Clock implements ClockInterface &#123; currentTime: Date; setTime(d: Date) &#123; this.currentTime = d; &#125; constructor(h: number, m: number) &#123; &#125;&#125; 인터페이스는 클래스의 public과 private이 아니라 public만을 기술할 수 있습니다. 그렇기 때문에 클래스를 사용하여 클래스 인스턴스의 private에 특정 타입이 있는지 확인할 수 없습니다. 클래스의 Static과 Instance의 차이점클래스와 인터페이스로 작업할 때 클래스에는 Static 측면의 타입과 Instance 측면의 타입이라는 두 가지 유형이 있음을 명심하세요. Construct signature를 사용하여 인터페이스를 만들고 이 인터페이스를 Implements하는 클래스를 만들려고 하면 오류가 발생할 수 있습니다. 12345678interface ClockConstructor &#123; new (hour: number, minute: number);&#125;class Clock implements ClockConstructor &#123; currentTime: Date; constructor(h: number, m: number) &#123; &#125;&#125; 이는 클래스가 인터페이스를 Implements할 때 클래스의 Instance 적인 면만 검사하기 때문입니다. 생성자는 Static 측면에 있으므로 이 Check에 포함되지 않습니다. 대신 클래스의 Static인 측면에서 직접 작업해야 합니다. 아래 예제에서 우리는 생성자를 위한 ClockConstructor와 인스턴스 메서드를 위한ClockInterface라는 두 개의 인터페이스를 정의합니다. 편의상 우리는 전달된 타입의 인스턴스를 생성하는 생성자 함수 createClock도 같이 정의합니다. 1234567891011121314151617181920212223242526interface ClockConstructor &#123; new (hour: number, minute: number): ClockInterface;&#125;interface ClockInterface &#123; tick();&#125;function createClock(ctor: ClockConstructor, hour: number, minute: number): ClockInterface &#123; return new ctor(hour, minute);&#125;class DigitalClock implements ClockInterface &#123; constructor(h: number, m: number) &#123; &#125; tick() &#123; console.log(\"beep beep\"); &#125;&#125;class AnalogClock implements ClockInterface &#123; constructor(h: number, m: number) &#123; &#125; tick() &#123; console.log(\"tick tock\"); &#125;&#125;let digital = createClock(DigitalClock, 12, 17);let analog = createClock(AnalogClock, 7, 32); createClock의 첫번째 파라미터는 ClockClonstructor 타입이고 createClock(AnalogClock, 7, 32)에 AnalogClock이 올바른 Construct signature를 가지고 있는지를 검사합니다. 인터페이스 확장클래스와 마찬가지로 인터페이스는 서로를 확장할 수 있습니다. 이렇게 하면 한 인터페이스의 구성원을 다른 인터페이스로 복사할 수 있으므로 인터페이스를 재사용 가능한 구성 요소로 분리하는 방법을 보다 유연하게 사용할 수 있습니다. 1234567891011interface Shape &#123; color: string;&#125;interface Square extends Shape &#123; sideLength: number;&#125;let square = &lt;Square&gt;&#123;&#125;;square.color = \"blue\";square.sideLength = 10; 인터페이스는 여러 인터페이스를 확장하고 모든 인터페이스를 조합하여 만들 수 있습니다. 12345678910111213141516interface Shape &#123; color: string;&#125;interface PenStroke &#123; penWidth: number;&#125;interface Square extends Shape, PenStroke &#123; sideLength: number;&#125;let square = &lt;Square&gt;&#123;&#125;;square.color = \"blue\";square.sideLength = 10;square.penWidth = 5.0; 결합 (Hybrid) 타입이전에 언급했듯이 인터페이스는 실제 JavaScript에서 제공되는 풍부한 타입을 나타낼 수 있습니다. JavaScript의 역동적이고 유연한 특성으로 인해 위에 설명된 일부 타입의 조합으로 작동하는 객체가 종종 발생할 수 있습니다. 이러한 예는 추가 프로퍼티을 사용하여 함수와 객체의 역할을 모두 수행하는 객체입니다. 1234567891011121314151617interface Counter &#123; (start: number): string; interval: number; reset(): void;&#125;function getCounter(): Counter &#123; let counter = &lt;Counter&gt;function (start: number) &#123; &#125;; counter.interval = 123; counter.reset = function () &#123; &#125;; return counter;&#125;let c = getCounter();c(10);c.reset();c.interval = 5.0; 타사 JavaScript 라이브러리와 상호 작용할 때 타입 모양을 완전히 설명하려면 위와 같은 패턴을 사용해야 할 수도 있습니다. 클래스 확장 인터페이스인터페이스 유형이 클래스 타입을 확장할 때 클래스 타입을 상속하지만 Implements된 내용은 상속되지 않습니다. 마치 인터페이스가 implements를 제공하지 않고 클래스의 모든 멤버를 선언 한 것과 같습니다. 인터페이스는 기본 클래스의 private 및 protected 멤버도 상속합니다. 즉, private 또는 protected 멤버가 있는 클래스를 확장하는 인터페이스를 만들면 해당 인터페이스 유형은 해당 클래스 또는 해당 클래스의 하위 클래스에서만 implements 할 수 있습니다. 이는 많은 상속 계층이 있지만 코드가 특정 프로퍼티가 있는 하위 클래스에서만 작동하도록 지정하려는 경우에 유용합니다. 서브 클래스는 기본 클래스에서 상속하는 것 외에 관련 될 필요가 없습니다. 1234567891011121314151617181920212223class Control &#123; private state: any;&#125;interface SelectableControl extends Control &#123; select(): void;&#125;class Button extends Control &#123; select() &#123; &#125;&#125;class TextBox extends Control &#123; select() &#123; &#125;&#125;class Image &#123; select() &#123; &#125;&#125;class Location &#123; select() &#123; &#125;&#125; 위의 예제에서, SelectableControl은 private state 속성을 포함하여 Control의 모든 멤버를 포함합니다. state는 private 멤버이기 때문에 Control의 자손만 SelectableControl을 구현할 수 있습니다. 왜냐하면 Control의 자손들만이 같은 선언에서 유래된 private state 멤버를 가질 것이기 때문입니다. 이는 private 멤버들이 호환 가능해야 한다는 요구 사항입니다. Control 클래스 안에서 SelectableControl 인스턴스를 통해 private state 멤버에 접근할 수 있습니다. 효율적으로 SelectableControl은 select 메소드를 가진 것으로 알려진 Control과 같은 역할을 합니다. Button과 TextBox 클래스는SelectableControl의 하위 타입입니다. (왜냐하면 둘 다 Control을 상속 받았고 select 메소드를 가졌기 때문입니다), 하지만 Image 클래스와 Location 클래스는 그렇지 않습니다. 이 내용은 나중에 참고하기 위해 제가 공부하며 정리한 내용입니다.의역, 오역, 직역이 있을 수 있음을 알려드립니다.This post is a translation of this original article [https://www.typescriptlang.org/docs/handbook/interfaces.html] 참고 TypeScript 핸드북 1 - 기본 타입 TypeScript 핸드북 2 - 변수 선언 TypeScript 핸드북 3 - 인터페이스 TypeScript 핸드북 4 - 클래스 TypeScript 핸드북 5 - 함수 TypeScript 핸드북 6 - Generic TypeScript 핸드북 7 - Enum TypeScript 핸드북 8 - 타입 유추 TypeScript 핸드북 9 - 타입 호환성 TypeScript 핸드북 10 - 고급 타입 TypeScript 핸드북 11 - Symbol TypeScript 핸드북 12 - Iterator와 Generator","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://infoscis.github.io/categories/TypeScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://infoscis.github.io/tags/JavaScript/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://infoscis.github.io/tags/TypeScript/"}]},{"title":"TypeScript 핸드북 2 - 변수 선언","slug":"TypeScript-handbook-variable-declarations","date":"2017-05-14T13:30:16.000Z","updated":"2018-01-27T15:05:53.099Z","comments":true,"path":"2017/05/14/TypeScript-handbook-variable-declarations/","link":"","permalink":"http://infoscis.github.io/2017/05/14/TypeScript-handbook-variable-declarations/","excerpt":"","text":"변수 선언변수 선언ECMAScript6에 let과 const라는 두개의 새로운 타입의 변수 선언자가 추가 되었습니다. 이전에 언급했듯이, let은 어떤면에서는 var와 유사하지만 사용자가 JavaScript로 실행하는 일반적인 “gotchas”를 피할 수 있습니다. const는 변수에 재할당하는 것을 막는다는 점에서 let을 보완한 것입니다. TypeScript가 JavaScript의 상위 집합체이기 때문에 TypeScript는 당연히 let과 const를 지원합니다. 이러한 새로운 선언자들을 조금더 자세히 설명하고 왜 var 선언자보다 바람직한지 자세히 설명 하겠습니다. 만약 여러분이 JavaScript를 offhandedly하게 사용한 적이 있다면, 다음에서 설명할 내용은 여러분이 경험했던 문제들을 해결하는 좋은 방법이 될 수있습니다. 그리고, JavaScript에서 var 선언의 모든 단점을 잘 알고 있다면 여기서 설명하는 내용은 건너 뛰어도 됩니다. var 선언자전통적으로 JavaScript에서 변수를 선언하는 방법은 var 선언자를 이용하는 방법입니다. 1var a = 10; 위 코드는 10의 값을 가진 변수 a를 선언합니다. 아래와 같이 함수 안에서 변수를 선언할 수도 있습니다. 1234function f() &#123; var message = \"Hello, world!\"; return message;&#125; 함수 내부의 다른 함수(중첩 함수)에서 변수에 액세스할 수 있습니다. 12345678910function f() &#123; var a = 10; return function g() &#123; var b = a + 1; return b; &#125;&#125;var g = f();g(); // returns '11' 위의 예제에서 함수 g는 함수 f에서 선언된 변수a를 사용합니다. 함수 g가 호출 될 때마다 변수 a의 값은 함수 f의 변수 a 값을 사용합니다. 그리고 함수 f가 실행 되고 함수 g를 호출하여 변수 a에 액세스하여 값을 수정할 수도 있습니다. 123456789101112131415function f() &#123; var a = 1; a = 2; var b = g(); a = 3; return b; function g() &#123; return a; &#125;&#125;f(); // returns '2' Scope 규칙var 키워드를 이용한 변수 선언은 C기반의 다른 언어에 익숙한 사람들에게는 약간 어색할 수 있습니다.다음 예제를 보겠습니다. 12345678910function f(shouldInitialize: boolean) &#123; if (shouldInitialize) &#123; var x = 10; &#125; return x;&#125;f(true); // returns '10'f(false); // returns 'undefined' 몇몇분은 위 예제를 보고 놀랄 수도 있습니다. 위 코드에서 변수 x는 if 블록 내에서 선언되었지만 그 블록 외부에서 변수에 접근할 수있었습니다. 왜냐하면 var 선언은 포함 함수, 모듈, 네임 스페이스 또는 전역 범위 (모든 요소는 포함된 블록에 관계없이)에서 액세스할 수 있기 때문입니다. 어떤 사람들은 이러한 방식을 var-scoping 또는 Function-scoping라고 표현합니다. 함수의 Parameter도 Function Scope입니다. 이러한 Scope 규칙은 여러가지 실수와 버그를 유발할 수 있습니다. 아래의 코드를 보듯이 그 중 하나는 동일한 변수를 여러 번 선언하는 것이 오류가 아니라는 것입니다. 1234567891011function sumMatrix(matrix: number[][]) &#123; var sum = 0; for (var i = 0; i &lt; matrix.length; i++) &#123; var currentRow = matrix[i]; for (var i = 0; i &lt; currentRow.length; i++) &#123; sum += currentRow[i]; &#125; &#125; return sum;&#125; 변수 i는 Function-scope의 변수를 참조하기 때문에 안쪽의 for-loop 는 우연히 변수 i 덮어 씁니다. 위 코드에서 보았듯이 경험이 많은 개발자라면 대부분 알고 있겠지만 위와 비슷한 종류의 버그는 코드리뷰에서 많은 논란을 일으킵니다. Variable capturing quirks잠깐 시간을내어 다음 스니펫의 결과가 무엇인지 추측 해보십시오. 123for (var i = 0; i &lt; 10; i++) &#123; setTimeout(function() &#123; console.log(i); &#125;, 100 * i);&#125; JavaScript의 setTimeout 함수는 특정 밀리초 후에 지정한 함수를 실행합니다. 1234567891010101010101010101010 많은 JavaScript 개발자는 코드의 실행 결과가 위와 같다는 것을 알고 있지만, 대부분의 사람들은 출력이 아래와 같을 거라 생각합니다. 123456789100123456789 코드에서 setTimeout에 전달하는 함수 표현식은 실제로 동일 Scope에서 같은 i를 참조합니다. 그게 무슨 뜻인지 잠시 생각해 봅시다. setTimeout은 몇 밀리초 후에 함수를 실행하지만, for loop가 실행을 멈춘 후에 실행됩니다. for loop가 실행을 마치면 i의 값은 10입니다. 따라서 주어진 함수가 호출 될 때마다 10이 출력됩니다! 일반적인 해결 방법은 각 반복마다 i를 캡처하는 IIFE(Immediately Invoked Function Expression : 함수를 바로 호출 하는 표현식)를 사용하는 것입니다. 1234567for (var i = 0; i &lt; 10; i++) &#123; // 'i'의 현재 상태를 캡처 // 현재 값으로 함수를 호출 (function(i) &#123; setTimeout(function() &#123; console.log(i); &#125;, 100 * i); &#125;)(i);&#125; 위에 예를 든 이상하게 보이는 코드는 실제로 매우 일반적인 사용 패턴입니다. Parameter list에 있는 i는 실제로 for loop에서 선언된 변수 i의 그림자와 같습니다. 그리고 같은 이름을 사용했기 때문에 loop 본문을 많이 수정하지 않아도 됩니다. let 선언자지금까지 var에는 몇 가지 문제가 있다는 것을 설명 했습니다. 이것이 let문이 도입된 이유입니다. 사용된 선언자 키워드는 틀리지만 let 선언자와 var 선언자는 동일한 방식으로 작성됩니다 1let hello = \"Hello!\"; 중요한 차이점은 구문에있는 것이 아니라 의미에 관한 것입니다. 이제 이 내용을 살펴 보겠습니다. Block-scoping변수가 let 선언자 키워드을 사용하여 선언되면, Lexical-scope 또는 Block-scope로 불리는 Scope를 사용합니다. var 키워드로 선언된 변수는 자신을 포함하는 Scope 함수 외부에 노출 되는 것과 달리 Block-Scope 변수는 자신을 포함하는 가장 가까운 블록 외부 또는 for loop 외부에서 엑세스할 수 없습니다. 123456789101112function f(input: boolean) &#123; let a = 100; if (input) &#123; // 'a'를 참조할 수 있습니다. let b = a + 1; return b; &#125; // Error: 'b'는 여기에 존재하지 않습니다. return b;&#125; 위 예제에는 두 개의 지역 변수 인 a와 b가 있습니다. a의 Scope은 함수 f의 본문으로 제한되며 b의 Scope은 if 문 블록으로 제한됩니다. catch 절에서 선언된 변수도 비슷한 범위 지정 규칙을가집니다. 123456789try &#123; throw \"oh no!\";&#125;catch (e) &#123; console.log(\"Oh well.\");&#125;// Error: 'e'는 여기에 존재하지 않습니다.console.log(e); Block-scope 변수의 또 다른 특징은 실제로 선언되기 전에 읽거나 쓸 수 없다는 것입니다. 변수의 선언이 모두 자신의 Temporal dead zone의 일부를 가리킬 때까지 Scope 내에서 “존재” 합니다. 이것은 let 선언문 이전에 변수에 접근할 수 없고 TypeScript는 이러한 내용을 알려 줍니다. 12a++; // 선언전에 'a'를 사용할 수 없습니다.let a; 주의해야 할 점은 Block-scope의 변수의 선언전에 캡처를 할 수 있다는 것입니다. 그리고 ES2015에서는 이러한 캡처가 함수를 호출하는 시점에 오류를 발생시키지만 지금의 TypeScript는 이러한 방식을 허용하고 있으며 에러를 발생하지 않습니다.(TypeScript에서는 var로 변환하기 때문에) 12345678910function foo() &#123; // okay to capture 'a' return a;&#125;// 'a' 선언전에 함수 foo를 호출 하는건 잘못됐습니다.// runtime시에 error를 발생시킬 것입니다.foo();let a; Temporal dead zone에 대한 자세한 내용은 Mozilla 개발자 네트워크의 관련 내용을 참조하십시오. 재선언 과 Shadowvar 선언자를 이용한 변수선언은 선언 횟수가 중요하지 않습니다. 12345678function f(x) &#123; var x; var x; if (true) &#123; var x; &#125;&#125; 위의 예제에서 x의 모든 선언은 실제로 같은 x를 참조하며 이것은 완벽하게 유효합니다. 이런 방식의 코딩은 종종 버그의 원인이되곤 합니다. 하지만 let 선언자를 이용한 변수 선언은 이러한 방식을 허용하지 않습니다. 12let x = 10;let x = 20; // error: 같은 Scope 내에서 변수 'x'를 재선언할 수 없습니다. 아래 예제와 같이 Block-scope 변수가 아니어도 변수의 재선언시 Typescript에서 문제가 있음을 알려줍니다. 12345678function f(x) &#123; let x = 100; // error: parameter 변수 선언에 간섭하고 있습니다.&#125;function g() &#123; let x = 100; var x = 100; // error: 변수 'x'를 두개 선언할 수 없습니다.&#125; 하지만 Block-scope 변수가 Function-scope에 절대로 선언 될 수 없다는 말은 아닙니다. 블록 범위 변수는 뚜렷하게 다른 블록 내에서 선언되어야만 합니다. 1234567891011function f(condition, x) &#123; if (condition) &#123; let x = 100; return x; &#125; return x;&#125;f(false, 0); // returns '0'f(true, 0); // returns '100' 중첩된 Scope에 기존의 변수 이름을 사용하는 것을 Shadow라고합니다. 하지만 우발적으로 Shadow를 사용할 경우 버그를 유발할 수 있기 때문에 양날의 검일수 있습니다. 아래의 예제는 let 변수를 사용하여 이전에 작성했던 sumMatrix 함수를 다시 작성했습니다. 1234567891011function sumMatrix(matrix: number[][]) &#123; let sum = 0; for (let i = 0; i &lt; matrix.length; i++) &#123; var currentRow = matrix[i]; for (let i = 0; i &lt; currentRow.length; i++) &#123; sum += currentRow[i]; &#125; &#125; return sum;&#125; 이 버전의 for loop는 실제로 내부 for loop의 i가 외부 for loop의 i를 Shadow 하기 때문에 실제로 합계를 올바르게 수행합니다. 일부 코드에서 Shadow가 필요할 수도 있지만 일반적으로 더 명확한 코드를 작성하기 위해 Shadow는 피해야합니다. Block-scoped variable capturingvar 선언자로 변수 캡쳐를 했을때 캡처된 변수가 어떻게 작동하는지 간단히 살펴 보았습니다. 조금더 자세히 설명하면, Scope가 실행될 때마다 변수의 “environment”을 생성합니다. Scope 내의 모든 것이 실행을 마친 후에도 “environment”와 캡처된 변수가 존재할 수 있습니다. 123456789101112function theCityThatAlwaysSleeps() &#123; let getCity; if (true) &#123; let city = \"Seattle\"; getCity = function() &#123; return city; &#125; &#125; return getCity();&#125; “environment” 안에서 city를 캡처 했으므로 ‘if’블록이 실행을 완료 했음에도 불구하고 여전히 액세스할 수 있습니다. 이전의 setTimeout 예제에서는for loop가 반복 될 때마다 변수의 상태를 캡처하기 위해 IIFE를 사용해야 할 필요가 있었습니다. 실제로 우리가 수행 한 작업은 캡처된 변수에 대한 새로운 변수 환경을 만드는 것이 었습니다. 이러한 방식은 약간 불편하지만 TypeScript에서는 다시할 필요가 없습니다. let 선언문은 루프의 일부로 선언 될 때 크게 다른 행동을 합니다. 루프 자체에 새로운 환경을 도입하기보다는 이러한 선언은 반복마다 새로운 Scope을 만듭니다. 어쨌든 IIFE를 사용하여이 작업을 수행했던 이전의 setTimeout 예제를 let 선언을 이용하여 변경할 수 있습니다. 123for (let i = 0; i &lt; 10 ; i++) &#123; setTimeout(function() &#123; console.log(i); &#125;, 100 * i);&#125; 예상대로 출력 됩니다. 123456789100123456789 const 선언자const 선언은 변수(상수)를 선언하는 또 다른 방법입니다. 1const numLivesForCat = 9; const 선언은 let 선언과 같지만, 그 이름이 암시 하듯이 값이 초기화 되면 값을 변경할 수 없습니다. 즉, let 과 동일한 범위 “Block-scope” 규칙을 갖지만 다시 할당할 수는 없습니다. 하지만 const 변수들이 참조하는 값이 불변일꺼라 생각하면 안됩니다. 1234567891011121314151617const numLivesForCat = 9;const kitty = &#123; name: \"Aurora\", numLives: numLivesForCat,&#125;// Errorkitty = &#123; name: \"Danielle\", numLives: numLivesForCat&#125;;// all \"okay\"kitty.name = \"Rory\";kitty.name = \"Kitty\";kitty.name = \"Cat\";kitty.numLives--; 이러한 현상을 피하기 위해 특별한 조치를 취하지 않는다면, const 변수의 내부 상태는 여전히 수정 가능합니다. 다행히 TypeScript를 사용하면 객체의 멤버를 readonly으로 지정할 수 있습니다. 인터페이스를 부분에 자세한 내용이 있습니다. let vs. const비슷한 “Block-scope” 유형을 가진 두 가지 선언이 있다고 가정할 때, let과 const중 어떤 것을 사용할지 스스로 선택해야 합니다. 간단히 힌트를 드리자면 다음과 같습니다. 최소 권한의 원칙(Principle of least privilege)을 적용하면 수정하려는 모든 선언은 const를 사용해야 합니다. 변수에 write 할 필요가 없는 경우, 같은 코드를 이용하여 협업하는 사람들이 자동으로 객체에 값을 쓰지 않아야 하는 경우, 변수에 실제로 재할당이 필요하는지 등의 여부를 고려해야합니다. const를 사용하면 데이터 흐름에 대해 추론할 때 코드를 더 예측 가능하게 만듭니다. 많은 사용자들은 간결함을 선호할 것 이기 때문에 var는 더이상 사용하지 않고 let을 사용할 것입니다. 이 핸드북의 대부분은 let 선언문을 사용합니다. DestructuringTypeScript에있는 또 다른 ECMAScript2015 기능은 Destructuring입니다. 좀더 자세한 정보는 Mozilla Developer Network의 기사를 참조하십시오. 이 섹션에서는 간단한 개요를 제공합니다. Array destructuring가장 간단한 형태의 Destructuring 는 배열의 비구조화 할당입니다. 1234let input = [1, 2];let [first, second] = input;console.log(first); // outputs 1console.log(second); // outputs 2 위 코드는 first와 second라는 두 개의 새로운 변수를 만듭니다. 이는 인덱스를 이용하는 것과 동일하지만 훨씬 편리합니다. 12first = input[0];second = input[1]; Destructuring은 이미 선언된 변수와 함께 작동합니다. 12// swap variables[first, second] = [second, first]; 함수에 대한 Parameter에 사용하면 다음과 같습니다. 12345function f([first, second]: [number, number]) &#123; console.log(first); console.log(second);&#125;f([1, 2]); ... 구문을 사용하여 목록의 나머지 항목에 대한 변수를 만들 수 있습니다. 123let [first, ...rest] = [1, 2, 3, 4];console.log(first); // outputs 1console.log(rest); // outputs [ 2, 3, 4 ] 물론 이것은 JavaScript이므로 관심이 없는 나머지 요소는 무시할 수 있습니다. 12let [first] = [1, 2, 3, 4];console.log(first); // outputs 1 또는 다른 요소들 1let [, second, , fourth] = [1, 2, 3, 4]; Object destructuring객체를 Destructuring 할 수도 있습니다. 123456let o = &#123; a: \"foo\", b: 12, c: \"bar\"&#125;;let &#123; a, b &#125; = o; 그러면 o.a와 o.b에서 새로운 변수 a와 b가 생성됩니다. 필요하지 않다면 c는 건너 뛸 수 있습니다. 배열 Destructuring과 마찬가지로 선언 없이 할당할 수 있습니다. 1(&#123; a, b &#125; = &#123; a: \"baz\", b: 101 &#125;); 이 문장을 괄호로 묶어야한다는 것을 주목하십시오. JavaScript는 일반적으로{를 블록의 시작으로 구문 분석합니다. ... 구문을 사용하여 객체의 나머지 항목에 대한 변수를 만들 수 있습니다. 12let &#123; a, ...passthrough &#125; = o;let total = passthrough.b + passthrough.c.length; Property 재명명(renaming)Property에 다른 이름을 지정할 수도 있습니다. 1let &#123; a: newName1, b: newName2 &#125; = o; 구문이 혼란스러워지기 시작합니다. a : newName1을 “a as newName1“로 읽을 수 있습니다. 방향은 왼쪽에서 오른쪽입니다. 12let newName1 = o.a;let newName2 = o.b; 혼란스럽지만 여기 콜론은 타입을 나타내지 않습니다. 타입을 지정하는 경우 전체 destructuring된 후에 타입을 지정해야 합니다. 1let &#123; a, b &#125;: &#123; a: string, b: number &#125; = o; 기본값(Default value)기본값을 사용하면 속성이 정의되지 않은 경우 기본값을 지정할 수 있습니다. 123function keepWholeObject(wholeObject: &#123; a: string, b?: number &#125;) &#123; let &#123; a, b = 1001 &#125; = wholeObject;&#125; keepWholeObject 함수는 b가 정의되지 않았더라도 a와 b 속성이 있는 wholeObject를 가집니다. Function 선언Destructuring은 함수 선언에서도 작동합니다. 아래의 간단한 예를 보겠습니다. 1234type C = &#123; a: string, b?: number &#125;function f(&#123; a, b &#125;: C): void &#123; // ...&#125; 그러나 Parameter의 기본값을 지정하는 것이 더 일반적이며, Destructuring시 정확한 기본값을 가져 오는 것은 까다로울 수 있습니다. 우선, 기본값 앞에 타입을 적어야 하는 것을 잊지 말아야 합니다. 1234function f(&#123; a, b &#125; = &#123; a: \"\", b: 0 &#125;): void &#123; // ...&#125;f(); // ok, default to &#123; a: \"\", b: 0 &#125; 그런 다음 메인 Initializer가 아닌 Destructured Property의 Optional Property에 대한 기본값을 지정해야 합니다. C에서 b는 Optional로 지정되었다는 것을 기억하세요. 123456function f(&#123; a, b = 0 &#125; = &#123; a: \"\" &#125;): void &#123; // ...&#125;f(&#123; a: \"yes\" &#125;); // ok, default b = 0f(); // ok, default to &#123; a: \"\" &#125;, which then defaults b = 0f(&#123;&#125;); // error, 'a' is required if you supply an argument 조심해서 Destructuring을 사용하십시오. 앞의 예제에서 보여 주듯이 단순한 Destructuring 표현을 제외하고는 혼란스러울 수 있습니다. 특히 이름 바꾸기, 기본값, type annotation을 사용하지 않아도 이해하기 힘든 깊이 중첩된 Destructuring에서는 특히 그렇습니다. Destructuring 표현은 단순하면서 최소한 유지하십시오. 언제든지 여러분이 생성한 Desctructuring을 할당해서 사용할 수 있습니다. SpreadSpread 연산자는 Destructuring의 반대입니다. 배열을 다른 배열로 펼치거나(Spread) 객체를 다른 객체로 퍼뜨릴(Spread) 수 있습니다. 123let first = [1, 2];let second = [3, 4];let bothPlus = [0, ...first, ...second, 5]; 이 코드는 bothPlus에[0, 1, 2, 3, 4, 5] 값을 부여합니다. Spread는 first와 second의 얕은 복사본을 만듭니다. 그리고 first와 second는 Spread 의해 값이 변하지 않습니다. 객체를 Spread할 수도 있습니다. 12let defaults = &#123; food: \"spicy\", price: \"$$\", ambiance: \"noisy\" &#125;;let search = &#123; ...defaults, food: \"rich\" &#125;; 이제 search는 {food : &quot;rich&quot;, price : &quot;$$&quot;, ambiance : &quot;noisy&quot;} 입니다. 객체 Spread는 배열 Spread보다 복잡합니다. 배열 Spread와 마찬가지로 왼쪽에서 오른쪽으로 진행되지만 결과는 여전히 객체입니다. 즉, 나중에 Spread된 객체의 Property중 이미 이전에 있던 Property와 이름이 같다면 Property의 값을 덮어 씁니다. 그래서 우리가 앞의 예제를 수정하여 끝에 Spread 하면 아래와 같습니다. 12let defaults = &#123; food: \"spicy\", price: \"$$\", ambiance: \"noisy\" &#125;;let search = &#123; food: \"rich\", ...defaults &#125;; defaults의 food Property는 food :&#39;rich&#39;로 덮어 씁니다.이 경우에는 우리가 원하는 것이 아닙니다. 객체 Spread에는 몇 가지 다른 놀라운 limit가 있습니다.첫째, 자신의 Enumerable property(열거 가능한 속성)만 포함됩니다. 이는 객체의 인스턴스를 Spread할 때 메서드가 손실된다는 것을 의미합니다. 123456789class C &#123; p = 12; m() &#123; &#125;&#125;let c = new C();let clone = &#123; ...c &#125;;clone.p; // okclone.m(); // error! 둘째, Typescript 컴파일러는 generic function의 Parameter 변수의 스프레드를 허용하지 않습니다. 이 기능은 향후 버전에서 지원될 것으로 예상됩니다. 이 내용은 나중에 참고하기 위해 제가 공부하며 정리한 내용입니다.의역, 오역, 직역이 있을 수 있음을 알려드립니다.This post is a translation of this original article [https://www.typescriptlang.org/docs/handbook/variable-declarations.html] 참고 TypeScript 핸드북 1 - 기본 타입 TypeScript 핸드북 2 - 변수 선언 TypeScript 핸드북 3 - 인터페이스 TypeScript 핸드북 4 - 클래스 TypeScript 핸드북 5 - 함수 TypeScript 핸드북 6 - Generic TypeScript 핸드북 7 - Enum TypeScript 핸드북 8 - 타입 유추 TypeScript 핸드북 9 - 타입 호환성 TypeScript 핸드북 10 - 고급 타입 TypeScript 핸드북 11 - Symbol TypeScript 핸드북 12 - Iterator와 Generator","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://infoscis.github.io/categories/TypeScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://infoscis.github.io/tags/JavaScript/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://infoscis.github.io/tags/TypeScript/"}]},{"title":"TypeScript 핸드북 1 - 기본 타입","slug":"TypeScript-handbook-basic-types","date":"2017-05-14T13:26:36.000Z","updated":"2018-01-27T15:04:06.485Z","comments":true,"path":"2017/05/14/TypeScript-handbook-basic-types/","link":"","permalink":"http://infoscis.github.io/2017/05/14/TypeScript-handbook-basic-types/","excerpt":"","text":"기본 Type소개프로그램을 구조적으로 잘 만들기 위해 number, string, structure, boolean 등 가장 간단한 데이터 단위로 작업을 할 수 있어야합니다. TypeScript에서는 이러한 타입들을 JavaScript와 거의 같은 형태로 지원합니다. BooleanJavaScript/TypeScript의 가장 기본적인 데이터 타입은 true/false 값을 가지는 boolean 입니다. 1let isDone: boolean = false; NumberJavaScript에서와 마찬가지로 TypeScript의 모든 숫자는 부동 소수점 값이고 number 타입을 가집니다. TypeScript는 16 진수 및 10 진수 리터럴 외에도 ECMAScript 2015에 도입된 바이너리 및 8 진수를 지원합니다. 1234let decimal: number = 6;let hex: number = 0xf00d;let binary: number = 0b1010;let octal: number = 0o744; String웹 페이지와 서버용 JavaScript에서 프로그램을 생성할 때 흔히 문자열 데이터를 많이 사용합니다. 다른 언어에서와 마찬가지로, TypeScript에서 이러한 문자 데이터 유형을 나타 내기 위해 string 타입 문자열을 사용합니다. JavaScript와 마찬가지로 TypeScript는 문자열 데이터를 표현하기 위해 큰 따옴표(“) 또는 작은 따옴표(‘)를 사용합니다. 12let color: string = \"blue\";color = 'red'; 문자열이 여러 행에 걸쳐 있고 표현식을 포함할 수있는 template string을 사용할 수도 있습니다. 이러한 문자열은 백틱/백 쿼트(` ) 문자로 둘러싸여 있있고, ${expr}를 이용하여 표현식을 포함할 수 있습니다. 12345let fullName: string = `Bob Bobbington`;let age: number = 37;let sentence: string = `Hello, my name is $&#123;fullName&#125;.I'll be $&#123; age + 1 &#125; years old next month.`; 위 코드는 String 변수를 다음과 같이 선언하는 것과 같습니다. 12let sentence: string = \"Hello, my name is \" + fullName + \".\\n\\n\" + \"I'll be \" + (age + 1) + \" years old next month.\"; ArrayTypeScript는 JavaScript와 마찬가지로 배열을 사용할 수있습니다. 배열 타입은 두 가지 방법 중 하나로 작성할 수 있습니다. 첫 번째로, 각 타입에 []를 붙여 해당 타입의 배열을 나타냅니다 1let list: number[] = [1, 2, 3]; 두 번째 방법은 일반적인 배열 타입 Array을 사용합니다. 1let list: Array&lt;number&gt; = [1, 2, 3]; Tuple튜플 타입을 사용하면 고정된 수의 요소 타입은 알고 있지만, 값의 종류가 다른 배열을 표현할 수 있습니다. 예를 들어, 문자열과 숫자의 쌍을 아래와 같이 표현할 수 있습니다. 123456// Declare a tuple typelet x: [string, number];// Initialize itx = [\"hello\", 10]; // OK// Initialize it incorrectlyx = [10, \"hello\"]; // Error 변수 선언에 포함된 인덱스 요소의 타입은 인덱스를 이용하여 정확한 타입으로 액세스가 가능합니다. 하지만, 타입이 서로 다를수 있기 때문에 액세스한 데이터의 처리는 달라질 수 있습니다. 12console.log(x[0].substr(1)); // OKconsole.log(x[1].substr(1)); // Error, 'number' does not have 'substr' 변수 선언에 포함되지 않는 요소에 대한 액세스는 Tuple 선언에 사용된 타입의 Union 타입으로 사용됩니다. 12345x[3] = \"world\"; // OK, 'string' can be assigned to 'string | number'console.log(x[5].toString()); // OK, 'string' and 'number' both have 'toString'x[6] = true; // Error, 'boolean' isn't 'string | number' Union 타입은 이후 장에서 다룰 고급 주제중 하나 입니다. EnumJavaScript의 표준 데이터 타입에서 유용한 기능중 하나는 enum입니다. C# 언어와 마찮가지로 enum은 숫자값 데이터 셋에 사람이 더 친숙한 이름을 지정하는 방법입니다. 12enum Color &#123;Red, Green, Blue&#125;let c: Color = Color.Green; 기본적으로 enum은 0부터 시작하여 멤버의 번호 매기기를 시작합니다. 멤버 중 하나의 값을 수동으로 설정하여 변경할 수 있습니다. 예를 들어 이전 예제를 0 대신 1로 시작할 수 있습니다. 12enum Color &#123;Red = 1, Green, Blue&#125;let c: Color = Color.Green; 또는 enum의 모든 값을 수동으로 설정할 수 있습니다. 12enum Color &#123;Red = 1, Green = 2, Blue = 4&#125;let c: Color = Color.Green; enum의 편리한 기능은 숫자 값에서 enum의 값 이름으로 이동할 수 있다는 것입니다. 예를 들어 값이 2이지만 위의 색상 enum에 매핑된 것이 확실하지 않은 경우 해당 이름을 찾을 수 있습니다. 1234enum Color &#123;Red = 1, Green, Blue&#125;let colorName: string = Color[2];alert(colorName); Any값을 자신 또는 타사 라이브러리의 동적 콘텐츠에서 가져오는 것과 같이 프로그램을 작성할 때 알지 못하는 변수 유형을 설명해야 할 수도 있습니다. 이 경우 컴파일시 타입 검사를 하지 않고 지나가도록 해야 합니다. 이런 방법을 위해 any 타입을 사용합니다. 123let notSure: any = 4;notSure = \"maybe a string instead\";notSure = false; // okay, definitely a boolean any 타입은 기존 JavaScript와 같이 작업하는 강력한 방법중 하나 입니다. 컴파일하는 동안 타입 검사를 옵트 인 (opt-in)하거나 옵트 아웃 (opt-out) 할 수 있습니다. 다른 언어도 비슷하지만 JavaScript의 Object 타입이 비슷한 역할을 합니다. 그러나 Object 타입의 변수는 값을 할당할 수만 있습니다. 실제 존재하는 메소드라도 임의의 메소드를 호출할 수는 없습니다 : 123456let notSure: any = 4;notSure.ifItExists(); // okay, ifItExists might exist at runtimenotSure.toFixed(); // okay, toFixed exists (but the compiler doesn't check)let prettySure: Object = 4;prettySure.toFixed(); // Error: Property 'toFixed' doesn't exist on type 'Object'. any 타입은 타입의 일부분을 알고 있다면 편리하지만 그렇지 않을 수도 있습니다. 예를 들어 배열이 있고, 배열에 있는 값은 다른 타입이 혼합되어 있을 수 있습니다. 123let list: any[] = [1, true, \"free\"];list[1] = 100; Voidvoid는 타입이 전혀 없다는 것에서 any의 반대 의미와 비슷합니다. 일반적으로 값을 반환하지 않는 함수의 반환 유형으로 이 타입을 사용합니다. 123function warnUser(): void &#123; alert(\"This is my warning message\");&#125; void 타입의 변수 선언은undefined 또는null 만 할당할 수 있기 때문에 그다지 유용하지 않습니다. 1let unusable: void = undefined; Null 과 UndefinedTypeScript에서 undefined와 null은 실제로 각각 undefined와 null이라는 이름의 타입을 가지고 있습니다. void와 매우 비슷하게, 이 타입들은 그 자체로 매우 유용하지는 않습니다. 123// Not much else we can assign to these variables!let u: undefined = undefined;let n: null = null; 기본적으로 null과 undefined는 다른 모든 유형의 하위 유형입니다. 즉,null과 undefined를 number와 같은 것에 할당할 수 있습니다. --strictNullChecks 플래그를 사용할 경우 null과 undefined는 void와 각각의 타입 변수에만 할당 가능합니다. 이렇게하면 많은 일반적인 오류를 피할 수 있습니다. string 또는 null 또는 undefined를 전달 하고자하는 경우, union 타입 string|null|undefined을 사용할 수 있습니다. 다시 한번, Union 타입은 후반부에 자세히 설명합니다. 가능하면 --strictNullChecks의 사용을 권장합니다. 그러나이 핸드북의 목적 상 우리는 플래그가 꺼져 있다고 가정 합니다. Nevernever 타입은 절대로 발생하지 않는 값의 타입을 나타냅니다. 예를 들어, never는 함수 표현식의 리턴 타입이거나, 항상 예외를 던지는 화살표 함수 표현식이거나, 리턴하지 않는 표현식입니다. 변수는 결코 true가 될 수없는 어떤 타입의 가드에 의해 좁혀 질 때 타입 never를 획득합니다.(?) never 타입은 모든 타입의 서브 타입이며, 모든 타입에 assign 가능합니다. 하지만 어떤 타입도 never (never 자체 제외)의 하위 타입이 아니고 assign 할 수 없습니다. 어떤 타입도 ‘never’에 assign되지 않습니다. ‘never’를 반환하는 함수의 몇 가지 예는 다음과 같습니다. 123456789101112131415// Function returning never must have unreachable end pointfunction error(message: string): never &#123; throw new Error(message);&#125;// Inferred return type is neverfunction fail() &#123; return error(\"Something failed\");&#125;// Function returning never must have unreachable end pointfunction infiniteLoop(): never &#123; while (true) &#123; &#125;&#125; Type assertions어떤 값에 대해 프로그래머는 때때로 TypeScript보다 더 많은 정보를 알수 있습니다. 보통 이런 경우는 어떤 엔티티의 타입이 현재 타입보다 더 구체적인 타입을 알고 있을 때입니다. 타입 어설션은 컴파일러에게 “나를 믿어. 내가 하고 있는 일을 잘 알아.”라고 말하는 방법입니다. 타입 어설션은 다른 언어의 타입 변환과 비슷하지만 특별한 검사 나 데이터 재구성을 수행하지 않습니다. 런타임에 영향을 미치지 않으며 컴파일러에서만 사용됩니다. TypeScript는 프로그래머가 필요한 특수 검사를 수행했다고 가정합니다. 타입 어설션에는 두 가지 형식이 있습니다. 하나는 “angle-bracket(&lt;&gt;)”구문입니다. 123let someValue: any = \"this is a string\";let strLength: number = (&lt;string&gt;someValue).length; 그리고 다른 하나는`as’ 구문입니다 : 123let someValue: any = \"this is a string\";let strLength: number = (someValue as string).length; 두가지 방법은 동일한 역할을 하기 때문에 어떤것을 사용하는지는 단지 선택의 문제입니다. 그러나 TypeScript를 JSX와 함께 사용할 경우는 as 스타일의 어설션만 허용됩니다. let에 대해지금까지 우리는 기존에 알고있는 JavaScript의 var 키워드 대신 let 키워드를 사용했습니다. let 키워드는 실제로 TypeScript에서 사용할 수있는 더 새로운 JavaScript 구문입니다. 나중에 자세한 내용을 다루 겠지만, 자바 스크립트의 많은 일반적인 문제는 let을 사용하여 완화되므로 가능할 때마다 var 대신 사용하십시오. 이 내용은 나중에 참고하기 위해 제가 공부하며 정리한 내용입니다.의역, 오역, 직역이 있을 수 있음을 알려드립니다.This post is a translation of this original article [https://www.typescriptlang.org/docs/handbook/basic-types.html] 참고 TypeScript 핸드북 1 - 기본 타입 TypeScript 핸드북 2 - 변수 선언 TypeScript 핸드북 3 - 인터페이스 TypeScript 핸드북 4 - 클래스 TypeScript 핸드북 5 - 함수 TypeScript 핸드북 6 - Generic TypeScript 핸드북 7 - Enum TypeScript 핸드북 8 - 타입 유추 TypeScript 핸드북 9 - 타입 호환성 TypeScript 핸드북 10 - 고급 타입 TypeScript 핸드북 11 - Symbol TypeScript 핸드북 12 - Iterator와 Generator","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://infoscis.github.io/categories/TypeScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://infoscis.github.io/tags/JavaScript/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://infoscis.github.io/tags/TypeScript/"}]},{"title":"JavaScript 함수 호출및 this의 이해","slug":"Understanding-javascript-function-invocation-and-this","date":"2017-05-14T13:21:59.000Z","updated":"2018-01-27T14:48:41.258Z","comments":true,"path":"2017/05/14/Understanding-javascript-function-invocation-and-this/","link":"","permalink":"http://infoscis.github.io/2017/05/14/Understanding-javascript-function-invocation-and-this/","excerpt":"","text":"지난 몇 년 동안 JavaScript 함수 호출에 대해 많은 혼란이 있었습니다. 특히 많은 사람들이 함수 호출에서 this의 의미가 혼란 스럽다고 불평했습니다. 필자의 견해로는, 이 혼란의 대부분은 Core function의 Invocation에 대한 Primitive를 이해하고 그 Primitive에서 함수를 호출하는 방법을 살펴봄으로써 해결됩니다. 실제로 이런 방법이 ECMAScript 스펙을 이해하는데 많은 도움이 됩니다. Core Primitive먼저 Core Function Primitive 기본 함수인 call 메서드[1]를 살펴 보겠습니다. call 메서드는 비교적 간단합니다. 첫번째 파라미터는 thisValue입니다. 두번째 파라미터부터 그 이후 파라미터들을 이용해 파라미터 목록 (argList)을 만듭니다. this를 thisValue로, argList를 Argument list로 하여 함수를 Invoke 합니다. 12345function hello(thing) &#123; console.log(this + \" says hello \" + thing);&#125;hello.call(\"Yehuda\", \"world\") //=&gt; Yehuda says hello world 보시다시피, this는 “Yehuda”로 설정되고 파라미터가 “world” 한개인 hello 메서드를 호출했습니다. 이것이 JavaScript 함수 호출의 Core Primitive입니다. 다른 모든 함수 호출은 이 Primitive에 대해 Desugaring하는 것으로 생각할 수 있습니다.( “desugar”에 이르기까지는 편리한 문법을 사용하여 보다 기본적인 Core primitive로 설명합니다). Desugaring: 소스 코드를 문법적으로 엄격한 형식에 맞춰 변환합니다. [1] ES5 스펙에서 call 함수를 다른 것(더 낮은 레벨의 primitive)으로 설명 하지만, 단지 Primitive 위의 아주 얇은 Wrapper이므로 여기서 간단하게 단순화 합니다. 자세한 내용은이 게시물의 끝 부분을 참조하십시오. 간단한 함수 Invocationcall 함수를 항상 호출하는 것은 많은 불편을 초래합니다. JavaScript에서는 Parens 구문(hello (&quot;world&quot;))을 사용하여 함수를 직접 Invoke 할 수있습니다. 그렇게 할 때 Invocation은 다음과 같이 됩니다. 123456789function hello(thing) &#123; console.log(\"Hello \" + thing);&#125;// this:hello(\"world\")// desugars to:hello.call(window, \"world\"); ECMAScript 5에서 strict mode[2]를 사용 할 때만 아래와 같이 변경됩니다. 12345// this:hello(\"world\")// desugars to:hello.call(undefined, \"world\"); 짧은 버전의 fn(… args) 함수 Invocation은 fn.call (window [ES5-strict: undefined], … args)과 동일합니다. 일반적인 (function() {})() 형태의 함수 호출은 (function() {}).call(window [ES5-strict: undefined])와 동일합니다. [2] 사실, 나는 조금 거짓말을 했습니다. ECMAScript 5 스펙에서는 undefined가 (거의) 항상 전달되지만, 호출되는 함수가 strict 모드가 아니면 thisValue를 전역 객체로 변경해야 한다고 합니다. 이렇게하면 strict 모드 호출자가 기존의 non-strict 모드 라이브러리를 손상시키지 않도록 할 수 있습니다. Member Function다음으로 함수를 호출하는 가장 일반적인 방법은 객체의 멤버 (person.hello())입니다. 이 경우, Invocation desugars는 다음과 같습니다. 123456789101112var person = &#123; name: \"Brendan Eich\", hello: function(thing) &#123; console.log(this + \" says hello \" + thing); &#125;&#125;// this:person.hello(\"world\")// desugars to this:person.hello.call(person, \"world\"); hello 메서드가 어떻게 이런 형태의 객체에 Attach 되는지 중요하지 않습니다. 이전 예제에서 hello를 Standalone 함수로 정의했음을 기억하십시오. 우리가 동적으로 메서드를 객체에 Attach 하면 어떻게되는지 살펴 보겠습니다. 12345678910function hello(thing) &#123; console.log(this + \" says hello \" + thing);&#125;person = &#123; name: \"Brendan Eich\" &#125; person.hello = hello;person.hello(\"world\") // still desugars to person.hello.call(person, \"world\")hello(\"world\") // \"[object DOMWindow]world\" 이 함수는 지속적인 this를 가지고 있지 않습니다. 호출자가 호출 한 방식에 따라 호출 시간에 항상 설정됩니다. Function.prototype.bind 사용하기지속적인 this 값은 함수에 대한 참조에서 편리 하기 때문에 대부분의 개발자들은 변하지 않는 this를 가진 함수로 변환하기 위해 간단한 Closure 트릭을 사용 해왔습니다. 12345678910var person = &#123; name: \"Brendan Eich\", hello: function(thing) &#123; console.log(this.name + \" says hello \" + thing); &#125;&#125;var boundHello = function(thing) &#123; return person.hello.call(person, thing); &#125;boundHello(\"world\"); boundHello 함수 호출은 여전히 boundHello.call(window, &quot;world&quot;)의 Desugar 임에도 불구하고 우회하여 Primitive call 메서드를 사용하여 this 값을 우리가 원했던 값으로 다시 변경합니다 . 함수를 조금 꼬아서 이 방법을 범용으로 만들 수 있습니다. 12345678var bind = function(func, thisValue) &#123; return function() &#123; return func.apply(thisValue, arguments); &#125;&#125;var boundHello = bind(person.hello, person); boundHello(\"world\") // \"Brendan Eich says hello world\" 이것을 이해하기 위해서는 두가지 정보가 더 필요합니다. 첫째, arguments는 함수에 전달된 모든 파라미터를 나타내는 Array와 비슷한 객체입니다. 그리고 둘째는, apply 메서드는 call Primitive와 똑같이 작동한다는 것입니다. 단, 한 번에 하나씩 인자를 나열하는 대신 Array와 비슷한 객체를 사용한다는 점이 call 메서드와 다릅니다. 우리의 bind 메서드는 단순히 새로운 함수를 반환합니다. bind 메서드가 호출 될 때, 우리의 새로운 함수는 전달된 원래의 함수를 단순히 호출하고, 또한 인수를 통해 전달된 thisValue를 this로 설정합니다. 이런 방법은 일반적으로 많이 사용되는 관용구 였기 때문에, ES5는 이 동작을 구현하는 모든 Function 객체에 새로운 메서드 bind를 도입했습니다. 12var boundHello = person.hello.bind(person); boundHello(\"world\") // \"Brendan Eich says hello world\" 콜백으로 전달할 Raw function이 필요할 때 가장 유용합니다. 12345678var person = &#123; name: \"Alex Russell\", hello: function() &#123; console.log(this.name + \" says hello world\"); &#125;&#125;$(\"#some-div\").click(person.hello.bind(person));// div가 클릭되면 \"Alex Russell says hello world\"라고 인쇄됩니다. 이런 방식은 다소 어수선하기 때문에, TC39(ECMAScript의 다음 버전 작업을 하는 위원회)는 보다 우아하고 하위 버전 호환성을 갖춘 해결책을 만들기 위해 준비중입니다. On jQueryjQuery는 익명의 콜백 함수를 많이 사용하기 때문에 내부적으로 call 메서드를 사용하여 콜백의 this 값을 보다 유용한 값으로 설정합니다. 예를 들어 특별한 처리없이 모든 이벤트 핸들러에서 window를 this로 수신하는 대신 jQuery는 첫번째 매개 변수로 이벤트 핸들러를 설정하는 요소로 콜백에 대해 call을 호출합니다. 이것은 익명의 콜백에서 this의 기본값이 특별히 유용하지 않기 때문에 매우 유용 하지만, 초보자에게 this는 일반적으로 돌연변이 같이 이상한 개념이된 이유입니다. 만약 Sugary Function 호출을 Desugar Function func.call (thisValue, ... args)로 변환하는 기본 규칙을 이해한다면, JavaScript this 값을 잘못 사용하여 위험한 곳에 사용된 것을 찾을수 있습니다. PS: I Cheated필자는 여러 곳에서 명세의 정확한 표현을 약간 단순화했습니다. 아마 가장 중요한 속임수는 func.call을 “Primitive”이라고 부르는 방식일 것입니다. 실제로 spec에는 ‘func.call과[obj.]func()’둘 다 사용하는 프리미티브 (내부적으로[[Call]])가 있습니다. func.call의 정의를 살펴 보겠습니다. IsCallable (func)이 false 인 경우 TypeError 예외를 발생시킵니다. argList를 빈 목록으로 둡니다. 이 메서드가 복수의 파라미터로 호출됐을 경우, arg1로 시작되는 왼쪽에서 오른쪽의 순서로 각 파라미터를 argList의 마지막 요소로서 추가합니다. thisArg를 this 값으로, argList를 파라미터 목록으로 제공하여 [[Call]]func의 내부 메서드 호출 결과를 반환합니다. 보시다시피, 이 정의는 기본적으로 Primitive [[Call]] 연산에 바인딩하는 매우 간단한 JavaScript 언어입니다. 함수를 invoke하는 정의를 살펴보면 처음 7 단계에서 thisValue와 argList를 설정하고 마지막 단계는 “func에서 [[Call]] 내부 메서드를 호출 한 결과를 반환하고 thisValue를 this 값으로 제공하고 argList리스트를 argument 값으로 제공하십시오.” 입니다. argList와 thisValue가 결정되면 그것은 본질적으로 동일한 문구입니다. call을 primitive라고 부르는 것에 조금 속임수를 썼지만, 의미는 본질적으로 이 글의 시작 부분에서 스펙을 이용해 설명 했던 것과 같습니다. 이 내용은 나중에 참고하기 위해 제가 공부하며 정리한 내용입니다.의역, 오역, 직역이 있을 수 있음을 알려드립니다.This post is a translation of this original article [http://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/] 참고 ES5 : http://es5.github.io/multi.html ES6 : http://www.ecma-international.org/ecma-262/6.0/index.html","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://infoscis.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://infoscis.github.io/tags/JavaScript/"}]},{"title":"Spring Boot에서 Background Thread 만들기","slug":"Springboot-background-thread","date":"2017-03-26T14:48:21.000Z","updated":"2018-01-27T14:55:09.628Z","comments":true,"path":"2017/03/26/Springboot-background-thread/","link":"","permalink":"http://infoscis.github.io/2017/03/26/Springboot-background-thread/","excerpt":"","text":"1.Event Listener1.1 Event Listener 란 어떠한 이벤트가 발생하면 호출되어 처리하는 객체. 1.2 Listener 사용법 구현할 기능과 관련된 각종 인터페이스만 제공함으로 클래스는 구현해야함. 1.3 Listener 인터페이스 종류ServletContextListener 웹 어플리케이션의 시작과 종료시 자동으로 발생되는 이벤트를 수행하기 위한 메소드를 정의한 인터페이스이다. method name 설명 contextInitialized(ServletContextEvent sce) : void 웹 컨테이너가 처음 구동될 때 실행되는 메소드 contextDestoryed(ServletContextEvent sce) 웹 컨테이너가 종료될 때 실행되는 메소드 ServletContextAttributeListener 컨테이너에 저장된 속성 값들의 변화가 있을 때 수행하기 위한 메소드를 정의한 인터페이스이다. method name 설명 attributeAdded(ServletContextAttributeEvent scae) : void 새로운 속성 값이 추가될 때 실행되는 메소드 attributeRemoved(ServletContextAttributeEvent scae) 속성 값이 제거될 때 실행되는 메소드 attributeReplaced(ServletContextAttributeEvent scae) 속성 값이 변경될 때 실행되는 메소드 HttpSessionListener HTTP 세션이 활성화 되거나 비활성화 되려할 때 혹은 속성 값들이 추가, 삭제, 변경될 경우 수행하기 위한 인터페이스 method name 설명 sessionCreated(HttpSession se) : void 세션이 생성되었을 경우 이 메소드가 실행 sessionDestoryed(HttpSession se) : void 세션이 무효화 되었을 경우 이 메소드 실행 HttpSessionAttributeListener HTTP 세션에 대한 속성 값이 변경되었을 경우 수행하기 위한 인터페이스 method name 설명 attributeAdded(HttpSessionBindingEvent e) : void 세션에 새로운 속성 값이 추가될 때 실행 attributeRemoved(HttpSessionBindingEvent e) : void 세션의 속성 값이 제거될 실행 attributeReplaced(HttpSessionBindingEvent e) : void 세션의 속성 값이 변경될 때 실행 HttpSessionActivationListener 세션에 대한 내용이 새로 생성되어 세션이 활성화 되었을 때 발생하는 이벤트를 수행하기 위한 인터페이스 method name 설명 sessionDidActivate(HttpSessionEvent e) : void 세션이 활성화 될 때 실행 sessionWillPassivate(HttpSessionEvent e) : void 세션이 비활성화 되려고 할 때 실행 HttpSessionBindingListener 클라이언트의 세션 정보에 대한 바인딩이 이루어졌을 경우 감지되는 이벤트를 수행하기 위한 인터페이스 method name 설명 valueBound(HttpSessionBindingEvent e) : void 세션에 연결될 때 발생하는 이벤트를 실행 valueUnBound(HttpSessionBindingEvnet e) : void 세션으로부터 연결이 해제될 때 발생하는 이벤트를 실행 2. Spring Boot Background Thread Listener &amp; Main ClassListener Thead1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import javax.servlet.ServletContext;import javax.servlet.ServletContextEvent;import javax.servlet.ServletContextListener;import javax.servlet.annotation.WebListener;@WebListenerpublic class DaemonListener implements ServletContextListener, Runnable&#123; /** 작업을 수행할 thread */ private Thread thread; private boolean isShutdown = false; /** context */ private ServletContext sc; /** 작업을 수행한다 */ public void startDaemon() &#123; if (thread == null) &#123; thread = new Thread(this, \"Daemon thread for background task\");// thread.setDaemon(true); &#125; if (!thread.isAlive()) &#123; thread.start(); &#125; &#125; /** 스레드가 실제로 작업하는 부분 */ public void run() &#123; Thread currentThread = Thread.currentThread(); while (currentThread == thread &amp;&amp; !this.isShutdown) &#123; try &#123; System.out.println (\"== DaemonListener is running. ==\"); Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println (\"== DaemonListener end. ==\"); &#125; /** 컨텍스트 초기화 시 데몬 스레드를 작동한다 */ public void contextInitialized (ServletContextEvent event) &#123; System.out.println (\"== DaemonListener.contextInitialized has been called. ==\"); sc = event.getServletContext(); startDaemon(); &#125; /** 컨텍스트 종료 시 thread를 종료시킨다 */ public void contextDestroyed (ServletContextEvent event) &#123; System.out.println (\"== DaemonListener.contextDestroyed has been called. ==\"); this.isShutdown = true; try &#123; thread.join(); thread = null; &#125; catch (InterruptedException ie) &#123; ie.printStackTrace(); &#125; &#125;&#125; Spring Boot Application123456789101112131415import org.springframework.boot.SpringApplication;import org.springframework.boot.actuate.system.ApplicationPidFileWriter;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.web.servlet.ServletComponentScan;@SpringBootApplication@ServletComponentScanpublic class SampleSpringBootApplication &#123; public static void main(String[] args) &#123; SpringApplication application = new SpringApplication(SampleSpringBootApplication.class); application.addListeners(new ApplicationPidFileWriter()); application.run(args); &#125;&#125; 이 내용은 나중에 참고하기 위해 제가 공부하며 정리한 내용입니다. 참고 Page Event Listener Sample Code","categories":[{"name":"Java","slug":"Java","permalink":"http://infoscis.github.io/categories/Java/"},{"name":"Spring","slug":"Java/Spring","permalink":"http://infoscis.github.io/categories/Java/Spring/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://infoscis.github.io/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"http://infoscis.github.io/tags/Spring/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://infoscis.github.io/tags/SpringBoot/"}]},{"title":"간단한 YARN Application 만들기","slug":"Writing-YARN-Applications","date":"2017-03-25T15:59:05.000Z","updated":"2017-06-19T14:35:28.354Z","comments":true,"path":"2017/03/26/Writing-YARN-Applications/","link":"","permalink":"http://infoscis.github.io/2017/03/26/Writing-YARN-Applications/","excerpt":"","text":"이 내용은 나중에 참고하기 위해 제가 공부하며 정리한 내용입니다.의역, 오역, 직역이 있을 수 있음을 알려드립니다.Original article: Writing YARN Applications이문서는 아파치 하둡 2.7.2 기준으로 작성되어 있습니다. Purpose이 문서는 High level에서 YARN용 Application을 구현하는 방법을 설명합니다. 개념 및 흐름일반적인 YARN 프로그램은 응용 프로그램을 제출하는 클라이언트(Driver 클래스)가 YARN ResourceManager(RM)에 응용 프로그램을 제출하는 형식입니다. 이 작업은 YarnClient object를 설정하여 수행 할 수 있습니다.YarnClient가 시작되면 클라이언트는 응용 프로그램 컨텍스트를 설정하고, ApplicationMaster(AM)가 포함 된 응용 프로그램의 첫 번째 컨테이너를 준비한 후 응용 프로그램을 제출할 수 있습니다. 응용 프로그램을 실행하는 데 필요한 로컬 file/jar, 실행 해야하는 실제 명령 (필요한 command line argument 사용), 모든 OS 환경 설정 (선택 사항) 등의 정보를 제공해야합니다.또한 ApplicationMaster를 위해 필요한 유닉스 프로세스를 효과적으로 기술 할 필요가 있습니다. YARN ResourceManager는 할당 된 컨테이너에서 지정한대로 ApplicationMaster를 시작합니다. 실행된 ApplicationMaster는 YARN 클러스터와 통신하고 응용 프로그램 실행을 처리합니다. 이러한 작업은 Asynchronous 방식으로 수행됩니다. 응용 프로그램 시작 시간 동안 ApplicationMaster의 주요 작업은 다음과 같습니다.a) 향후 컨테이너에 대한 자원을 협상하고 할당하기 위해 ResourceManager와 통신하고,b) 컨테이너 할당 후 YARN NodeManager (NMs)와 통신하여 응용 프로그램 컨테이너를 시작합니다 . a)는 AMRMClientAsyncCallbackHandler 유형의 Event Handler에 지정된 이벤트 핸들링 메소드로 AMRMClientAsync 오브젝트를 통해 비동기 적으로 수행 할 수 있습니다. Event Handler는 클라이언트에 명시적으로 설정해야합니다. b)는 컨테이너가 할당 될 때 컨테이너를 시작하는 실행 가능한 object를 실행함으로써 수행 될 수 있습니다. 이 컨테이너를 시작하는 과정에서 AM은 command line argument, 환경 등과 같은 실행 정보가있는 ContainerLaunchContext를 지정해야합니다. 응용 프로그램 실행 중에 ApplicationMaster는 NMClientAsync 객체를 통해 NodeManager와 통신합니다. 모든 컨테이너 이벤트는 NMClientAsync와 연결된 NMClientAsync.CallbackHandler에 의해 처리됩니다. 일반적인 Callback handler는 클라이언트 시작, 중지, 상태 업데이트 및 오류를 처리합니다. 또한 ApplicationMaster는 AMRMClientAsync.CallbackHandler의 getProgress() 메소드를 호출하여 ResourceManager에 실행 진행률을 보고합니다. Asynchronous 클라이언트 외에도 특정 워크 플로 (AMRMClient 및 NMClient)에 대한 Synchronous 버전이 있습니다. Asynchronous 클라이언트는 (주관적으로) 보다 간단한 사용법 때문에 권장되며 이 문서에서는 주로 Asynchronous 클라이언트에 대해 다룹니다. Synchronous 클라이언트에 대한 자세한 내용은 AMRMClient 및 NMClient를 참조하십시오. Interfaces다음은 중요한 인터페이스입니다. Client &lt;–&gt; ResourceManager YarnClient 객체를 사용합니다. ApplicationMaster &lt;–&gt; ResourceManager AMRMClientAsync object를사용하여 AMRMClientAsync.CallbackHandler에 의해 이벤트를 비동기적으로 처리합니다. ApplicationMaster &lt;–&gt; NodeManager 컨테이너들을 실행 합니다. NMClientAsync object를 사용하여 노드 관리자와 통신하고 NMClientAsync.CallbackHandler에 의해 컨테이너 이벤트를 처리합니다. YARN 응용 프로그램 (ApplicationClientProtocol, ApplicationMasterProtocol 및 ContainerManagementProtocol)의 세가지 주요 프로토콜은 여전히 유효합니다. 세가지 클라이언트는 YARN 응용 프로그램에 대한보다 단순한 프로그래밍 모델을 제공하기 위해 이 세가지 프로토콜을 래핑합니다. 매우 드문 경우지만 프로그래머는 응용 프로그램을 구현하기 위해 3개의 프로토콜을 직접 사용할 수 있습니다. 그러나 일반적인 사용 사례에서는 이러한 동작이 더 이상 권장되지 않습니다. 간단한 Yarn Application 작성Client 작성클라이언트가 해야 할 첫 번째 단계는 YarnClient를 초기화하고 시작하는 것입니다. 123YarnClient yarnClient = YarnClient.createYarnClient();yarnClient.init(conf);yarnClient.start(); 일단 클라이언트가 설정되면 클라이언트는 application을 작성하고 application ID를 가져와야합니다. 12YarnClientApplication app = yarnClient.createApplication();GetNewApplicationResponse appResponse = app.getNewApplicationResponse(); 새 응용 프로그램에 대한 YarnClientApplication의 응답에는 클러스터의 최소/최대 자원 기능과 같은 클러스터에 대한 정보도 들어 있습니다. 이는 ApplicationMaster가 시작될 컨테이너의 스펙을 올바르게 설정할 수 있도록하기 위해 필요합니다. 자세한 내용은 GetNewApplicationResponse를 참조하십시오. 클라이언트의 주된 요지는 RM이 AM을 시작하는 데 필요한 모든 정보를 정의하는 ApplicationSubmissionContext를 설정하는 것입니다. 클라이언트는 컨텍스트에 다음을 설정해야합니다. Application 정보 : ID, 이름 Queue, Priority 정보 : 응용 프로그램이 전송 될 대기열, 응용 프로그램에 할당 될 우선 순위입니다. User : 응용 프로그램을 제출하는 사용자 ContainerLaunchContext : AM이 시작되고 실행될 컨테이너를 정의하는 정보입니다. 이전에 언급했듯이 ContainerLaunchContext는 로컬 리소스 (바이너리, jar, 파일 등), 환경 설정 (CLASSPATH 등), 실행할 명령 및 보안 토큰 (RECT)과 같은 응용 프로그램을 실행하는 데 필요한 모든 필수 정보를 정의합니다. ). 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143// application 제출 컨텍스트 설정ApplicationSubmissionContext appContext = app.getApplicationSubmissionContext();ApplicationId appId = appContext.getApplicationId();appContext.setKeepContainersAcrossApplicationAttempts(keepContainers);appContext.setApplicationName(appName);// Application Master에 대한 로컬 리소스 설정.// 필요한 경우 로컬 파일 또는 아카이브.// 이 시나리오에서 Application Master의 jar 파일은 로컬 자원의 일부.Map&lt;String, LocalResource&gt; localResources = new HashMap&lt;String, LocalResource&gt;();LOG.info(\"Copy App Master jar from local filesystem and add to local environment\");// Application Master jar파일을 hdfs filesystem으로 복사// 대상 jar 경로를 가리 키도록 로컬 리소스를 생성.FileSystem fs = FileSystem.get(conf);addToLocalResources(fs, appMasterJar, appMasterJarPath, appId.toString(), localResources, null);// 필요한 경우 log4j properties를 설정if (!log4jPropFile.isEmpty()) &#123; addToLocalResources(fs, log4jPropFile, log4jPath, appId.toString(), localResources, null);&#125;// 쉘 스크립트는 실행될 최종 컨테이너에서 사용할 수 있어야 합니다.// 이를 위해서는 우선 yarn 프레임 워크에서 볼 수있는 파일 시스템에 복사해야합니다.// Shell 스크립트는 Application Master에서 필요하지 않으므로 Application Master를 위해 로컬 리소스로 설정할 필요가 없습니다.String hdfsShellScriptLocation = \"\";long hdfsShellScriptLen = 0;long hdfsShellScriptTimestamp = 0;if (!shellScriptPath.isEmpty()) &#123; Path shellSrc = new Path(shellScriptPath); String shellPathSuffix = appName + \"/\" + appId.toString() + \"/\" + SCRIPT_PATH; Path shellDst = new Path(fs.getHomeDirectory(), shellPathSuffix); fs.copyFromLocalFile(false, true, shellSrc, shellDst); hdfsShellScriptLocation = shellDst.toUri().toString(); FileStatus shellFileStatus = fs.getFileStatus(shellDst); hdfsShellScriptLen = shellFileStatus.getLen(); hdfsShellScriptTimestamp = shellFileStatus.getModificationTime();&#125;if (!shellCommand.isEmpty()) &#123; addToLocalResources(fs, null, shellCommandPath, appId.toString(), localResources, shellCommand);&#125;if (shellArgs.length &gt; 0) &#123; addToLocalResources(fs, null, shellArgsPath, appId.toString(), localResources, StringUtils.join(shellArgs, \" \"));&#125;// env 변수를 설정하여 Application Master가 실행될 env에 설정합니다.LOG.info(\"Set the environment for the application master\");Map&lt;String, String&gt; env = new HashMap&lt;String, String&gt;();// shell 스크립트의 위치를 env에 넣는다.// env info를 사용하여 Application Master는 Shell 스크립트를 실행하기 위해 실행될 최종 컨테이너에 대한 올바른 로컬 리소스를 만듭니다env.put(DSConstants.DISTRIBUTEDSHELLSCRIPTLOCATION, hdfsShellScriptLocation);env.put(DSConstants.DISTRIBUTEDSHELLSCRIPTTIMESTAMP, Long.toString(hdfsShellScriptTimestamp));env.put(DSConstants.DISTRIBUTEDSHELLSCRIPTLEN, Long.toString(hdfsShellScriptLen));// AppMaster.jar 위치를 클래스 경로에 추가.// 어떤 점에서 우리는 env에 특정 hadoop 클래스 경로를 추가 할 필요가 없습니다.// 이제 classpath를 포함하여 필요한 모든 classpath를 \".\"로 설정하십시오.StringBuilder classPathEnv = new StringBuilder(Environment.CLASSPATH.$$()).append(ApplicationConstants.CLASS_PATH_SEPARATOR).append(\"./*\");for (String c : conf.getStrings( YarnConfiguration.YARN_APPLICATION_CLASSPATH, YarnConfiguration.DEFAULT_YARN_CROSS_PLATFORM_APPLICATION_CLASSPATH)) &#123; classPathEnv.append(ApplicationConstants.CLASS_PATH_SEPARATOR); classPathEnv.append(c.trim());&#125;classPathEnv.append(ApplicationConstants.CLASS_PATH_SEPARATOR).append(\"./log4j.properties\");// AM을 실행하는 데 필요한 명령어를 설정Vector&lt;CharSequence&gt; vargs = new Vector&lt;CharSequence&gt;(30);// Java 실행명렁어 설정LOG.info(\"Setting up app master command\");vargs.add(Environment.JAVA_HOME.$$() + \"/bin/java\");// Xmx 메모리 설정vargs.add(\"-Xmx\" + amMemory + \"m\");// Set class namevargs.add(appMasterMainClass);// AM paramter 설정vargs.add(\"--container_memory \" + String.valueOf(containerMemory));vargs.add(\"--container_vcores \" + String.valueOf(containerVirtualCores));vargs.add(\"--num_containers \" + String.valueOf(numContainers));vargs.add(\"--priority \" + String.valueOf(shellCmdPriority));for (Map.Entry&lt;String, String&gt; entry : shellEnv.entrySet()) &#123; vargs.add(\"--shell_env \" + entry.getKey() + \"=\" + entry.getValue());&#125;if (debugFlag) &#123; vargs.add(\"--debug\");&#125;vargs.add(\"1&gt;\" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + \"/AppMaster.stdout\");vargs.add(\"2&gt;\" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + \"/AppMaster.stderr\");// 최종 명령어 생성StringBuilder command = new StringBuilder();for (CharSequence str : vargs) &#123; command.append(str).append(\" \");&#125;LOG.info(\"Completed setting up app master command \" + command.toString());List&lt;String&gt; commands = new ArrayList&lt;String&gt;();commands.add(command.toString());// AM을 위한 Container launch 컨텍스트 설정ContainerLaunchContext amContainer = ContainerLaunchContext.newInstance(localResources, env, commands, null, null, null);// 리소스 유형 요구사항 설정// 이제는 메모리와 vCore가 모두 지원되므로 메모리 및 vCore 요구 사항을 설정.Resource capability = Resource.newInstance(amMemory, amVCores);appContext.setResource(capability);// 서비스 데이터는 응용 프로그램에 전달 될 수있는 binary BLOB입니다.// 이 시나리오에서는 필요 없음// amContainer.setServiceData(serviceData);// Setup security tokensif (UserGroupInformation.isSecurityEnabled()) &#123; // Note: Credentials 클래스는 HDFS 및 MapReduce에 대해 LimitedPrivate로 표시됩니다. Credentials credentials = new Credentials(); String tokenRenewer = conf.get(YarnConfiguration.RM_PRINCIPAL); if (tokenRenewer == null | | tokenRenewer.length() == 0) &#123; throw new IOException(\"Can't get Master Kerberos principal for the RM to use as renewer\"); &#125; // 지금은 기본 파일 시스템에 대한 토큰만 얻습니다. final Token&lt;?&gt; tokens[] = fs.addDelegationTokens(tokenRenewer, credentials); if (tokens != null) &#123; for (Token&lt;?&gt; token : tokens) &#123; LOG.info(\"Got dt for \" + fs.getUri() + \"; \" + token); &#125; &#125; DataOutputBuffer dob = new DataOutputBuffer(); credentials.writeTokenStorageToStream(dob); ByteBuffer fsTokens = ByteBuffer.wrap(dob.getData(), 0, dob.getLength()); amContainer.setTokens(fsTokens);&#125;appContext.setAMContainerSpec(amContainer); 설정 프로세스가 완료되면 클라이언트는 지정된 우선 순위 및 대기열을 사용하여 응용 프로그램을 제출할 준비가됩니다. 1234567891011// AM의 priority 설정Priority pri = Priority.newInstance(amPriority);appContext.setPriority(pri);// RM에서 application이 제출 될 대기열을 설정.appContext.setQueue(amQueue);// Application Mansger에 application 제출// SubmitApplicationResponse submitResp = applicationsManager.submitApplication(appRequest);yarnClient.submitApplication(appContext); 이 시점에서 RM은 Application을 수락하고 백그라운드에서 필요한 사양의 컨테이너를 할당 한 다음, 할당 된 컨테이너에서 AM을 설정하고 시작하는 프로세스를 진행합니다.클라이언트가 실제 작업의 진행 상황을 추적 할 수 있는 여러 가지 방법이 있습니다.RM과 통신하여 YarnClient의 getApplicationReport() 메소드를 통해 애플리케이션의 보고서를 요청할 수 있습니다. 12// Get application report for the appId we are interested inApplicationReport report = yarnClient.getApplicationReport(appId); RM으로 부터 받은 ApplicationReport는 아래와 같이 구성되어 있습니다. 일반 응용 프로그램 정보 : 응용 프로그램 ID, 응용 프로그램이 제출 된 큐, 응용 프로그램을 제출 한 사용자 및 응용 프로그램의 시작 시간. ApplicationMaster 상세 정보 : AM이 실행되는 호스트, 클라이언트의 요청을 수신하는 rpc 포트 (있는 경우) 및 클라이언트가 AM과 통신해야하는 토큰. 응용 프로그램 추적 정보 : 응용 프로그램에서 진행 추적의 일부 양식을 지원하는 경우 클라이언트가 진행 상황을 모니터링하기 위해 볼 수있는 ApplicationReport의 getTrackingUrl() 메서드를 통해 사용할 수있는 추적 URL을 설정할 수 있습니다. 응용 프로그램 상태 : ResourceManager에서 볼 수있는 응용 프로그램 상태는 ApplicationReport.getYarnApplicationState를 통해 사용할 수 있습니다. YarnApplicationState가 FINISHED로 설정된 경우 클라이언트는 ApplicationReport.getFinalApplicationStatus를 참조하여 응용 프로그램 작업 자체의 실제 성공/실패를 확인해야합니다. 실패한 경우 ApplicationReport.getDiagnostics가 실패에 대해 더 많은 정보를 제공하는 데 유용 할 수 있습니다. ApplicationMaster가 지원하면 클라이언트는 응용 프로그램 보고서에서 얻은 host:rpcport 정보를 통해 AM 자체에 진행 상태 업데이트를 직접 쿼리 할 수 있습니다. 가능한 경우 보고서에서 얻은 추적 URL을 사용할 수도 있습니다. 특정 상황에서 응용 프로그램이 너무 오래 걸리거나 다른 요인으로 인해 클라이언트가 응용 프로그램을 종료하려고 할 수 있습니다. YarnClient는 클라이언트가 ResourceManager를 통해 AM에 kill 신호를 보낼 수있게하는 killApplication 호출을 지원합니다. 그렇게 설계된 경우 ApplicationMaster는 클라이언트가 활용할 수있는 rpc 계층을 통해 중단 호출을 지원할 수도 있습니다. 1yarnClient.killApplication(appId); ApplicationMaster (AM) 작성AM은 실제 작업 소유자입니다. AM은 RM에 의해 시작되며 클라이언트를 통해 AM 감독 및 완료 임무가 주어진 모든 필요한 정보와 자원을 제공 받게됩니다.멀티 테넌시 특성을 고려할 때 다른 컨테이너와 물리적 호스트를 공유 할 수있는 컨테이너 내에서 AM이 시작될 때 미리 설정된된 포트을 listen 할수 있다는 것과 같은 가정은 할 수 없습니다. AM이 시작되면 Environment를 통해 여러 parameter를 사용할 수 있습니다. 여기에는 AM 컨테이너의 ContainerId, 응용 프로그램 제출 시간 및 ApplicationMaster를 실행하는 NM(NodeManager) 호스트에 대한 세부 정보가 포함됩니다. ApplicationConstants는 parameter 이름을 참조합니다. RM과의 모든 상호 작용에는 ApplicationAttemptId가 필요합니다 (실패한 경우 응용 프로그램마다 여러 번 시도 할 수 있음). ApplicationAttemptId는 AM의 컨테이너 ID에서 가져올 수 있습니다. Environment에서 얻은 값을 object로 변환하는 helper API가 있습니다. 12345678Map&lt;String, String&gt; envs = System.getenv();String containerIdString = envs.get(ApplicationConstants.AM_CONTAINER_ID_ENV);if (containerIdString == null) &#123; // 컨테이너 ID는 항상 프레임 워크에 의해 env에 설정됩니다. throw new IllegalArgumentException(\"ContainerId not set in the environment\");&#125;ContainerId containerId = ConverterUtils.toContainerId(containerIdString);ApplicationAttemptId appAttemptID = containerId.getApplicationAttemptId(); AM이 완전히 초기화 된 후에 ResourceManager와 NodeManager에서 두개의 클라이언트를 시작할 수 있습니다. 여기에서는 커스터마이징 된 Event handler를 사용하여 설정하고 이 Event handler는 나중에 대해 자세히 설명합니다. 123456789AMRMClientAsync.CallbackHandler allocListener = new RMCallbackHandler();amRMClient = AMRMClientAsync.createAMRMClientAsync(1000, allocListener);amRMClient.init(conf);amRMClient.start();containerListener = createNMCallbackHandler();nmClientAsync = new NMClientAsyncImpl(containerListener);nmClientAsync.init(conf);nmClientAsync.start(); AM은 AM이 살아 있고 여전히 실행 중임을 알리기 위해 RM에게 하트비트를 Emit 해야합니다. RM의 timeout 만료는 YarnConfiguration.RM_AM_EXPIRY_INTERVAL_MS를 통해 액세스 할 수있는 구성 설정에 의해 정의되며 기본값은 YarnConfiguration.DEFAULT_RM_AM_EXPIRY_INTERVAL_MS로 정의됩니다. ApplicationMaster는 하트비트를 시작하기 위해 ResourceManager에 등록해야합니다. 1234// RM에 자신을 등록// 이렇게 하면 RM에 heartbeat을 emit 할수 있습니다.appMasterHostname = NetUtils.getHostname();RegisterApplicationMasterResponse response = amRMClient.registerApplicationMaster(appMasterHostname, appMasterRpcPort, appMasterTrackingUrl); 등록 응답에 포함 된 경우 최대 리소스를 확인할수 있습니다. 그리고 이를 사용하여 응용 프로그램의 요청을 확인할 수도 있습니다. 123456789101112131415161718192021// 자원 관리자가 볼 수있는 클러스터 기능(capability)에 대한 정보를 덤프합니다.int maxMem = response.getMaximumResourceCapability().getMemory();LOG.info(\"Max mem capabililty of resources in this cluster \" + maxMem);int maxVCores = response.getMaximumResourceCapability().getVirtualCores();LOG.info(\"Max vcores capabililty of resources in this cluster \" + maxVCores);// 리소스 요청은 최대 값을 초과 할 수 없습니다.if (containerMemory &gt; maxMem) &#123; LOG.info(\"Container memory specified above max threshold of cluster.\" + \" Using max value.\" + \", specified=\" + containerMemory + \", max=\" + maxMem); containerMemory = maxMem;&#125;if (containerVirtualCores &gt; maxVCores) &#123; LOG.info(\"Container virtual cores specified above max threshold of cluster.\" + \" Using max value.\" + \", specified=\" + containerVirtualCores + \", max=\" + maxVCores); containerVirtualCores = maxVCores;&#125;List&lt;Container&gt; previousAMRunningContainers = response.getContainersFromPreviousAttempts();LOG.info(\"Received \" + previousAMRunningContainers.size() + \" previous AM's running containers on AM registration.\"); 작업 요구 사항에 따라 AM은 해당 작업을 실행할 컨테이너 세트를 요청할 수 있습니다. 이제 얼마나 많은 컨테이너가 필요한지 계산할 수 있고, 계산된 컨테이너를 요청할 수 있습니다. 123456789101112List&lt;Container&gt; previousAMRunningContainers = response.getContainersFromPreviousAttempts();List&lt;Container&gt; previousAMRunningContainers = response.getContainersFromPreviousAttempts();LOG.info(\"Received \" + previousAMRunningContainers.size() + \" previous AM's running containers on AM registration.\");int numTotalContainersToRequest = numTotalContainers - previousAMRunningContainers.size();// RM에게 컨테이너를 위한 SETUP 문의 &amp; Request 전송// 할당량이 완전히 할당 될 때까지 컨테이너에 대한 RM 폴링을 계속// 모든 컨테이너가 시작되고 쉘 스크립트의 성공/실패 여부와 관계없이 실행될 때까지 루핑.for (int i = 0; i &lt; numTotalContainersToRequest; ++i) &#123; ContainerRequest containerAsk = setupContainerAskForRM(); amRMClient.addContainerRequest(containerAsk);&#125; setupContainerAskForRM()에서 다음 두 가지를 설정해야합니다. Resource capability : 현재 YARN은 메모리 기반 리소스 요구 사항을 지원하므로 요청에서 필요한 메모리 양을 정의해야합니다. 이 값은 MB 단위로 정의되며 클러스터의 최대 용량보다 작아야하며 최소 용량의 정확한 배수 여야합니다. 메모리 자원은 타스크 컨테이너에 부과 된 실제 메모리 한계에 해당합니다. 또한 코드에 표시된 것처럼 Computation based resource(vCore)도 지원합니다. Priority : 컨테이너 집합을 요구할 때, AM은 각 집합에 대해 다른 우선 순위를 정의 할 수 있습니다. 예를 들어 Map-Reduce AM은 Map Task에 필요한 컨테이너에 우선 순위를 높이고 Reduce Task 컨테이너에 대해서는 우선 순위를 낮출수 있습니다. 1234567891011121314private ContainerRequest setupContainerAskForRM() &#123; // host들에 대한 요구사항을 setup // 분산 Shell Application에서 *를 이용하면 어떤 host든 가능 // 요청의 우선순위를 설정 Priority pri = Priority.newInstance(requestPriority); // 리소스 타입 요구사항 설정 // 이제는, 메모리와 CPU가 지원되므로 메모리와 CPU 요구 사항을 설정합니다. Resource capability = Resource.newInstance(containerMemory, containerVirtualCores); ContainerRequest request = new ContainerRequest(capability, null, null, pri); LOG.info(\"Requested container ask: \" + request.toString()); return request;&#125; 컨테이너 할당 요청이 Application manager에게 보내진 후 컨테이너는 AMRMClientAsync 클라이언트의 Event handler에 의해 Asynchronous하게 시작됩니다. Handler는 AMRMClientAsync.CallbackHandler 인터페이스를 구현 해야합니다.할당 된 컨테이너가있을 때 Handler는 컨테이너를 시작하는 코드를 실행하는 쓰레드를 설정합니다. 이 글에서는 LaunchContainerRunnable이라는 이름을 사용하여 설명합니다. 이 글의 다음 부분에서 LaunchContainerRunnable 클래스에 대해 설명 할 예정입니다. 123456789101112131415@Overridepublic void onContainersAllocated(List&lt;Container&gt; allocatedContainers) &#123; LOG.info(\"Got response from RM for container ask, allocatedCnt=\" + allocatedContainers.size()); numAllocatedContainers.addAndGet(allocatedContainers.size()); for (Container allocatedContainer : allocatedContainers) &#123; LaunchContainerRunnable runnableLaunchContainer = new LaunchContainerRunnable(allocatedContainer, containerListener); Thread launchThread = new Thread(runnableLaunchContainer); // 따로 유지할 별도의 스레드에서 컨테이너를 실행하고 시작합니다. // main thread가 unblocked 됩니다. // 모든 컨테이너는 한 번에 할당되지 않을 수 있습니다. launchThreads.add(launchThread); launchThread.start(); &#125;&#125; Event handler는 heartbeat에서 프로그램의 진행 상황을 보고합니다. 123456@Overridepublic float getProgress() &#123; // 다음 heartbeat에서 RM에 전달할 진행률 설정 float progress = (float) numCompletedContainers.get()/numTotalContainers; return progress;&#125; 컨테이너 실행 스레드는 실제로 NM에서 컨테이너를 시작합니다. 컨테이너가 AM에 할당 된 후에는 할당 된 컨테이너에서 실행될 최종 작업에 대해 ContainerLaunchContext를 설정할 때 클라이언트가 수행 한 것과 비슷한 프로세스를 따라야합니다. ContainerLaunchContext가 정의되면 AM은 NMClientAsync를 통해 시작할 수 있습니다. 1234567891011121314151617181920212223242526272829303132333435// 할당 된 컨테이너에서 실행하기 위해 필요한 명령을 설정Vector&lt;CharSequence&gt; vargs = new Vector&lt;CharSequence&gt;(5);// 실행 가능한 command를 설정vargs.add(shellCommand);// shell script path 설정if (!scriptPath.isEmpty()) &#123; vargs.add(Shell.WINDOWS ? ExecBatScripStringtPath : ExecShellStringPath);&#125;// shell command의 args를 설정(있는 경우)vargs.add(shellArgs);// log redirect params 추가vargs.add(\"1&gt;\" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + \"/stdout\");vargs.add(\"2&gt;\" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + \"/stderr\");// 최종 commmand 생성StringBuilder command = new StringBuilder();for (CharSequence str : vargs) &#123; command.append(str).append(\" \");&#125;List&lt;String&gt; commands = new ArrayList&lt;String&gt;();commands.add(command.toString());// ContainerLaunchContext를 설정하고 생성자에 대한 로컬 리소스, 환경, 명령 및 토큰을 설정합니다.// Note for tokens: 컨테이너에 토큰을 설정하십시오. // 오늘날 일반적인 셸 명령의 경우 distribute-shell의 컨테이너에는 토큰이 필요하지 않습니다.// NodeManagers에서 distributed file-system의 모든 파일을 다운로드 할 수 있도록 토큰을 설정합니다.// 토큰은 분산 쉘 내부에서 예를 들어, \"hadoop dfs\"명령을 실행하는 경우에 유용합니다.ContainerLaunchContext ctx = ContainerLaunchContext.newInstance( localResources, shellEnv, commands, null, allTokens.duplicate(), null);containerListener.addContainer(container.getId(), container);nmClientAsync.startContainerAsync(container, ctx); NMClientAsync object는 Event handler와 함께 컨테이너 시작, 중지, 상태 업데이트, 오류 발생등의 컨테이너 이벤트를 처리합니다.ApplicationMaster가 작업이 완료되었다고 판단하면, AM-RM 클라이언트를 통해 자체 등록을 취소하고 클라이언트를 중지 해야합니다. 12345678try &#123; amRMClient.unregisterApplicationMaster(appStatus, appMessage, null);&#125; catch (YarnException ex) &#123; LOG.error(\"Failed to unregister application\", ex);&#125; catch (IOException e) &#123; LOG.error(\"Failed to unregister application\", e);&#125;amRMClient.stop(); FAQ응용 프로그램의 jar 파일을 필요로하는 YARN 클러스터의 모든 노드에 배포하려면 어떻게합니까?LocalResource를 사용하여 Application request에 리소스를 추가 할 수 있습니다. 그러면 YARN이 리소스를 ApplicationMaster 노드에 배포하게됩니다. 리소스가 tgz, zip 또는 jar 인 경우 YARN에 압축을 풀 수 있습니다. 그런 다음 압축 해제 된 폴더를 클래스 경로에 추가하기 만하면됩니다. 예를 들어, Application request를 만들때 : 1234567891011121314151617181920File packageFile = new File(packagePath);Url packageUrl = ConverterUtils.getYarnUrlFromPath(FileContext.getFileContext.makeQualified(new Path(packagePath)));packageResource.setResource(packageUrl);packageResource.setSize(packageFile.length());packageResource.setTimestamp(packageFile.lastModified());packageResource.setType(LocalResourceType.ARCHIVE);packageResource.setVisibility(LocalResourceVisibility.APPLICATION);resource.setMemory(memory);containerCtx.setResource(resource);containerCtx.setCommands(ImmutableList.of( \"java -cp './package/*' some.class.to.Run \" + \"1&gt;\" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + \"/stdout \" + \"2&gt;\" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + \"/stderr\"));containerCtx.setLocalResources(Collections.singletonMap(\"package\", packageResource));appCtx.setApplicationId(appId);appCtx.setUser(user.getShortUserName);appCtx.setAMContainerSpec(containerCtx);yarnClient.submitApplication(appCtx); 위에 보시다시피, setLocalResources는 리소스의 이름을 map으로 가져옵니다. 이 이름은 application의 현재 폴더 (pwd)에서 system link가 되기 때문에 ./package/*를 사용하여 참조 가능합니다. Note:Java의 classpath (cp) 인수는 매우 민감합니다. 정확한 구문을 정확하게 입력하십시오. 패키지가 AM에 배포되면 AM이 새 컨테이너를 시작할 때마다 동일한 프로세스를 수행해야합니다 (리소스를 컨테이너로 보내려는 경우). 이경우에도 코드는 동일합니다. 컨테이너 ctx와 함께 리소스 URL을 보낼 수 있도록 AM에 패키지 경로 (HDFS 또는 로컬)를 제공하면됩니다. ApplicationMaster의 ApplicationAttemptId는 어떻게 가져올수 있나요?ApplicationAttemptId는 Environment를 통해 AM에 전달되며 Environment의 값은 ConverterUtils 도우미 함수를 통해 ApplicationAttemptId object로 변환 할수 있습니다. 왜 내 컨테이너를 NodeManager가 죽이나요?이는 요청한 컨테이너 메모리 크기를 초과하는 높은 메모리 사용량 때문일 수 있습니다.이 문제를 일으킬 수있는 여러 가지 이유가 있습니다. 먼저 NodeManager가 컨테이너를 죽일 때 덤프하는 프로세스 트리를 살펴보십시오. 관심있는 두 가지 사항은 실제 메모리와 가상 메모리입니다. 실제 메모리 제한을 초과하면 앱이 너무 많은 실제 메모리를 사용하고 있습니다. Java 응용 프로그램을 실행중인 경우 -hprof를 사용하여 힙에서 차지하는 공간을 확인할 수 있습니다. 가상 메모리를 초과 한 경우에는 클러스터 전체의 구성 변수 인 yarn.nodemanager.vmem-pmem-ratio의 값을 늘려야 할 수 있습니다. 어떻게 native library들을 포함시킬수 있나요?컨테이너를 실행할때 command에서 -Djava.library.path를 설정하면 Hadoop이 사용하는 기본 라이브러리가 올바르게 로드되지 않고 오류가 발생할 수 있습니다. 대신 LD_LIBRARY_PATH를 사용하는 것이 더 깔끔합니다. Sample Code hadoop-yarn-applications-distributedshell","categories":[{"name":"Hadoop","slug":"Hadoop","permalink":"http://infoscis.github.io/categories/Hadoop/"}],"tags":[{"name":"Hadoop","slug":"Hadoop","permalink":"http://infoscis.github.io/tags/Hadoop/"},{"name":"YARN","slug":"YARN","permalink":"http://infoscis.github.io/tags/YARN/"}]},{"title":"Java 9 와 Project Jigsaw 소개 2","slug":"First-steps-with-java9-and-jigsaw-part-2","date":"2017-03-23T15:43:40.000Z","updated":"2018-01-27T14:37:42.210Z","comments":true,"path":"2017/03/24/First-steps-with-java9-and-jigsaw-part-2/","link":"","permalink":"http://infoscis.github.io/2017/03/24/First-steps-with-java9-and-jigsaw-part-2/","excerpt":"","text":"의역, 오역, 직역이 있을 수 있음을 알려드립니다.이 포스트는 원저자의 동의를 얻어 한글로 번역한 내용입니다. This post is a translation of this original article [https://blog.codecentric.de/en/2015/11/first-steps-with-java9-jigsaw-part-2] by Florian Troßbach from codecentricAuthor: Florian Troßbach 참고 자료http://openjdk.java.net/projects/jigsaw/spec/sotms/http://openjdk.java.net/projects/jigsaw/http://openjdk.java.net/projects/jdk9/http://greatkim91.tistory.com/197Modularity in Java 9JDK 9 Early Access with Project JigsawJEP JDK9 Schedule 2016/05/26 Feature Complete 2016/12/22 Feature Extension Complete 2017/01/05 Rampdown Start 2017/02/09 All Tests Run 2017/02/16 Zero Bug Bounce 2017/03/16 Rampdown Phase 2 2017/07/06 Final Release Candidate 2017/07/27 General Availability 이 포스트는 Project Jigsaw 시작을 돕는 시리즈 중에 두번째 파트 입니다. 첫번째 파트에서는 Module의 정의와 Java Runtime이 어떻게 모듈화 되는지에 대해 간략히 이야기했습니다. 그런 다음 modular application을 컴파일(또는 안되게), 패키징, 실행하는 등의 방법을 보여주는 간단한 예제로 진행했습니다. 이번 포스트에서 우리는 아래의 질문에 답하려고 합니다. export된 패키지에 대한 접근(읽기)을 제한 할 수 있습니까? 다른 버전들의 Module을 modulepath에 적용 할 수 있습니까? Jigsaw에서 기존 모듈화되지 않은 레거시 코드를 어떻게 사용 할 수 있습니까? 내 자신만의 Java Runtime 이미지를 어떻게 작성 할 수 있습니까? 우리는 첫번째 파트의 예제를 기본으로 삼아 계속해서 진행할 예정입니다. 코드는 여기에서 사용할 수 있습니다. 특정 모듈에 대한 접근(읽기) 제한첫번째 파트에서 Jigsaw가 Java 접근성(accessiblity)을 어떻게 확장 시킬수 있는지 얘기 했습니다. 첫번째 파트에서 언급된 정교하지 않은 접근성 레벨 중 하나는 “특정 모듈에만 Public“ 입니다. 이 경우 우리는 export된 패키지를 읽을 수 있는 모듈을 제한 할 수 있습니다. 따라서 de.codecentric.zipvalidator의 개발자가 de.codecentric.nastymodule을 개발한 팀을 싫어 한다면 module-info.java를 다음과 같이 변경할 수 있습니다. 1234module de.codecentric.zipvalidator&#123; exports de.codecentric.zipvalidator.api to de.codecentric.addresschecker;&#125; 이렇게 하면 de.codecentric.addresschecker만 zipvalidator API를 액세스 할 수 있습니다. 하지만 접근 제한은 패키지 수준에서 이뤄지기 때문에 일부 패키지의 액세스를 완벽하게 제한 할 수 있지만, 제한 하지 않는 다른 패키지는 모든 권한을 허용합니다. 이것이 Qualified export 입니다. de.codecentric.nastymodule이 de.codecentric.zipvalidator.api의 모든 타입에 액세스 하려고 하면 아래와 같이 컴파일 오류가 발생합니다. 123./de.cc.nastymodule/de/cc/nastymodule/internal/AddressCheckerImpl.java:4: error: ZipCodeValidatorFactory is not visible because package de.cc.zipvalidator.api is not visible zipvalidator는 실제 nastymodule에 보여지는 package(visible package)를 따로 export할 수 있기 때문에 module-info.java는 아무런 문제가 없습니다. 그리고 Qualified export는 application을 외부 client와 공유하지 않고 내부적으로 모듈화하려는 경우에 사용할 수 있습니다. 모듈 버전 충돌일반적인 버전 충돌 시나리오 중 하나는 추이 종속성 (transitive dependencies)을 통해 동일한 애플리케이션에서 서로 다른 버전의 라이브러리를 갖게되어 결국 모듈이 modulepath에 두번 있게 되는 상황입니다. 아래의 두가지 시나리오를 생각해 보겠습니다. 동일한 이름을 사용하는 모듈이 다른 폴더 또는 다른 modular jar에 있고 컴파일 타임에 사용하는 경우. 모듈의 버전별로 서로 다른 이름을 가지게 하는 경우. zipvalidator를 복사하여 첫번째 시나리오에 따라 컴파일 해봅시다.복사한 애플리케이션은 아래와 같은 구조를 가집니다. 123456789101112131415161718192021222324252627282930313233two-modules-multiple-versions├── de.codecentric.addresschecker│ ├── de│ │ └── codecentric│ │ └── addresschecker│ │ ├── api│ │ │ ├── AddressChecker.java│ │ │ └── Run.java│ │ └── internal│ │ └── AddressCheckerImpl.java│ └── module-info.java├── de.codecentric.zipvalidator.v1│ ├── de│ │ └── codecentric│ │ └── zipvalidator│ │ ├── api│ │ │ ├── ZipCodeValidator.java│ │ │ └── ZipCodeValidatorFactory.java│ │ ├── internal│ │ │ └── ZipCodeValidatorImpl.java│ │ └── model│ └── module-info.java├── de.codecentric.zipvalidator.v2│ ├── de│ │ └── codecentric│ │ └── zipvalidator│ │ ├── api│ │ │ ├── ZipCodeValidator.java│ │ │ └── ZipCodeValidatorFactory.java│ │ ├── internal│ │ │ └── ZipCodeValidatorImpl.java│ │ └── model│ └── module-info.java 중복된 모듈을 다른 폴더에 넣었습니다. 하지만 모듈 이름을 바꾸지는 않았습니다. 그럼 컴파일 할때 Jigsaw가 어떤 메시지를 보여줄까요? 12./de.codecentric.zipvalidator.v2/module-info.java:1: error: duplicate module: de.codecentric.zipvalidator 좋습니다. 결과를 확인 했습니다. Jigsaw는 컴파일 할때 modulepath에 있는 두 모듈이 같은 이름을 가지면 컴파일 할때 에러를 발생 시킵니다. 두번째 경우는 어떨까요?Directory 구조는 그대로 둔 상태에서 두개의 zipvalidator를 서로 다른 이름 (de.codecentric.zipvalidator.v{1|2})으로 변경하고, addresschecker에서 아래의 코드와 같이 두개의 모듈을 모두 읽도록 합니다. 12345module de.codecentric.addresschecker&#123; exports de.codecentric.addresschecker.api; requires de.codecentric.zipvalidator.v1; requires de.codecentric.zipvalidator.v2;&#125; 이건 확실히 컴파일이 될까요? 동일한 패키지를 내보내는 두 개의 모듈을 읽을 수 있을까요? 네. 확실히 가능합니다. 컴파일러는 이상황을 인정(허용)하지만 아래와 같이 경고를 보냅니다. 12./de.cc.zipvalidator.v1/de/codecentric/zipvalidator/api/ZipCodeValidator.java:1: warning: package exists in another module: de.codecentric.zipvalidator.v2 Jigsaw는 이런 상황을 좋아하지 않지만, 만약 개발자가 위의 메시지를 봤음에도 불구하고 애플리케이션을 실행시키면 Runtime에 아래와 같은 메시지를 보냅니다. 123java.lang.module.ResolutionException: Modules de.codecentric.zipvalidator.v2 and de.codecentric.zipvalidator.v1 export package de.codecentric.zipvalidator.api to module de.codecentric.addresschecker 개인적으로 이런 방식은 직관적이지 않기 때문에 컴파일시 오류가 더 좋을 수도 있다고 생각합니다. 필자는 메일 링리스트로 이러한 선택의 동기에 대해 질문했지만 글을 쓸 때 까지 아직 답변을 받지 못했습니다. Automatic module과 Unnamed module지금까지 우리는 모두 모듈로 구성된 환경에서 작업해 왔습니다. 그러나 모듈화되지 않은 Jar 파일을 사용해야하는 경우는 어떨까요? 이제 우리는 Automatic module과 Unnamed module을 이용해서 작업해 보도록 하겠습니다. Automatic moduleAutomatic module부터 시작해보도록 하겠습니다. Automatic module은 modulepath에 있는 jar 파일입니다. 일단 modulepath에 jar를 추가할려면 다음 세 가지 질문에 답을 해야합니다. Q: 이름은 어떻게 되나요? (name) A: jar 파일의 이름입니다. 만약 guava.jar를 modulepath에 추가한다면 guava라는 Automatic module이 생깁니다. 이것은 또한 guava-18.0이 유효한 Java 식별자가 아니기 때문에 Maven 저장소에서 바로 Jar을 사용할 수 없다는 것을 의미합니다. Q: 어떤것을 제공하게 되나요? (export) A: automatic module은 모든 패키지를 export 합니다. 그렇기 때문에 모든 public type은 Automatic module을 이용하는 모든 모듈에서 사용할 수 있습니다. Q: 어떤것이 필요하나요? (require) A: Automatic module은 사용 가능한 다른 모든 모듈 (다음에서 설명할 Unnamed module 포함 해서)을 액세스 할수 있습니다. 이것은 매우 중요한 내용입니다.! 어느 곳에서도 따로 지정할 필요없이 암묵적(imply)으로 Automatic module에서는 다른 모듈이 export한 모든 타입에 액세스 할 수 있습니다. 예를 들어 보겠습니다. 우리의 zipvalidator에서 com.google.common.base.Strings를 사용하기 시작했습니다. 이 액세스를 허용하려면 아래의 예제와 같이 Guava의 Automatic module에 대한 읽기 접점(read edge)을 정의해야합니다. 12345module de.codecentric.zipvalidator&#123; exports de.codecentric.zipvalidator.api; requires public de.codecentric.zipvalidator.model; requires guava; &#125; 컴파일을 하려면 guava.jar을 아래와 같이 modulepath에 추가해야 합니다. (./jars 에 있다고 가정합니다.)1javac -d . -modulepath ../jars -modulesourcepath . $(find . -name &quot;*.java&quot;) 이 예제는 잘 컴파일 되고 실행이 됩니다. (기록을 위해 남깁니다. 이 예제를 잘 동작 하기까지 쉽지 않았습니다. Jigsaw 빌드 86을 사용하면 몇 가지 문제가 발생합니다. jdk.management.resource라는 모듈에 대한 종속성에 문제가 있다고 나왔기 때문입니다. mailing list에 질문을 남겼고 내용은 여기에서 확인 하실수 있습니다.기본적인 해결책은 초기 버전을 사용하지 않고 직접 JDK를 빌드해서 사용하는 것이었습니다. 위의 메일 스레드에서 볼 수 있듯이 OSX Mavericks에서 더 많은 문제가 있었고, makefile을 변경해서 정상 작동하도록 했습니다.하지만 여러분은 이후 Release 버전에 따라 다를수 있습니다.) Jigsaw로 전환할때 가장 유요한 도구를 소개하도록 하겠습니다.모듈화되지 않은 코드를 살펴보고 종속성에 대해 알려주는 jdeps라는 도구가 있습니다. guava.jar를 살펴보도록 하겠습니다. 1jdeps -s ../jars/guava.jar 아래는 위 명령어를 실행했을 때의 결과입니다. 123guava.jar -&gt; java.baseguava.jar -&gt; java.loggingguava.jar -&gt; not found 이 결과는 Automatic guava 모듈은 java.base, java.logging이 필요하고… “찾을수 없다”고?.이건 무었이죠? jdeps에 -s 옵션을 추가하여 모듈 레벨에서 패키지 레벨 관점으로 이동해서 살펴보도록 하겠습니다. (guava에는 많은 패키지가 있지만 짧게 표시합니다.) 1234com.google.common.xml (guava.jar) -&gt; com.google.common.escape guava.jar -&gt; java.lang -&gt; javax.annotation not found 위 내용을 보면 com.google.common.xml 패키지는 모듈 내부에 있는 com.google.common.escape, 이미 잘 알려진 java.lang, 그리고 여기서 찾을 수 없는 javax.annotation 패키지에 종속되어 있음을 알수 있습니다. 또한 이것은 javax.annotation이 포함되어 있는(JSR-305 타입이 같이 있는) jar가 필요하다는 것을 말해줍니다. (이 예제에서는 jar파일을 추가하는 작업을 수행하지 않습니다. 예제에서 이 패키지가 필요하지 않으며 컴파일러도 런타임에도 사용하지 않습니다..) Unnamed module그렇다면 Unnamed module은 무엇일까요? 역시 아래의 세 가지 질문에 다시 답해보겠습니다. Q: 이름은 어떻게 되나요? (name) A: 아직 추측하지 못했나요? Unnamed module에는 이름이 없습니다. Q: 어떤것을 제공하게 되나요? (export) A: Unnamed module 은 자신의 모든 패키지를 다른 모듈로 export 합니다. 그렇다고 다른 모듈에서 읽을 수있는 것은 아닙니다. 이름이 없으므로 require 할 수 없습니다! requires unnamed;는 쓸수 없습니다. Q: 어떤것이 필요하나요? (require) A: Unnamed module은 사용 가능한 다른 모든 모듈을 읽습니다. 그럼 여러분의 모듈 중 하나에서 Unnamed module을 읽을 수 없다면 다른 중요한 점은 무었일까요? 이것에 대한 대답하기 위해 우리는 옛 친구를 (classpath) 만나봐야 합니다. classpath (modulepath 대신)에서 읽은 모든 타입은 Unnamed module로 자동 배치됩니다. 또는 다르게 설명하면 Unnamed module의 모든 타입은 classpath를 통해 로드됩니다.Unnamed module은 다른 모든 모듈을 읽을 수 있으므로 classpath에 로드된 모든 exported된 타입을 읽을수 있습니다. Java9는 classpath와 modulepath를 단독으로 사용하거나 하위 호환성을 위해 혼합하여 사용할 수 있도록 지원합니다. 몇가지 예제를 살펴보도록 하겠습니다. 우리는 여전히 잘 작동하는 zipvalidator 모듈을 가지고 있고, addresschecker는 여전히 모듈화된 상태가 아니며 module-info.java가 없다고 가정해 보겠습니다.아래는 우리 소스의 구조입니다. 1234567891011121314151617181920212223one-module-with-unnamed-ok/├── classpath│ └── de.codecentric.legacy.addresschecker│ └── de│ └── codecentric│ └── legacy│ └── addresschecker│ ├── api│ │ ├── AddressChecker.java│ │ └── Run.java│ └── internal│ └── AddressCheckerImpl.java├── modulepath│ └── de.codecentric.zipvalidator│ ├── de│ │ └── codecentric│ │ └── zipvalidator│ │ ├── api│ │ │ ├── ZipCodeValidator.java│ │ │ └── ZipCodeValidatorFactory.java│ │ └── internal│ │ └── ZipCodeValidatorImpl.java│ └── module-info.java 위 소스의 구조에는 레거시 코드가 포함된 zipvalidator에 액세스하려는 classpath 폴더와 zipvalidator 모듈이 포함된 modulepath라는 폴더가 있습니다. 일반적인 방법으로 우리의 모듈은 컴파일 할수 있습니다. 그리고 레거시 코드를 컴파일하려면 modular 코드에 대한 정보를 제공해야 합니다. 이러한 정보는 아래의 예제와 같이 classpath에 포함하면 됩니다. 12javac -d classpath/de.codecentric.legacy.addresschecker -classpath modulepath/de.codecentric.zipvalidator/ $(find classpath -name &quot;*.java&quot;) 이런 방식은 평소대로 잘 작동합니다. 런타임에는 아래의 두가지 옵션을 사용할 수 있습니다. 모듈을 classpath에 추가 하는 방법 classpath와 modulepath를 혼합하는 방법 첫 번째 옵션을 사용하면 모듈 시스템을 사용하지 않는다는 것을 의미합니다. 모든 타입은 자유롭게 서로 액세스 할 수있는 Unnamed module로 처리 됩니다. 12java -cp modulepath/de.cc.zipvalidator/:classpath/de.cc.legacy.addresschecker/ de.codecentric.legacy.addresschecker.api.Run 76185 위와 같이 할 경우 현재 사용중인 Java 응용 프로그램과 정확히 동일하게 작동합니다. classpath와 modulepath를 섞어서 사용하면 다음과 같이됩니다.123java -modulepath modulepath -addmods de.codecentric.zipvalidator -classpath classpath/de.codecentric.legacy.addresschecker/ de.codecentric.legacy.addresschecker.api.Run -classpath 및 -modulepath 옵션을 모두 사용합니다. 새로운 추가 기능은 -addmods 옵션입니다. classpath와 modulepath를 혼합하여 사용 할 때 modulepath 폴더에있는 모든 모듈을 액세스 할 수있는 것은 아니며, 어떤 모듈을 사용할지 구체적으로 명시해야합니다. 이 접근법은 잘 작동하지만 주의 할 점이 있습니다! “Unnamed module이 요구하는 것(require)”에 대한 대답은 “다른 모든 모듈”입니다. modulepath를 통해 zipvalidator 모듈을 사용할때는 zipvalidator 모듈의 exported된 패키지 만 사용할 수 있습니다. 그러지 않을 경우 런타임시 IllegalAccessError가 발생합니다. 그렇기 때문에 이러한 경우 모듈 시스템의 규칙을 준수해야 합니다. jlink를 이용한 runtime image모듈에 대한 예제는 이걸로 끝입니다. 하지만 우리가 관심을 가질 또 다른 새로운 도구가 있습니다. jlink는 여러분 만의 자체 JVM 배포판을 만들수 있는 Java9 의 유틸리티입니다. 멋진 점은 새로 모듈화 된 JDK 특성으로 인해 이 배포판에 포함 할 모듈만을 선택할 수 있다는 것입니다. 예제를 한번 보겠습니다. 우리의 addresschecker가 포함된 런타임 이미지를 만들고자 한다면 다음 명령어를 실행하면 됩니다. 12jlink --modulepath $JAVA9_BIN/../../images/jmods/:two-modules-ok/ --addmods de.codecentric.addresschecker --output linkedjdk 여러분은 아래의 세 가지만을 지정하면 됩니다. module path (여러분의 모듈이 포함되고, Java의 standard 모듈이 포함되어 있는 JDK의 jmods 폴더) 여러분의 배포판에 포함되길 원하는 모듈 배포판이 저장될 폴더 위의 명령어는 아래와 같은 폴더를 생성합니다.1234567891011121314151617181920212223242526272829303132333435363738linkedjdk/├── bin│ ├── java│ └── keytool├── conf│ ├── net.properties│ └── security│ ├── java.policy│ └── java.security└── lib ├── classlist ├── jli │ └── libjli.dylib ├── jspawnhelper ├── jvm.cfg ├── libjava.dylib ├── libjimage.dylib ├── libjsig.diz ├── libjsig.dylib ├── libnet.dylib ├── libnio.dylib ├── libosxsecurity.dylib ├── libverify.dylib ├── libzip.dylib ├── modules │ └── bootmodules.jimage ├── security │ ├── US_export_policy.jar │ ├── blacklisted.certs │ ├── cacerts │ └── local_policy.jar ├── server │ ├── Xusage.txt │ ├── libjsig.diz │ ├── libjsig.dylib │ ├── libjvm.diz │ └── libjvm.dylib └── tzdb.dat 이것이 끝입니다. OSX Mavericks의 경우 약 47MB정도 크기입니다. 또한 압축 기능을 사용하거나, 프로덕션 시스템에서 필요하지 않은 일부 디버깅 기능을 제거 할 수 있습니다. 지금까지 작업한 예제의 가장 작은 배포판은 다음 명령을 사용하여 만들었습니다. 123jlink --modulepath $JAVA9_BIN/../../images/jmods/:two-modules-ok/bin --addmods de.codecentric.addresschecker --output linkedjdk --exclude-files *.diz --compress-resources on --strip-java-debug on --compress-resources-level 2 이 방식은 배포판을 약 18MB로 줄여줘 즐겁게 합니다. 아마도 Linux에서는 13MB까지 줄일수 있을 것입니다. 1/bin/java --listmods 위 명령어를 실행하면 배포판에 포함된 모듈을 보여줍니다. 123de.codecentric.addresscheckerde.codecentric.zipvalidatorjava.base@9.0 따라서 위의 모듈중 하나 또는 모든 모듈에 의존성이 있는 모든 응용프로그램은 이 JVM에서 실행 할 수 있습니다. 하지만 저는 이 시나리오를 이용해서 main class를 실행할 수 없었습니다. 다른 방법을 사용해야 했습니다.예리한 눈을 가진 분은 jlink의 두번째 예제에서 첫번째 예제와 다른 modulepath를 지정한것을 발견했을 것입니다. 두 번째 예제에서 bin 폴더까지 경로를 지정했습니다. 이 폴더는 modular jar들을 포함하고, addresschecker jar는 Manifest에 메인 클래스 정보를 포함합니다. jlink는 이 정보를 사용하여 JVM bin 폴더에 추가 내용을 포함합니다. 1234567linkedjdk/├── bin│ ├── de.codecentric.addresschecker│ ├── java│ └── keytool... 이러한 방법을 이용하여 우리의 애플리케이션을 직접 호출 할 수 있습니다. 1./linkedjdk/bin/de.codecentric.addresschecker 76185 실행 결과176185 is a valid zip code 결론이것으로 Jigsaw 소개를 마칩니다. 우리는 Jigsaw 및 Java 9로 할 수있는 것과 할 수없는 것을 보여주는 몇 가지 예를 살펴 보았습니다. Jigsaw는 쉽게 이해 및 적용할 수 있었던 Lambda 또는 try-with-resources와 다르게 다소 혼란스러운 변화일 수 있습니다. Maven 또는 Gradle과 같은 빌드 도구 부터 IDE까지 전체 툴 체인이 모듈 시스템을 적용해야 합니다. JavaOne에서 Gradle Inc.의 Hans Dockter는 Java9 이하 버전에서 모듈러 코드를 작성하는 방법을 보여주는 세션을 진행했습니다. Gradle은 컴파일 타임에 검사를 수행하고 모듈 무결성을 위반하면 실패합니다. 이 (실험적) 기능은 최근 출시 된 Gradle 2.9에 포함되었습니다. 관련 문서 Java 9 와 Project Jigsaw 소개 1","categories":[{"name":"Java","slug":"Java","permalink":"http://infoscis.github.io/categories/Java/"},{"name":"Java9","slug":"Java/Java9","permalink":"http://infoscis.github.io/categories/Java/Java9/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://infoscis.github.io/tags/Java/"},{"name":"Java9","slug":"Java9","permalink":"http://infoscis.github.io/tags/Java9/"},{"name":"JDK9","slug":"JDK9","permalink":"http://infoscis.github.io/tags/JDK9/"},{"name":"Jigsaw","slug":"Jigsaw","permalink":"http://infoscis.github.io/tags/Jigsaw/"}]},{"title":"Java 9 와 Project Jigsaw 소개 1","slug":"First-steps-with-java9-and-jigsaw-part-1","date":"2017-03-23T15:43:19.000Z","updated":"2018-01-27T14:37:43.146Z","comments":true,"path":"2017/03/24/First-steps-with-java9-and-jigsaw-part-1/","link":"","permalink":"http://infoscis.github.io/2017/03/24/First-steps-with-java9-and-jigsaw-part-1/","excerpt":"","text":"의역, 오역, 직역이 있을 수 있음을 알려드립니다.이 포스트는 원저자의 동의를 얻어 한글로 번역한 내용입니다. This post is a translation of this original article [https://blog.codecentric.de/en/2015/11/first-steps-with-java9-jigsaw-part-1] by Florian Troßbach from codecentricAuthor: Florian Troßbach 참고 자료http://openjdk.java.net/projects/jigsaw/spec/sotms/http://openjdk.java.net/projects/jigsaw/http://openjdk.java.net/projects/jdk9/http://greatkim91.tistory.com/197Modularity in Java 9JDK 9 Early Access with Project JigsawJEP JDK9 Schedule 2016/05/26 Feature Complete 2016/12/22 Feature Extension Complete 2017/01/05 Rampdown Start 2017/02/09 All Tests Run 2017/02/16 Zero Bug Bounce 2017/03/16 Rampdown Phase 2 2017/07/06 Final Release Candidate 2017/07/27 General Availability Module (Project Jigsaw)Java 플랫폼의 모듈화및 일반 library의 모듈화 시스템 Project Jigsaw는 첫 발표후 8년이 지난후에서야 Java9에 포함될 예정입니다.적용 대상 릴리스는 Java7, Java8, Java9로 수년에 걸쳐 변경 되었고 또한 적용 범위도 몇번이나 바뀌 었습니다.2015년 JavaOne keynote에서 대대적으로 다뤘고 또한 많은 세션에서 포커싱 했던 Project Jigsaw의 주요한 토픽들에 대해 어느정도 정리가 된듯 합니다. Project Jigsaw 란 무엇이며 우리가 어떻게 사용할 수 있을까요? 이 두개의 파트로 구성된 이 블로그 시리즈는 Module system에 대한 간단한 소개와 Project Jigsaw의 동작을 보여주기 위한 실제 예제 코드를 제공하는 것을 목표로합니다.첫번째 부분에서는 Module system이 무엇인지, JDK가 어떻게 모듈화 되었는지에 대해 조금 이야기하고 특정 상황에서 컴파일러와 런타임이 어떻게 작동하는지 설명합니다. Module 이란 뭘까요?Module을 설명하는건 간단합니다. module-info.java라는 파일에 아래의 세 가지 질문에 대한 답을 선언하는 소프트웨어적인 단위일 뿐입니다. 이름이 무엇인가? (name) 어떤것을 제공하는가? (export) 어떤것들이 필요한가 ? (require) Module 첫 번째 질문에 대한 대답은 간단합니다. (대부분의) 각 Module에는 이름이 있습니다. 그리고 이름은 충돌을 피하기 위해 패키지 명명 규칙과 유사해야 합니다 (예: de.codecentric.mymodule)두번째 질문에 대한 답은, 우리의 Module은 다른 외부 모듈에서 사용할 수 있도록 공개 API로 간주되는 모든 패키지 목록을 제공합니다.또한 만약 어떤 클래스가 public이라 할지라도 export된 패키지에 없으면 모듈 외부의 어떤것도 이 클래스에 접근 할 수 없습니다.세번째 질문에 대한 답은, 우리의 모듈과 의존 관계가 있는 다른 모듈 목록(우리 모듈은 다른 모듈의 export된 모든 public type에 접근 가능합니다.)으로 얘기할 수 있습니다.Jigsaw팀은 이것을 다른 모듈 읽기(reading another module)라고 합니다. 이것은 매우 큰 변화입니다. Java 8까지 classpath에 있는 모든 public type은 다른 어떤 type에서도 접근이 가능 했습니다.Jigsaw를 사용하면 Java의 type들에 대한 기존의 접근 방법이 public private default protected 에서 외부에 모두 Public (public to everyone who reads this module (exports)) 특정 모듈에만 Public (public to some modules that read this module (exports to)) 모듈 내부만 Public (public to every other class within the module itself) private default protected 로 변한다는 것입니다. JDK 모듈화모듈의 종속성은 순환 종속성(상호 참조)을 금지하는 비순환 그래프를 형성해야합니다. 이러한 원칙을 유지하기 위해 Jigsaw 팀의 주요한 작업중 하나는 기존 Java Runtime의 순환 참조(상호 참조)및 직관적이지 않은 종속성을 모듈화하는 것이었습니다. 그들은 아래의 그래프와 같이 모듈을 새로 그렸습니다. 아직 개발이 완료된 상황이 아니기 때문에 계속 바뀔수 있습니다. 그래프 하단에 java.base가 있습니다. 외부 참조가 없는 (inbound 만 있음)유일한 모듈입니다.여러분이 생성하는 모든 모듈이 (Java의 모든 클래스가) java.lang.Object를 암시적으로 상속 하는 것과 유사하게 모듈내부의 선언 여부에 관계없이 java.base를 참조합니다. java.base는 java.lang, java.util, java.math 등과 같은 패키지를 export합니다. JDK의 모듈화는 사용하려는 Java Runtime의 모듈을 따로 지정할 수 있음을 의미합니다.이제는 java.desktop 또는 java.corba를 사용하지 않는 경우, Swing 또는 Corba 모듈이 포함된 환경에서 애플리케이션을 실행할 필요가 없습니다.(애플리케이션에서 사용하는 모듈만 모아 Runtime 이미지를 만들수 있습니다.) 이제 체험 해봅시다. 아래의 모든 예제들은 JDK9가 필요합니다.JDK 9 Early Access with Project Jigsaw에서 다운받아 실행 가능합니다.JDK9의 설치는 기존 개발환경에 영향을 줄수 있기 때문에 신중히 설치하세요. 컴파일, 패키징 및 예제 실행을 위한 셸 스크립트를 비롯하여 다음에 나오는 모든 코드는 여기에서 확인할 수 있습니다. 우리의 기본적인 Use case는 매우 간단합니다.우편번호 유효성 검사를 수행하는 de.codecentric.zipvalidator라는 모듈이 있습니다. 이 zipvalidator 모듈은 de.codecentric.addresschecker 모듈이 사용합니다. (예제에서 zipvalidator 모듈이 우편 번호보다 더 많은 것을 검사 할 수 있지만 그렇게 하지 않습니다.) zipvalidator는 다음 module-info.java에 다음과 같이 선언됩니다. 123module de.codecentric.zipvalidator&#123; exports de.codecentric.zipvalidator.api; &#125; 이 모듈은 de.codecentric.zipvalidator.api 패키지를 export하고 다른 모듈은 사용하지 않습니다 (java.base 제외). 그리고 이 모듈은 addresschecker에 의해 사용됩니다. 1234module de.codecentric.addresschecker&#123; exports de.codecentric.addresschecker.api; requires de.codecentric.zipvalidator;&#125; 전체 파일 시스템 구조는 다음과 같습니다.12345678910111213141516171819202122two-modules-ok/├── de.codecentric.addresschecker│ ├── de│ │ └── codecentric│ │ └── addresschecker│ │ ├── api│ │ │ ├── AddressChecker.java│ │ │ └── Run.java│ │ └── internal│ │ └── AddressCheckerImpl.java│ └── module-info.java├── de.codecentric.zipvalidator│ ├── de│ │ └── codecentric│ │ └── zipvalidator│ │ ├── api│ │ │ ├── ZipCodeValidator.java│ │ │ └── ZipCodeValidatorFactory.java│ │ ├── internal│ │ │ └── ZipCodeValidatorImpl.java│ │ └── model│ └── module-info.java 기존 패키지의 관례에 따라 모듈도 모듈과 동일한 이름의 폴더에 위치 합니다.우리의 첫번째 예제는 잘 동작합니다.(AddressCheckerImpl 클래스는 de.codecentric.zipvalidator에서 export된 패키지 ZipCodeValidator 및 ZipCodeValidatorFactory에만 액세스 할 수 있습니다.) 123456public class AddressCheckerImpl implements AddressChecker &#123; @Override public boolean checkZipCode(String zipCode) &#123; return ZipCodeValidatorFactory.getInstance().zipCodeIsValid(zipCode); &#125;&#125; 이제 javac를 이용하여 컴파일 하고 bytecode를 생성해 봅시다.zipvalidator를 컴파일 하려면 일반적으로 아래의 예제와 같이 실행을 하지만, addresschecker가 zipvalidator를 사용하려면 우리가 먼저 해야할 일이 있습니다. 12javac -d de.codecentric.zipvalidator \\$(find de.codecentric.zipvalidator -name &quot;*.java&quot;) 보는 바와 같이 매우 익숙한 명령어입니다. zipvalidator는 어떤 커스텀 모듈에도 의존하지 않기 때문에 다른 모듈에 대해 언급할 필요는 아직 없습니다.find 명렁어는 폴더 안에 있는 .java 파일들을 리스팅하도록 합니다.하지만 컴파일 할 때 javac 명령어에 모듈 구조에 대해 어떻게 설명할까요?이를 위해 Jigsaw는 -modulepath 또는 -mp 옵션을 적용했습니다. addresschecker를 컴파일하기 위해 다음과 같이 수정하여 사용합니다.12javac -modulepath . -d de.codecentric.addresschecker \\$(find de.codecentric.addresschecker -name &quot;*.java&quot;) classpath 옵션과 유사하게 -modulepath를 이용하여 javac가 기존 컴파일된 모듈을 어디에서 찾을수 있는지 알려 줄 수 있습니다.(위의 예제의 경우 .입니다.)여러개의 모듈을 각각 컴파일하는건 번거럽기 때문에, 아래와 같이 -modulesourcepath 옵션을 이용하여 한꺼번에 컴파일 할 수 있습니다. 1javac -d . -modulesourcepath . $(find . -name &quot;*.java&quot;) 위 예제는 . 하위의 모든 서브 디렉토리의 모듈을 검색하고 모든 Java 파일을 컴파일합니다.모든 컴파일이 완료되면 이제 실행을 해볼 수 있습니다. 1java -mp . -m de.codecentric.addresschecker/de.codecentric.addresschecker.api.Run 76185 위 예제와 같이 java명령어를 실행하면서 Main 클래스 및 매개 변수도 지정 할 수있고, 또한 JVM이 어디에서 컴파일 된 모듈을 찾아야 하는지도 지정할 수 있습니다.위 예제의 실행 결과는 아래와 같이 나옵니다. 176185 is a valid zip code Modular Jars기존 Java 프로그램에서 jar파일을 library로 매우 많이 사용하고 있습니다.Jigsaw에서는 modular jar라는 개념을 도입했습니다. modular jar는 일반 jar와 매우 유사하지만 컴파일 된 module-info.class을 포함 하고 있습니다.그리고 특정 JVM 버전용으로 컴파일 된 경우 이 jar는 하위 버전과 호환됩니다.module-info.java는 유효한 타입 이름이 아니기 때문에 컴파일 된 module-info.class는 이전 JVM에서 무시됩니다. zipvalidator 용 jar파일을 만들기 위해 아래와 같이 실행하면 됩니다. 12jar --create --file bin/zipvalidator.jar \\--module-version=1.0 -C de.codecentric.zipvalidator . 위 예제에서 결과 파일, 버전(런타임에 Jigsaw에서 여러버전의 Module을 사용한다는 지시는 표현 되어 있지 않지만), 모듈을 패키징 합니다. zipvalidator에는 Main 클래스가 있으므로 다음과 같이 지정할 수도 있습니다. 123jar --create --file=bin/addresschecker.jar --module-version=1.0 \\--main-class=de.codecentric.addresschecker.api.Run \\-C de.codecentric.addresschecker . Main 클래스는 Jigsaw 팀에서 처음 계획 한대로 module-info.java에 설정되지 않고 평소대로 Manifest에 작성되었습니다. 다음 명령어로 실행해 볼수 있습니다. 1java -mp bin -m de.codecentric.addresschecker 76185 이전에 실행한 결과와 같습니다.위 예제에서 jar 파일이 생성된 bin 폴더를 modulepath에 다시 설정합니다.addresschecker.jar의 Manifest에는 이 정보가 이미 포함되어 있으므로 Main 클래스를 지정할 필요가 없습니다. 단지 -m 옵션을 이용하여 모듈 이름을 제공하면 충분합니다. Module 사용시 유의할 점지금까지의 예제는 모두 잘 만들어지고 동작하는 코드들이었습니다. 이제 우리는 정상적이지 않는 경우에 Jigsaw가 컴파일과 런타임에서 어떻게 동작하는지 살펴 보기 위해 Module을 조금 수정해 보도록 하겠습니다. 1.5.1 Export하지 않은 타입 사용이번 예제에서 사용해서는 안되는 다른 모듈을 액세스 할때 어떤 일이 발생하는지 확인해 보겠습니다.AddressCheckerImpl에서 ZipCodeValidatorFactory를 이용하는 부분을 다음과 같이 변경합니다. 1234567public class AddressCheckerImpl implements AddressChecker &#123; @Override public boolean checkZipCode(String zipCode) &#123; //return ZipCodeValidatorFactory.getInstance().zipCodeIsValid(zipCode); return new ZipCodeValidatorImpl().zipCodeIsValid(zipCode); &#125;&#125; 위 예제를 컴파일하면 아래와 같은 결과가 나옵니다. 12error: ZipCodeValidatorImpl is not visible because package de.codecentric.zipvalidator.internal is not visible 따라서 직접 export하지 않은 타입을 사용하는 것은 컴파일 할 때 에러가 발생합니다.하지만 만약 아래와 같이 reflection을 이용하도록 코드를 수정하면 어떻게 될까요? 1234567ClassLoader classLoader = AddressCheckerImpl.class.getClassLoader();try &#123; Class aClass = classLoader.loadClass(\"de.[..].internal.ZipCodeValidatorImpl\"); return ((ZipCodeValidator)aClass.newInstance()).zipCodeIsValid(zipCode);&#125; catch (Exception e) &#123; throw new RuntimeException(e);&#125; 위의 코드는 정상적으로 컴파일되고 실행할 수 있습니다.그럼 실행해 볼까요?. 하지만 Jigsaw는 쉽게 속지 않습니다. 1234567java.lang.IllegalAccessException:class de.codecentric.addresschecker.internal.AddressCheckerImpl (in module de.codecentric.addresschecker) cannot access class [..].internal.ZipCodeValidatorImpl (in module de.codecentric.zipvalidator) because modulede.codecentric.zipvalidator does not export packagede.codecentric.zipvalidator.internal to modulede.codecentric.addresschecker Jigsaw는 컴파일시 체크 뿐만 아니라 런타임시에도 체크가 포함되어 있습니다!. 그래서 우리가 잘못한 것을 매우 분명하게 알아 냅니다. 순환 참조 (Circular dependencies)다음의 경우를 가정해 봅시다.개발하는 도중에 어느 순간 zipvalidator가 사용하고자 하는 API 클래스를 addresschecker 모듈이 포함하고 있음을 깨닫게 되었습니다.하지만 귀찮거나 다른 이유로 해당 클래스를 다른 모듈로 리팩토링하는 대신 아래의 코드처럼 addresschecker에 그냥 의존성을 선언할 수 있습니다. 1234module de.codecentric.zipvalidator&#123; requires de.codecentric.addresschecker; exports de.codecentric.zipvalidator.api;&#125; 그렇지만 Jigsaw에서 순환 참조는 허용되지 않기 때문에 컴파일러는 아래와 같은 에러 메시지를 보여줍니다. 12./de.codecentric.zipvalidator/module-info.java:2: error: cyclic dependence involving de.codecentric.addresschecker 우리는 이러한 문제들을 컴파일 타임에 바로 알수 있게 됩니다. 묵시적인 접근(Implied readability)좀 더 많은 기능을 제공하기 위해 우리는 리턴 타입으로 boolean을 사용하는 대신 유효성 검사 결과를 위한 일종의 모델을 포함하는 새로운 모듈 de.codecentric.zipvalidator.model을 도입하여 zipvalidator를 확장했습니다. 새로운 파일 구조는 다음과 같습니다. 1234567891011121314151617181920212223242526272829three-modules-ok/├── de.codecentric.addresschecker│ ├── de│ │ └── codecentric│ │ └── addresschecker│ │ ├── api│ │ │ ├── AddressChecker.java│ │ │ └── Run.java│ │ └── internal│ │ └── AddressCheckerImpl.java│ └── module-info.java├── de.codecentric.zipvalidator│ ├── de│ │ └── codecentric│ │ └── zipvalidator│ │ ├── api│ │ │ ├── ZipCodeValidator.java│ │ │ └── ZipCodeValidatorFactory.java│ │ └── internal│ │ └── ZipCodeValidatorImpl.java│ └── module-info.java├── de.codecentric.zipvalidator.model│ ├── de│ │ └── codecentric│ │ └── zipvalidator│ │ └── model│ │ └── api│ │ └── ZipCodeValidationResult.java│ └── module-info.java ZipCodeValidationResult는 “too short”, “too long” 등과 같은 인스턴스가 있는 간단한 enum 타입입니다.module-info.java는 아래와 같이 수정되었습니다. 1234module de.codecentric.zipvalidator&#123; exports de.codecentric.zipvalidator.api; requires de.codecentric.zipvalidator.model;&#125; 그리고 ZipCodeValidator의 구현체 (ZipCodeValidatorImpl.java)는 다음과 같습니다. 123456789101112@Overridepublic ZipCodeValidationResult zipCodeIsValid(String zipCode) &#123; if (zipCode == null) &#123; return ZipCodeValidationResult.ZIP_CODE_NULL; &#125; else if (zipCode.length() &lt; 5) &#123; return ZipCodeValidationResult.ZIP_CODE_TOO_SHORT; &#125; else if (zipCode.length() &gt; 5) &#123; return ZipCodeValidationResult.ZIP_CODE_TOO_LONG; &#125; else &#123; return ZipCodeValidationResult.OK; &#125;&#125; addresschecker 모듈이 ZipCodeValidationResult를 리턴 타입으로 사용하도록 수정되었기 때문에 컴파일이 잘 되어야 합니다.그럴까요? 아래는 컴파일 결과입니다. 123./de.codecentric.addresschecker/de/[..]/internal/AddressCheckerImpl.java:5: error: ZipCodeValidationResult is not visible because packagede.codecentric.zipvalidator.model.api is not visible addresschecker의 컴파일에 에러가 발생합니다. zipvalidator는 zipvalidator.model에서 export한 public API타입을 사용합니다.하지만 addresschecker은 module-info.java에서 requires를 하지 않았기 때문에 zipvalidator.model 모듈을 액세스 할 수 없습니다. 이 문제를 해결하기 위한 두가지 방법이 있습니다.확실한 방법은 addresschecker에서 zipvalidator.model에 대한 read edge를 추가하는 것입니다.그러나 이것은 그리 좋은 방법이 아닙니다. 왜 addresschecker가 zipvalidator를 사용하기 위해 zipvalidator.model에 대한 dependency를 추가해야 할까요?그리고 zipvalidator를 사용하는 모든 곳에서 zipvalidator에서 참조하는 모든 모듈에 액세스 할 수 있어야 할까요? 하지만 그렇게 해야만하고 그렇게 할 수 있습니다. Implied readability에 오신 것을 환영합니다.zipvalidator의 requires definition에 public 키워드를 추가하여 zipvalidator의 모든 클라이언트 모듈에 또 다른 모듈을 읽을 필요가 있음을 알립니다. 아래 코드는 zipvalidator의 업데이트 된 module-info.java입니다. 1234module de.codecentric.zipvalidator&#123; exports de.codecentric.zipvalidator.api; requires public de.codecentric.zipvalidator.model;&#125; public 키워드는 zipvalidator 모듈을 사용하는 모든 모듈에게 zipvalidator.model모듈을 읽을 필요가 있다고 알려줍니다.이것은 classpath를 사용하던 익숙한 방식으로 부터 변화입니다. 더이상 Maven POM에 의존 해서는 안됩니다.그렇기 때문에 public API의 일부인 경우 모든 client가 여러분 모듈의 dependency를 사용할 수 있도록 하려면 명시적으로 지정해야 합니다. 이것은 매우 좋은 모델입니다.만약 의존성이 있는 모듈을 내부에서만 사용하는 경우 client를 귀찮게 하지 않아도 됩니다.그리고 모듈을 대외적으로 사용한다면 자신이 사용하는 모듈에 대해 자신의 클라이언트에 알려줘야 합니다. 관련 문서 Java 9 와 Project Jigsaw 소개 2","categories":[{"name":"Java","slug":"Java","permalink":"http://infoscis.github.io/categories/Java/"},{"name":"Java9","slug":"Java/Java9","permalink":"http://infoscis.github.io/categories/Java/Java9/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://infoscis.github.io/tags/Java/"},{"name":"Java9","slug":"Java9","permalink":"http://infoscis.github.io/tags/Java9/"},{"name":"JDK9","slug":"JDK9","permalink":"http://infoscis.github.io/tags/JDK9/"},{"name":"Jigsaw","slug":"Jigsaw","permalink":"http://infoscis.github.io/tags/Jigsaw/"}]},{"title":"JVM에서 JavaScript 프로그램 하기(Nashorn에 대한 소개)","slug":"Riding-the-Nashorn","date":"2017-03-23T14:57:25.000Z","updated":"2018-01-27T14:52:35.932Z","comments":true,"path":"2017/03/23/Riding-the-Nashorn/","link":"","permalink":"http://infoscis.github.io/2017/03/23/Riding-the-Nashorn/","excerpt":"","text":"의역, 오역, 직역이 있을 수 있음을 알려드립니다.이 포스트는 원저자의 동의를 얻어 한글로 번역한 내용입니다. This post is a translation of this original article Riding the Nashorn: Programming JavaScript on the JVM by Niko Köbler from http://www.n-k.deOriginal article: Riding the Nashorn: Programming JavaScript on the JVM Author: Niko KöblerAuthor Email: niko@n-k.deAuthor Blog: http://www.n-k.deAuthor Twitter: @dasniko Nashorn은 Java8 버전 부터 Java Virtual Machine의 공식 JavaScript 엔진입니다.ECMAScript 5.1 사양에 따라 구현되었으며 Google V8 (Node.js의 스크립트 엔진)과 경쟁합니다.Nashorn은 런타임 동안 JavaScript를 Java 바이트 코드로 컴파일하기 때문에 Java와 JavaScript의 사이의 높은 상호 운용성을 제공합니다. 이 글은 Nashorn에서 가장 많이 사용 되는 Option, Function, Feature와 그리고 Use case에 대해 살펴 보려고합니다.이 튜토리얼을 읽은 후에는 일반 Java 프로그램에서 Nashorn을 이용하여 JavaScript 동적 스크립팅 기능을 사용할 수 있을 것으로 기대합니다. Nashorn을 공부하기 위한 또 다른 좋은 방법은 Official Project Nashorn 웹 사이트이며, 공식 웹사이트에는 메일 링리스트, 블로그 및 wiki 페이지들이 있습니다. 바로 확인해 보세요. JDK 8의 Nashorn은 위에 언급 한대로 ECMAScript 5.1 사양을 구현했습니다.Nashorn의 전략은 ECMAScript 사양을 따르는 것입니다. 그렇기 때문에 Nashorn의 주요 후속 버전에서는 ECMAScript 2015 spec을 구현할 예정입니다. 1. Nashorn의 Command Line Interface (CLI)Nashorn은 jjs라는 명령행 클라이언트(CLI)를 제공합니다. 이 jjs는 $JAVA_HOME/bin에 위치해 있지만, 바로가기/링크/Path등의 설정이 Java 8 설치 기능에 포함되어 있지 않습니다. 따라서 jjs로 작업하기를 원한다면 아래와 같이 jjs 링크를 설정해야 합니다. 1234$ cd /usr/bin$ ln -s $JAVA_HOME/bin/jjs jjs$ jjsjjs&gt; print(&apos;Hello World&apos;); 환경변수의 PATH에 $JAVA_HOME/bin을 추가하면 따로 설정할 필요가 없습니다. 이제 jjs 쉘에서 직접 JavaScript 코드를 실행할 수 있습니다.123jjs&gt; var x = 10;jjs&gt; print(x);10 그리고 jjs를 이용하여 파일로 저장되어 있는 JavaScript를 로드하고 실행할 수 있습니다. test.js123var x = 10;var y = 20;print(x + y); 12$ jjs test.js30 jjs 종료jjs 클라이언트는 아래와 같은 함수를 호출하여 종료할 수 있습니다. 12345jjs&gt; exit() // 일반적인 종료jjs&gt; exit(1) // 종료 코드를 포함한 종료jjs&gt; quit() // 일반적인 종료jjs&gt; quit(1) // 종료 코드를 포함한 종료 도움말 / 옵션-help 옵션을 사용하면 jjs의 모든 옵션이 나열됩니다. 1$ jjs -help 1.1. Scripting 모드Nashorn은 ECMAScript 5.1 사양 외에도 자체 구문및 확장 API를 구현했습니다. (다음 장 참조).이러한 확장 기능의 대부분은 스크립팅 모드에서만 사용할 수 있습니다.스크립팅 모드는 cli의 -scripting 옵션을 사용하여 활성화 됩니다. 1$ jjs -scripting 스크립팅 모드에서 Nashorn은 Shell 스타일의 ‘#’을 이용한 한 줄 전체 주석을 사용할 수 있습니다. test.js1234# style line comment -scripting mode# prints helloprint('hello'); 1.2 ShebangShebang은 Unix 계열 shell script에서 script 해석 인터프리터를 명시한 것을 말합니다.대부분의 Unix 계열 shell script의 첫번째 라인에 아래와 같은 부분이 있는데 이게 Shebang입니다. 1234#!/usr/bin/perl#!/bin/sh#!/usr/bin/php#!/usr/bin/ruby Nashorn은 Shebang 스크립팅을 지원합니다.따라서 아래와 같이 기존 방식처럼 JavaScript 파일을 호출하는 대신 test.js1print('hello'); 1$ jjs test.js 첫 줄에 Shebang과 함께 다음과 같은 JavaScript 파일을 작성할 수 있습니다.12#!/usr/bin/jjsprint('hello'); 다른 shell 스크립트와 마찬가지로 실행 파일로 만들고 명령 행에서 실행할 수 있습니다. 12$ chmod 755 test.js$ ./test.js 이 장의 시작 부분에서 언급했듯이 jjs에 대한 링크가 있어야합니다.Shebang Nashorn 스크립트를 실행하면 스크립팅 모드가 자동으로 활성화됩니다. 2. Java에서 Nashorn JavaScript 엔진 사용Nashorn 엔진은 JSR-223(Scripting for the Java Platform)의 자바 스크립트 구현이며 javax.script API의 구현체 입니다.따라서 Java에서 JavaScript 코드를 사용하기 위해서는 Nashorn javax.script.ScriptEngine을 생성 해야 합니다. 12ScriptEngine engine = new ScriptEngineManager().getEngineByName(\"nashorn\"); // --- (1)engine.eval(\"print('Hello World');\"); (1) 여기에서 사용할 수있는 Nashorn 엔진 이름은 “nashorn”, “javascript”및 “js”입니다. 위에서 볼 수 있듯이 JavaScript 코드는 엔진 객체의 eval() 메서드에 문자열로 전달하여 직접 실행할 수 있습니다.또는 파일을 가리키는 FileReader 객체를 전달하여 .js 파일을 구문 분석(및 실행)을 할 수 있습니다. 12ScriptEngine engine = new ScriptEngineManager().getEngineByName(\"nashorn\");engine.eval(new FileReader(\"test.js\")); 2.1. Java에서 JavaScript 함수 호출Java 프로그램 내부에서 단일 JavaScript 구문 또는 JavaScript 파일을 실행하거나 JavaScript 함수를 호출할 수도 있습니다.또한 Java 객체를 JavaScript 함수의 arguments로 전달하고, JavaScript 함수에서 호출한 Java 메서드로 데이터를 반환할 수 있습니다. example.js1234var sayHello = function(name) &#123; print('Hello, ' + name + '!'); return 'hello from javascript';&#125;; 위와 같이 작성된 example.js에 정의된 sayHello 함수를 호출하려면,먼저 아래의 코드에서 보는 바와 같이 engine 객체를 NashornScriptEngine에서 구현된 Invocable Interface로 캐스팅해야합니다.Invocable Interface는 invokeFunktion() 메서드를 제공하는데, 이 메서드는 입력값으로 받은 JavaScript 함수이름과 arguments를 이용해 Javascript를 실행할수 있습니다. 12345678910111213ScriptEngine engine = new ScriptEngineManager().getEngineByName(\"nashorn\");engine.eval(new FileReader(\"example.js\"));// cast the script engine to an invocable instanceInvocable invocable = (Invocable) engine;Object result = invocable.invokeFunction(\"sayHello\", \"John Doe\");System.out.println(result);System.out.println(result.getClass());// Hello, John Doe!// hello from javascript// class java.lang.String 위에 기술한 코드는 콘솔에 세 줄을 출력합니다.JavaScript의 sayHello 함수의 print()는 System.out에 pipe되어 출력하고, Java 코드의 두개 System.out.println() 메소드에서 sayHello 함수의 리턴값과 리턴값의 Class이름을 출력합니다. 2.2. Javascript에서 Java method 호출JavaScript 코드에서 Java 메소드를 호출하거나 실행하는 반대의 경우도 간단합니다.Java의 두 종류의 메소드를 가정해 보겠습니다. MyJavaClass.java12345678910111213package my.package;public class MyJavaClass &#123; public static String sayHello(String name) &#123; return String.format(\"Hello %s from Java!\", name); &#125; public int add(int a, int b) &#123; return a + b; &#125;&#125; Java 클래스는 Java.type API 확장을 통해 JavaScript에서 참조할 수 있습니다.이는 Java의 import 문과 유사합니다. Java 클래스를 참조한 후에 sayhello() 메서드와 같은 static method는 바로 호출하여 결과를 System.out에 출력할 수 있습니다. 또한 add()와 같은 일반 메서드들은 class의 인스턴스를 생성하여 호출할 수 있습니다. 12345678910111213var MyJavaClass = Java.type('my.package.MyJavaClass');// call the static methodvar greetingResult = MyJavaClass.sayHello('John Doe');print(greetingResult);// create a new intance of MyJavaClassvar myClass = new MyJavaClass();var calcResult = myClass.add(1, 2);print(calcResult);// Hello John Doe from Java!// 3 2.2.1. Nashorn의 type 변환아래의 간단한 예제를 통해 JavaScript에서 Java 메서드를 호출할 때 Nashorn이 Java와 JavaScript 간의 형식 변환을 처리하는 방법을 확인할 수 있습니다. 123public static void printType(Object object) &#123; System.out.println(object.getClass());&#125; 123456789101112131415161718192021222324252627MyJavaClass.printType('Hello');// class java.lang.StringMyJavaClass.printType(123);// class java.lang.IntegerMyJavaClass.printType(12.34);// class java.lang.DoubleMyJavaClass.printType(true);// class java.lang.BooleanMyJavaClass.printType(new Number(123));// class jdk.nashorn.internal.objects.NativeNumber// class jdk.nashorn.api.scripting.ScriptObjectMirrorMyJavaClass.printType(new Date());// class jdk.nashorn.internal.objects.NativeDate// class jdk.nashorn.api.scripting.ScriptObjectMirrorMyJavaClass.printType(new RegExp());// class jdk.nashorn.internal.objects.NativeRegExp// class jdk.nashorn.api.scripting.ScriptObjectMirrorMyJavaClass.printType(&#123;foo: 'bar'&#125;);// class jdk.nashorn.internal.scripts.J04// class jdk.nashorn.api.scripting.ScriptObjectMirror Primitive JavaScript type은 적절한 Java 래퍼 클래스로 변환됩니다. Native JavaScript 객체는 ScriptObjectMirror 내부의 각각 어댑터 클래스로 표현됩니다. jdk.nashorn.internal의 클래스는 추후 변경 될 수 있으므로 클라이언트 코드에서 해당 클래스에 대해 프로그램을 작성하면 안됩니다. 2.3. ScriptObjectMirrorScriptObjectMirror는 jdk.nashorn.api의 일부이며 기본 Javascript 내부 클래스 대신 Java 클라이언트 코드에서 사용하기위한 것입니다. 이 미러 객체는 JavaScript의 기본 객체의 표현입니다. 또한 Java Map 인터페이스를 구현하였으며, 객체, 메서드 및 속성에 대한 액세스를 제공합니다. 위의 예제를 조금 바꿔 보겠습니다.123public static void printObjectMirror(ScriptObjectMirror mirror) &#123; System.out.println(mirror.getClassName() + \": \" + Arrays.toString(mirror.getOwnKeys(true)));&#125; 마지막 네개의 JavaScript 함수 호출 (number, date, regexp 및 object literal)을 사용하여이 메서드를 호출하면 다음과 같습니다. 1234567MyJavaClass.printObjectMirror(new Number(123));MyJavaClass.printObjectMirror(new Date());MyJavaClass.printObjectMirror(new RegExp());MyJavaClass.printObjectMirror(&#123; foo: 'bar', bar: 'foo'&#125;); 결과는 다음과 같습니다. 1234Number: []Date: []RegExp: [lastIndex, source, global, ignoreCase, multiline]Object: [foo, bar] 또한 Java에서 JavaScript 객체의 멤버 함수를 호출할 수 있습니다.firstName, lastName 속성과 getFullName() 함수를 가진 JavaScript Person 타입을 가정해 보겠습니다. 1234567function Person(firstName, lastName) &#123; this.firstName = firstName; this.lastName = lastName; this.getFullName = function() &#123; return this.firstName + ' ' + this.lastName; &#125;&#125; Javascript의 getFullName() 함수는 ScriptObjectMirror 클래스의 callMember() 메서드를 이용해 호출할수 있습니다. 123public static void getFullName(ScriptObjectMirror person) &#123; System.out.println(\"Full name is: \" + person.callMember(\"getFullName\"));&#125; person 객체를 Java 메서드에 전달하면 콘솔에 원하는 결과가 표시됩니다. 1234var person = new Person('John', 'Doe');MyJavaClass.getFullName(person);// Full name is: John Doe 2.4. Script engine 옵션nashorn.args system property을 사용하여 Nashorn 스크립트 엔진을 customize 할 수 있습니다. 예를 들어 아래와 같이 스트립팅 모드 사용옵션을 -Dnashorn.args = ...을 이용하여 지정할 수 있습니다. 1$ java -Dnashorn.args=-scripting MyJavaClass customize 옵션을 파라메터로 넘겨 Nashorn engine을 생성할 수도 있습니다. 이 경우 아래 예제와 같이 NashornScriptEngineFactory를 직접 인스턴스화 해야합니다. 12NashornScriptEngineFactory factory = new NashornScriptEngineFactory();ScriptEngine engine = factory.getScriptEngine(new String[] &#123; \"-scripting\" &#125;); jjs -help를 호출하여 사용 가능한 옵션을 확인할 수 있습니다. 2.5. Bindings / ContextScriptContext는 하나 이상의 jsr223 “scope”이 Binding 되어 포함되어 있습니다. 그리고 디폴트 scope으로 ENGINE_SCOPE와 GLOBAL_SCOPE의 두 가지가 있습니다. ENGINE_SCOPE GLOBAL_SCOPE Nashorn 엔진이 생성되고 default context를 생성합니다. 1ScriptContext defaultContext = engine.getContext(); default context의 ENGINE_SCOPE은 ECMAScript “global” object를 래핑한 인스턴스입니다. 이 object는 최상위 script의 “this”입니다. 따라서 이 scope 객체에서 “Object”, “Math”, “RegExp”, “undefined”와 같은 ECMAScript 최상위 객체를 액세스할 수 있습니다. 또한 GLOBAL_SCOPE은 같은 ScriptEngineManager로 작성된 모든 엔진 사이에 공유됩니다.context에 변수들을 저장할 수 있지만 scope은 선택 사항이며 기본값은 ENGINE_SCOPE입니다. 123456789ScriptContext context = engine.getContext();// stores an object under the key `myKey` in the (engine scoped) contextcontext.setAttribute(\"myKey\", object, ScriptContext.ENGINE_SCOPE);// retrieves the object with key `myKey` from (engine scoped) contextcontext.getAttribute(\"myKey\", ScriptContext.ENGINE_SCOPE);Bindings b = context.getBindings(ScriptContext.ENGINE_SCOPE);b.get(\"Object\"); // gets ECMAScript \"Object\" constructorb.get(\"undefined\"); // ECMAScript 'undefined' value Nashorn이 변수를 검색할 때 ENGINE_SCOPE에 없으면 GLOBAL_SCOPE Binding에서 검색합니다. ECMAScript의 “global“ property가(최상위 레벨의 “this”) GLOBAL_SCOPE가 아닌 ENGINE_SCOPE에 있어 혼란이 있을 수 있습니다. 더 많은 Bindings와 ScriptContext정보는 wiki를 참고하세요. 3. API and Language ExtensionsNashorn은 ECMAScript 표준 외에도 다양한 언어 및 API 확장 기능을 제공합니다. 대부분의 API 확장은 Rhino에 대한 호환성 때문에 발생합니다. Rhino는 mozilla에서 개발한 Java로 구현된 JavaScript engine이다.과거 Netscape에서 Java로 구현된 navigator를 구현하려는 시도를 한 적이 있는데, 이때 사용했던 JavaScript engine이 Rhino engine의 전신이된다.Javagator라고 불리던 이 프로젝트는 JavaScript를 Java byte code로 컴파일하여 실행하기 때문에 당시에 있던 다른 브라우저보다 빠른 성능을 낼 수 있을것으로 기대했지만, JVM 자체의 성능 이슈와 다른 여러가지 상황때문에 중간에 중단되었지만, 일부 회사들의 지원으로 JavaScript framework은 분리되어 Rhino가 되었다. Rhino의 가장 큰 특징은 내부적으로 Reflection을 이용하여 JavaScript 코드에서 Java class를 그대로 가져다 쓸 수 있다는 것이다.또한 Java구현체를 그대로 사용할 수 있기 때문에, JavaScript engine 중에서는 특이하게 multi thread support가 된다는 특징을 가진다. JVM이 꾸준히 성장하여 많은 성능 개선을 이루었지만, WebKit이 사용하는 JSC(JavaScript Core)나 Google이 개발한 v8 engine도 내부적으로 JavaScript를 compile하기 때문에 Rhino가 가지는 성능상의 이점은 없다. 사실상 v8이나 jsc보다 느리다. 성능상에 이점은 없지만, 반드시 Java를 사용해야 하거나 multi-core support가 필요한 일부 환경에서는 Rhino engine을 사용하는 경우가 있다. 하지만 이 중에 이름만 들어서 알만한 유명한 프로젝트는 없다.Rhino를 사용하는 가장 유명한 구현체는 RingoJS로 보인다.http://blog.seulgi.kim/2014/06/rhino-javascript-framework.html 제가 생각하기에 흥미롭고 유횽한 기능들 위주로 살펴 보도록 하겠습니다. 3.1. Print FunctionNashorn은 arguments를 문자열로 변환 한 후 표준 출력(stdout)으로 출력하는 기능을 제공합니다. 12print(\"Hello\", \"World\");// Hello World echo()함수는 print() 함수와 동일한 기능을 합니다.Nashorn에는 브라우저에서 주로 로깅에 사용하는 console object를 가지고 있지 않습니다. 3.2. Stdin에서 읽기stdin에서 읽으려는 경우 readLine() 함수를 사용할 수 있습니다. 1234jjs&gt; var name = readLine(\"What is your name? \")What is your name? Johnjjs&gt; print(\"Hello, $&#123;name&#125;!\")Hello, John! 3.3. Files에서 읽기stdin이 충분하지 않으면 readFully()를 사용하여 전체 파일 내용을 변수로 읽을 수 있습니다. 1var content = readFully('text.txt'); 3.4 문자열 Interpolation${expression} 구문을 사용하여 문자열 리터럴에 표현식을 지정할 수 있습니다. 문자열 값은 ${expression} 표현식의 이름을 해당 변수의 값으로 대체하여 계산됩니다. 1234var name = \"World\";var str = \"Hello, $&#123;name&#125;!\";print(str);// Hello, World! 3.5 Back-quote 실행 표현식Nashorn은 back quote(역 따옴표) 문자열과 같은 유닉스 shell을 지원합니다. back quote로 묶인 문자열은 ‘exec’로 실행되고 리턴된 문자열을 프로그램에서 받을 수 있습니다. test.js1234567#!/usr/bin/jjsvar files = `ls -l`; // get file listing as a stringvar lines = files.split(\"\\n\");for (var l in lines) &#123; var line = lines[l]; print(line);&#125; 이방법은 ES6의 새로운 역 따옴표 문자열 템플릿과 함께 사용하지 마십시오. 위에서 언급 한 문자열 Interpolation과 유사합니다! 3.6. Java BeansNashorn을 사용하면 Java bean의 getter 및 setter로 작업하는 대신 Java bean에서 값을 가져 오거나 설정하는 데 간단히 속성 이름을 사용할 수 있습니다. 12345var Date = Java.type('java.util.Date');var date = new Date();date.year += 1900; // -&gt; no setter!print(date.year); // -&gt; no getter!// 2016 3.7. Function Literals간단한 한 줄 함수의 경우, 반드시 중괄호를 사용할 필요는 없습니다 (또한 return 키워드도 생략할 수도 있습니다). 12345function sqr(x) x * x;print(sqr(3)); // 9function add(a, b) a + b;print(add(1, 2)); // 3 3.8. Binding Properties두 개의 서로 다른 객체의 속성을 함께 바인딩할 수 있습니다. 12345678910#!/usr/bin/jjsvar o1 = &#123;&#125;;var o2 = &#123; foo: 'bar' &#125;;Object.bindProperties(o1, o2);print(o1.foo); // baro1.foo = 'John';print(o2.foo); // John 3.9. Trimming Stringstrim()뿐만 아니라 trimLeft(), trimRight()를 이용하여 문자열의 white space를 제거할 수 있습니다. 12345678#!/usr/bin/jjsvar bar = \" bar\";var foo = \"foo \";print (\"[\" + bar.trim() +\"]\"); // [bar]print (\"[\" + bar.trimLeft() + \"]\"); // [bar]print (\"[\" + foo.trimRight() + \"bar\" + \"]\"); // [foobar] 3.10. Whereis만약 프로그램중에 현재의 위치를 알아야 할 경우 아래와 같이 사용할 수 있습니다. 1print(__FILE__, __LINE__, __DIR__); 3.11. Import Scopes때로는 한 번에 많은 자바 패키지를 import 해야할 수도 있습니다. 그럴 경우 JavaImporter 클래스를 with 문과 함께 사용하여 import한 Java 패키지의 모든 클래스 파일을 with 문의 로컬 scope 내에서 액세스할 수 있습니다. 12345var imports = new JavaImporter(java.io, java.lang);with (imports) &#123; var file = new File(__FILE__); System.out.println(file.getAbsolutePath()); // /path/to/my/script.js&#125; 3.12. PackagesPacakges및 연관된 객체들이 script내에서 Java 패키지에 대한 액세스를 지원합니다. Packages 변수의 속성은 모두 Java, javax와 같은 최상위 Java 패키지입니다. 12345678var Vector = Packages.java.util.Vector;// but short-cuts defined for important package prefixes like// Packages.java, Packages.javax, Packages.com// Packages.edu, Packages.javafx, Packages.orgvar JFrame = javax.swing.JFrame; // javax == Packages.javaxvar List = java.util.List; // java == Packages.java jjs에서 다음을 테스트 해보세요 12345678910jjs&gt; Packages.java[JavaPackage java]jjs&gt; java[JavaPackage java]jjs&gt; java.util.Vector[JavaClass java.util.Vector]jjs&gt; javax[JavaPackage javax]jjs&gt; javax.swing.JFrame[JavaClass javax.swing.JFrame] 3.13. Typed ArraysNative JavaScript의 배열은 타입이 지정되지 않습니다. 하지만 Nashorn은 ECMAScript 2015 명세에 지정된 유형화된 배열을 구현합니다. 예를 들어 아래와 같이 int형 타입을 가진 배열을 만들수 있습니다. 123456789101112131415161718192021var IntArray = Java.type('int[]');var array = new IntArray(3);array[0] = 3;array[1] = 2;array[2] = 1;try &#123; array[3] = 0; // would be possible in pure JS&#125; catch (e) &#123; print(e.message); // Array index out of range: 3&#125;array[0] = '42';print(array[0]); // 42array[0] = 'some wrong type';print(array[0]); // 0array[0] = '3.14';print(array[0]); // 3 int[] 배열은, 실제의 Java int 배열과 같이 동작합니다. 또한 Nashorn은 정수가 아닌 값을 추가하려고 할 때 implicit 한 형변환을 수행합니다. 또한 가능한 경우 문자열은 자동으로 int로 변환됩니다. 3.14. Collections and For-Each자바 스크립트에서의 배열 처리는 때때로 짜증날때가 있습니다. 이제 Javascript의 배열의 사용 대신 모든 자바 컬렉션을 사용할 수 있습니다. 먼저 Java.type을 통해 Java 유형을 정의한 다음 필요에 따라 새 인스턴스를 작성하십시오. 1234567var ArrayList = Java.type('java.util.ArrayList');var list = new ArrayList();list.add('a');list.add('b');list.add('c');for each (var el in list) print(el); // a, b, c 컬렉션과 배열을 순회하는 Java의 foreach문처럼 Nashorn에는 for each문이 있습니다.다음은 HashMap을 사용하는 다른 컬렉션의 for each 예제입니다. 1234567var map = new java.util.HashMap();map.put('foo', 'red');map.put('bar', 'green');for each (var e in map.keySet()) print(e); // foo, barfor each (var e in map.values()) print(e); // red, green 3.15. Array 변환java.util, java.lang과 같은 일부 패키지는 Java.type 또는 JavaImporter를 사용하지 않고 직접 액세스할 수 있습니다. 1234var list = new java.util.ArrayList();list.add(\"s1\");list.add(\"s2\");list.add(\"s3\"); 아래 코드는 Java List를 Native JavaScript Array로 변환합니다. 123var jsArray = Java.from(list);print(jsArray); // s1,s2,s3print(Object.prototype.toString.call(jsArray)); // [object Array] 그리고 그 반대의 경우는 아래와 같은 코드를 사용할 수 있습니다. 1var javaArray = Java.to([3, 5, 7, 11], \"int[]\"); 3.16. Lambdas and StreamsJava 8의 Lambda와 Streams을 Nashorn에서도 사용할 수 있습니다. 그리고ECMAScript 5.1에는 Java 8 Lambda의 간단한 화살표 구문( -&gt; )이 없습니다. 하지만 Java 8 Lambda가 허용되는 곳에서는 함수 리터럴을 사용할 수 있습니다. 1234567891011121314151617181920var list2 = new java.util.ArrayList();list2.add(\"ddd2\");list2.add(\"aaa2\");list2.add(\"bbb1\");list2.add(\"aaa1\");list2.add(\"bbb3\");list2.add(\"ccc\");list2.add(\"bbb2\");list2.add(\"ddd1\");list2 .stream() .filter(function(el) &#123; return el.startsWith(\"aaa\"); &#125;) .sorted() .forEach(function(el) &#123; print(el); &#125;); // aaa1, aaa2 Java 8 Lambda 또는 SAM (single-abstract-method) 유형이 필요한 곳에서는 ECMAScript 함수를 인수로 전달할 수 있습니다! 3.16.1. 모든 람다식은 JavaScript Function 입니다.람다 형식의 인스턴스인 모든 Java 객체는 JavaScript Function처럼 취급 될 수 있습니다. 12345678910var JFunction = Java.type('java.util.function.Function')var obj = new JFunction() &#123; apply: function(x) &#123; print(x * x) &#125;&#125;print(typeof obj); // prints \"function\"// 'calls' lambda as though it is a functionobj(23); 3.17. Extending ClassesJava 타입은 Java.extend 함수를 사용하여 간단히 확장할 수 있습니다. 12345678910111213141516var Runnable = Java.type('java.lang.Runnable');var Printer = Java.extend(Runnable, &#123; run: function() &#123; print('printed from a separate thread'); &#125;&#125;);var Thread = Java.type('java.lang.Thread');new Thread(new Printer()).start();new Thread(function() &#123; print('printed from another thread');&#125;).start();// printed from a separate thread// printed from another thread 위 코드에서 보듯이 Nashorn에서는 멀티 스레드 코드도 가능합니다. 3.18. Calling SuperECMAScript에 Java의 super에 해당하는 키워드가 없기 때문에 JavaScript에서는 오버라이드된 멤버를 액세스하는 것은 어렵습니다. 하지만 Nashorn에서는 가능 합니다. 먼저 Java 코드에서 super class를 정의합니다. 123456class SuperRunner implements Runnable &#123; @Override public void run() &#123; System.out.println(\"super run\"); &#125;&#125; 다음으로 JavaScript로부터 SuperRunner를 오버라이드(override) 합니다.새로운 Runner 인스턴스를 생성할때 확장된 Nashorn 구문을 사용하는데 주의하세요.오버라이드 멤버 구문은 Java의 익명 객체를 이용하여 정의 합니다. 12345678910111213var SuperRunner = Java.type('my.package.SuperRunner');var Runner = Java.extend(SuperRunner);var runner = new Runner() &#123; run: function() &#123; Java.super(runner).run(); print('local run'); &#125;&#125;runner.run();// super run// local run Java.super 확장을 활용하여 재정의된 메소드 SuperRunner.run ()을 호출합니다. 3.19. Loading ScriptsJavaScript에서 추가 스크립트 파일을 실행 하는 것은 매우 쉽습니다. load 함수를 사용하여 로컬 또는 원격 스크립트를 로드할 수 있습니다. 아래의 예제는 moment.js와 Underscore.js를 로드해서 사용하는 예제입니다. 12345load('https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.11.1/moment.min.js');var now = new moment();print(now);// Thu Dec 31 2015 23:59:59 GMT+0100 1234567oad('http://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.6.0/underscore-min.js');var odds = _.filter([1, 2, 3, 4, 5, 6], function (num) &#123; return num % 2 == 1;&#125;);print(odds); // 1, 3, 5 외부 스크립트는 동일한 JavaScript context에서 evaluate 되므로 moment, Underscore를 직접 액세스할 수 있습니다. 3.19.1. Load in new Global Context외부 파일을 로드할 때 로드된 코드에 자신의 코드에 있는 동일한 변수 이름이 사용될 수 있습니다. 이를 방지하기 위해 파일을 새로운 global context으로 로드할 수 있습니다. 1loadWithNewGlobal('script.js'); 위와 같이 로드된 스크립트는 Nashorn glogal context (현재 engine context가 아님)에서만 사용할 수 있습니다. 3.20. Error ObjectNashorn은 ECMAScript의 표준 Error 객체에 몇 가지 흥미로운 속성을 추가 하여 확장했습니다.12345678910111213141516171819function func() &#123; throw new Error();&#125;function f() &#123; func();&#125;try &#123; f();&#125; catch (e) &#123; print(e.stack); print(e.lineNumber); print(e.columnNumber); print(e.fileName); // of course, also this is possible e.printStackTrace();&#125; 3.21. Scripting Mode Extension ObjectsNashorn에는 -scripting 모드로 실행 되었을때 사용할 수 있는 몇몇 global 객체가 정의되어 있습니다.대부분은 바로 알수 있는 부분이라 아래의 소스 코드를 참고하길 바랍니다. 3.21.1. $ARG12345$ jjs -scripting -- arg1 arg2 arg3jjs&gt; $ARGarg1,arg2,arg3jjs&gt; $ARG[1]arg2 arguments123456$ jjs -scripting -- arg1 arg2 arg3jjs&gt; argumentsarg1,arg2,arg3jjs&gt; arguments[1]arg2` 3.21.2. $ENV12345// print $JAVA_HOME and $PATH from the OS shellprint($ENV[\"JAVA_HOME\"])print($ENV[\"PATH\"])print($ENV.JAVA_HOME)print($ENV.PATH) 3.21.3. $EXECShell 명령어 수행을 위한 프로세스 실행 1234567jjs&gt; $EXEC(\"ls -l\")total 0drwxr-xr-x+ 1 johndoe staff 4096 Dec 31 12:34 dir-rwxrw-r-- 1 johndoe staff 168 Dec 31 13:37 file.txtjjs&gt; $EXEC(\"cat\", \"Send this to stdout\")Send this to stdout 3.21.4. $OUT$OUT 변수는 가장 최근에 $EXEC로 실행된 프로세스의 stdout 출력이 저장됩니다. 123456// use curl to download JSON weather data from the netvar str = `curl http://api.openweathermap.org/data/2.5/weather?q=Hamburg,de&amp;units=metric&amp;appid=44db6a862fba0b067b1930da0d769e98`;// parse JSON and print the current temperaturevar weather = JSON.parse($OUT);print(weather.main.temp); 3.21.5. $ERR$ERR 변수는 가장 최근에 $EXEC로 실행된 프로세스의 stderr 출력이 저장됩니다. 3.21.6. $EXIT$EXIT 변수는 $EXEC로 실행된 프로세스의 종료 코드가 저장됩니다. 3.21.7. $OPTIONS이 속성은 Nashorn CLI의 실행 옵션을 제공합니다. 123print(\"-scripting = \" + $OPTIONS._scripting); // -scripting = trueprint(\"--compile-only = \" + $OPTIONS._compile_only); // --compile-only = falseprint(\"-timezone = \" + $OPTIONS._timezone.ID); // -timezone = Europe/Berlin Nashorn이 구현한 다양한 언어 및 API 확장에 대한 설명은 Wiki 페이지에서 확인할 수 있습니다. 4. Working with Package Managers &amp; RepositoriesNashorn으로 작업할 때, 처음부터 모든 기능을 개발하고 싶지는 않을 것입니다. 다행이도 Maven의 의존성 라이브러리를 사용하는 것처럼 이미 필요한 기능을 제공하는 Nashorn 라이브러리를 사용할 수 있습니다. 게다가 Java, JavaScript와 완벽히 호환되는 다양한 Repository와 Package Manager를 선택할 수도 있습니다. 4.1. NPMNode Package Manager - https://npmjs.org npm은 Node.js의 Package Manager이고 개발자들이 JavaScript 애플리케이션에서 파일, 메타데이터, 의존성을 쉽게 관리하도록 만들어졌습니다. 2009년 오픈 소스 프로젝트로 시작된 npm은 개발자들이 인터넷을 통한 서비스로 오픈 소스 코드를 관리할 수 있도록 패키지 저장소 기능을 제공합니다. (https://nodejs.github.io/nodejs-ko/articles/2015/06/17/npm-is-massive/) NPM은 JavaScript의 server-side 프로그램인 Node.js 패키지 관리 프로그램입니다. NPM Repository는 오픈 소스코드의 공개 컬랙션입니다. 또한 NPM은 Command line 클라이언트 입니다. Nashorn 내에서 NPM 패키지를 사용할 수 있습니다!. 하지만 … 4.1.1. JVM-NPM대부분의 많은 JavaScript 패키지는 CommonJS의 require()문 (Java에서 import와 같은)을 사용합니다. 하지만 불행이도 Nashorn은 JavaScript 엔진일 뿐이고 Package Manager 및 dependency loading 매커니즘을 지원하지 않습니다. 하지만 다행이도 npm-jvm(JVM 용 NPM 호환 CommonJS 모듈 로더) 프로젝트가 있습니다. 이 모듈은 Nashorn script context에서 require() 함수를 사용할 수 있도록 합니다. Nashorn script context에서 CommonJS에 의존성이 있는 패키지를 사용하려 할 때 require() 함수를 사용하여 다른 모듈을 로드할 수 있습니다. UsageNashorn이 제공하는 global load() 함수를 사용하여 jvm-npm.js를 global execution context에 로드합니다. 그런 다음 require()를 사용하여 원하는 모듈을 로드할 수 있습니다. 12nashorn&gt; load('./jvm-npm.js');nashorn&gt; var x = require('some_module'); 또는 비슷한 역할을 하는 commonjs-modules-javax-script 프로젝트도 있습니다. 4.1.2. Polyfill.jsNPM에 등록된 많은 라이브러리는 Node.js 또는 브라우저 공통 API를 사용합니다. Nashorn은 Node.js도 브라우저도 아니기 때문에 라이브러리에서 사용하는 Node.js 또는 브라우저의 공통 API를 정의 하여야 합니다. 이러한 부분을 보통 polyfill이라 부르고 사용할 수없는 환경에서 필요한 기능을 제공하기 위해 사용합니다. nashorn-polyfill.js123456789var global = this; // ---(1)var window = this; // ---(2)var process = &#123;env:&#123;&#125;&#125;; // ---(3)var console = &#123;&#125;; // ---(4)console.debug = print;console.log = print;console.warn = print;console.error = print; (1) Node.js에 있는 global variable을 위해 제공 (global context)(2) 브라우저에 있는 window variable을 위해 제공 (global context)(3) 몇몇 라이브러리에서 사용하는 Node.js의 process.env variable을 위해 제공(4) Nashorn에는 console이 없기 때문에 가장 많이 사용되는 콘솔 출력 함수들을 print 함수에 할당합니다. 4.1.3. Native API accessNashorn은 Native API (C/C++)를 액세스할 수 없습니다. 그래서 Native API를 사용하는 NPM 패키지는 Nashorn에서 사용할 수 없습니다. 4.2. MavenJava 프로젝트 내에서 Nashorn을 사용할 때 대부분의 경우 Maven을 저장소 및 패키지 관리자로 사용합니다. 몇가지 plugin과 helper를 이용하면 문제 없이 사용할 수 있습니다. 4.2.1. Maven and NPM, Grunt, Gulp, etc.Node.js ecosystem, NPM 그리고 프론트 엔드 빌드 도구인 Grunt, Gulp, Webpack등과 같이 사용하고 싶다면 아래의 편리한 Maven plugin을 사용할 수 있습니다. https://github.com/eirslett/frontend-maven-plugin/ (이 plugin에 대한 자세한 설명과 문서는 Github 페이지를 참고하세요.) 4.2.2. WebJars가장 많이 사용되고 인기 있는 NPM 패키지는 WebJars에서 제공하고 있습니다. WebJars를 사용하면 NPM 패키지를 프로젝트에서 Maven dependency를 이용하여 사용할 수 있습니다. 아래는 Moment.js를 Maven에서 사용하는 예제입니다. 12345&lt;dependency&gt; &lt;groupId&gt;org.webjars.npm&lt;/groupId&gt; &lt;artifactId&gt;moment&lt;/artifactId&gt; &lt;version&gt;2.11.2&lt;/version&gt;&lt;/dependency&gt; 만약 사용할수 있는 NPM 패키지가 Webjar에 없다면 웹 페이지에 있는 자세히 설명된 문서를 이용하여 쉽게 추가할 수 있습니다. 4.2.3. NasvenNasven.js는 Maven을 이용하여 아티팩트의 dependency를 관리하는 JavaScript 애플리케이션(서버, 데스크탑 및 쉘 스크립트)의 런타임입니다. 개발자는 순수한 서버 측 응용 프로그램, 쉘 스크립트 또는 JavaFX 데스크탑 응용 프로그램을 만들 수 있으며 Maven dependency는 클래스 경로에 자동으로 다운로드되고 구성됩니다. Nasven = Nashorn + Maven. 1234567$ nasven package.jsonnashorn full version 1.8.0_72-b15[NASVEN] Building temporary Apache Maven project to find dependencies ...[NASVEN] Done![NASVEN] About to run your nasven.js application under /Users/Niko/nasven/nasven-samples/camel/index.js ...[NASVEN] Calling jjs for your application ... 예제 JAX-RS Apache Camel 5. Isomorphic JavaScript5.1 Isomorphic의 뜻, 그리고 무엇을 할 수 있고 왜 사용해야 하는가?Isomorphic은 그리스어의 “isos”에서 “equal”의 의미를 , “morph”는 “shape”의 의미가 유래 되었습니다. 그래서, 동일하거나 동등한 형태의 뜻을 나타냅니다. Isomorphism은 동일한 엔티티(1)에 대해 두개의 서로 다른 context(2) 에서 같은 결과(3)를 내야 한다고 설명합니다.(http://isomorphic.net/javascript) code client and server result, html, DOM, etc. 우리의 경우에는 “우리가 클라이언트와 서버에서 같은 JavaScript 코드를 사용한다면 우리는 같은 결과/html을 얻어야한다.”입니다. 5.1.1. Isomorphic codeIsomorphic 코드는 클라이언트와 서버 측에서 동일한 로직을 공유할 수 있으므로 DRY 원칙 (Don’t Repeat Yourself)을 활용한 코드 작성이 가능합니다. 애플리케이션 로직은 한번 개발되고 하나의 코드베이스에서만 유지 하면됩니다. 만약 오류가 발생하는 경우 코드의 수정은 한곳에서만 진행하면 됩니다. 그리고 Isomorphic 코드로 인해 개발자가 하나의 기술에만 집중할 수 있으므로 여러 프로그래밍 언어에 대한 전문가가 될 필요는 없습니다. Example 아래의 예제는 브라우저에서 사용하기 위해 JavaScript로 개발 한 패스워드 검증 코드입니다. 1234function isPasswordValid(password) &#123; var score = scorePasswordStrength(password); return score &gt;= 3;&#125; 위 코드는 잘 작동하지만 만약 사용자가 브라우저에서 JavaScript를 사용하지 못하도록하고, 잘못된 암호를 서버에 전달하는 경우를 대비해, 서버(Java)에서 사용되는 프로그래밍 언어로 동일한 로직을 다시 개발해야합니다.이것은 추가적인 노력이며, 구현할때 오류로 이어질 수 있고, 최근 변경된 로직에 대한 부분을 잊어 버리고 미구현할 수 있습니다.Java 코드에서 JavaScript 코드 로직을 다시 사용하지 않을 이유가 있을까요? 아래 예제가 그 해법을 제시합니다. 1234567public Boolean isPasswordValid(String password) &#123; try &#123; return (Boolean) nashorn.invokeFunction(\"isPasswordValid\", password); &#125; catch (ScriptException | NoSuchMethodException e) &#123; throw new RuntimeException(e); &#125;&#125; 5.1.2. SPAs현재 대부분의 SPA(Single Page Web Application)는 HTML 스켈레톤과 UI 렌더링, transition 관리, path routing, 네비게이션, 로직등을 하나 이상의 JavaScript 라이브러리에서 처리 합니다. index.html1234567&lt;html&gt;&lt;head&gt; &lt;title&gt;Awesome Website&lt;/title&gt; &lt;script src=\"./app-bundle.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 이러한 응용 프로그램은 대단히 훌륭하지만 몇 가지 단점이 있습니다. 단점 UX/Performance - 전체 스크립트 코드가 클라이언트(브라우저)에서 로드, 평가 및 실행되기 전까지 사용자는 아무 것도 볼 수 없습니다. 인터넷 연결 속도가 빠름에도 불구하고 Long wait time 사용자가 떠날 가능성이 있음 (3초 룰) 느린 인터넷 연결을 생각해 보십시오! Legacy Browser(아직 많이 사용하고 있습니다.)에서는 새로운 자바 스크립트를 실행시킬수 없습니다. SEO - 컨텐츠가 없기 때문에 검색엔진에서 여러분의 웹사이트를 인덱스할 수 없습니다. Google이 웹 사이트에서 JavaScript를 실행(evaluate)할 수 있다고 해도 여전히 오류가 발생하기 쉽습니다. 위와 같은 이유로 웹 페이지를 서버에 렌더링하는 것이 더 좋을수 있습니다. 장점 하지만 이건 어떨까요? UX - 멋진 화면 전환 효과 (다른 동종의 사이트들과 경쟁할 수 있어야 합니다.) Performance - 페이지의 일부분만 빠르게 렌더링 Performance - 전체 HTML 대신 필요한 데이터만 전송 이러한 장점들은 클라이언트에서 프로그램을 실행하고 페이지를 렌더링할 때만 얻을 수 있습니다! 해결방법 사용자가 처음 URL을 요청합니다. 서버가 해당 URL의 콘텐츠를 가져옵니다. 서버에서 콘텐츠를 응답 형태로 렌더링합니다. 사용자는 콘텐츠를 봅니다. 그 동안에 클라이언트가 초기화됩니다. 사용자가 다른 URL로 이동합니다. 클라이언트가 해당 URL의 콘텐츠를 가져옵니다. 클라이언트가 DOM에 내용을 렌더링합니다. 사용자가 앱 또는 앱 경로에 대한 초기 요청할 때 페이지를 서버에서 렌더링하여 클라이언트에게 전송합니다.그 순간부터 클라이언트는 콘텐트를 제어하고 콘텐트 렌더링을 계속할 수 있습니다.이렇게하면 사용자가 초기 서버 측 렌더링 페이지를 사용하는 동안 클라이언트를 초기화하는 시간이 줄어듭니다.그리고 검색 엔진에서 사이트의 인덱스를 생성하는 경우 이미 렌더링된 콘텐츠의 유효한 HTML을 서버에서 가져올수 있습니다.그리고 기존 브라우저는 클라이언트가 페이지를 렌더링할 수 없는 경우에도 사이트를 사용할 수 있습니다. 5.2. React.jsReact.js는 Facebook에서 개발 한 사용자 인터페이스를 구현한 JavaScript 라이브러리입니다. 앱을 빌드하기 위한 전체 스택 클라이언트 프레임 워크가 아닙니다. MVC 또는 MVVM에서 React.js는 V(iew) 부분을 컴포넌트로 만들기 위한 라이브러리입니다. React.js는 컴포넌트 기반 가상 DOM을 가지고 있습니다. 이 가상 DOM과 비교후 다른 부분을 적용하여 깜박임없이 페이지 전환 또는 콘텐츠 업데이트가 가능합니다. 또한 React는 템플릿의 서버 측 렌더링을 지원합니다. 5.2.1. FluxReact를 이용하여 full-stack 애플리케이션을 구현하는 방법중에 Flux라는 아키텍처 방식이 있습니다.이 아키텍처에는 직접 접근으로 변경할 수없는 Immutable Entity 및 collection이 있습니다. 응용 프로그램의 상태는 Store에 저장되고, 이 Store는 템플릿을 렌더링하기위한 데이터들이 저장됩니다. 또한 Store는 Action의 Event(데이터 포함)를 받은Dispatcher만 수정할 수 있습니다. Action만이 Store가 외부 세계와 소통할 수있는 유일한 방법입니다. 현재 가장 널리 사용되는 Flux 구현 라이브러리는 Redux가 있고 다른 많은 라이브러리도 있습니다. 5.2.2. JSXReact.js는 JavaScript의 새로은 변형인 JSX를 HTML 요소와 혼합하여 많이 사용합니다. 아마도 처음에는 조금 어색할수 있지만 더 많이 사용하면 편리하다는 것을 느끼게 됩니다. app.jsx12345678910class Book extends React.Component &#123; render() &#123; return ( &lt;div className=\"book\"&gt; &lt;h3&gt;&#123;this.props.author&#125;&lt;/h3&gt; &lt;div className=\"lead\"&gt;&#123;this.props.children.toString()&#125;&lt;/div&gt; &lt;/div&gt; ); &#125;&#125; (위의 코드를 볼때 몇몇분들은 JSP가 생각날 수도 있습니다….) JSX는 Babel.js를 사용하여 실행 가능한 JavaScript (ES5)로 변환 됩니다. (이전에는 Facebook의 라이브러리 인 JSXTransformer에서이 작업을 수행했지만 더 강력한 Babel로 바뀌었습니다.) app.js12345678910var Book = React.createClass(&#123;displayName: \"Book\", render: function () &#123; return ( React.createElement(\"div\", &#123;className: \"book\"&#125;, React.createElement(\"h3\", null, this.props.author), React.createElement(\"div\", &#123;className: \"lead\"&#125;, this.props.children.toString()) ) ); &#125;&#125;); 런타임시 위의 JavaScript 코드는 적절한 HTML로 렌더링됩니다. app.html1234&lt;div class=\"book\" data-reactid=\".1c3dv7jhtco.1.$0\"&gt; &lt;h3 data-reactid=\".1c3dv7jhtco.1.$0.0\"&gt;George Orwell&lt;/h3&gt; &lt;div class=\"lead\" data-reactid=\".1c3dv7jhtco.1.$0.1\"&gt;1984&lt;/div&gt;&lt;/div&gt; React는 데이터 변경시 data-reactid 속성을 통해 변경해야하는 (가상) DOM 부분을 찾을 수 있습니다. React.js, JSX 및 Flux에 대한 자세한 내용은 해당 웹 사이트를 참조하십시오! 5.3. Isomorphic App을 위한 Spring Boot MVC서버 측 렌더링을 위해 Spring (Boot) MVC 및 React.js를 사용하는 예제가 몇 가지 있습니다. sdeleuze/spring-react-isomorphic winterbe/spring-react-example Spring MVC로 Isomorphic 응용 프로그램을 만드는 데 관심이 있다면이 위의 링크들을 참조하십시오. 5.4. Isomorphic App을 위한 Java EE 8 MVC 1.0Java EE 8과 그 참조 구현인 Ozark에서 Action-based Web-Framework MVC 1.0을 새로 만들기 위해 React.js의 튜토리얼을 참고하여 ViewEngine 예제를 작성했습니다. dasniko/ozark-react dasniko/ozark-react-example 위의 두 저장소에서 가져온 아래 간단한 코드 조각은 JavaScript/Java EE 애플리케이션이 어떻게 Isomorphic으로 구현이 되는지 보여줍니다. React 기반 ViewEngine을 사용하여 응용 프로그램을 만들때 위에서 언급한 저장소의 원래 코드를 사용해야합니다. 원래 코드들은 아래의 단순화된 예제보다 훨씬 더 유연하고 강력합니다! ReactController는 새로운 @Controller 어노테이션을 사용한 표준 MVC 컨트롤러입니다. ReactController.java123456789101112131415161718@Controller // --- (1)@Path(\"/react\")public class ReactController &#123; @Inject private Models models; // --- (2) @Inject private BookService service; // --- (3) @GET public String index() throws Exception &#123; List&lt;Book&gt; books = service.getBooks(); models.put(\"data\", books); // --- (4) return \"react:react.jsp\"; // --- (5) &#125;&#125; MVC 컨트롤러 어노테이션 Map 형식의 MVC 내부 Model Entity 데이터를 조회하거나 저장하는 서비스 Book list를 가져와서 Java 오브젝트를 Model에 넣습니다. ReactViewEngine이 사용할 react: 접두어가 있는 템플릿의 Path를 반환합니다. 아래 예제가 React.js와 상호 작용하는 실제 ViewEngine 구현 클래스 입니다. ReactViewEngine.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class ReactViewEngine extends ServletViewEngine &#123; private static final String viewPrefix = \"react:\"; @Inject React react; // --- (1) ObjectMapper mapper = new ObjectMapper(); @Override public boolean supports(String view) &#123; // --- (2) return view.startsWith(viewPrefix); &#125; @Override public void processView(ViewEngineContext context) throws ViewEngineException &#123; // --- (3) // parse view and extract the actual template String template = context.getView().substring(viewPrefix.length()); // get \"data\" from model Models models = context.getModels(); Object data = models.get(\"data\"); // call js function on data to generate html String content = react.render(data); // and put results as string in model models.put(\"content\", content); try &#123; // additionally put the data as JSON also to the model // this overrides the List data stored previously under the same key models.put(\"data\", mapper.writeValueAsString(data)); &#125; catch (JsonProcessingException e) &#123; throw new ViewEngineException(e); &#125; // create a new context with the actual view and forward to ServletViewEngine ViewEngineContext ctx = new ViewEngineContextImpl(template, models, context.getRequest(), context.getResponse(), context.getUriInfo(), context.getResourceInfo(), context.getConfiguration()); try &#123; forwardRequest(ctx, \"*.jsp\", \"*.jspx\"); &#125; catch (ServletException | IOException e) &#123; throw new ViewEngineException(e); &#125; &#125;&#125; React 클래스는 React.js JavaScript 코드와 상호 작용합니다. (자세한 내용은 아래 클래스를 참조하십시오.) supports() 메서드는 이 ReactViewEngine 클래스가 컨트롤러의 리턴 문자열에 적합한 ViewEngine으로 사용되어도 되는지 여부를 판단 합니다. processView() 메서드는 실제로 View를 처리하기 위한 일을 합니다. 자세한 내용은 인라인 주석을 참조하십시오. 아래 React 클래스는 JavaScript React.js와 상호 작용하는 클래스입니다. React.java12345678910111213141516171819202122232425262728293031public class React &#123; private ThreadLocal&lt;ScriptEngine&gt; engineHolder = ThreadLocal.withInitial(() -&gt; &#123; // --- (1) ScriptEngine nashorn = new ScriptEngineManager().getEngineByName(\"nashorn\"); try &#123; nashorn.eval(read(\"/nashorn-polyfill.js\")); nashorn.eval(read(\"/META-INF/resources/webjars/react/0.14.2/react.min.js\")); nashorn.eval(read( \"/META-INF/resources/webjars/showdown/0.3.1/compressed/showdown.js\")); nashorn.eval(read(\"/js/bookBox.js\")); &#125; catch (ScriptException e) &#123; throw new RuntimeException(e); &#125; return nashorn; &#125;); public String render(Object object) &#123; // --- (2) try &#123; Object html = ((Invocable) engineHolder.get()).invokeFunction(\"renderServer\", object); return String.valueOf(html); &#125; catch (Exception e) &#123; throw new IllegalStateException(\"failed to render react component\", e); &#125; &#125; private Reader read(String path) &#123; // --- (3) return new InputStreamReader(getClass().getClassLoader().getResourceAsStream(path)); &#125;&#125; 필요한 JavaScript 라이브러리들과 함께 새로운 ThreadLocal&lt;ScriptEngine&gt;을 초기화 합니다. 왜냐하면 React.js는 Thread Safe하지 않기 때문에 각 요청에서 전용 ScriptEngine을 사용해야 합니다. JSX/JS 코드의 renderServer 함수를 호출하고 결과를 문자열로 반환합니다 (아래 코드 참조). 중복 코드 제거를 위한 메서드 아래 코드는 original JSX 코드입니다. (Nashorn에 로드하기 전에 JS로 렌더링 됨, Babel.js 라이브러리를 빌드 도중 또는 런타임에 Nashorn ScriptEngine에 로드할 수 있지만 로드 시간이 더 길어질 수 있음). bookBox.jsx 12345678910111213141516... // --- (1)var renderClient = function (books) &#123; // --- (2) var data = books || []; React.render( &lt;BookBox data=&#123;data&#125; url='books.json' pollInterval=&#123;5000&#125; /&gt;, // --- (4) document.getElementById(\"content\") );&#125;;var renderServer = function (books) &#123; // --- (3) var data = Java.from(books); return React.renderToString( &lt;BookBox data=&#123;data&#125; url='books.json' pollInterval=&#123;5000&#125; /&gt; // --- (4) );&#125;; 이전 코드 생략. 이 함수는 클라이언트에 의해 호출되며 응용 프로그램을 초기화하고 컨텐츠를 렌더링합니다. 이 함수는 서버 (위 React.java 참조)에 의해 호출되어 컨텐츠를 렌더링합니다. Component는 (1)에 있는 생략된 코드입니다. 실제 isomorphic 코드입니다. 추가 정보가 포함된 HTML skeleton이 서버에서 렌더링되고 클라이언트에 전송됩니다. react.jsp123456789101112131415161718192021222324&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;ReactJS Bookstore with Ozark&lt;/title&gt; &lt;script src=\"$&#123;mvc.contextPath&#125;/webjars/react/0.14.2/react.min.js\"&gt;&lt;/script&gt; //--- (1) &lt;script src=\"$&#123;mvc.contextPath&#125;/webjars/showdown/0.3.1/compressed/showdown.js\"&gt;&lt;/script&gt; &lt;script src=\"$&#123;mvc.contextPath&#125;/webjars/jquery/1.11.3/jquery.min.js\"&gt;&lt;/script&gt; &lt;link href=\"$&#123;mvc.contextPath&#125;/webjars/bootstrap/3.3.5/css/bootstrap.css\" rel=\"stylesheet\"&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"content\" class=\"container\"&gt;$&#123;content&#125;&lt;/div&gt; // --- (2) &lt;script type=\"text/javascript\" src=\"$&#123;mvc.contextPath&#125;/js/bookBox.js\"&gt;&lt;/script&gt; // --- (3) &lt;script type=\"text/javascript\"&gt; $(function () &#123; renderClient($&#123;data&#125;); // --- (4) &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; WebJars를 이용한 JavaScript 라이브러리 (Maven/Gradle 빌드 파일에서 dependency 설정) Client 또는 Server에서 렌더링된 내용을 넣을 div 실제 응용 프로그램 스크립트 (bookBox.jsx 참고) 응용 프로그램이 클라이언트 측에서 실행 또는 초기화 될 때 호출 되는 함수입니다 (bookBox.js 참고) ReactController에서 ReactViewEngine을 호출하지 않고 애플리케이션이 시작된 경우 (예를 들어 “react.jsp“만 반환하면 표준 JSP ViewEngine을 사용합니다.), 서버에서 수신 받은 초기 데이터를 보면 &lt;div id = &quot;content&quot;/&gt; 엘리먼트에는 눈으로 확인할 수 있는 HTML 코드가 포함되어 있지 않습니다. 하지만 renderClient()를 클라이언트에서 호출하기 때문에 브라우저에서 렌더링되고 컨텐츠가 표시됩니다. 프로그램에서 ReactViewEngine을 사용하면 서버에서 받은 초기 코드의 &lt;div id = &quot;content&quot;/&gt; 엘리먼트에는 렌더링된 컨텐츠가 표시 됩니다. 클라이언트의 renderClient() 함수도 실행이 되지만 (가상) DOM에는 변경 사항이 없으므로 페이지가 그대로 유지되고, DOM이 다시 렌더링되지 않아 깜박임 현상이 없어집니다. 6.JavaFX with JavaScripthttp://www.n-k.de/riding-the-nashorn/#_javafx_with_javascript JavaFx는 한국에서 별로 인기가 없어서 따로 번역을 하지 않았습니다.자세한 설명은 원문을 참고하세요. 7. Nashorn Script 테스트와 디버깅 하기7.1. TestingNashorn 스크립트의 테스트는 아직 사용해 보지 않아서 어려워 보일수 있지만 그렇지 않습니다. 7.1.1. Function(al) testing with JUnit모든 JavaScript 함수에는 반환 값이 있으므로 (모든 JavaScript 함수, 명시 적 반환 값이없는 함수조차도 undefined를 반환합니다) 이러한 값을 지정할 수 있습니다.Java 메서드를 개발하는 것처럼 JavaScript 파일을 빌드, 테스트 가능한 atomic 함수로 작업하면됩니다.그런 다음 테스트에서 JavaScript 함수를 호출하고 결과를 assert 선언할 수 있습니다. 다음 JavaScript 코드가 있다고 가정 해 보겠습니다. calculator.js1234567var add = function(a, b) &#123; return a + b;&#125;var square = function(a) &#123; return a * a;&#125; 이제 다음 표준 JUnit 테스트를 사용하여 함수를 테스트할 수 있습니다 CalculatorTest.java1234567891011121314151617181920212223public class CalculatorTest &#123; ScriptEngine nashorn; @Before public void setup() &#123; nashorn = new ScriptEngineManager().getEngineByName(\"nashorn\"); nashorn.eval(new InputStreamReader( getClass().getClassLoader().getResourceAsStream(\"/calculator.js\"))); &#125; @Test public void testAdd() throws Exception &#123; Object result = ((Invocable) nashorn).invokeFunction(\"add\", 1, 2); Assert.assertEquals(1, result); &#125; @Test public void testSquare() throws Exception &#123; Object result = ((Invocable) nashorn).invokeFunction(\"square\", 2); Assert.assertEquals(4, result); &#125;&#125; 7.1.2. Mocking JavaScript functions &amp; using SpockNashorn 스크립트를 테스트하는 훨씬 더 좋은 (더 강력한) 방법은 JUnit 대신 Spock을 사용하는 것입니다. Spock은 동적언어 Groovy 코드를 기반으로 작성되었습니다. 그렇기 때문에 Groovy로 만든 객체와 함수를 Nashorn과 테스트 하기 쉽습니다 Spock을 사용하면 직접 제어할 수 없거나 Nashorn에서 사용할 수없는 기능에 대해 mock function을 사용하기가 매우 쉽습니다. 이런 제어할수 없는 기능들 중에는 테스트 중에는 실행하고 싶지 않은 콜백 함수 (JavaScript에서 널리 사용됨), alert() 함수 등이 있을수 있습니다. Callback.groovy123456789101112131415161718192021222324252627282930313233343536373839404142class CallbackSpec &#123; @Shared ScriptEngine nashorn = new ScriptEngineManager().getEngineByName('nashorn'); def \"callback\"() &#123; // -- (1) given: nashorn.eval('function callMe(callback) &#123; return callback(\"\") + \" Doe\"; &#125;') when: def result = nashorn.invokeFunction('callMe', &#123; return 'John' &#125; as Function) then: result == 'John Doe' &#125; def \"mocked callback\"() &#123; // -- (2) given: nashorn.eval('function callMe(callback) &#123; return callback(\"\") + \" Doe\"; &#125;') def callback = Mock(Function) when: def result = nashorn.invokeFunction('callMe', callback) then: 1 * callback.apply('') &gt;&gt; 'John' result == 'John Doe' &#125; def \"alert\"() &#123; // -- (3) given: nashorn.eval('function alertMe() &#123; alert(\"Huh!\"); &#125;') def alert = Mock(Function) nashorn.put('alert', alert) when: nashorn.invokeFunction('alertMe') then: 1 * alert.apply('Huh!') &#125;&#125; 이 함수는 테스트 호출시 inject된 다른 콜백 함수 (java.util.function.Function 유형)를 가져옵니다. 이 함수에서 콜백 함수는 mock 함수로 대체 되고, mock 함수가 “John”값으로 한 번 호출된 이후에 테스트됩니다. Nashorn에는 사용할수 있는 alert() 함수가 없기 때문에 실제 함수가 호출되기 전에 Nashorn context에 추가해야합니다. Spock과 Nashorn의 더 많은 예제는 GitHub 저장소 dasniko/nashorn-spock-jasmine에서 찾을 수 있습니다. 7.2. DebuggingNashorn JavaScript의 디버깅은 다음과 같은 주요 IDE에서 지원됩니다. JetBrains IntelliJ IDEA (13.1 이상) https://blog.jetbrains.com/idea/2014/03/debugger-for-jdk8s-nashorn-javascript-in-intellij-idea-13-1/ Oracle Netbeans (version 8 이상) http://wiki.netbeans.org/NetBeans_80_NewAndNoteworthy#JavaScript_in_Nashorn https://blogs.oracle.com/geertjan/entry/youtube_debugger_for_jdk8_s https://blogs.oracle.com/sundararajan/entry/remote_debugging_of_nashorn_scripts Eclipse Nodeclipse로 가능 합니다. 참고 Riding the Nashorn: Programming JavaScript on the JVM Java 8 Nashorn Tutorial NPM is Massive Isomorphic JavaScript","categories":[{"name":"Java","slug":"Java","permalink":"http://infoscis.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://infoscis.github.io/tags/Java/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://infoscis.github.io/tags/JavaScript/"},{"name":"Nashorn","slug":"Nashorn","permalink":"http://infoscis.github.io/tags/Nashorn/"}]}]}