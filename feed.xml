<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Developer&#39;s Record</title>
  <subtitle>개발자의 기록 보관소</subtitle>
  <link href="/feed.xml" rel="self"/>
  
  <link href="http://infoscis.github.io/"/>
  <updated>2018-11-28T13:55:08.820Z</updated>
  <id>http://infoscis.github.io/</id>
  
  <author>
    <name>Jongcheol-Kim</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring Boot와 Kotlin으로 웹 애플리케이션 구축하기</title>
    <link href="http://infoscis.github.io/2018/08/30/spring-boot-kotlin/"/>
    <id>http://infoscis.github.io/2018/08/30/spring-boot-kotlin/</id>
    <published>2018-08-29T15:30:20.000Z</published>
    <updated>2018-11-28T13:55:08.820Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-Boot와-Kotlin으로-웹-애플리케이션-구축하기"><a href="#Spring-Boot와-Kotlin으로-웹-애플리케이션-구축하기" class="headerlink" title="Spring Boot와 Kotlin으로 웹 애플리케이션 구축하기"></a>Spring Boot와 Kotlin으로 웹 애플리케이션 구축하기</h1><p>이 튜토리얼은 <a href="https://projects.spring.io/spring-boot/" target="_blank" rel="external">Spring Boot</a>와 <a href="https://kotlinlang.org/" target="_blank" rel="external">Kotlin</a>을 결합하여 예제 블로그 애플리케이션을 효율적으로 빌드하는 방법을 설명합니다..</p>
<p>만약 Kotlin을 처음 시작한다면 <a href="https://kotlinlang.org/docs/reference/" target="_blank" rel="external">참고 문서</a>를 읽고 온라인 <a href="https://try.kotlinlang.org/" target="_blank" rel="external">Kotlin Koans 자습서</a>를 따라하며 언어를 배울 수 있습니다.</p>
<p>Spring Kotlin 지원은 <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/languages.html#kotlin" target="_blank" rel="external">Spring Framework</a> 및 <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-kotlin.html" target="_blank" rel="external">Spring Boot</a> 참고문서에 설명되어 있습니다. 도움이 필요하면 StackOverflow에서 <a href="https://stackoverflow.com/questions/tagged/kotlin+spring" target="_blank" rel="external">Spring 및 kotlin 태그로 검색하거나 질문</a>을 할 수 있고, <a href="http://slack.kotlinlang.org/" target="_blank" rel="external">Kotlin Slack</a>의 <code>#spring</code> 채널에서 토론하십시오.</p>
<h2 id="새-프로젝트-만들기"><a href="#새-프로젝트-만들기" class="headerlink" title="새 프로젝트 만들기"></a>새 프로젝트 만들기</h2><p>먼저 Spring Boot 애플리케이션을 만들어야하고, 이는 여러 가지 방법으로 수행 할 수 있습니다. 예를 들어, 우리는 Kotlin 생태계에서 가장 많이 사용하는 Gradle 빌드 시스템을 사용할 것이지만, 만약 원하는 경우 Maven도 자유롭게 사용할 수 있습니다.(예제 블로그 프로젝트의 일부로 Gradle 빌드와 동일한 Maven pom.xml을 <a href="https://github.com/spring-guides/tut-spring-boot-kotlin/blob/master/pom.xml" target="_blank" rel="external">사용할 수</a> 있습니다).</p>
<h3 id="Initializr-웹-사이트-사용"><a href="#Initializr-웹-사이트-사용" class="headerlink" title="Initializr 웹 사이트 사용"></a>Initializr 웹 사이트 사용</h3><p><a href="https://start.spring.io" target="_blank" rel="external">https://start.spring.io</a> 로 이동하여 Kotlin 언어를 선택합니다. 또는 Kotlin을 미리 선택하려면 직접 <a href="https://start.spring.io/#!language=kotlin" target="_blank" rel="external">https://start.spring.io/#!language=kotlin</a> 로 방문할 수 있습니다.</p>
<p>그런 다음 Gradle 빌드 시스템, “blog” Artifact, “blog” Package Name(고급 설정)을 선택하고 “Web”, “Mustache”, “JPA”및 “H2” 종속성을 시작점으로 추가한 다음 “Generate Project”를 클릭합니다.<br><img src="https://github.com/spring-guides/tut-spring-boot-kotlin/raw/master/images/initializr.png" alt=""></p>
<p>압축을 풀기전에 빈 디렉토리를 만듭니다. 그리고 .zip 파일의 루트 디렉토리에는 표준 Gradle 프로젝트가 포함되어 있습니다.</p>
<h3 id="Command-Line-사용"><a href="#Command-Line-사용" class="headerlink" title="Command Line 사용"></a>Command Line 사용</h3><p>Command Line에서 Initializr HTTP API를 사용할 수 있습니다 (예 : UN*X 시스템의 curl).</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ mkdir blog &amp;&amp; cd blog</div><div class="line">$ curl https://start.spring.io/starter.zip -d type=gradle-project -d language=kotlin -d style=web,mustache,jpa,h2 -d packageName=blog -d name=Blog -o blog.zip</div></pre></td></tr></table></figure>
<h3 id="IntelliJ-IDEA-사용"><a href="#IntelliJ-IDEA-사용" class="headerlink" title="IntelliJ IDEA 사용"></a>IntelliJ IDEA 사용</h3><p>또한 Spring Initializr은 IntelliJ IDEA Ultimate 에디션에 통합되어 있어 IDE에서 Command Line 또는 웹 UI와 같이 새 프로젝트를 만들고 가져올 수 있습니다.</p>
<p>File | New | Project를 선택하고 Spring Initializr을 선택합니다.</p>
<p>각 단계에 따라 다음 파라미터를 사용합니다.</p>
<ul>
<li>Package name: “blog”</li>
<li>Artifact: “blog”</li>
<li>Type: Gradle Project</li>
<li>Language: Kotlin</li>
<li>Name: “Blog”</li>
<li>Dependencies: “Web”, “Mustache”, JPA” and “H2”</li>
</ul>
<h2 id="생성된-프로젝트-이해하기"><a href="#생성된-프로젝트-이해하기" class="headerlink" title="생성된 프로젝트 이해하기"></a>생성된 프로젝트 이해하기</h2><h3 id="Gradle-build"><a href="#Gradle-build" class="headerlink" title="Gradle build"></a>Gradle build</h3><h4 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h4><p>명백한 <a href="https://kotlinlang.org/docs/reference/using-gradle.html" target="_blank" rel="external">Kotlin Gradle plugin</a> 외에도, 기본 설정은 스프링 Annotation으로 annotated 또는 meta-annotated가 달린 클래스와 메서드가 자동으로 열리는(Automatically open)<a href="https://kotlinlang.org/docs/reference/compiler-plugins.html#spring-support" target="_blank" rel="external">kotlin-spring plugin</a>을 선언합니다 (Java와 달리 Kotlin의 기본 한정자(Qualifier)는 <code>final</code>입니다). 예를 들어 CGLIB 프록시에 필요한 <code>open</code> 한정자를 추가하지 않고도 <code>@Configuration</code> 또는 <code>@Transactional</code> Bean을 만들 수있는 경우에 유용합니다.</p>
<p><strong>build.gradle</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">buildscript &#123;</div><div class="line">  ext &#123;</div><div class="line">44kotlinVersion = &apos;1.2.51&apos;</div><div class="line">44springBootVersion = &apos;2.0.4.RELEASE&apos;</div><div class="line">  &#125;</div><div class="line">  repositories &#123;</div><div class="line">    mavenCentral()</div><div class="line">  &#125;</div><div class="line">  dependencies &#123;</div><div class="line">    classpath(&quot;org.springframework.boot:spring-boot-gradle-plugin:$&#123;springBootVersion&#125;&quot;)</div><div class="line">    classpath(&quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$&#123;kotlinVersion&#125;&quot;)</div><div class="line">    classpath(&quot;org.jetbrains.kotlin:kotlin-allopen:$&#123;kotlinVersion&#125;&quot;)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">apply plugin: &apos;kotlin&apos;</div><div class="line">apply plugin: &apos;kotlin-spring&apos;</div><div class="line">apply plugin: &apos;org.springframework.boot&apos;</div><div class="line">apply plugin: &apos;io.spring.dependency-management&apos;</div></pre></td></tr></table></figure></p>
<h4 id="컴파일러-옵션-Compiler-options"><a href="#컴파일러-옵션-Compiler-options" class="headerlink" title="컴파일러 옵션 (Compiler options)"></a>컴파일러 옵션 (Compiler options)</h4><p>Kotlin의 핵심 기능 중 하나는 런타임시 유명한 <code>NullPointerException</code>에 부딪히지 않고 컴파일 타임에 <code>null</code>값을 깔끔하게 처리하는 <a href="https://kotlinlang.org/docs/reference/null-safety.html" target="_blank" rel="external">null-safety</a>입니다. 따라서 애플리케이션이 null 허용 선언을 통해 안전하고, <code>Optional</code>(“값 또는 값 없음” 의미를 표현)과 같은 래퍼의 비용을 지불하지 않아도됩니다. Kotlin은 nullable 값을 가진 함수 생성자를 사용할 수 있습니다. <a href="http://www.baeldung.com/kotlin-null-safety" target="_blank" rel="external">Kotlin null-safety에 대한 포괄적 가이드</a>를 확인하십시오.</p>
<p>Java는 type-system에서 null-safety를 허용하지 않지만 Spring Framework는 <code>org.springframework.lang</code> 패키지에 선언된 도구 친화적인(Tooling-friendly) Annotation을 통해 전체 Spring Framework API의 null-safety를 제공합니다. 기본적으로 Kotlin에서 사용되는 Java API의 타입은 null 체크가 완화된 <a href="https://kotlinlang.org/docs/reference/java-interop.html#null-safety-and-platform-types" target="_blank" rel="external">플랫폼 타입</a>으로 인식됩니다. <a href="https://kotlinlang.org/docs/reference/java-interop.html#jsr-305-support" target="_blank" rel="external">JSR 305 annotations</a> + Spring Nullability Annotation에 대한 Kotlin 지원은 컴파일 타임에 <code>null</code> 관련 문제를 처리 할 수 있다는 이점을 가지고 Kotlin 개발자에게 전체 Spring Framework API에 대한 null-safety를 제공합니다.</p>
<p>이 기능은 <code>-Xjsr305</code> 컴파일러 플래그에 <code>strict</code> 옵션을 추가하여 활성화 할 수 있습니다.</p>
<p>아래 코드의 Kotlin 컴파일러는 Java 8 바이트 코드 (Java 6이 기본값)를 생성하도록 구성되어 있습니다.</p>
<p><strong>build.gradle</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">sourceCompatibility = 1.8</div><div class="line">compileKotlin &#123;</div><div class="line">  kotlinOptions &#123;</div><div class="line">    freeCompilerArgs = [&quot;-Xjsr305=strict&quot;]</div><div class="line">    jvmTarget = &quot;1.8&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">compileTestKotlin &#123;</div><div class="line">  kotlinOptions &#123;</div><div class="line">    freeCompilerArgs = [&quot;-Xjsr305=strict&quot;]</div><div class="line">    jvmTarget = &quot;1.8&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="종속성-Dependencies"><a href="#종속성-Dependencies" class="headerlink" title="종속성(Dependencies)"></a>종속성(Dependencies)</h4><p>Kotlin 특정 라이브러리 3개는 이러한 Spring Boot 웹 애플리케이션에 필요하며 기본 구성에 필요합니다.</p>
<ul>
<li><code>kotlin-stdlib-jdk8</code>은 Kotlin 표준 라이브러리의 Java 8 변형입니다.</li>
<li><code>kotlin-reflect</code>은 Kotlin 리플렉션 라이브러리입니다 (Spring Framework 5에서 필수).</li>
<li><code>jackson-module-kotlin</code>은 Kotlin 클래스 및 데이터 클래스의 직렬화 / 비 직렬화에 대한 지원을 추가합니다 (단일 생성자 클래스는 자동으로 사용할 수 있고 보조 생성자 또는 정적 팩토리가 있는 클래스도 지원됩니다)</li>
</ul>
<p><strong>build.gradle</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">dependencies &#123;</div><div class="line">  compile(&apos;org.springframework.boot:spring-boot-starter-data-jpa&apos;)</div><div class="line">  compile(&apos;org.springframework.boot:spring-boot-starter-web&apos;)</div><div class="line">  compile(&apos;org.springframework.boot:spring-boot-starter-mustache&apos;)</div><div class="line">  compile(&apos;com.fasterxml.jackson.module:jackson-module-kotlin&apos;)</div><div class="line">  compile(&quot;org.jetbrains.kotlin:kotlin-stdlib-jdk8&quot;)</div><div class="line">  compile(&quot;org.jetbrains.kotlin:kotlin-reflect&quot;)</div><div class="line">  testCompile(&apos;org.springframework.boot:spring-boot-starter-test&apos;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Spring Boot Gradle 플러그인은 Kotlin Gradle 플러그인에 선언된 Kotlin 버전을 자동으로 사용합니다.</p>
<h3 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h3><p><strong>src/main/kotlin/blog/BlogApplication.kt</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> blog</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication</div><div class="line"><span class="keyword">import</span> org.springframework.boot.runApplication</div><div class="line"></div><div class="line"><span class="meta">@SpringBootApplication</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlogApplication</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  runApplication&lt;BlogApplication&gt;(*args)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Java와 비교하면, 세미콜론이 줄어들었고, 빈 클래스에 괄호가 없으며 (<code>@Bean</code> Annotation을 통해 Bean을 선언해야하는 경우 추가 할 수 있습니다), 최상위 수준 함수 <code>runApplication</code>을 사용할 수 있다는 것을 알수 있습니다. <code>runApplication&lt;BlogApplication&gt;(*args)</code>은 <code>SpringApplication.run(BlogApplication::class.java, *args)</code>에 대한 Kotlin의 대안적인 표현이며, 다음 구문을 사용하여 사용자 정의 애플리케이션을 사용할 수 있습니다.</p>
<p><strong>src/main/kotlin/blog/BlogApplication.kt</strong><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</div><div class="line">  runApplication&lt;BlogApplication&gt;(*args) &#123;</div><div class="line">    setBannerMode(Banner.Mode.OFF)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="첫-번째-Kotlin-컨트롤러-작성하기"><a href="#첫-번째-Kotlin-컨트롤러-작성하기" class="headerlink" title="첫 번째 Kotlin 컨트롤러 작성하기"></a>첫 번째 Kotlin 컨트롤러 작성하기</h2><p>간단한 웹 페이지를 표시하는 간단 컨트롤러를 만들어 보겠습니다.</p>
<p><strong>src/main/kotlin/blog/HtmlController.kt</strong><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> blog</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller</div><div class="line"><span class="keyword">import</span> org.springframework.ui.Model</div><div class="line"><span class="keyword">import</span> org.springframework.ui.<span class="keyword">set</span></div><div class="line"><span class="keyword">import</span> org.springframework.web.bind.<span class="keyword">annotation</span>.GetMapping</div><div class="line"></div><div class="line"><span class="meta">@Controller</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HtmlController</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="meta">@GetMapping(<span class="meta-string">"/"</span>)</span></div><div class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">blog</span><span class="params">(model: <span class="type">Model</span>)</span></span>: String &#123;</div><div class="line">    model[<span class="string">"title"</span>] = <span class="string">"Blog"</span></div><div class="line">    <span class="keyword">return</span> <span class="string">"blog"</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><a href="https://kotlinlang.org/docs/reference/extensions.html" target="_blank" rel="external">Kotlin extension</a>을 사용하여 기존의 Spring 타입에 Kotlin 함수나 연산자를 추가 할 수 있습니다. 여기에서는 <code>model.addAttribute(&quot;title&quot;, &quot;Blog&quot;)</code> 대신 <code>model[&quot;title&quot;] = &quot;Blog&quot;</code>를 사용할 수 있도록 <code>org.springframework.ui.set</code> 확장 함수를 가져옵니다.</p>
<p>그리고 관련된 Mustache 템플릿을 만들어야합니다.</p>
<p><strong>src/main/resources/templates/header.mustache</strong><br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>&#123;&#123;title&#125;&#125;<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p><strong>src/main/resources/templates/footer.mustache</strong><br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p><strong>src/main/resources/templates/blog.mustache</strong><br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;&#123;&gt; header&#125;&#125;</div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;title&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line"></div><div class="line">&#123;&#123;&gt; footer&#125;&#125;</div></pre></td></tr></table></figure></p>
<p><code>BlogApplication.kt</code>의 <code>main</code> 함수를 실행하여 응용프로그램을 시작하고, <code>http://localhost:8080/</code>으로 이동하면 “Blog” 제목이 있는 단순한 웹 페이지가 나타납니다.</p>
<h2 id="JUnit-5로-테스트하기"><a href="#JUnit-5로-테스트하기" class="headerlink" title="JUnit 5로 테스트하기"></a>JUnit 5로 테스트하기</h2><p>JUnit 4는 여전히 Spring Boot와 함께 제공되는 기본 테스트 프레임 워크이지만, JUnit 5는 null이 허용되지 않는 <code>val</code> 프로퍼티를 사용할 수 있는 <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/testing.html#testcontext-junit-jupiter-di" target="_blank" rel="external">생성자/메서드 파라미터의 Autowiring</a>을 포함하여 Kotlin에서 매우 편리한 다양한 기능을 제공합니다. 그리고 <code>@BeforeAll</code>/<code>@AfterAll</code>을 일반적인 비 정적 메서드에서 사용할 수 있습니다.</p>
<h3 id="JUnit-4에서-JUnit-5로-전환"><a href="#JUnit-4에서-JUnit-5로-전환" class="headerlink" title="JUnit 4에서 JUnit 5로 전환"></a>JUnit 4에서 JUnit 5로 전환</h3><p>먼저 <a href="https://docs.gradle.org/4.6/release-notes.html#junit-5-support" target="_blank" rel="external">네이티브 JUnit 5 지원</a>을 활용할 수 있도록 <code>./gradlew -version</code>을 실행하여 Gradle 4.6 이상을 사용하고 있는지 확인하십시오. 이전 버전을 사용하는 경우 <code>./gradlew wrapper --gradle-version 4.7</code>을 실행하여 <a href="https://docs.gradle.org/current/release-notes.html" target="_blank" rel="external">최신 버전의 Gradle</a>을 업데이트 할 수 있습니다.</p>
<p><code>build.gradle</code> 파일에 다음 줄을 추가하여 JUnit 5 지원을 활성화합니다.</p>
<p><strong>build.gradle</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">test &#123;</div><div class="line">  useJUnitPlatform()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>그런 다음 <code>junit</code>을 <code>spring-boot-starter-test</code> 전이(transitive) 의존성에서 제외하고 <code>junit-jupiter-api</code> 및 <code>junit-jupiter-engine</code>을 추가합니다.</p>
<p><strong>build.gradle</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">dependencies &#123;</div><div class="line">  testCompile(&apos;org.springframework.boot:spring-boot-starter-test&apos;) &#123;</div><div class="line">    exclude module: &apos;junit&apos;</div><div class="line">  &#125;</div><div class="line">  testImplementation(&apos;org.junit.jupiter:junit-jupiter-api&apos;)</div><div class="line">  testRuntimeOnly(&apos;org.junit.jupiter:junit-jupiter-engine&apos;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Gradle 설정을 새로 고치고 <code>BlogApplicationTests</code>를 열어 <code>@RunWith(SpringRunner::class)</code>를 <code>@ExtendWith(SpringExtension::class)</code>로 대체합니다.</p>
<p><strong>src/test/kotlin/blog/BlogApplicationTests.kt</strong><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@ExtendWith(SpringExtension::class)</span></div><div class="line"><span class="meta">@SpringBootTest</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlogApplicationTests</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="meta">@Test</span></div><div class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">contextLoads</span><span class="params">()</span></span> &#123;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>테스트는 Command Line과 IDE에서 잘 실행되어야합니다.</p>
<h3 id="Kotlin에서-JUnit-5-테스트-작성하기"><a href="#Kotlin에서-JUnit-5-테스트-작성하기" class="headerlink" title="Kotlin에서 JUnit 5 테스트 작성하기"></a>Kotlin에서 JUnit 5 테스트 작성하기</h3><p>이 예제에서는 다양한 기능을 보여주기 위해 통합 테스트를 작성해 보겠습니다.</p>
<ul>
<li>표현형 테스트 함수 이름을 제공하기 위해 camel-case 대신 백틱 사이에 실제 문장을 사용합니다.</li>
<li>JUnit 5는 생성자와 메서드 파라미터를 삽입(Inject) 할 수 있습니다.이 파라미터는 Kotlin 불변(Immutable) 및 Nullable 속성과 잘 어울립니다.</li>
<li>이 코드는 <code>getForObject</code> 및 <code>getForEntity</code> Kotlin extension을 사용합니다 (import 할 필요가 있음).</li>
</ul>
<p><strong>src/test/kotlin/blog/IntegrationTests.kt</strong><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@ExtendWith(SpringExtension::class)</span></div><div class="line"><span class="meta">@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntegrationTests</span></span>(<span class="meta">@Autowired</span> <span class="keyword">val</span> restTemplate: TestRestTemplate) &#123;</div><div class="line"></div><div class="line">  <span class="meta">@Test</span></div><div class="line">  <span class="function"><span class="keyword">fun</span> `Assert blog page title, content and status code`<span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">val</span> entity = restTemplate.getForEntity&lt;String&gt;(<span class="string">"/"</span>)</div><div class="line">    assertThat(entity.statusCode).isEqualTo(HttpStatus.OK)</div><div class="line">    assertThat(entity.body).contains(<span class="string">"&lt;h1&gt;Blog&lt;/h1&gt;"</span>)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="테스트-인스턴스-생명주기-Lifecycle"><a href="#테스트-인스턴스-생명주기-Lifecycle" class="headerlink" title="테스트 인스턴스 생명주기(Lifecycle)"></a>테스트 인스턴스 생명주기(Lifecycle)</h3><p>때로는 주어진 클래스의 모든 테스트 전후에 메서드를 실행해야 할 때가 있습니다. Junit 4와 마찬가지로 JUnit 5는 테스트 클래스가 테스트마다 한 번 인스턴스화되기 때문에 기본적으로 이 메서드가 정적 (이것은 Kotlin의 <a href="https://kotlinlang.org/docs/reference/object-declarations.html#companion-objects" target="_blank" rel="external">companion object</a>로 변환되며, 이는 매우 장황하고 직설적이지 않습니다.) 이어야합니다.</p>
<p>그러나 Junit 5에서는 이 기본 동작을 변경하고 클래스당 한 번 테스트 클래스를 인스턴스화 할 수 있습니다. 이 작업은 <a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-test-instance-lifecycle" target="_blank" rel="external">다양한 방법</a>으로 수행 할 수 있습니다. 여기서는 프로퍼티 파일을 사용하여 전체 프로젝트의 기본 동작을 변경합니다.</p>
<p><strong>src/test/resources/junit-platform.properties</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">junit.jupiter.testinstance.lifecycle.default = per_class</div></pre></td></tr></table></figure>
<p>이 구성(Configuration)을 사용하면 위의 <code>IntegrationTest</code>의 업데이트된 버전과 같은 일반 메서드에서 <code>@BeforeAll</code> 및 <code>@AfterAll</code> Annotation을 사용할 수 있습니다.</p>
<p><strong>src/test/kotlin/blog/IntegrationTests.kt</strong><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@ExtendWith(SpringExtension::class)</span></div><div class="line"><span class="meta">@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntegrationTests</span></span>(<span class="meta">@Autowired</span> <span class="keyword">val</span> restTemplate: TestRestTemplate) &#123;</div><div class="line"></div><div class="line">  <span class="meta">@BeforeAll</span></div><div class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">setup</span><span class="params">()</span></span> &#123;</div><div class="line">    println(<span class="string">"&gt;&gt; Setup"</span>)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Test</span></div><div class="line">  <span class="function"><span class="keyword">fun</span> `Assert blog page title, content and status code`<span class="params">()</span></span> &#123;</div><div class="line">    println(<span class="string">"&gt;&gt; Assert blog page title, content and status code"</span>)</div><div class="line">    <span class="keyword">val</span> entity = restTemplate.getForEntity&lt;String&gt;(<span class="string">"/"</span>)</div><div class="line">    assertThat(entity.statusCode).isEqualTo(HttpStatus.OK)</div><div class="line">    assertThat(entity.body).contains(<span class="string">"&lt;h1&gt;Blog&lt;/h1&gt;"</span>)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Test</span></div><div class="line">  <span class="function"><span class="keyword">fun</span> `Assert article page title, content and status code`<span class="params">()</span></span> &#123;</div><div class="line">    println(<span class="string">"&gt;&gt; TODO"</span>)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@AfterAll</span></div><div class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">teardown</span><span class="params">()</span></span> &#123;</div><div class="line">    println(<span class="string">"&gt;&gt; Tear down"</span>)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="JPA를-이용한-Persistence"><a href="#JPA를-이용한-Persistence" class="headerlink" title="JPA를 이용한 Persistence"></a>JPA를 이용한 Persistence</h2><p>Kotlin 불변 클래스(Immutable class)를 사용하려면 <a href="https://kotlinlang.org/docs/reference/compiler-plugins.html#jpa-support" target="_blank" rel="external">Kotlin JPA 플러그인</a>을 활성화해야합니다. <code>@Entity</code>, <code>@MappedSuperclass</code> 또는 <code>@Embeddable</code>로 Annotation된 모든 클래스에 대해 파라미터가 없는 생성자를 생성합니다.</p>
<p><strong>build.gradle</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">buildscript &#123;</div><div class="line">  dependencies &#123;</div><div class="line">    classpath(&quot;org.jetbrains.kotlin:kotlin-noarg:$&#123;kotlinVersion&#125;&quot;)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">apply plugin: &apos;kotlin-jpa&apos;</div></pre></td></tr></table></figure></p>
<p>그런 다음 데이터를 보유하고 <code>equals()</code>, <code>hashCode()</code>, <code>toString()</code>, <code>componentN()</code> 함수 및 <code>copy()</code>를 자동으로 제공하도록 설계된 Kotlin <a href="https://kotlinlang.org/docs/reference/data-classes.html" target="_blank" rel="external">데이터 클래스(Data class)</a>를 사용하여 모델을 만듭니다.</p>
<p><strong>src/main/kotlin/blog/Model.kt</strong><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Entity</span></div><div class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Article</span></span>(</div><div class="line">    <span class="keyword">val</span> title: String,</div><div class="line">    <span class="keyword">val</span> headline: String,</div><div class="line">    <span class="keyword">val</span> content: String,</div><div class="line">    <span class="meta">@ManyToOne</span> <span class="meta">@JoinColumn</span> <span class="keyword">val</span> author: User,</div><div class="line">    <span class="meta">@Id</span> <span class="meta">@GeneratedValue</span> <span class="keyword">val</span> id: <span class="built_in">Long</span>? = <span class="literal">null</span>,</div><div class="line">    <span class="keyword">val</span> addedAt: LocalDateTime = LocalDateTime.now())</div><div class="line"></div><div class="line"><span class="meta">@Entity</span></div><div class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(</div><div class="line">    <span class="meta">@Id</span> <span class="keyword">val</span> login: String,</div><div class="line">    <span class="keyword">val</span> firstname: String,</div><div class="line">    <span class="keyword">val</span> lastname: String,</div><div class="line">    <span class="keyword">val</span> description: String? = <span class="literal">null</span>)</div></pre></td></tr></table></figure></p>
<p>기본 값이 있는 선택적 파라미터는 위치가 있는 파라미터를 사용할 때 생략 할 수 있도록 마지막 위치에 정의됩니다 (Kotlin은 <a href="https://kotlinlang.org/docs/reference/functions.html#named-arguments" target="_blank" rel="external">이름이 있는 파라미터</a>도 지원함). Kotlin에서 동일한 파일에서 간결한 클래스 선언을 그룹화하는 것은 이례적인 일이 아닙니다.</p>
<p>Spring Data JPA Repository를 다음과 같이 선언합니다.</p>
<p><strong>src/main/kotlin/blog/Repositories.kt</strong><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ArticleRepository</span> : <span class="type">CrudRepository</span>&lt;<span class="type">Article, Long</span>&gt; </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">findAllByOrderByAddedAtDesc</span><span class="params">()</span></span>: Iterable&lt;Article&gt;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> : <span class="type">CrudRepository</span>&lt;<span class="type">User, String</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>그리고 JPA 테스트를 작성하여 기본 유스 케이스가 예상대로 작동하는지 확인합니다.</p>
<p><strong>src/test/kotlin/blog/RepositoriesTests.kt</strong><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@ExtendWith(SpringExtension::class)</span></div><div class="line"><span class="meta">@DataJpaTest</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RepositoriesTests</span></span>(<span class="meta">@Autowired</span> <span class="keyword">val</span> entityManager: TestEntityManager,</div><div class="line">                        <span class="meta">@Autowired</span> <span class="keyword">val</span> userRepository: UserRepository,</div><div class="line">                        <span class="meta">@Autowired</span> <span class="keyword">val</span> articleRepository: ArticleRepository) &#123;</div><div class="line"></div><div class="line">  <span class="meta">@Test</span></div><div class="line">  <span class="function"><span class="keyword">fun</span> `When findById then return Article`<span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">val</span> juergen = User(<span class="string">"springjuergen"</span>, <span class="string">"Juergen"</span>, <span class="string">"Hoeller"</span>)</div><div class="line">    entityManager.persist(juergen)</div><div class="line">    <span class="keyword">val</span> article = Article(<span class="string">"Spring Framework 5.0 goes GA"</span>, <span class="string">"Dear Spring community ..."</span>, <span class="string">"Lorem ipsum"</span>, juergen)</div><div class="line">    entityManager.persist(article)</div><div class="line">    entityManager.flush()</div><div class="line"></div><div class="line">    <span class="keyword">val</span> found = articleRepository.findById(article.id!!)</div><div class="line"></div><div class="line">    assertThat(found.<span class="keyword">get</span>()).isEqualTo(article)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Test</span></div><div class="line">  <span class="function"><span class="keyword">fun</span> `When findById then return User`<span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">val</span> juergen = User(<span class="string">"springjuergen"</span>, <span class="string">"Juergen"</span>, <span class="string">"Hoeller"</span>)</div><div class="line">    entityManager.persist(juergen)</div><div class="line">    entityManager.flush()</div><div class="line"></div><div class="line">    <span class="keyword">val</span> found = userRepository.findById(juergen.login)</div><div class="line"></div><div class="line">    assertThat(found.<span class="keyword">get</span>()).isEqualTo(juergen)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="나만의-확장-기능-만들기"><a href="#나만의-확장-기능-만들기" class="headerlink" title="나만의 확장 기능 만들기"></a>나만의 확장 기능 만들기</h2><p>Java에서 추상 메서드로 util 클래스를 사용하지만, Kotlin에서는 Kotlin 확장을 통해 제공하는 것이 일반적입니다. 여기서 영어 날짜 형식으로 텍스트를 생성하기 위해 기존 <code>LocalDateTime</code> 타입에 <code>format()</code> 함수를 추가 할 것입니다.</p>
<p><strong>src/main/kotlin/blog/Extensions.kt</strong><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> LocalDateTime.<span class="title">format</span><span class="params">()</span></span> = <span class="keyword">this</span>.format(englishDateFormatter)</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">val</span> daysLookup = (<span class="number">1.</span><span class="number">.31</span>).associate &#123; it.toLong() to getOrdinal(it) &#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">val</span> englishDateFormatter = DateTimeFormatterBuilder()</div><div class="line">    .appendPattern(<span class="string">"MMMM"</span>)</div><div class="line">    .appendLiteral(<span class="string">" "</span>)</div><div class="line">    .appendText(ChronoField.DAY_OF_MONTH, daysLookup)</div><div class="line">    .appendLiteral(<span class="string">" "</span>)</div><div class="line">    .appendPattern(<span class="string">"yyyy"</span>)</div><div class="line">    .toFormatter(Locale.ENGLISH)</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getOrdinal</span><span class="params">(n: <span class="type">Int</span>)</span></span> = <span class="keyword">when</span> &#123;</div><div class="line">  n <span class="keyword">in</span> <span class="number">11.</span><span class="number">.13</span> -&gt; <span class="string">"<span class="subst">$&#123;n&#125;</span>th"</span></div><div class="line">  n % <span class="number">10</span> == <span class="number">1</span> -&gt; <span class="string">"<span class="subst">$&#123;n&#125;</span>st"</span></div><div class="line">  n % <span class="number">10</span> == <span class="number">2</span> -&gt; <span class="string">"<span class="subst">$&#123;n&#125;</span>nd"</span></div><div class="line">  n % <span class="number">10</span> == <span class="number">3</span> -&gt; <span class="string">"<span class="subst">$&#123;n&#125;</span>rd"</span></div><div class="line">  <span class="keyword">else</span> -&gt; <span class="string">"<span class="subst">$&#123;n&#125;</span>th"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>다음 섹션에서 이 확장을 활용할 것입니다.</p>
<h2 id="블로그-엔진-구현하기"><a href="#블로그-엔진-구현하기" class="headerlink" title="블로그 엔진 구현하기"></a>블로그 엔진 구현하기</h2><p>우리가 구현중인 블로그 엔진은 Markdown을 HTML로 렌더링해야하며, 이를 위해 <code>commonmark</code> 라이브러리를 사용할 것입니다.</p>
<p><strong>build.gradle</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">dependencies &#123;</div><div class="line">  compile(&quot;com.atlassian.commonmark:commonmark:0.11.0&quot;)</div><div class="line">  compile(&quot;com.atlassian.commonmark:commonmark-ext-autolink:0.11.0&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><a href="https://kotlinlang.org/docs/reference/lambdas.html#function-types" target="_blank" rel="external">Kotlin 함수 타입</a>을 활용하는 <code>MarkdownConverter</code> Bean을 소개합니다.</p>
<p><strong>src/main/kotlin/blog/MarkdownConverter.kt</strong><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Service</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MarkdownConverter</span> : <span class="type"></span></span>(String?) -&gt; String &#123;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">val</span> parser = Parser.builder().extensions(listOf(AutolinkExtension.create())).build()</div><div class="line">  <span class="keyword">private</span> <span class="keyword">val</span> renderer = HtmlRenderer.builder().build()</div><div class="line"></div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(input: <span class="type">String</span>?)</span></span>: String &#123;</div><div class="line">    <span class="keyword">if</span> (input == <span class="literal">null</span> || input == <span class="string">""</span>) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="string">""</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> renderer.render(parser.parse(input))</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>그리고 HTML을 렌더링 할 수 있는 커스텀 <code>Mustache.Compiler</code> Bean을 제공합니다.</p>
<p><strong>src/main/kotlin/blog/BlogApplication.kt</strong><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SpringBootApplication</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlogApplication</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="meta">@Bean</span></div><div class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">mustacheCompiler</span><span class="params">(loader: <span class="type">Mustache</span>.<span class="type">TemplateLoader</span>?)</span></span> =</div><div class="line">      Mustache.compiler().escapeHTML(<span class="literal">false</span>).withLoader(loader)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Null을 허용하는 <code>Mustache.TemplateLoader?</code>는 선택적인 Bean이라는 것을 의미합니다(JPA 전용 테스트를 실행할 때 실패를 피하기 위해서).</p>
<p>“Blog” Mustache 템플릿을 업데이트합니다.</p>
<p><strong>src/main/resources/templates/blog.mustache</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&#123;&#123;&gt; header&#125;&#125;</div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;title&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"articles"</span>&gt;</span></div><div class="line"></div><div class="line">  &#123;&#123;#articles&#125;&#125;</div><div class="line">    <span class="tag">&lt;<span class="name">section</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">"article-header"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">"article-title"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/article/&#123;&#123;id&#125;&#125;"</span>&gt;</span>&#123;&#123;title&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"article-meta"</span>&gt;</span>By  <span class="tag">&lt;<span class="name">strong</span>&gt;</span>&#123;&#123;author.firstname&#125;&#125;<span class="tag">&lt;/<span class="name">strong</span>&gt;</span>, on <span class="tag">&lt;<span class="name">strong</span>&gt;</span>&#123;&#123;addedAt&#125;&#125;<span class="tag">&lt;/<span class="name">strong</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">header</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"article-description"</span>&gt;</span></div><div class="line">        &#123;&#123;headline&#125;&#125;</div><div class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></div><div class="line">  &#123;&#123;/articles&#125;&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line">&#123;&#123;&gt; footer&#125;&#125;</div></pre></td></tr></table></figure>
<p>그리고 우리는 새로운 “article”를 만듭니다.</p>
<p><strong>src/main/resources/templates/article.mustache</strong><br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&#123;&#123;&gt; header&#125;&#125;</div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"article"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">"article-header"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"article-title"</span>&gt;</span>&#123;&#123;article.title&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"article-meta"</span>&gt;</span>By  <span class="tag">&lt;<span class="name">strong</span>&gt;</span>&#123;&#123;article.author.firstname&#125;&#125;<span class="tag">&lt;/<span class="name">strong</span>&gt;</span>, on <span class="tag">&lt;<span class="name">strong</span>&gt;</span>&#123;&#123;article.addedAt&#125;&#125;<span class="tag">&lt;/<span class="name">strong</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"article-description"</span>&gt;</span></div><div class="line">    &#123;&#123;article.headline&#125;&#125;</div><div class="line"></div><div class="line">    &#123;&#123;article.content&#125;&#125;</div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></div><div class="line"></div><div class="line">&#123;&#123;&gt; footer&#125;&#125;</div></pre></td></tr></table></figure></p>
<p>렌더링된 마크 다운 및 형식이 지정된 날짜로 블로그 및 기사 페이지를 렌더링하기 위해 <code>HtmlController</code>를 업데이트합니다. <code>ArticleRepository</code> 및 <code>MarkdownConverter</code> 생성자 파라미터는 <code>HtmlController</code>가 단일 생성자 (암시적 <code>@Autowired</code>)를 가지고 있기 때문에 자동으로 Autowired 됩니다.</p>
<p><strong>src/main/kotlin/blog/HtmlController.kt</strong><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Controller</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HtmlController</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> repository: ArticleRepository,</div><div class="line">           <span class="keyword">private</span> <span class="keyword">val</span> markdownConverter: MarkdownConverter) &#123;</div><div class="line"></div><div class="line">    <span class="meta">@GetMapping(<span class="meta-string">"/"</span>)</span></div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">blog</span><span class="params">(model: <span class="type">Model</span>)</span></span>: String &#123;</div><div class="line">      model[<span class="string">"title"</span>] = <span class="string">"Blog"</span></div><div class="line">      model[<span class="string">"articles"</span>] = repository.findAllByOrderByAddedAtDesc().map &#123; it.render() &#125;</div><div class="line">      <span class="keyword">return</span> <span class="string">"blog"</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@GetMapping(<span class="meta-string">"/article/&#123;id&#125;"</span>)</span></div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">article</span><span class="params">(<span class="meta">@PathVariable</span> id: <span class="type">Long</span>, model: <span class="type">Model</span>)</span></span>: String &#123;</div><div class="line">      <span class="keyword">val</span> article = repository</div><div class="line">          .findById(id)</div><div class="line">          .orElseThrow &#123; IllegalArgumentException(<span class="string">"Wrong article id provided"</span>) &#125;</div><div class="line">          .render()</div><div class="line">      model[<span class="string">"title"</span>] = article.title</div><div class="line">      model[<span class="string">"article"</span>] = article</div><div class="line">      <span class="keyword">return</span> <span class="string">"article"</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">fun</span> Article.<span class="title">render</span><span class="params">()</span></span> = RenderedArticle(</div><div class="line">        title,</div><div class="line">        markdownConverter.invoke(headline),</div><div class="line">        markdownConverter.invoke(content),</div><div class="line">        author,</div><div class="line">        id,</div><div class="line">        addedAt.format()</div><div class="line">    )</div><div class="line"></div><div class="line">    <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">RenderedArticle</span></span>(</div><div class="line">        <span class="keyword">val</span> title: String,</div><div class="line">        <span class="keyword">val</span> headline: String,</div><div class="line">        <span class="keyword">val</span> content: String,</div><div class="line">        <span class="keyword">val</span> author: User,</div><div class="line">        <span class="keyword">val</span> id: <span class="built_in">Long</span>?,</div><div class="line">        <span class="keyword">val</span> addedAt: String)</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>BlogApplication</code>에 데이터 초기화를 추가합니다.</p>
<p><strong>src/main/kotlin/blog/BlogApplication.kt</strong><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Bean</span></div><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">databaseInitializer</span><span class="params">(userRepository: <span class="type">UserRepository</span>,</span></span></div><div class="line">                        articleRepository: <span class="type">ArticleRepository</span>) = CommandLineRunner &#123;</div><div class="line">  <span class="keyword">val</span> smaldini = User(<span class="string">"smaldini"</span>, <span class="string">"Stéphane"</span>, <span class="string">"Maldini"</span>)</div><div class="line">  userRepository.save(smaldini)</div><div class="line"></div><div class="line">  articleRepository.save(Article(</div><div class="line">      <span class="string">"Reactor Bismuth is out"</span>,</div><div class="line">      <span class="string">"Lorem ipsum"</span>,</div><div class="line">      <span class="string">"dolor **sit** amet https://projectreactor.io/"</span>,</div><div class="line">      smaldini,</div><div class="line">      <span class="number">1</span></div><div class="line">  ))</div><div class="line">  articleRepository.save(Article(</div><div class="line">      <span class="string">"Reactor Aluminium has landed"</span>,</div><div class="line">      <span class="string">"Lorem ipsum"</span>,</div><div class="line">      <span class="string">"dolor **sit** amet https://projectreactor.io/"</span>,</div><div class="line">      smaldini,</div><div class="line">      <span class="number">2</span></div><div class="line">  ))</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>그리고 통합 테스트(Integration test)도 업데이트합니다.</p>
<p><strong>src/test/kotlin/blog/IntegrationTests.kt</strong><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@ExtendWith(SpringExtension::class)</span></div><div class="line"><span class="meta">@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntegrationTests</span></span>(<span class="meta">@Autowired</span> <span class="keyword">val</span> restTemplate: TestRestTemplate) &#123;</div><div class="line"></div><div class="line">  <span class="meta">@BeforeAll</span></div><div class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">setup</span><span class="params">()</span></span> &#123;</div><div class="line">    println(<span class="string">"&gt;&gt; Setup"</span>)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Test</span></div><div class="line">  <span class="function"><span class="keyword">fun</span> `Assert blog page title, content and status code`<span class="params">()</span></span> &#123;</div><div class="line">    println(<span class="string">"&gt;&gt; Assert blog page title, content and status code"</span>)</div><div class="line">    <span class="keyword">val</span> entity = restTemplate.getForEntity&lt;String&gt;(<span class="string">"/"</span>)</div><div class="line">    assertThat(entity.statusCode).isEqualTo(HttpStatus.OK)</div><div class="line">    assertThat(entity.body).contains(<span class="string">"&lt;h1&gt;Blog&lt;/h1&gt;"</span>, <span class="string">"Reactor"</span>)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Test</span></div><div class="line">  <span class="function"><span class="keyword">fun</span> `Assert article page title, content and status code`<span class="params">()</span></span> &#123;</div><div class="line">    println(<span class="string">"&gt;&gt; Assert article page title, content and status code"</span>)</div><div class="line">    <span class="keyword">val</span> entity = restTemplate.getForEntity&lt;String&gt;(<span class="string">"/article/2"</span>)</div><div class="line">    assertThat(entity.statusCode).isEqualTo(HttpStatus.OK)</div><div class="line">    assertThat(entity.body).contains(<span class="string">"Reactor Aluminium has landed"</span>,,</div><div class="line">        <span class="string">"&lt;a href=\"https://projectreactor.io/\"&gt;https://projectreactor.io/&lt;/a&gt;"</span>)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@AfterAll</span></div><div class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">teardown</span><span class="params">()</span></span> &#123;</div><div class="line">    println(<span class="string">"&gt;&gt; Tear down"</span>)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>웹 애플리케이션을 시작(또는 재시작)하고 <code>http://localhost:8080/</code>으로 이동하면 클릭 가능한 링크가있는 기사 목록이 나타나 특정 기사를 볼 수 있습니다.</p>
<h2 id="HTTP-API-노출"><a href="#HTTP-API-노출" class="headerlink" title="HTTP API 노출"></a>HTTP API 노출</h2><p><code>@RestController</code> Annotation이 달린 컨트롤러를 통해 HTTP API를 구현합니다.</p>
<p><strong>src/main/kotlin/blog/HttpApi.kt</strong><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RestController</span></div><div class="line"><span class="meta">@RequestMapping(<span class="meta-string">"/api/article"</span>)</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArticleController</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> repository: ArticleRepository,</div><div class="line">            <span class="keyword">private</span> <span class="keyword">val</span> markdownConverter: MarkdownConverter) &#123;</div><div class="line"></div><div class="line">  <span class="meta">@GetMapping(<span class="meta-string">"/"</span>)</span></div><div class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">findAll</span><span class="params">()</span></span> = repository.findAllByOrderByAddedAtDesc()</div><div class="line"></div><div class="line">  <span class="meta">@GetMapping(<span class="meta-string">"/&#123;id&#125;"</span>)</span></div><div class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">findOne</span><span class="params">(<span class="meta">@PathVariable</span> id: <span class="type">Long</span>, <span class="meta">@RequestParam</span> converter: <span class="type">String</span>?)</span></span> = <span class="keyword">when</span> (converter) &#123;</div><div class="line">    <span class="string">"markdown"</span> -&gt; repository.findById(id).map &#123; it.copy(</div><div class="line">        headline = markdownConverter.invoke(it.headline),</div><div class="line">        content = markdownConverter.invoke(it.content)) &#125;</div><div class="line">    <span class="literal">null</span> -&gt; repository.findById(id)</div><div class="line">    <span class="keyword">else</span> -&gt; <span class="keyword">throw</span> IllegalArgumentException(<span class="string">"Only markdown converter is supported"</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@RestController</span></div><div class="line"><span class="meta">@RequestMapping(<span class="meta-string">"/api/user"</span>)</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserController</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> repository: UserRepository) &#123;</div><div class="line"></div><div class="line">  <span class="meta">@GetMapping(<span class="meta-string">"/"</span>)</span></div><div class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">findAll</span><span class="params">()</span></span> = repository.findAll()</div><div class="line"></div><div class="line">  <span class="meta">@GetMapping(<span class="meta-string">"/&#123;login&#125;"</span>)</span></div><div class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">findOne</span><span class="params">(<span class="meta">@PathVariable</span> login: <span class="type">String</span>)</span></span> = repository.findById(login)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>테스트의 경우 통합 테스트 대신 <code>@WebMvcTest</code> 및 <code>@MockBean</code>을 사용하여 웹 레이어만 테스트합니다.</p>
<p><strong>src/test/kotlin/blog/HttpApiTests.kt</strong><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@ExtendWith(SpringExtension::class)</span></div><div class="line"><span class="meta">@WebMvcTest</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpApiTests</span></span>(<span class="meta">@Autowired</span> <span class="keyword">val</span> mockMvc: MockMvc) &#123;</div><div class="line"></div><div class="line">  <span class="meta">@MockBean</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> userRepository: UserRepository</div><div class="line"></div><div class="line">  <span class="meta">@MockBean</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> articleRepository: ArticleRepository</div><div class="line"></div><div class="line">  <span class="meta">@MockBean</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> markdownConverter: MarkdownConverter</div><div class="line"></div><div class="line">  <span class="meta">@Test</span></div><div class="line">  <span class="function"><span class="keyword">fun</span> `List articles`<span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">val</span> juergen = User(<span class="string">"springjuergen"</span>, <span class="string">"Juergen"</span>, <span class="string">"Hoeller"</span>)</div><div class="line">    <span class="keyword">val</span> spring5Article = Article(<span class="string">"Spring Framework 5.0 goes GA"</span>, <span class="string">"Dear Spring community ..."</span>, <span class="string">"Lorem ipsum"</span>, juergen, <span class="number">1</span>)</div><div class="line">    <span class="keyword">val</span> spring43Article = Article(<span class="string">"Spring Framework 4.3 goes GA"</span>, <span class="string">"Dear Spring community ..."</span>, <span class="string">"Lorem ipsum"</span>, juergen, <span class="number">2</span>)</div><div class="line">    whenever(articleRepository.findAllByOrderByAddedAtDesc()).thenReturn(listOf(spring5Article, spring43Article))</div><div class="line">    whenever(markdownConverter.invoke(any())).thenAnswer &#123; it.arguments[<span class="number">0</span>] &#125;</div><div class="line">    mockMvc.perform(<span class="keyword">get</span>(<span class="string">"/api/article/"</span>).accept(MediaType.APPLICATION_JSON))</div><div class="line">        .andExpect(status().isOk)</div><div class="line">        .andExpect(content().contentType(MediaType.APPLICATION_JSON_UTF8))</div><div class="line">        .andExpect(jsonPath(<span class="string">"\$.[0].author.login"</span>).value(juergen.login))</div><div class="line">        .andExpect(jsonPath(<span class="string">"\$.[0].id"</span>).value(spring5Article.id!!))</div><div class="line">        .andExpect(jsonPath(<span class="string">"\$.[1].author.login"</span>).value(juergen.login))</div><div class="line">        .andExpect(jsonPath(<span class="string">"\$.[1].id"</span>).value(spring43Article.id!!))</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Test</span></div><div class="line">  <span class="function"><span class="keyword">fun</span> `List users`<span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">val</span> juergen = User(<span class="string">"springjuergen"</span>, <span class="string">"Juergen"</span>, <span class="string">"Hoeller"</span>)</div><div class="line">    <span class="keyword">val</span> smaldini = User(<span class="string">"smaldini"</span>, <span class="string">"Stéphane"</span>, <span class="string">"Maldini"</span>)</div><div class="line">    whenever(userRepository.findAll()).thenReturn(listOf(juergen, smaldini))</div><div class="line">    mockMvc.perform(<span class="keyword">get</span>(<span class="string">"/api/user/"</span>).accept(MediaType.APPLICATION_JSON))</div><div class="line">        .andExpect(status().isOk)</div><div class="line">        .andExpect(content().contentType(MediaType.APPLICATION_JSON_UTF8))</div><div class="line">        .andExpect(jsonPath(<span class="string">"\$.[0].login"</span>).value(juergen.login))</div><div class="line">        .andExpect(jsonPath(<span class="string">"\$.[1].login"</span>).value(smaldini.login))</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>when</code>은 예약된 Kotlin 키워드이므로, <code>whenever</code> 별칭을 제공하는 <a href="https://github.com/nhaarman/mockito-kotlin/" target="_blank" rel="external">mockito-kotlin</a> 라이브러리 (이스케이프된 <code>`when` </code>도 사용 가능)를 사용하기로 결정한 이유입니다. 이를 사용하려면 다음 종속성을 추가하십시오.</p>
<p><strong>build.gradle</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dependencies &#123;</div><div class="line">  testCompile(&quot;com.nhaarman:mockito-kotlin:1.5.0&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>$</code>는 문자열 보간(Interpolation)에 사용되기 때문에 문자열에서 이스케이프 해야합니다. <code>@MockBean</code> JUnit 5 파라미터 리졸버(Parameter resolver)가 <a href="https://github.com/spring-projects/spring-boot/issues/13113" target="_blank" rel="external">아직 없으므로</a> 지금은 <code>lateinit var</code>를 사용해야합니다.</p>
<h2 id="Configuration-properties"><a href="#Configuration-properties" class="headerlink" title="Configuration properties"></a>Configuration properties</h2><p>애플리케이션 프로퍼티를 관리하는 가장 좋은 방법은 <code>@ConfigurationProperties</code>를 활용하는 것입니다. 변경할 수 없는 프로퍼티는 <a href="https://github.com/spring-projects/spring-boot/issues/8762" target="_blank" rel="external">아직 지원되지 않지만</a> Null이 허용되지 않는 프로퍼티를 처리해야하는 경우 <code>lateinit var</code>을 사용할 수 있습니다.</p>
<p><strong>src/main/kotlin/blog/BlogProperties.kt</strong><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@ConfigurationProperties(<span class="meta-string">"blog"</span>)</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlogProperties</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">lateinit</span> <span class="keyword">var</span> title: String</div><div class="line">  <span class="keyword">val</span> banner = Banner()</div><div class="line"></div><div class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Banner</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> title: String? = <span class="literal">null</span></div><div class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> content: String</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>그런 다음 <code>BlogApplication</code> 수준에서 사용하도록 설정합니다.</p>
<p><strong>src/main/kotlin/blog/BlogApplication.kt</strong><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SpringBootApplication</span></div><div class="line"><span class="meta">@EnableConfigurationProperties(BlogProperties::class)</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlogApplication</span> </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>IDE에서 이러한 사용자 정의 프로퍼티를 인식하기 위해 <a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#configuration-metadata-annotation-processor" target="_blank" rel="external">자신의 메타 데이터</a>를 생성하려면 <code>spring-boot-configuration-processor</code> 종속성을 사용하여 다음과 같이  <a href="https://kotlinlang.org/docs/reference/kapt.html" target="_blank" rel="external">Kapt가 설정되어야</a>합니다.</p>
<p><strong>build.gradle</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">apply plugin: &apos;kotlin-kapt&apos;</div><div class="line">dependencies &#123;</div><div class="line">  kapt(&quot;org.springframework.boot:spring-boot-configuration-processor&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>IntelliJ IDEA에서 :</p>
<ul>
<li>메뉴 File | Settings | Plugins | Spring Boot 에서 Spring Boot plugin이 활성화되어 있는지 확인하십시오.</li>
<li>Annotation 처리를 위해 메뉴의 File | Settings | Build, Execution, Deployement | Compiler | Annotation Processors | Enable annotation processing 을 활성화 합니다.</li>
<li><a href="https://youtrack.jetbrains.com/issue/KT-15040" target="_blank" rel="external">Kapt가 아직 IDEA에 통합되지 않았으므로</a> 메타 데이터를 생성하려면 <code>./gradlew kaptKotlin</code> 명령을 수동으로 실행해야합니다.</li>
</ul>
<p><code>application.properties</code>(Autocomplete, Validation 등)를 편집 할 때 사용자 정의 프로퍼티를 인식해야합니다.</p>
<p><strong>src/main/resources/application.properties</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">blog.title=Blog</div><div class="line">blog.banner.title=Warning</div><div class="line">blog.banner.content=The blog will be down tomorrow.</div></pre></td></tr></table></figure></p>
<p>그에 따라 템플릿과 컨트롤러를 수정합니다.</p>
<p><strong>src/main/resources/templates/blog.mustache</strong><br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&#123;&#123;&gt; header&#125;&#125;</div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"articles"</span>&gt;</span></div><div class="line"></div><div class="line">  &#123;&#123;#banner.title&#125;&#125;</div><div class="line">  <span class="tag">&lt;<span class="name">section</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">"banner"</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">"banner-title"</span>&gt;</span>&#123;&#123;banner.title&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">header</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"banner-content"</span>&gt;</span></div><div class="line">      &#123;&#123;banner.content&#125;&#125;</div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">section</span>&gt;</span></div><div class="line">  &#123;&#123;/banner.title&#125;&#125;</div><div class="line"></div><div class="line">  ...</div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line">&#123;&#123;&gt; footer&#125;&#125;</div></pre></td></tr></table></figure></p>
<p><strong>src/main/kotlin/blog/HtmlController.kt</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Controller</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HtmlController</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> repository: ArticleRepository,</div><div class="line">           <span class="keyword">private</span> <span class="keyword">val</span> markdownConverter: MarkdownConverter,</div><div class="line">           <span class="keyword">private</span> <span class="keyword">val</span> properties: BlogProperties) &#123;</div><div class="line"></div><div class="line">  <span class="meta">@GetMapping(<span class="meta-string">"/"</span>)</span></div><div class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">blog</span><span class="params">(model: <span class="type">Model</span>)</span></span>: String &#123;</div><div class="line">    model[<span class="string">"title"</span>] = properties.title</div><div class="line">    model[<span class="string">"banner"</span>] = properties.banner</div><div class="line">    model[<span class="string">"articles"</span>] = repository.findAllByOrderByAddedAtDesc().map &#123; it.render() &#125;</div><div class="line">    <span class="keyword">return</span> <span class="string">"blog"</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// ...</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>웹 애플리케이션을 다시 시작하고 <code>http://localhost:8080/</code>을 새로 고치면 블로그 홈페이지에 배너가 나타납니다.</p>
<h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>이제 이 예제 Kotlin 블로그 애플리케이션을 빌드했습니다. 소스 코드는 <a href="https://github.com/spring-guides/tut-spring-boot-kotlin" target="_blank" rel="external">Github에서 사용</a>할 수 있습니다. 특정 기능에 대한 자세한 내용은 <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/languages.html#kotlin" target="_blank" rel="external">Spring Framework</a> 및 <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-kotlin.html" target="_blank" rel="external">Spring Boot</a> 참고 문서를 읽어 보십시오.</p>
<hr>
<blockquote>
<p>이 내용은 나중에 참고하기 위해 Spring Boot 가이드 문서를 공부하며 정리한 내용입니다.<br>의역, 오역, 직역이 있을 수 있음을 알려드립니다.<br>This post is a translation of this original article <a href="http://spring.io/guides/tutorials/spring-boot-kotlin/" target="_blank" rel="external">Building web applications with Spring Boot and Kotlin</a></p>
</blockquote>
<h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Spring-Boot와-Kotlin으로-웹-애플리케이션-구축하기&quot;&gt;&lt;a href=&quot;#Spring-Boot와-Kotlin으로-웹-애플리케이션-구축하기&quot; class=&quot;headerlink&quot; title=&quot;Spring Boot와 Kotlin으로 
    
    </summary>
    
      <category term="Kotlin" scheme="http://infoscis.github.io/categories/Kotlin/"/>
    
      <category term="SpringBoot" scheme="http://infoscis.github.io/categories/Kotlin/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="http://infoscis.github.io/tags/SpringBoot/"/>
    
      <category term="Kotlin" scheme="http://infoscis.github.io/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Angular Observable &amp; RxJS</title>
    <link href="http://infoscis.github.io/2018/08/08/angular-observables-and-rxjs/"/>
    <id>http://infoscis.github.io/2018/08/08/angular-observables-and-rxjs/</id>
    <published>2018-08-08T14:38:02.000Z</published>
    <updated>2018-08-08T14:44:11.432Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Observable"><a href="#Observable" class="headerlink" title="Observable"></a>Observable</h1><p><em>Observable</em>은 Application의 Publisher와 Subscriber 사이의 메시지 전달을 지원하는 기능을 제공합니다. <em>Observable</em>은 이벤트 처리, 비동기 프로그래밍 및 다중 값 처리와 관련된 다른 기술에 비해 상당한 이점을 제공합니다.</p>
<p><em>Observable</em>은 선언적입니다. 즉, 여러분이 값을 게시하는 함수를 정의해도, Consumer가 구독 하기전까지 실행되지 않습니다. 그리고 구독된 Consumer는 함수가 완료되거나 구독을 취소 할 때까지 알림을 받습니다.</p>
<p><em>Observable</em>은 컨텍스트에 따라 리터럴(Literal), 메시지(Message) 또는 이벤트(Event)등 여러 값을 전달할 수 있습니다. 값을 수신하기 위한 API는 값이 동기적 또는 비동기적으로 전달되는지 여부에 관계없이 동일합니다. 설정 및 해체 로직은 모두 <em>Observable</em>에 의해 처리되고, 응용 프로그램에서는 값을 소비하기 위해 구독하고, 완료되면 구독을 취소하는 것에 신경을 써야 합니다. Stream이 Keystroke인지, HTTP 응답인지, 인터벌 타이머인지 여부와 관계없이 값을 구독하고 멈추는 인터페이스는 동일합니다.</p>
<p>이러한 이점 때문에 <em>Observable</em>은 Angular 내에서 광범위하게 사용되며 앱 개발에도 권장됩니다.</p>
<h2 id="기본-사용법-및-용어"><a href="#기본-사용법-및-용어" class="headerlink" title="기본 사용법 및 용어"></a>기본 사용법 및 용어</h2><p>Publisher는 <em>subscriber</em> 함수를 정의하는 <em>Observable</em> 인스턴스를 만듭니다. 이 함수는 Consumer가 <code>subscribe()</code>함수를 호출할 때 실행 됩니다. <em>subscriber</em> 함수는 게시될 값 또는 메시지를 얻거나 생성하는 방법을 정의합니다. </p>
<p>생성한 <em>Observable</em> 객체를 실행하고 알림 수신을 시작하려면 <em>observer</em>를 전달하여 <code>subscribe()</code> 메서드를 호출합니다. <em>observer</em>는 여러분이 수신한 알림을 처리하는 핸드러를 정의한 JavaScript 객체입니다. <code>subscribe()</code> 메서드는 Subscripotion 객체를 반환하는데, 이 객체에는 알림 수신을 중지하기 위해 호출하는 <code>unsubscribe()</code> 메서드가 있습니다.</p>
<p>다음은 Geolocation 업데이트 정보 제공에 <em>Observable</em>을 어떻게 사용할 수 있지 보여줌으로써 기본 사용 모델을 설명하는 예제입니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Consumer가 구독할때 Geolocation 변경사항을 수신하는 *Observable*을 생성합니다.</span></div><div class="line"><span class="keyword">const</span> locations = <span class="keyword">new</span> Observable(<span class="function">(<span class="params">observer</span>) =&gt;</span> &#123;</div><div class="line">  <span class="comment">// next와 error 콜백을 가져옵니다. 이것은 Consumer가 구독할때 넘겨줍니다.</span></div><div class="line">  <span class="keyword">const</span> &#123;next, error&#125; = observer;</div><div class="line">  <span class="keyword">let</span> watchId;</div><div class="line"> </div><div class="line">  <span class="comment">// 게시할 값을 제공하는 간단한 geolocation API를 확인</span></div><div class="line">  <span class="keyword">if</span> (<span class="string">'geolocation'</span> <span class="keyword">in</span> navigator) &#123;</div><div class="line">    watchId = navigator.geolocation.watchPosition(next, error);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    error(<span class="string">'Geolocation not available'</span>);</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="comment">// Consumer가 구독을 중지하면 다음 구독을 위해 준비한 데이터를 정리합니다.</span></div><div class="line">  <span class="keyword">return</span> &#123;unsubscribe() &#123; navigator.geolocation.clearWatch(watchId); &#125;&#125;;</div><div class="line">&#125;);</div><div class="line"> </div><div class="line"><span class="comment">// 변경사항 수신을 시작하기 위해 subscribe()를 호출합니다.</span></div><div class="line"><span class="keyword">const</span> locationsSubscription = locations.subscribe(&#123;</div><div class="line">  next(position) &#123; <span class="built_in">console</span>.log(<span class="string">'Current Position: '</span>, position); &#125;,</div><div class="line">  error(msg) &#123; <span class="built_in">console</span>.log(<span class="string">'Error Getting Location: '</span>, msg); &#125;</div><div class="line">&#125;);</div><div class="line"> </div><div class="line"><span class="comment">// 10초후에 수신을 중지합니다.</span></div><div class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123; locationsSubscription.unsubscribe(); &#125;, <span class="number">10000</span>);</div></pre></td></tr></table></figure>
<h2 id="Observer-정의"><a href="#Observer-정의" class="headerlink" title="Observer 정의"></a>Observer 정의</h2><p><em>Observable</em> 알람을 수신하기 위한 핸들러는 <code>Observer</code> 인터페이스를 구현합니다. 이것은 <em>Observable</em>이 보낼수 있는 3가지 알람 타입을 처리할 수 있는 콜백 메서드가 정의된 객체입니다.</p>
<table>
<thead>
<tr>
<th></th>
<th>알람 종류</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>next</code></td>
<td>필수. 전달된 각각의 값을 처리하는 핸들러. 실행 시작후 0번 또는 그 이상 호출됩니다.</td>
</tr>
<tr>
<td><code>error</code></td>
<td>선택사항. 오류 알람에 대한 처리 핸들러. 오류로 인해 <em>Observable</em> 인스턴스의 실행이 중지됩니다.</td>
</tr>
<tr>
<td><code>complete</code></td>
<td>선택사항. 실행 완료 알람에 대한 처리 핸들러. 지연된 값은 실행 완료 후에도 계속해서 <code>next</code> 핸들러로 전달될 수 있습니다.</td>
</tr>
</tbody>
</table>
<p><em>Observable</em> 객체는 이러한 핸들러의 조합을 정의할 수 있습니다. 만약 알람 종류에 대한 핸들러를 제공하지 않으면, <em>observer</em>는 해당 종류의 알람을 무시합니다.</p>
<h2 id="구독-Subscribing"><a href="#구독-Subscribing" class="headerlink" title="구독(Subscribing)"></a>구독(Subscribing)</h2><p><code>Observable</code> 인스턴스는 누군가가 구독할 때만 값을 게시 시작합니다. 여러분은 알람을 수신받을 <em>observer</em> 객체를 <code>Observable</code> 인스턴스의 <code>subscribe()</code> 메서드에 넘겨 구독을 시작합니다.</p>
<blockquote>
<p>어떻게 구독(Subscribing)이 작동하는지 보여주기 위해 새로운 <em>Observable</em>을 만듭니다. 새로운 인스턴스를 생성하기 위해 사용할 수 있는 생성자가 있지만, 설명을 위해 <em>Observable</em> 클래스에서 자주 사용하는 간단한 <em>Observable</em>을 만드는 몇가지 정적 메서드를 사용할 수 있습니다.</p>
<ul>
<li>Observable.of(…items)-인수로 제공된 값을 동기적으로 전달하는 <code>Observable</code> 인스턴스를 반환합니다.</li>
<li>Observable.from(iterable)-인수를 <code>Observable</code> 인스턴스로 변경합니다. 일반적으로 이 메서드는 Array를 <em>Observable</em>로 변환할 때 사용합니다.</li>
</ul>
</blockquote>
<p>다음은 수신받은 메시지를 console에 기록하는 간단한 <em>observer</em>를 이용하여 <em>Observable</em>을 생성하고 구독하는 예제입니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 값 3개를 발생시키는 간단한 observable 생성</span></div><div class="line"><span class="keyword">const</span> myObservable = Observable.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</div><div class="line"></div><div class="line"><span class="comment">// observer 객체 생성</span></div><div class="line"><span class="keyword">const</span> myObserver = &#123;</div><div class="line">  next: <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Observer got a next value: '</span> + x),</div><div class="line">  error: <span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.error(<span class="string">'Observer got an error: '</span> + err),</div><div class="line">  complete: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Observer got a complete notification'</span>),</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// observer 객체를 이용해 실행시킴</span></div><div class="line">myObservable.subscribe(myObserver);</div><div class="line"><span class="comment">// Logs:</span></div><div class="line"><span class="comment">// Observer got a next value: 1</span></div><div class="line"><span class="comment">// Observer got a next value: 2</span></div><div class="line"><span class="comment">// Observer got a next value: 3</span></div><div class="line"><span class="comment">// Observer got a complete notification</span></div></pre></td></tr></table></figure>
<p>또는 <code>subscribe()</code> 메서드는 <code>next</code>, <code>error</code> 및 <code>complete</code> 핸들러에 대한 콜백 함수를 인수에서 정의하는 것을 허용합니다. 예를 들어, 다음 <code>subscribe()</code> 호출은 사전 정의된 <em>observer</em>를 지정하여 호출하는 것과 똑같습니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">myObservable.subscribe(</div><div class="line">  <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Observer got a next value: '</span> + x),</div><div class="line">  <span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.error(<span class="string">'Observer got an error: '</span> + err),</div><div class="line">  <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Observer got a complete notification'</span>)</div><div class="line">);</div></pre></td></tr></table></figure>
<p>위의 두가지 방법 모두 <code>next</code>는 필수사항이고, <code>error</code>와 <code>complete</code>는 선택사항입니다.</p>
<p><code>next</code> 메서드는 컨텍스트에 따라 메시지 문자열, 이벤트 객체, 숫자값 또는 구조체를 수신 받을수 있습니다. 일반적으로 우리는 <em>Stream</em>에 의해 <em>Observable</em>로 게시된 데이터를 참조합니다. 모든 타입은 <em>Observable</em>로 표시될 수 있으며, 해당 값은 <em>Stream</em>으로 게시됩니다.</p>
<h2 id="Observable-생성"><a href="#Observable-생성" class="headerlink" title="Observable 생성"></a>Observable 생성</h2><p><code>Observable</code> 생성자를 사용하여 모든 타입의 <em>Observable Stream</em>을 만듭니다. 생성자는 <em>Observable</em>의 <code>subscribe()</code> 메서드가 호출될 때 실행시킬 <em>subscriber</em> 함수를 인수로 받습니다. <em>subscriber</em> 함수는 <em>observer</em> 객체를 받고, <em>observer</em>의 <code>next</code> 메서드에 값을 게시할 수 있습니다.</p>
<p>예를 들어 <code>Observable.of(1, 2, 3)</code>에 해당하는 <em>Observable</em> 객체를 만들려면 다음과 같이할 수 있습니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 이 함수는 subscribe()가 호출될 때 실행됩니다.</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sequenceSubscriber</span>(<span class="params">observer</span>) </span>&#123;</div><div class="line">  <span class="comment">// 순차적으로 1, 2, 그리고 3 을 전달하 후 완료(complete) 합니다.</span></div><div class="line">  observer.next(<span class="number">1</span>);</div><div class="line">  observer.next(<span class="number">2</span>);</div><div class="line">  observer.next(<span class="number">3</span>);</div><div class="line">  observer.complete();</div><div class="line"> </div><div class="line">  <span class="comment">// 값이 순차적으로 전달되기 때문에 unsubscribe 함수는 아무것도 할 필요가 없습니다.</span></div><div class="line">  <span class="keyword">return</span> &#123;unsubscribe() &#123;&#125;&#125;;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// 위의 시퀀스를 전달할 새로운 Observable을 생성합니다.</span></div><div class="line"><span class="keyword">const</span> sequence = <span class="keyword">new</span> Observable(sequenceSubscriber);</div><div class="line"> </div><div class="line"><span class="comment">// Observable을 실행 시키고 각 알람의 결과를 출력합니다.</span></div><div class="line">sequence.subscribe(&#123;</div><div class="line">  next(num) &#123; <span class="built_in">console</span>.log(num); &#125;,</div><div class="line">  complete() &#123; <span class="built_in">console</span>.log(<span class="string">'Finished sequence'</span>); &#125;</div><div class="line">&#125;);</div><div class="line"> </div><div class="line"><span class="comment">// Logs:</span></div><div class="line"><span class="comment">// 1</span></div><div class="line"><span class="comment">// 2</span></div><div class="line"><span class="comment">// 3</span></div><div class="line"><span class="comment">// Finished sequence</span></div></pre></td></tr></table></figure>
<p>이 예를 좀 더 발전시키기 위해, 우리는 이벤트를 게시하는 <em>Observable</em>을 생성할 수 있습니다. 이 예제에서 <em>subscriber</em>함수가 인라인으로 정의 됩니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fromEvent</span>(<span class="params">target, eventName</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Observable(<span class="function">(<span class="params">observer</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">const</span> handler = <span class="function">(<span class="params">e</span>) =&gt;</span> observer.next(e);</div><div class="line"> </div><div class="line">    <span class="comment">// target에 Event 핸들러를 붙입니다.</span></div><div class="line">    target.addEventListener(eventName, handler);</div><div class="line"> </div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      <span class="comment">// target에서 이벤트 핸들러를 제거합니다.</span></div><div class="line">      target.removeEventListener(eventName, handler);</div><div class="line">    &#125;;</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>이제 이 함수를 keydown 이벤트를 게시하는 <em>Observable</em>을 생성하는데 사용할 수 있습니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> ESC_KEY = <span class="number">27</span>;</div><div class="line"><span class="keyword">const</span> nameInput = <span class="built_in">document</span>.getElementById(<span class="string">'name'</span>) <span class="keyword">as</span> HTMLInputElement;</div><div class="line"></div><div class="line"><span class="keyword">const</span> subscription = fromEvent(nameInput, <span class="string">'keydown'</span>)</div><div class="line">  .subscribe(<span class="function">(<span class="params">e: KeyboardEvent</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">if</span> (e.keyCode === ESC_KEY) &#123;</div><div class="line">      nameInput.value = <span class="string">''</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;);</div></pre></td></tr></table></figure>
<h2 id="여러-Comsumer에게-동시에-보내기-Multicasting"><a href="#여러-Comsumer에게-동시에-보내기-Multicasting" class="headerlink" title="여러 Comsumer에게 동시에 보내기(Multicasting)"></a>여러 Comsumer에게 동시에 보내기(Multicasting)</h2><p>일반적인 <em>Observable</em> 생성은, 구독하는 각각 <em>observer</em>에 대해 독립적으로 실행 됩니다. <em>observer</em>가 구독할 때 <em>Observable</em>은 이벤트 핸들러를 연결하고 그 <em>observer</em>에 값을 전달합니다. 두 번째 <em>observer</em>가 구독하면 <em>Observable</em>은 새로운 이벤트 핸들러에 연결하고 별도의 실행으로 두 번째 <em>observer</em>에 값을 전달합니다.</p>
<p>Document 객체에 대한 클릭을 <em>Observable</em>하는 경우와 같이 각 <em>subscriber</em>가 독립된 실행으로 시작하는 대신에 이미 값이 발행되고 있다고 할지라도 각 구독자가 같은 값을 갖기를 원할 수도 있습니다.</p>
<p><em>Multicasting</em>은 단일 실행으로 여러 구독자 목록에 브로드 캐스트하는 기능입니다. <em>Multicasting observable</em>을 활용하면 Document에 여러개의 수신자(Listener)를 등록할 필요가 없고, 첫 번째 수신자(Listener)를 재사용하여 각 구독자에 값을 보냅니다.</p>
<p><em>Observable</em>을 생성할 때 <em>Observable</em>을 어떻게 사용 할지, 그리고 값을 Multicast 할지 말지를 결정합니다.</p>
<p>아래의 예제는 1부터 3까지 카운트 하며, 각 숫자가 발행된 후 1초가 지연됩니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sequenceSubscriber</span>(<span class="params">observer</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> seq = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line">  <span class="keyword">let</span> timeoutId;</div><div class="line"> </div><div class="line">  <span class="comment">// 배열 끝에 도달 할 때까지 초당 하나의 값을 게시하는 숫자 배열을 따라 실행합니다.</span></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">doSequence</span>(<span class="params">arr, idx</span>) </span>&#123;</div><div class="line">    timeoutId = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      observer.next(arr[idx]);</div><div class="line">      <span class="keyword">if</span> (idx === arr.length - <span class="number">1</span>) &#123;</div><div class="line">        observer.complete();</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        doSequence(arr, idx++);</div><div class="line">      &#125;</div><div class="line">    &#125;, <span class="number">1000</span>);</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  doSequence(seq, <span class="number">0</span>);</div><div class="line"> </div><div class="line">  <span class="comment">// Unsubscribe 할때 timeout을 취소 합니다.</span></div><div class="line">  <span class="keyword">return</span> &#123;unsubscribe() &#123;</div><div class="line">    clearTimeout(timeoutId);</div><div class="line">  &#125;&#125;;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// 위에 정의한 시퀀스를 전달하는 Observable을 새로 생성합니다.</span></div><div class="line"><span class="keyword">const</span> sequence = <span class="keyword">new</span> Observable(sequenceSubscriber);</div><div class="line"> </div><div class="line">sequence.subscribe(&#123;</div><div class="line">  next(num) &#123; <span class="built_in">console</span>.log(num); &#125;,</div><div class="line">  complete() &#123; <span class="built_in">console</span>.log(<span class="string">'Finished sequence'</span>); &#125;</div><div class="line">&#125;);</div><div class="line"> </div><div class="line"><span class="comment">// 출력 결과:</span></div><div class="line"><span class="comment">// (at 1 second): 1</span></div><div class="line"><span class="comment">// (at 2 seconds): 2</span></div><div class="line"><span class="comment">// (at 3 seconds): 3</span></div><div class="line"><span class="comment">// (at 3 seconds): Finished sequence</span></div></pre></td></tr></table></figure>
<p>두번 구독하면 매초 값이 게시되는 두개의 분리된 Stream이 생성되고, 아래와 같이 보여집니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 구독을 시작합니다. 1초후 값이 게시 됩니다.</span></div><div class="line">sequence.subscribe(&#123;</div><div class="line">  next(num) &#123; <span class="built_in">console</span>.log(<span class="string">'1st subscribe: '</span> + num); &#125;,</div><div class="line">  complete() &#123; <span class="built_in">console</span>.log(<span class="string">'1st sequence finished.'</span>); &#125;</div><div class="line">&#125;);</div><div class="line"> </div><div class="line"><span class="comment">// 0.5초 후에 다시 구독합니다.</span></div><div class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  sequence.subscribe(&#123;</div><div class="line">    next(num) &#123; <span class="built_in">console</span>.log(<span class="string">'2nd subscribe: '</span> + num); &#125;,</div><div class="line">    complete() &#123; <span class="built_in">console</span>.log(<span class="string">'2nd sequence finished.'</span>); &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;, <span class="number">500</span>);</div><div class="line"> </div><div class="line"><span class="comment">// 출력:</span></div><div class="line"><span class="comment">// (at 1 second): 1st subscribe: 1</span></div><div class="line"><span class="comment">// (at 1.5 seconds): 2nd subscribe: 1</span></div><div class="line"><span class="comment">// (at 2 seconds): 1st subscribe: 2</span></div><div class="line"><span class="comment">// (at 2.5 seconds): 2nd subscribe: 2</span></div><div class="line"><span class="comment">// (at 3 seconds): 1st subscribe: 3</span></div><div class="line"><span class="comment">// (at 3 seconds): 1st sequence finished</span></div><div class="line"><span class="comment">// (at 3.5 seconds): 2nd subscribe: 3</span></div><div class="line"><span class="comment">// (at 3.5 seconds): 2nd sequence finished</span></div></pre></td></tr></table></figure>
<p><em>Observable</em>을 Multicasting 으로 변경하면 다음과 같습니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">multicastSequenceSubscriber</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> seq = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line">  <span class="comment">// 각 observer를 추적합니다.(모든 활성 구독마다 하나씩).</span></div><div class="line">  <span class="keyword">const</span> observers = [];</div><div class="line">  <span class="comment">// 하나의 value set만 생성되고 각 subscriber로 Multicast 되기 때문에 하나의 timeoutId만 있습니다.</span></div><div class="line">  <span class="keyword">let</span> timeoutId;</div><div class="line"> </div><div class="line">  <span class="comment">// subscribe() 함수가 invoke 될때 실행 되는 subscriber 함수를 리턴합니다.</span></div><div class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">observer</span>) =&gt;</span> &#123;</div><div class="line">    observers.push(observer);</div><div class="line">    <span class="comment">// 첫 번째 구독인 경우 시퀀스를 시작합니다.</span></div><div class="line">    <span class="keyword">if</span> (observers.length === <span class="number">1</span>) &#123;</div><div class="line">      timeoutId = doSequence(&#123;</div><div class="line">        next(val) &#123;</div><div class="line">          <span class="comment">// observer를 순회하면서 모든 구독에 알람을 줍니다.</span></div><div class="line">          observers.forEach(<span class="function"><span class="params">obs</span> =&gt;</span> obs.next(val));</div><div class="line">        &#125;,</div><div class="line">        complete() &#123;</div><div class="line">          <span class="comment">// 모든 complete 콜백에 알람을 줍니다.</span></div><div class="line">          observers.forEach(<span class="function"><span class="params">obs</span> =&gt;</span> obs.complete());</div><div class="line">        &#125;</div><div class="line">      &#125;, seq, <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">      unsubscribe() &#123;</div><div class="line">        <span class="comment">// observer 배열에서 제거합니다. 그리고 더이상 알람을 받지 않습니다.</span></div><div class="line">        observers.splice(observers.indexOf(observer), <span class="number">1</span>);</div><div class="line">        <span class="comment">// Listener가 없을 경우 정리합니다.</span></div><div class="line">        <span class="keyword">if</span> (observers.length === <span class="number">0</span>) &#123;</div><div class="line">          clearTimeout(timeoutId);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;;</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// 배열을 순회하면서 배열의 끝에 다다를 때까지 1초에 하나의 값을 게시합니다.</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSequence</span>(<span class="params">observer, arr, idx</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    observer.next(arr[idx]);</div><div class="line">    <span class="keyword">if</span> (idx === arr.length - <span class="number">1</span>) &#123;</div><div class="line">      observer.complete();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      doSequence(observer, arr, idx++);</div><div class="line">    &#125;</div><div class="line">  &#125;, <span class="number">1000</span>);</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// 위의 시퀀스를 전달하는 새로운 Observable을 생성합니다.</span></div><div class="line"><span class="keyword">const</span> multicastSequence = <span class="keyword">new</span> Observable(multicastSequenceSubscriber);</div><div class="line"> </div><div class="line"><span class="comment">// 구독을 시작하고 1초후에 게시를 시작합니다.</span></div><div class="line">multicastSequence.subscribe(&#123;</div><div class="line">  next(num) &#123; <span class="built_in">console</span>.log(<span class="string">'1st subscribe: '</span> + num); &#125;,</div><div class="line">  complete() &#123; <span class="built_in">console</span>.log(<span class="string">'1st sequence finished.'</span>); &#125;</div><div class="line">&#125;);</div><div class="line"> </div><div class="line"><span class="comment">// 1.5초 후에 구독을 다시 시작 합니다. (첫 값은 받지 못합니다.)</span></div><div class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  multicastSequence.subscribe(&#123;</div><div class="line">    next(num) &#123; <span class="built_in">console</span>.log(<span class="string">'2nd subscribe: '</span> + num); &#125;,</div><div class="line">    complete() &#123; <span class="built_in">console</span>.log(<span class="string">'2nd sequence finished.'</span>); &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;, <span class="number">1500</span>);</div><div class="line"> </div><div class="line"><span class="comment">// 출력:</span></div><div class="line"><span class="comment">// (at 1 second): 1st subscribe: 1</span></div><div class="line"><span class="comment">// (at 2 seconds): 1st subscribe: 2</span></div><div class="line"><span class="comment">// (at 2 seconds): 2nd subscribe: 2</span></div><div class="line"><span class="comment">// (at 3 seconds): 1st subscribe: 3</span></div><div class="line"><span class="comment">// (at 3 seconds): 1st sequence finished</span></div><div class="line"><span class="comment">// (at 3 seconds): 2nd subscribe: 3</span></div><div class="line"><span class="comment">// (at 3 seconds): 2nd sequence finished</span></div></pre></td></tr></table></figure>
<blockquote>
<p><em>Multicast Observable</em>은 조금더 많은 설정을 필요로 하지만, 어떤 어플리케이션에서는 이러한 사용법이 훨씬 더 유용할 수 있습니다. 나중에 Multicasting 프로세스를 간소화하는 도구를 살펴볼 예정이며, 또한 임의의 <em>Observable</em>을 가져와 Multicasting 할 수도 있습니다.</p>
</blockquote>
<h2 id="오류-처리"><a href="#오류-처리" class="headerlink" title="오류 처리"></a>오류 처리</h2><p><em>Observable</em>은 값을 동기적으로 생성하기 때문에 오류를 잡는데(catch) try/catch가 효율적이지 않습니다. 대신에 <em>observer</em>의 <code>error</code> 콜백을 지정하여 오류를 처리할 수 있습니다. 오류가 발생하면 <em>Observable</em>이 구독을 정리하고 값 생성을 중지합니다. <em>Observable</em>은 값을 생성하거나 (<code>next</code> 콜백을 호출할 수 있습니다.) <code>complete</code> 또는<code>error</code> 콜백을 호출하여 완료할 수 있습니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">myObservable.subscribe(&#123;</div><div class="line">  next(num) &#123; <span class="built_in">console</span>.log(<span class="string">'Next num: '</span> + num)&#125;,</div><div class="line">  error(err) &#123; <span class="built_in">console</span>.log(<span class="string">'Received an errror: '</span> + err)&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>오류 처리(특히 오류 복구)에 대해서는 다음 섹션에서 자세히 설명합니다.</p>
<h1 id="RxJS-라이브러리"><a href="#RxJS-라이브러리" class="headerlink" title="RxJS 라이브러리"></a>RxJS 라이브러리</h1><p>반응형 프로그래밍(Reactive programming)은 데이터 스트림 및 변경 전파와 관련된 비동기 프로그래밍 패러다임입니다.  RxJS (Reactive Extensions for JavaScript)는 비동기 또는 콜백 기반 코드를 보다 쉽게 작성할 수 있도록 <em>Observable</em>을 이용한 반응형 프로그래밍 라이브러리 입니다.</p>
<p>RxJS는 <code>Observable</code> 타입 구현을 제공합니다. 이 구현은 <code>Observable</code>이 언어(Language)의 일부 또는 브라우저가 지원할 때까지 필요합니다. 이 라이브러리는 <code>Observable</code> 객체를 생성하고 작업하기 위한 유틸리티 함수도 제공합니다. 이 유틸리티 함수는 다음과 같은 경우에 사용할 수 있습니다.</p>
<ul>
<li>기존 코드를 <em>Observable</em>의 비동기 작업으로 변환</li>
<li>스트림의 값 순회</li>
<li>값을 다른 타입으로 매핑</li>
<li>스트림 필터링</li>
<li>여러 스트림 작성</li>
</ul>
<h2 id="Observable-생성-함수"><a href="#Observable-생성-함수" class="headerlink" title="Observable 생성 함수"></a>Observable 생성 함수</h2><p>RxJS는 새로운 <em>Observable</em>을 생성하는데 사용할 수 있는 몇가지 함수를 제공합니다. 이러한 함수는 Event, Timer , Promise등으로 부터 <em>Observable</em> 객체를 만드는 프로세스를 단순화 할 수 있습니다.</p>
<p><strong>Promise로 부터 Observable 생성</strong><br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; fromPromise &#125; <span class="keyword">from</span> <span class="string">'rxjs'</span>;</div><div class="line"></div><div class="line"><span class="comment">// Promise에서 Observable을 만듭니다.</span></div><div class="line"><span class="keyword">const</span> data = fromPromise(fetch(<span class="string">'/api/endpoint'</span>));</div><div class="line"><span class="comment">// 구독하여 비동기적으로 결과를 수신 시작</span></div><div class="line">data.subscribe(&#123;</div><div class="line"> next(response) &#123; <span class="built_in">console</span>.log(response); &#125;,</div><div class="line"> error(err) &#123; <span class="built_in">console</span>.error(<span class="string">'Error: '</span> + err); &#125;,</div><div class="line"> complete() &#123; <span class="built_in">console</span>.log(<span class="string">'Completed'</span>); &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p><strong>Counter로 부터 Observable 생성</strong><br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; interval &#125; <span class="keyword">from</span> <span class="string">'rxjs'</span>;</div><div class="line"></div><div class="line"><span class="comment">// 주기적으로 값을 게시하는 Observable 생성</span></div><div class="line"><span class="keyword">const</span> secondsCounter = interval(<span class="number">1000</span>);</div><div class="line"><span class="comment">// 구독하여 값의 게시를 시작</span></div><div class="line">secondsCounter.subscribe(<span class="function"><span class="params">n</span> =&gt;</span></div><div class="line">  <span class="built_in">console</span>.log(<span class="string">`It's been <span class="subst">$&#123;n&#125;</span> seconds since subscribing!`</span>));</div></pre></td></tr></table></figure></p>
<p><strong>이벤트(Event)로 부터 Observable 생성</strong><br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; fromEvent &#125; <span class="keyword">from</span> <span class="string">'rxjs'</span>;</div><div class="line"> </div><div class="line"><span class="keyword">const</span> el = <span class="built_in">document</span>.getElementById(<span class="string">'my-element'</span>);</div><div class="line"> </div><div class="line"><span class="comment">// 마우스 이동을 게시하는 Observable 생성</span></div><div class="line"><span class="keyword">const</span> mouseMoves = fromEvent(el, <span class="string">'mousemove'</span>);</div><div class="line"> </div><div class="line"><span class="comment">// 구독하여 마우스 이동 이벤트를 수신 시작</span></div><div class="line"><span class="keyword">const</span> subscription = mouseMoves.subscribe(<span class="function">(<span class="params">evt: MouseEvent</span>) =&gt;</span> &#123;</div><div class="line">  <span class="comment">// 마우스 움직임 좌표를 로깅</span></div><div class="line">  <span class="built_in">console</span>.log(<span class="string">`Coords: <span class="subst">$&#123;evt.clientX&#125;</span> X <span class="subst">$&#123;evt.clientY&#125;</span>`</span>);</div><div class="line"> </div><div class="line">  <span class="comment">// 마우스가 화면의 왼쪽 상단에 있을때 구독을 중지하여 마우스 이동정보 수신을 중지한다.</span></div><div class="line">  <span class="keyword">if</span> (evt.clientX &lt; <span class="number">40</span> &amp;&amp; evt.clientY &lt; <span class="number">40</span>) &#123;</div><div class="line">    subscription.unsubscribe();</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p><strong>AJAX 요청을 생성하는 Observable 생성</strong><br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; ajax &#125; <span class="keyword">from</span> <span class="string">'rxjs/ajax'</span>;</div><div class="line"></div><div class="line"><span class="comment">// AJAX 요청을 생성하는 Observable 생성</span></div><div class="line"><span class="keyword">const</span> apiData = ajax(<span class="string">'/api/data'</span>);</div><div class="line"><span class="comment">// 구독하여 요청을 생성</span></div><div class="line">apiData.subscribe(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res.status, res.response));</div></pre></td></tr></table></figure></p>
<h2 id="연산자-Operator"><a href="#연산자-Operator" class="headerlink" title="연산자(Operator)"></a>연산자(Operator)</h2><p>연산자는 컬렉션의 정교한 조작을 가능하게하는 <em>Observable</em>의 기반이 되는 함수입니다. 예를 들어, RxJS는 <code>map()</code>, <code>filter()</code>, <code>concat()</code> 및 <code>flatMap()</code>과 같은 연산자를 정의합니다. 연산자는 설정 옵션을 사용하고 원본 <em>Observable</em>을 사용하는 함수를 반환합니다. </p>
<p>반환된 함수를 실행할 때, 연산자는 원본 <em>Observable</em>에서 생성된 값을 주시하여, 변환하고 변환된 값의 새로운 <em>Observable</em> 값을 반환합니다. 다음은 간단한 예입니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; map &#125; <span class="keyword">from</span> <span class="string">'rxjs/operators'</span>;</div><div class="line"> </div><div class="line"><span class="keyword">const</span> nums = of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</div><div class="line"> </div><div class="line"><span class="keyword">const</span> squareValues = map(<span class="function">(<span class="params">val: <span class="built_in">number</span></span>) =&gt;</span> val * val);</div><div class="line"><span class="keyword">const</span> squaredNums = squareValues(nums);</div><div class="line"> </div><div class="line">squaredNums.subscribe(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(x));</div><div class="line"> </div><div class="line"><span class="comment">// Logs</span></div><div class="line"><span class="comment">// 1</span></div><div class="line"><span class="comment">// 4</span></div><div class="line"><span class="comment">// 9</span></div></pre></td></tr></table></figure>
<p><em>pipe</em>를 사용하여 연산자를 함께 연결할 수 있습니다. <em>pipe</em>를 사용하면 여러 함수를 단일 함수로 결합할 수 있습니다. <code>pipe()</code> 함수는 결합하려는 함수를 인수로 받고, 실행될 때 작성된 순서대로 함수를 실행하는 새로운 함수를 반환합니다.</p>
<p><em>Observable</em>에 적용되는 연산자 집합은 레시피입니다. 즉, 원하는 값을 생성하기 위한 지침 집합입니다. 레시피 자체적으로는 아무 것도하지 않습니다. 레시피를 통해 결과를 얻으려면 <code>subscribe()</code>를 호출 해야합니다.</p>
<p>아래 예제를 보겠습니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; filter, map &#125; <span class="keyword">from</span> <span class="string">'rxjs/operators'</span>;</div><div class="line"> </div><div class="line"><span class="keyword">const</span> nums = of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</div><div class="line"> </div><div class="line"><span class="comment">// Observable을 받는 함수를 생성합니다.</span></div><div class="line"><span class="keyword">const</span> squareOddVals = pipe(</div><div class="line">  filter(<span class="function"><span class="params">n</span> =&gt;</span> n % <span class="number">2</span>),</div><div class="line">  map(<span class="function"><span class="params">n</span> =&gt;</span> n * n)</div><div class="line">);</div><div class="line"> </div><div class="line"><span class="comment">// filter와 map 함수를 실행시키는 Observable을 생성합니다.</span></div><div class="line"><span class="keyword">const</span> squareOdd = squareOddVals(nums);</div><div class="line"> </div><div class="line"><span class="comment">// 구독하여 결합된 함수를 실행합니다.</span></div><div class="line">squareOdd.subscribe(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(x));</div></pre></td></tr></table></figure>
<p><code>pipe()</code> 함수는 RxJS <code>Observable</code>의 메서드이기도 하므로 아래와 같이 짧은 표현식을 사용하여 동일한 연산을 정의할 수 있습니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; filter, map &#125; <span class="keyword">from</span> <span class="string">'rxjs/operators'</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> squareOdd = of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</div><div class="line">  .pipe(</div><div class="line">    filter(<span class="function"><span class="params">n</span> =&gt;</span> n % <span class="number">2</span> !== <span class="number">0</span>),</div><div class="line">    map(<span class="function"><span class="params">n</span> =&gt;</span> n * n)</div><div class="line">  );</div><div class="line"></div><div class="line"><span class="comment">// 구독하여 값을 받습니다.</span></div><div class="line">squareOdd.subscribe(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(x));</div></pre></td></tr></table></figure>
<h2 id="일반-연산자"><a href="#일반-연산자" class="headerlink" title="일반 연산자"></a>일반 연산자</h2><p>RxJS는 많은 연산자(150개 이상)를 제공하지만 몇몇 연산자만 자주 사용됩니다. 다음은 일반 연산자 목록입니다. 사용 예는 RxJS 문서의 <a href="https://github.com/btroncone/learn-rxjs/blob/master/operators/complete.md" target="_blank" rel="external">RxJS 5 연산자 사용 예제</a>를 참조하십시오.</p>
<blockquote>
<p>Angular app의 경우 체인(chaining)을 연결하는 대신 연산자를 파이프(pipe)와 결합하는 것이 더 좋습니다. 하지만 체인(chaining)은 많은 RxJS 예제에서 사용됩니다.</p>
</blockquote>
<table>
<thead>
<tr>
<th></th>
<th>영역</th>
<th>연산자들</th>
</tr>
</thead>
<tbody>
<tr>
<td>생성</td>
<td><code>from</code> , <code>fromPromise</code> , <code>fromEvent</code> , <code>of</code></td>
</tr>
<tr>
<td>결합</td>
<td><code>combineLatest</code> , <code>concat</code> , <code>merge</code> , <code>startWith</code> , <code>withLatestFrom</code> , <code>zip</code></td>
</tr>
<tr>
<td>필터링</td>
<td><code>debounceTime</code> , <code>distinctUntilChanged</code> , <code>filter</code> , <code>take</code> , <code>takeUntil</code></td>
</tr>
<tr>
<td>변환</td>
<td><code>bufferTime</code> , <code>concatMap</code> , <code>map</code> , <code>mergeMap</code> , <code>scan</code> , <code>switchMap</code></td>
</tr>
<tr>
<td>유틸리티</td>
<td><code>tap</code></td>
</tr>
<tr>
<td>멀티캐스팅</td>
<td><code>share</code></td>
</tr>
</tbody>
</table>
<h2 id="오류-처리-1"><a href="#오류-처리-1" class="headerlink" title="오류 처리"></a>오류 처리</h2><p>RxJS는 <code>subscribe()</code>서 사용할 수 있는 <code>error()</code> 핸들러 외에도 알려진 오류를 처리 할 수있는 <code>catchError</code> 연산자도 제공합니다.</p>
<p>예를 들어, API 요청을 만들고 서버의 응답에 매핑하는 <em>Observable</em>이 있다고 가정해 보겠습니다. 만약 서버에서 오류를 반환하거나 값이 없다면 오류가 발생합니다. 하지만 여러분이 이 오류를 잡아서 Default 값을 제공한다면, Stream은 오류 대신 계속 진행될 것입니다.</p>
<p>아래는 <code>catchError</code> 연산자를 사용하는 예제입니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; ajax &#125; <span class="keyword">from</span> <span class="string">'rxjs/ajax'</span>;</div><div class="line"><span class="keyword">import</span> &#123; map, catchError &#125; <span class="keyword">from</span> <span class="string">'rxjs/operators'</span>;</div><div class="line"><span class="comment">// API에서 "response"를 반환합니다. 하지만 오류가 발생하면 빈 배열을 반환합니다.</span></div><div class="line"><span class="keyword">const</span> apiData = ajax(<span class="string">'/api/data'</span>).pipe(</div><div class="line">  map(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">if</span> (!res.response) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Value expected!'</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> res.response;</div><div class="line">  &#125;),</div><div class="line">  catchError(<span class="function"><span class="params">err</span> =&gt;</span> of([]))</div><div class="line">);</div><div class="line"> </div><div class="line">apiData.subscribe(&#123;</div><div class="line">  next(x) &#123; <span class="built_in">console</span>.log(<span class="string">'data: '</span>, x); &#125;,</div><div class="line">  error(err) &#123; <span class="built_in">console</span>.log(<span class="string">'errors already caught... will not run'</span>); &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="실패한-Observable-재시도"><a href="#실패한-Observable-재시도" class="headerlink" title="실패한 Observable 재시도"></a>실패한 Observable 재시도</h2><p><code>catchError</code> 연산자가 간단한 복구 경로를 제공하는 경우, <code>retry</code> 연산자를 사용하여 실패한 요청을 다시 시도할 수 있습니다.</p>
<p><code>catchError</code> 연산자 앞에 <code>retry</code>연산자를 사용합니다. 이는 <em>Observable</em> 원본 소스를 다시 구독하여 오류를 유발한 모든 동작 시퀀스를 다시 실행할 수 있습니다. 그리고 만약 HTTP 요청을 포함하고 있다면 HTTP 요청을 다시 보냅니다.</p>
<p>아래 예제는 이전 예제를 수정하여 오류를 발생하기 전에 요청을 다시 시도합니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; ajax &#125; <span class="keyword">from</span> <span class="string">'rxjs/ajax'</span>;</div><div class="line"><span class="keyword">import</span> &#123; map, retry, catchError &#125; <span class="keyword">from</span> <span class="string">'rxjs/operators'</span>;</div><div class="line"> </div><div class="line"><span class="keyword">const</span> apiData = ajax(<span class="string">'/api/data'</span>).pipe(</div><div class="line">  retry(<span class="number">3</span>), <span class="comment">// 실패하기 전에 최대 3번 다시 시도합니다.</span></div><div class="line">  map(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">if</span> (!res.response) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Value expected!'</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> res.response;</div><div class="line">  &#125;),</div><div class="line">  catchError(<span class="function"><span class="params">err</span> =&gt;</span> of([]))</div><div class="line">);</div><div class="line"> </div><div class="line">apiData.subscribe(&#123;</div><div class="line">  next(x) &#123; <span class="built_in">console</span>.log(<span class="string">'data: '</span>, x); &#125;,</div><div class="line">  error(err) &#123; <span class="built_in">console</span>.log(<span class="string">'errors already caught... will not run'</span>); &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<blockquote>
<p>인증 요청은 사용자 작업에 의해서만 시작되어야 하므로 다시 시도하지 마십시오. 사용자가 시작하지 않은 반복 로그인 요청으로 사용자 계정이 잠길수 있습니다.</p>
</blockquote>
<h3 id="Observable에-대한-명명-규칙"><a href="#Observable에-대한-명명-규칙" class="headerlink" title="Observable에 대한 명명 규칙"></a>Observable에 대한 명명 규칙</h3><p>Angular 응용 프로그램은 대부분 TypeScript로 작성되기 때문에 일반적으로 변수가 Observable 일때 알 수 있습니다. 비록 Angular 프레임워크가 <em>Observable</em>에 대한 명명 규칙을 강제하지 않더라도 여러분은 종종 이름 끝에 “$”가 붙은 변수를 볼수 있습니다.</p>
<p>이러한 방법은 코드를 훑어 보며 <em>Observable</em> 값을 찾을때 유용할 수 있습니다. 또한, <em>Observable</em>에서 가장 최근의 값을 저장하는 프로퍼티를 원할 때 “$”의 유무와 상관없이 동일한 이름을 사용하는 것이 편리할 수 있습니다.</p>
<p>예를 들어 아래와 같습니다.<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</div><div class="line"><span class="keyword">import</span> &#123; Observable &#125; <span class="keyword">from</span> <span class="string">'rxjs'</span>;</div><div class="line"> </div><div class="line"><span class="meta">@Component</span>(&#123;</div><div class="line">  selector: <span class="string">'app-stopwatch'</span>,</div><div class="line">  templateUrl: <span class="string">'./stopwatch.component.html'</span></div><div class="line">&#125;)</div><div class="line"><span class="keyword">export</span> <span class="keyword">class</span> StopwatchComponent &#123;</div><div class="line"> </div><div class="line">  stopwatchValue: <span class="built_in">number</span>;</div><div class="line">  stopwatchValue$: Observable&lt;<span class="built_in">number</span>&gt;;</div><div class="line"> </div><div class="line">  start() &#123;</div><div class="line">    <span class="keyword">this</span>.stopwatchValue$.subscribe(<span class="function"><span class="params">num</span> =&gt;</span></div><div class="line">      <span class="keyword">this</span>.stopwatchValue = num</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="Angular에서-Observable"><a href="#Angular에서-Observable" class="headerlink" title="Angular에서 Observable"></a>Angular에서 Observable</h1><p>Angular는 <em>Observable</em>을 다양한 공통의 비동기 작업을 처리하기 위한 인터페이스로 사용합니다. 예를 들어:</p>
<ul>
<li><code>EventEmitter</code> 클래스는 <code>Observable</code>를 상속받습니다.</li>
<li>HTTP 모듈은 <em>Observable</em>을 사용하여 AJAX 요청 및 응답을 처리합니다.</li>
<li>Router 및 Form 모듈은 <em>Observable</em>을 사용하여 사용자 입력 이벤트를 수신하고 응답합니다.</li>
</ul>
<h2 id="Event-Emitter"><a href="#Event-Emitter" class="headerlink" title="Event Emitter"></a>Event Emitter</h2><p>Angular는 <code>@Output()</code> 데코레이터를 통해 <em>Component</em>의 값을 게시할 때 사용되는 <code>EventEmitter</code> 클래스를 제공합니다. <code>EventEmitter</code>는 <code>Observable</code>을 상속하고 <code>emit()</code> 메서드를 추가하여 임의의 값을 방출할 수 있습니다. <code>emit()</code> 메서드를 호출하면 방출된 값을 구독하고 있는 <em>observer</em>의 <code>next()</code> 메서드로 전달합니다.</p>
<p><a href="https://angular.io/api/core/EventEmitter" target="_blank" rel="external">EventEmitter</a> 문서에서 좋은 예제들을 찾을 수 있습니다. 다음은 open 및 close 이벤트를 수신하는 예제 <em>Component</em> 입니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;zippy (open)=<span class="string">"onOpen($event)"</span> (close)=<span class="string">"onClose($event)"</span>&gt;&lt;<span class="regexp">/zippy&gt;</span></div></pre></td></tr></table></figure>
<p>아래는 <em>Component</em>에 대한 정의입니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span>(&#123;</div><div class="line">  selector: <span class="string">'zippy'</span>,</div><div class="line">  template: <span class="string">`</span></div><div class="line">  &lt;div class="zippy"&gt;</div><div class="line">    &lt;div (click)="toggle()"&gt;Toggle&lt;/div&gt;</div><div class="line">    &lt;div [hidden]="!visible"&gt;</div><div class="line">      &lt;ng-content&gt;&lt;/ng-content&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">  &lt;/div&gt;`&#125;)</div><div class="line"> </div><div class="line"><span class="keyword">export</span> <span class="keyword">class</span> ZippyComponent &#123;</div><div class="line">  visible = <span class="literal">true</span>;</div><div class="line">  <span class="meta">@Output</span>() open = <span class="keyword">new</span> EventEmitter&lt;<span class="built_in">any</span>&gt;();</div><div class="line">  <span class="meta">@Output</span>() close = <span class="keyword">new</span> EventEmitter&lt;<span class="built_in">any</span>&gt;();</div><div class="line"> </div><div class="line">  toggle() &#123;</div><div class="line">    <span class="keyword">this</span>.visible = !<span class="keyword">this</span>.visible;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.visible) &#123;</div><div class="line">      <span class="keyword">this</span>.open.emit(<span class="literal">null</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">this</span>.close.emit(<span class="literal">null</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>Angular의 <code>HttpClient</code>는 HTTP 메서드 호출에서 <em>Observable</em>을 반환합니다. 예를 들어 <code>http.get(&#39;/api&#39;)</code>은 <em>Observable</em>을 반환합니다. 이러한 방식은 <em>Promise</em> 기반의 API에 비해 몇가지 장점을 제공합니다.</p>
<ul>
<li>Observables는 서버 응답을 변경하지 않습니다 (<em>Promise</em>의 <code>.then()</code> 호출을 통해 발생할 수 있음). 대신에 필요하다면 일련의 연산자를 이용하여 값을 변형할 수 있습니다.</li>
<li><code>unsubscribe()</code> 메서드를 통해 HTTP 요청을 취소할 수 있습니다.</li>
<li>요청에 대한 설정을 통해 진행 이벤트 업데이트를 가져올 수 있습니다.</li>
<li>실패한 요청을 쉽게 재시도할 수 있습니다.</li>
</ul>
<h2 id="비동기-Pipe-Async-Pipe"><a href="#비동기-Pipe-Async-Pipe" class="headerlink" title="비동기 Pipe (Async Pipe)"></a>비동기 Pipe (Async Pipe)</h2><p><a href="https://angular.io/api/common/AsyncPipe" target="_blank" rel="external">AsyncPipe</a>는 <em>Observable</em> 또는 <em>Promise</em>를 구독하고 방출된 최신 값을 반환합니다. 새 값이 방출(emit)되면 Pipe는 변경 사항을 검사할 <em>Component</em>를 표시합니다.</p>
<p>아래 예제는 <code>time</code> <em>Observable</em>을 <em>Component</em>의 뷰에 바인딩 합니다. <em>Observable</em>은 연속적으로 현재 시각을 뷰에 업데이트 합니다.<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span>(&#123;</div><div class="line">  selector: <span class="string">'async-observable-pipe'</span>,</div><div class="line">  template: <span class="string">`&lt;div&gt;&lt;code&gt;observable|async&lt;/code&gt;:</span></div><div class="line">       Time: &#123;&#123; time | async &#125;&#125;&lt;/div&gt;`</div><div class="line">&#125;)</div><div class="line"><span class="keyword">export</span> <span class="keyword">class</span> AsyncObservablePipeComponent &#123;</div><div class="line">  time = <span class="keyword">new</span> Observable(<span class="function"><span class="params">observer</span> =&gt;</span></div><div class="line">    setInterval(<span class="function"><span class="params">()</span> =&gt;</span> observer.next(<span class="keyword">new</span> <span class="built_in">Date</span>().toString()), <span class="number">1000</span>)</div><div class="line">  );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h2><p><a href="https://angular.io/api/router/Router#events" target="_blank" rel="external">Router.events</a>는 이벤트를 <em>Observable</em>로 제공합니다. RxJS의 <code>filter()</code> 연산자를 사용하여 관심있는 이벤트를 찾을수 있고 Navigation 프로세스의 이벤트 순서를 기반으로 의사 결정을 내리기 위해 구독할 수 있습니다. 예를 들어:</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; Router, NavigationStart &#125; <span class="keyword">from</span> <span class="string">'@angular/router'</span>;</div><div class="line"><span class="keyword">import</span> &#123; filter &#125; <span class="keyword">from</span> <span class="string">'rxjs/operators'</span>;</div><div class="line"> </div><div class="line"><span class="meta">@Component</span>(&#123;</div><div class="line">  selector: <span class="string">'app-routable'</span>,</div><div class="line">  templateUrl: <span class="string">'./routable.component.html'</span>,</div><div class="line">  styleUrls: [<span class="string">'./routable.component.css'</span>]</div><div class="line">&#125;)</div><div class="line"><span class="keyword">export</span> <span class="keyword">class</span> Routable1Component <span class="keyword">implements</span> OnInit &#123;</div><div class="line"> </div><div class="line">  navStart: Observable&lt;NavigationStart&gt;;</div><div class="line"> </div><div class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> router: Router</span>) &#123;</div><div class="line">    <span class="comment">// NavigationStart만 게시하기 위한 새로운 Observable을 생성합니다.</span></div><div class="line">    <span class="keyword">this</span>.navStart = router.events.pipe(</div><div class="line">      filter(<span class="function"><span class="params">evt</span> =&gt;</span> evt <span class="keyword">instanceof</span> NavigationStart)</div><div class="line">    ) <span class="keyword">as</span> Observable&lt;NavigationStart&gt;;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  ngOnInit() &#123;</div><div class="line">    <span class="keyword">this</span>.navStart.subscribe(<span class="function"><span class="params">evt</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Navigation Started!'</span>));</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://angular.io/api/router/ActivatedRoute" target="_blank" rel="external">ActivatedRoute</a>는 <em>Observable</em>을 사용하여 Route path 및 파라미터에 대한 정보를 가져 오는 Inject된 Router <em>Service</em>입니다. 예를 들어, <code>ActivateRoute.url]</code>에는 Route path를 보고하는 <em>Observable</em>을 포함하고 있습니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; ActivatedRoute &#125; <span class="keyword">from</span> <span class="string">'@angular/router'</span>;</div><div class="line"> </div><div class="line"><span class="meta">@Component</span>(&#123;</div><div class="line">  selector: <span class="string">'app-routable'</span>,</div><div class="line">  templateUrl: <span class="string">'./routable.component.html'</span>,</div><div class="line">  styleUrls: [<span class="string">'./routable.component.css'</span>]</div><div class="line">&#125;)</div><div class="line"><span class="keyword">export</span> <span class="keyword">class</span> Routable2Component <span class="keyword">implements</span> OnInit &#123;</div><div class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> activatedRoute: ActivatedRoute</span>) &#123;&#125;</div><div class="line"> </div><div class="line">  ngOnInit() &#123;</div><div class="line">    <span class="keyword">this</span>.activatedRoute.url</div><div class="line">      .subscribe(<span class="function"><span class="params">url</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'The URL changed to: '</span> + url));</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="반응형-Form-Reactive-form"><a href="#반응형-Form-Reactive-form" class="headerlink" title="반응형 Form (Reactive form)"></a>반응형 Form (Reactive form)</h2><p>반응형 Form은 <em>Observable</em>을 사용하여 Form control 값을 모니터링하는 프로퍼티를 가지고 있습니다. <a href="https://angular.io/api/forms/FormControl" target="_blank" rel="external">FormControl</a> 프로퍼티는 변경 이벤트를 발생시키는 <code>valueChanges</code> 및 <code>statusChanges</code> <em>Observable</em>을 포함합니다. <em>Observable</em> From control 프로퍼티를 구독하는 것은 <em>Component</em> 클래스 내에서 응용 프로그램 로직을 실행시키는 방법입니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; FormGroup &#125; <span class="keyword">from</span> <span class="string">'@angular/forms'</span>;</div><div class="line"> </div><div class="line"><span class="meta">@Component</span>(&#123;</div><div class="line">  selector: <span class="string">'my-component'</span>,</div><div class="line">  template: <span class="string">'MyComponent Template'</span></div><div class="line">&#125;)</div><div class="line"><span class="keyword">export</span> <span class="keyword">class</span> MyComponent <span class="keyword">implements</span> OnInit &#123;</div><div class="line">  nameChangeLog: <span class="built_in">string</span>[] = [];</div><div class="line">  heroForm: FormGroup;</div><div class="line"> </div><div class="line">  ngOnInit() &#123;</div><div class="line">    <span class="keyword">this</span>.logNameChange();</div><div class="line">  &#125;</div><div class="line">  logNameChange() &#123;</div><div class="line">    <span class="keyword">const</span> nameControl = <span class="keyword">this</span>.heroForm.get(<span class="string">'name'</span>);</div><div class="line">    nameControl.valueChanges.forEach(</div><div class="line">      <span class="function">(<span class="params">value: <span class="built_in">string</span></span>) =&gt;</span> <span class="keyword">this</span>.nameChangeLog.push(value)</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Observable의-실제-사용방법"><a href="#Observable의-실제-사용방법" class="headerlink" title="Observable의 실제 사용방법"></a>Observable의 실제 사용방법</h1><p>다음은 <em>Observable</em>이 특히 유용한 도메인의 예입니다.</p>
<h2 id="자동완성-Type-ahead-suggestion"><a href="#자동완성-Type-ahead-suggestion" class="headerlink" title="자동완성(Type-ahead suggestion)"></a>자동완성(Type-ahead suggestion)</h2><p><em>Observable</em>은 자동완성(Type-ahead)의 구현을 간단히할 수 있습니다. 일반적으로 자동완성(Type-ahead)은 일련의 별도 작업을 수행해야합니다.</p>
<ul>
<li>입력 데이터 수신합니다.</li>
<li>값에서 공백을 제거하고, 최소 길이인지 확인합니다.</li>
<li>Debounce(모든 키 입력에 대해 API 요청을 보내지 않고 대신 키 입력이 중단될 때까지 대기).</li>
<li>값이 동일하게 유지되면 요청을 보내지 않습니다 (예를 들어 문자를 빠르게 치고 백스 페이스 하는등).</li>
<li>업데이트된 결과로 인해 결과가 무효화되는 경우 진행중인 AJAX 요청을 취소합니다.</li>
</ul>
<p>이런 내용을 JavaScript로 전체 작성하면 상당히 복잡할 수 있습니다. 하지만 <em>Observable</em>를 사용하면 간단한 일련의 RxJS 연산자를 사용할 수 있습니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; fromEvent &#125; <span class="keyword">from</span> <span class="string">'rxjs'</span>;</div><div class="line"><span class="keyword">import</span> &#123; ajax &#125; <span class="keyword">from</span> <span class="string">'rxjs/ajax'</span>;</div><div class="line"><span class="keyword">import</span> &#123; map, filter, debounceTime, distinctUntilChanged, switchMap &#125; <span class="keyword">from</span> <span class="string">'rxjs/operators'</span>;</div><div class="line"> </div><div class="line"><span class="keyword">const</span> searchBox = <span class="built_in">document</span>.getElementById(<span class="string">'search-box'</span>);</div><div class="line"> </div><div class="line"><span class="keyword">const</span> typeahead = fromEvent(searchBox, <span class="string">'input'</span>).pipe(</div><div class="line">  map(<span class="function">(<span class="params">e: KeyboardEvent</span>) =&gt;</span> e.target.value),</div><div class="line">  filter(<span class="function"><span class="params">text</span> =&gt;</span> text.length &gt; <span class="number">2</span>),</div><div class="line">  debounceTime(<span class="number">10</span>),</div><div class="line">  distinctUntilChanged(),</div><div class="line">  switchMap(<span class="function"><span class="params">()</span> =&gt;</span> ajax(<span class="string">'/api/endpoint'</span>))</div><div class="line">);</div><div class="line"> </div><div class="line">typeahead.subscribe(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</div><div class="line"> <span class="comment">// API로 부터 받은 데이터 처리</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="Exponential-backoff"><a href="#Exponential-backoff" class="headerlink" title="Exponential backoff"></a>Exponential backoff</h2><blockquote>
<p>대규모 서비스를 설계할 때, 적절한 타임아웃 설정이 중요합니다. 실제로 어떤 요청에 대해 부하 상태 등으로 타임아웃이 발생하게 되면 그 다음 요청에 대한 응답을 조금 더 긴 시간에 랜덤으로 처리하는 방법을 엑스포넨셜 백오프(exponential backoff)라고 합니다.</p>
</blockquote>
<p>엑스포넨셜 백오프는 API 요청 실패후 재시도하고, 연속적인 실패가 발생할 때마다 재시도 간격을 늘립니다. 그리고 최대 재시도 횟수이후 요청이 실패한 것으로 간주하는 기술입니다. 이러한 내용을 <em>Promise</em>와 AJAX 호출을 추적하는 다른 메서드로 구현하는 것은 꽤 복잡 할 수 있습니다. 하지만 <em>Observable</em>로 구현하는 것은 매우 쉽습니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; pipe, range, timer, zip &#125; <span class="keyword">from</span> <span class="string">'rxjs'</span>;</div><div class="line"><span class="keyword">import</span> &#123; ajax &#125; <span class="keyword">from</span> <span class="string">'rxjs/ajax'</span>;</div><div class="line"><span class="keyword">import</span> &#123; retryWhen, map, mergeMap &#125; <span class="keyword">from</span> <span class="string">'rxjs/operators'</span>;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">backoff</span>(<span class="params">maxTries, ms</span>) </span>&#123;</div><div class="line"> <span class="keyword">return</span> pipe(</div><div class="line">   retryWhen(<span class="function"><span class="params">attempts</span> =&gt;</span> range(<span class="number">1</span>, maxTries)</div><div class="line">     .pipe(</div><div class="line">       zip(attempts, <span class="function">(<span class="params">i</span>) =&gt;</span> i),</div><div class="line">       map(<span class="function"><span class="params">i</span> =&gt;</span> i * i),</div><div class="line">       mergeMap(<span class="function"><span class="params">i</span> =&gt;</span>  timer(i * ms))</div><div class="line">     )</div><div class="line">   )</div><div class="line"> );</div><div class="line">&#125;</div><div class="line"> </div><div class="line">ajax(<span class="string">'/api/endpoint'</span>)</div><div class="line">  .pipe(backoff(<span class="number">3</span>, <span class="number">250</span>))</div><div class="line">  .subscribe(<span class="function"><span class="params">data</span> =&gt;</span> handleData(data));</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleData</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="다른-기술들과-Observable-비교"><a href="#다른-기술들과-Observable-비교" class="headerlink" title="다른 기술들과 Observable 비교"></a>다른 기술들과 Observable 비교</h1><p><em>Observable</em>을 이용하여 <em>Promise</em> 대신 값을 비동기로 전달할 수 있고, <em>Event</em> 핸들러 대신 사용할 수 있습니다. 그리고 <em>Observable</em>이 여러개의 값을 전달할 수 있기 때문에 <em>Array</em>를 만들고 처리할 수 있는 곳에 사용할 수 있습니다.</p>
<p><em>Observable</em>는 이러한 각각의 상황에서 대체 기술과 다소 다르게 동작하지만 중요한 이점을 제공합니다. 다음은 차이점에 대한 자세한 비교 내용입니다.</p>
<h2 id="Observable과-Promise-비교"><a href="#Observable과-Promise-비교" class="headerlink" title="Observable과 Promise 비교"></a>Observable과 Promise 비교</h2><p><em>Observable</em>은 종종 <em>Promise</em>와 비교됩니다. 주요 차이점은 다음과 같습니다.</p>
<ul>
<li><em>Observable</em>은 선언적입니다. 구독이 될 때까지 실행을 하지 않습니다. 하지만 <em>Promise</em>는 생성즉시 실행이 됩니다. 따라서 <em>Observable</em>은 결과가 필요할 때마다 실행할 수 있는 레시피를 정의하는데 유용합니다.</li>
<li><em>Observable</em> 다수의 값을 제공할 수 있습니다. 하지만 <em>Promise</em>는 하나만 제공합니다. <em>Observable</em>은 시간이 지남에 따라 여러 값을 얻는데 유용할 수 있습니다.</li>
<li><em>Observable</em>는 체인과 구독을 구분합니다. 하지만 <em>Promise</em>에는 <code>.then()</code> 절만 있습니다. 이것은 <em>Observable</em>로 시스템의 다른 부분에서 사용할 수 있고, 작업이 바로 실행 되지 않는 복잡한 변환 레시피를 만드는데 유용하게 합니다.</li>
<li><em>Observable</em>의 <code>subscribe()</code>는 오류 처리를 담당합니다. <em>Promise</em>는 오류를 자식(Child) <em>Promise</em>로 넘깁니다. 따라서 <em>Observable</em>은 중앙 집중적이고 예측 가능한 오류 처리에 유용합니다.</li>
</ul>
<h3 id="생성과-구독"><a href="#생성과-구독" class="headerlink" title="생성과 구독"></a>생성과 구독</h3><ul>
<li><em>Observable</em>은 Consumer가 구독할 때까지 실행되지 않습니다. <code>subscribe()</code>는 행위에 대한 정의를 한번 실행하고, 다시 호출할 수 있습니다. 각 구독은 고유한 계산이 존재 합니다. 그리고 재구독은 값의 재계산을 유발합니다.</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 게시 작업을 선언합니다.</span></div><div class="line"><span class="keyword">new</span> Observable(<span class="function">(<span class="params">observer</span>) =&gt;</span> &#123; subscriber_fn &#125;);</div><div class="line"><span class="comment">// 실행을 시작</span></div><div class="line">observable.subscribe(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      <span class="comment">// observer가 알람을 처리</span></div><div class="line">    &#125;);</div></pre></td></tr></table></figure>
<ul>
<li><em>Promise</em>는 즉시 한번만 실행이 됩니다. 결과 계산은 <em>Promise</em>가 만들어지면 시작됩니다. 작업을 재시작 할 수 있는 방법이 없습니다. 모든 <code>then</code> 절(구독)은 동일한 계산을 공유합니다.</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 실행 시작</span></div><div class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; executer_fn &#125;);</div><div class="line"><span class="comment">// 반환값을 처리</span></div><div class="line">promise.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</div><div class="line">      <span class="comment">// 여기에서 결과값을 처리</span></div><div class="line">    &#125;);</div></pre></td></tr></table></figure>
<h3 id="체인-Chaining"><a href="#체인-Chaining" class="headerlink" title="체인(Chaining)"></a>체인(Chaining)</h3><ul>
<li><p><em>Observable</em>은 map과 같은 변환 함수와 구독(subscription)을 구분합니다. 구독(subscription)만 subscriber 함수를 활성화하여 값 계산을 시작합니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">observable.map(<span class="function">(<span class="params">v</span>) =&gt;</span> <span class="number">2</span>*v);</div></pre></td></tr></table></figure>
</li>
<li><p><em>Promise</em>는 마지막 <code>.then</code> 절(구독과 동일)과 중간 <code>.then</code> 절 (map과 동일)을 구별하지 않습니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">promise.then(<span class="function">(<span class="params">v</span>) =&gt;</span> <span class="number">2</span>*v);</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="취소-Cancellation"><a href="#취소-Cancellation" class="headerlink" title="취소(Cancellation)"></a>취소(Cancellation)</h3><ul>
<li><p><em>Observable</em> 구독을 취소할 수 있습니다. 구독 취소는 수신자(listener)가 더 이상 값을 받지 못하도록 하고 subscriber 함수에 작업 취소를 알립니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> sub = obs.subscribe(...);</div><div class="line">sub.unsubscribe();</div></pre></td></tr></table></figure>
</li>
<li><p><em>Promise</em>는 취소가 가능하지 않습니다.</p>
</li>
</ul>
<h3 id="오류-처리-Error-handling"><a href="#오류-처리-Error-handling" class="headerlink" title="오류 처리 (Error handling)"></a>오류 처리 (Error handling)</h3><ul>
<li><em>Observable</em> 실행 오류는 <em>subscriber</em>의 오류 처리기로 전달되며 <em>subscriber</em>는 자동으로 <em>Observable</em>에서 구독을 취소합니다.</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">obs.subscribe(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">'my error'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<ul>
<li><em>Promise</em>는 자식 <em>Promise</em>에 오류를 넘깁니다.</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">promise.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">'my error'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="Cheat-sheet"><a href="#Cheat-sheet" class="headerlink" title="Cheat sheet"></a>Cheat sheet</h3><p>아래 코드는 <em>Observable</em>과 <em>Promise</em>를 이용하여 같은 종류의 연산을 정의하는 방법을 보여줍니다.</p>
<ul>
<li><p>생성 (Creation)</p>
<ul>
<li><p>Observable</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Observable(<span class="function">(<span class="params">observer</span>) =&gt;</span> &#123;</div><div class="line">  observer.next(<span class="number">123</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
<li><p>Promise</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">  resolve(<span class="number">123</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>변환 (Transform)</p>
<ul>
<li><p>Observable</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">obs.map(<span class="function">(<span class="params">value</span>) =&gt;</span> value * <span class="number">2</span> );</div></pre></td></tr></table></figure>
</li>
<li><p>Promise</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">promise.then(<span class="function">(<span class="params">value</span>) =&gt;</span> value * <span class="number">2</span>);</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>구독 (Subscribe)</p>
<ul>
<li><p>Observable</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sub = obs.subscribe(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(value)</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
<li><p>Promise</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">promise.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(value);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>구독 취소 (Unsubscribe)</p>
<ul>
<li><p>Observable</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sub.unsubscribe();</div></pre></td></tr></table></figure>
</li>
<li><p>Promise :  Promise의 해결(resolve)로 암묵적으로 처리</p>
</li>
</ul>
</li>
</ul>
<h2 id="Observable과-Event-API-비교"><a href="#Observable과-Event-API-비교" class="headerlink" title="Observable과 Event API 비교"></a>Observable과 Event API 비교</h2><p><em>Observable</em>은 <em>Event API</em>를 사용하는 <em>Event</em> 핸들러와 매우 유사합니다. 이 두 개술은 모두 알람에 대한 핸들러를 정의하고 시간이 지남에 따라 전달되는 여러 값을 처리하는데 사용합니다. <em>Observable</em>을 구독하는 것은 <em>Event</em> Listener를 추가하는 것과 같습니다. 한가지 주요한 다른점은 <em>Observable</em>은 이벤트가 핸들러에 전달되기 전에 이벤트를 변환하도록 구성할 수 있다는 것입니다.</p>
<p><em>Observable</em>을 사용하여 <em>Event</em> 및 비동기 작업을 처리하면 HTTP 요청과 같은 컨텍스트에서 일관성이 향상됩니다.</p>
<p>다음은 <em>Observable</em>와 <em>Event API</em>를 사용하여 같은 종류의 연산을 정의하는 방법을 보여주는 코드 샘플입니다.</p>
<ul>
<li><p>생성과 취소 (Creation &amp; cancellation)</p>
<ul>
<li><p>Observable</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Setup</span></div><div class="line"><span class="keyword">let</span> clicks$ = fromEvent(buttonEl, ‘click’);</div><div class="line"><span class="comment">// Begin listening</span></div><div class="line"><span class="keyword">let</span> subscription = clicks$</div><div class="line">  .subscribe(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(‘Clicked’, e))</div><div class="line"><span class="comment">// Stop listening</span></div><div class="line">subscription.unsubscribe();</div></pre></td></tr></table></figure>
</li>
<li><p>Event API</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">handler</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(‘Clicked’, e);</div><div class="line">&#125;</div><div class="line"><span class="comment">// Setup &amp; begin listening</span></div><div class="line">button.addEventListener(‘click’, handler);</div><div class="line"><span class="comment">// Stop listening</span></div><div class="line">button.removeEventListener(‘click’, handler);</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>구독 (Subscription)</p>
<ul>
<li><p>Observable</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">observable.subscribe(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="comment">// notification handlers here</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
<li><p>Event API</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">element.addEventListener(eventName, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</div><div class="line">  <span class="comment">// notification handler here</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>구성 (Configuration)</p>
<ul>
<li><p>Observable<br>Keystroke를 Listen 하지만 입력 값을 나타내는 Stream을 제공합니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fromEvent(inputEl, <span class="string">'keydown'</span>).pipe(</div><div class="line">  map(<span class="function"><span class="params">e</span> =&gt;</span> e.target.value)</div><div class="line">);</div></pre></td></tr></table></figure>
</li>
<li><p>Event API<br>구성은 제공하지 않습니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">element.addEventListener(eventName, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</div><div class="line">  <span class="comment">// 핸들러에 도착하기 전에 전달된 이벤트를 다른 값으로 변경할 수 없습니다.</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="Observable과-Array-비교"><a href="#Observable과-Array-비교" class="headerlink" title="Observable과 Array 비교"></a>Observable과 Array 비교</h2><p><em>Observable</em>은 시간이 지남에 따라 값을 발생시킵니다. <em>Array</em>는 정적인 값 집합으로 만들어집니다. 어떤 의미에서, <em>Observable</em>은 <em>Array</em>가 동기적인 곳에서 비동기적입니다. 다음 예에서 ➞는 비동기 값 전달을 의미합니다.</p>
<ul>
<li><p>Given</p>
<ul>
<li><p>Observable</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">obs: ➞<span class="number">1</span>➞<span class="number">2</span>➞<span class="number">3</span>➞<span class="number">5</span>➞<span class="number">7</span></div><div class="line">obsB: ➞<span class="string">'a'</span>➞<span class="string">'b'</span>➞<span class="string">'c'</span></div></pre></td></tr></table></figure>
</li>
<li><p>Array</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">arr: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>]</div><div class="line">arrB: [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>concat()</p>
<ul>
<li><p>Observable</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">obs.concat(obsB)</div><div class="line">➞<span class="number">1</span>➞<span class="number">2</span>➞<span class="number">3</span>➞<span class="number">5</span>➞<span class="number">7</span>➞<span class="string">'a'</span>➞<span class="string">'b'</span>➞<span class="string">'c'</span></div></pre></td></tr></table></figure>
</li>
<li><p>Array</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">arr.concat(arrB)</div><div class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>]</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>filter()</p>
<ul>
<li><p>Observable</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">obs.filter(<span class="function">(<span class="params">v</span>) =&gt;</span> v&gt;<span class="number">3</span>)</div><div class="line">➞<span class="number">5</span>➞<span class="number">7</span></div></pre></td></tr></table></figure>
</li>
<li><p>Array</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">arr.filter(<span class="function">(<span class="params">v</span>) =&gt;</span> v&gt;<span class="number">3</span>)</div><div class="line">[<span class="number">5</span>, <span class="number">7</span>]</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>find()</p>
<ul>
<li><p>Observable</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">obs.find(<span class="function">(<span class="params">v</span>) =&gt;</span> v&gt;<span class="number">3</span>)</div><div class="line">➞<span class="number">5</span></div></pre></td></tr></table></figure>
</li>
<li><p>Array</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">arr.find(<span class="function">(<span class="params">v</span>) =&gt;</span> v&gt;<span class="number">3</span>)</div><div class="line"><span class="number">5</span></div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>findIndex()</p>
<ul>
<li><p>Observable</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">obs.findIndex(<span class="function">(<span class="params">v</span>) =&gt;</span> v&gt;<span class="number">3</span>)</div><div class="line">➞<span class="number">3</span></div></pre></td></tr></table></figure>
</li>
<li><p>Array</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">arr.findIndex(<span class="function">(<span class="params">v</span>) =&gt;</span> v&gt;<span class="number">3</span>)</div><div class="line"><span class="number">3</span></div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>forEach()</p>
<ul>
<li><p>Observable</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">obs.forEach(<span class="function">(<span class="params">v</span>) =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(v);</div><div class="line">&#125;)</div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">2</span></div><div class="line"><span class="number">3</span></div><div class="line"><span class="number">5</span></div><div class="line"><span class="number">7</span></div></pre></td></tr></table></figure>
</li>
<li><p>Array</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">arr.forEach(<span class="function">(<span class="params">v</span>) =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(v);</div><div class="line">&#125;)</div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">2</span></div><div class="line"><span class="number">3</span></div><div class="line"><span class="number">5</span></div><div class="line"><span class="number">7</span></div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>map()</p>
<ul>
<li><p>Observable</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">obs.map(<span class="function">(<span class="params">v</span>) =&gt;</span> -v)</div><div class="line">➞<span class="number">-1</span>➞<span class="number">-2</span>➞<span class="number">-3</span>➞<span class="number">-5</span>➞<span class="number">-7</span></div></pre></td></tr></table></figure>
</li>
<li><p>Array</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">arr.map(<span class="function">(<span class="params">v</span>) =&gt;</span> -v)</div><div class="line">[<span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-3</span>, <span class="number">-5</span>, <span class="number">-7</span>]</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>reduce()</p>
<ul>
<li><p>Observable</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">obs.scan(<span class="function">(<span class="params">s,v</span>)=&gt;</span> s+v, <span class="number">0</span>)</div><div class="line">➞<span class="number">1</span>➞<span class="number">3</span>➞<span class="number">6</span>➞<span class="number">11</span>➞<span class="number">18</span></div></pre></td></tr></table></figure>
</li>
<li><p>Array</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">arr.reduce(<span class="function">(<span class="params">s,v</span>) =&gt;</span> s+v, <span class="number">0</span>)</div><div class="line"><span class="number">18</span></div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<hr>
<blockquote>
<p>이 내용은 나중에 참고하기 위해 Angular 6.0.4 기술 문서를 공부하며 정리한 내용입니다.<br>의역, 오역, 직역이 있을 수 있음을 알려드립니다.<br>This post is a translation of this original article [<a href="https://angular.io/guide/observables" target="_blank" rel="external">https://angular.io/guide/observables</a>, <a href="https://angular.io/guide/rx-library" target="_blank" rel="external">https://angular.io/guide/rx-library</a>, <a href="https://angular.io/guide/observables-in-angular" target="_blank" rel="external">https://angular.io/guide/observables-in-angular</a>, <a href="https://angular.io/guide/comparing-observables" target="_blank" rel="external">https://angular.io/guide/comparing-observables</a>]</p>
</blockquote>
<h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul>
<li><a href="https://infoscis.github.io/2017/07/21/angular-tutorial-introduction/">Angular 튜토리얼 - 소개</a></li>
<li><a href="https://infoscis.github.io/2017/07/21/angular-tutorial-the-hero-editor/">Angular 튜터리얼 - Hero 에디터</a></li>
<li><a href="https://infoscis.github.io/2017/07/21/angular-tutorial-master-detail/">Angular 튜터리얼 - Master/Detail</a></li>
<li><a href="https://infoscis.github.io/2017/07/21/angular-tutorial-multiple-components/">Angular 튜터리얼 - 다중 콤포넌트</a></li>
<li><a href="https://infoscis.github.io/2017/07/21/angular-tutorial-services/">Angular 튜터리얼 - 서비스</a></li>
<li><a href="https://infoscis.github.io/2017/07/21/angular-tutorial-routing/">Angular 튜터리얼 - 라우팅</a></li>
<li><a href="https://infoscis.github.io/2017/07/21/angular-tutorial-http/">Angular 튜터리얼 - HTTP</a></li>
<li><a href="https://infoscis.github.io/2017/07/21/angular-http-client/">Angular HttpClient</a></li>
<li><a href="https://infoscis.github.io/2018/01/24/angular-translation-service/">Angular에서 간단하게 번역기능 구현하기</a></li>
<li><a href="https://infoscis.github.io/2018/01/24/angular-dynamic-component/">Angular 동적 컴포넌트 로딩</a></li>
<li><a href="https://infoscis.github.io/2018/02/13/dynamic-content-in-angular/">Angular에서 동적 컨텐츠 생성</a></li>
<li><a href="https://infoscis.github.io/2018/02/13/understanding-viewchildren-contentchildren-and-querylist-in-angular/">Angular에서 ViewChildren, ContentChildren, 그리고 QueryList 이해하기</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Observable&quot;&gt;&lt;a href=&quot;#Observable&quot; class=&quot;headerlink&quot; title=&quot;Observable&quot;&gt;&lt;/a&gt;Observable&lt;/h1&gt;&lt;p&gt;&lt;em&gt;Observable&lt;/em&gt;은 Application의 Publ
    
    </summary>
    
      <category term="Angular" scheme="http://infoscis.github.io/categories/Angular/"/>
    
    
      <category term="Angular" scheme="http://infoscis.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>ECMAScript 6 부록 B. ECMAScript 7 (2016) 이해하기</title>
    <link href="http://infoscis.github.io/2018/02/27/ecmascript-6-appendix-b-understanding-ecmascript-7/"/>
    <id>http://infoscis.github.io/2018/02/27/ecmascript-6-appendix-b-understanding-ecmascript-7/</id>
    <published>2018-02-27T13:32:48.000Z</published>
    <updated>2018-02-27T14:11:41.460Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ECMAScript-6-부록-B-ECMAScript-7-2016-이해하기"><a href="#ECMAScript-6-부록-B-ECMAScript-7-2016-이해하기" class="headerlink" title="ECMAScript 6 부록 B. ECMAScript 7 (2016) 이해하기"></a>ECMAScript 6 부록 B. ECMAScript 7 (2016) 이해하기</h1><p>ECMAScript 6의 개발은 약 4년이 걸렸으며, 그후 TC-39는 이러한 긴 개발 프로세스가 지속 가능하지 않다고 결정했습니다. 대신, 매년 릴리즈하는 주기로 전환하여 새로운 기능 적용을 더 빨리 진행할 수 있도록 했습니다.</p>
<p>더자주 출시되려면 ECMAScript의 새버전은 ECMAScript 6보다 새로운 기능이 적어야합니다. 이 변경 사항을 나타내기 위해 새버전의 사양에는 더이상 버전 번호가 표시되지 않으며 대신 사양이 게시된 연도를 나타냅니다. 결과적으로 ECMAScript 6은 ECMAScript 2015로 알려져 있으며 ECMAScript 7은 공식적으로 ECMAScript 2016으로 알려져 있습니다. TC-39는 향후 모든 ECMAScript 에디션에 연도 기반 명명 시스템을 사용할 것으로 기대하고 있습니다.</p>
<p>ECMAScript 2016은 2016년 3월에 완성되었으며 새로운 수학 연산자, 새로운 <em>Array</em> 메서드 및 새로운 구문 오류가 추가된 3가지 기능만 포함되었습니다. 모두 이 부록에서 다룹니다.</p>
<h2 id="지수-연산자"><a href="#지수-연산자" class="headerlink" title="지수 연산자"></a>지수 연산자</h2><p>ECMAScript 2016에서 소개된 JavaScript 구문의 유일한 변경 사항은 <em>지수 연산자</em>입니다. 이는 베이스에 지수를 적용하는 수학 연산입니다. JavaScript는 지수 연산을 수행하기 위해 이미 <code>Math.pow()</code> 메서드를 가지고 있었지만 JavaScript는 공식 연산자가 아닌 메서드를 필요로하는 유일한 언어중 하나이기도합니다. (일부 개발자들은 연산자가 읽고 이해하기가 더 쉽다고 주장합니다.)</p>
<p>지수 연산은 두개의 별표(<code>**</code>)이며 왼쪽 피연산자는 베이스이고 오른쪽 피연산자는 지수입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> result = <span class="number">5</span> ** <span class="number">2</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(result);                        <span class="comment">// 25</span></div><div class="line"><span class="built_in">console</span>.log(result === <span class="built_in">Math</span>.pow(<span class="number">5</span>, <span class="number">2</span>));     <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>이 예제에서는 5^2와 동일한 25를 계산합니다. <code>Math.pow()</code>를 사용하여 동일한 결과를 얻을 수 있습니다.</p>
<h3 id="연산자-우선순위"><a href="#연산자-우선순위" class="headerlink" title="연산자 우선순위"></a>연산자 우선순위</h3><p>지수 연산자는 JavaScript에서 모든 2진 연산자중 우선 순위가 가장 높습니다 (단항 연산자는 <code>**</code>보다 우선 순위가 높음). 즉, 아래 예제에서와 같이 모든 복합 연산에서 처음에 적용됩니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> result = <span class="number">2</span> * <span class="number">5</span> ** <span class="number">2</span>;</div><div class="line"><span class="built_in">console</span>.log(result);        <span class="comment">// 50</span></div></pre></td></tr></table></figure>
<p>먼저 5^2의 계산이 수행되고 결과 값에 2를 곱해 최종 결과 50을 얻습니다.</p>
<h3 id="피연산자-제한"><a href="#피연산자-제한" class="headerlink" title="피연산자 제한"></a>피연산자 제한</h3><p>지수 연산자는 다른 연산자에 대해 존재하지 않는 다소 특이한 제한이 있습니다. 지수 연산의 왼쪽은 <code>++</code> 또는 <code>--</code>이외의 단항식일 수 없습니다. 예를 들어 아래는 잘못된 구문입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 구문 오류</span></div><div class="line"><span class="keyword">let</span> result = <span class="number">-5</span> ** <span class="number">2</span>;</div></pre></td></tr></table></figure>
<p>이 예제에서 <code>-5</code>는 연산 순서가 모호하기 때문에 구문 오류입니다. <code>-</code>는 <code>5</code> 또는 <code>5 ** 2</code> 표현식의 어떤 결과에 적용되어야 할까요? 지수 연산자의 왼쪽에 단항식을 허용하지 않으면 해당 모호성이 제거됩니다. 의도를 명확하게 지정하려면 다음과 같이 <code>-5</code> 또는 <code>5 ** 2</code> 주변에 괄호를 포함시켜야합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ok</span></div><div class="line"><span class="keyword">let</span> result1 = -(<span class="number">5</span> ** <span class="number">2</span>);    <span class="comment">// equal to -25</span></div><div class="line"></div><div class="line"><span class="comment">// also ok</span></div><div class="line"><span class="keyword">let</span> result2 = (<span class="number">-5</span>) ** <span class="number">2</span>;    <span class="comment">// equal to 25</span></div></pre></td></tr></table></figure>
<p>식 주변에 괄호를 넣으면 <code>-</code>가 전체에 적용됩니다. 괄호가 <code>-5</code>를 둘러 싸면 <code>-5</code>의 2승에 대한 계산이 분명해집니다.</p>
<p>지수 연산자의 왼쪽에 <code>++</code> 및 <code>--</code>를 사용하면 두 연산자가 피연산자에 대해 명확하게 정의된 동작을 하기 때문에 괄호가 필요하지 않습니다. 접두어 <code>++</code> 또는 <code>--</code>는 다른 연산이 수행되기 전에 피연산자를 변경하며, 접미어 버전은 전체 표현식이 평가될 때까지 변경 사항을 적용하지 않습니다. 이 코드는 다음과 같이 이 연산자의 왼쪽에서 두 사례 모두 안전합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> num1 = <span class="number">2</span>,</div><div class="line">    num2 = <span class="number">2</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(++num1 ** <span class="number">2</span>);       <span class="comment">// 9</span></div><div class="line"><span class="built_in">console</span>.log(num1);              <span class="comment">// 3</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(num2-- ** <span class="number">2</span>);       <span class="comment">// 4</span></div><div class="line"><span class="built_in">console</span>.log(num2);              <span class="comment">// 1</span></div></pre></td></tr></table></figure>
<p>이 예제에서, 지수 연산자가 적용되기 전에 <code>num1</code>이 증가하기 때문에 <code>num1</code>은 3이되고 연산 결과는 9가됩니다. <code>num2</code>의 경우, 지수 연산값은 2를 유지한 다음 1로 감소합니다.</p>
<h2 id="Array-prototype-includes-메서드"><a href="#Array-prototype-includes-메서드" class="headerlink" title="Array.prototype.includes() 메서드"></a>Array.prototype.includes() 메서드</h2><p>주어진 문자열 내에 특정 부분 문자열이 존재하는지 확인하기 위해 ECMAScript 6에 <code>String.prototype.includes()</code>를 추가했음 기억하실 것입니다. 원래 ECMAScript 6에는 문자열과 <em>Array</em>를 비슷한 방식으로 처리하기 위해 <code>Array.prototype.includes()</code> 메서드를 도입했습니다. 그러나 <code>Array.prototype.includes()</code>에 대한 사양을 ECMAScript 6 마감 시한에 완료하지 못하고 <code>Array.prototype.includes()</code>는 ECMAScript 2016에서 완료되었습니다.</p>
<h3 id="Array-prototype-includes-사용법"><a href="#Array-prototype-includes-사용법" class="headerlink" title="Array.prototype.includes() 사용법"></a>Array.prototype.includes() 사용법</h3><p><code>Array.prototype.includes()</code> 메서드는 검색할 값과 검색을 시작할 선택적 인덱스라는 두개의 파라미터를 받습니다. 두 번째 파라미터가 제공되면 <code>includes()</code>가 해당 인덱스에서 검색을 시작합니다. (기본 시작 인덱스는 0입니다.) 값이 <em>Array</em> 안에 있으면 <code>true</code>를 반환하고 그렇지 않으면 <code>false</code>를 반환합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(values.includes(<span class="number">1</span>));        <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(values.includes(<span class="number">0</span>));        <span class="comment">// false</span></div><div class="line"></div><div class="line"><span class="comment">// 인덱스 2부터 검색 시작</span></div><div class="line"><span class="built_in">console</span>.log(values.includes(<span class="number">1</span>, <span class="number">2</span>));     <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p>여기서 <code>values.includes()</code>를 호출하면 <code>1</code>의 값은 <code>true</code>를, <code>0</code>은 <em>Array</em>에 없기 때문에 <code>false</code>를 반환합니다. 두 번째 파라미터가 인덱스 2 (값 <code>3</code>을 포함)에서 검색을 시작하는데 사용되고, 인덱스 2와 <em>Array</em>의 끝 사이에 숫자 <code>1</code>이 없기 때문에 <code>values.includes()</code> 메서드는 <code>false</code>를 반환합니다.</p>
<h3 id="값-비교"><a href="#값-비교" class="headerlink" title="값 비교"></a>값 비교</h3><p><code>includes()</code> 메서드에 의해 수행된 값 비교는 한가지 예외를 제외하고는 <code>===</code> 연산자를 사용합니다(<code>NaN === NaN</code>이 <code>false</code>로 평가 되더라도<code>NaN</code>은 <code>NaN</code>과 같은 것으로 간주됩니다). 이는 비교를 위해 엄격하게 <code>===</code>를 사용하는 <code>indexOf()</code> 메서드의 동작과는 다릅니다. 차이점을 확인하기위해 다음 코드를 살펴 보겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> values = [<span class="number">1</span>, <span class="literal">NaN</span>, <span class="number">2</span>];</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(values.indexOf(<span class="literal">NaN</span>));       <span class="comment">// -1</span></div><div class="line"><span class="built_in">console</span>.log(values.includes(<span class="literal">NaN</span>));      <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p><code>values.indexOf()</code> 메서드는 <code>NaN</code>이 <code>values</code> <em>Array</em>에 포함되어 있더라도 <code>NaN</code>에 대해 <code>-1</code>을 반환합니다. 하지만, <code>values.includes()</code>는 다른 값 비교 연산자를 사용하기 때문에 <code>NaN</code>에 대해 <code>true</code>를 반환합니다.</p>
<blockquote>
<p><em>Array</em>에서 값의 존재만을 확인하고 인덱스를 알 필요가 없는 경우 <code>NaN</code>을 처리하는 방법의 차이 때문에 <code>includes()</code>를 사용하는 것이 좋습니다. 하지만 <em>Array</em>의 어느 위치에 값이 있는지 알아야하는 경우 <code>indexOf()</code> 메서드를 사용해야합니다.</p>
</blockquote>
<p>이 구현의 또 다른 단점은 <code>+0</code>과 <code>-0</code>이 같은 것으로 간주된다는 것입니다. 이 경우 <code>indexOf()</code> 및 <code>includes()</code>의 동작은 동일합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> values = [<span class="number">1</span>, +<span class="number">0</span>, <span class="number">2</span>];</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(values.indexOf(<span class="number">-0</span>));        <span class="comment">// 1</span></div><div class="line"><span class="built_in">console</span>.log(values.includes(<span class="number">-0</span>));       <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>여기에서 <code>indexOf()</code>와 <code>includes()</code>는 두값이 같다고 간주되어 <code>-0</code>이 전달되면 <code>+0</code>을 찾습니다. 이것은 <code>+0</code> 및 <code>-0</code>을 다른 값으로 간주하는 <code>Object.is()</code> 메서드의 동작과 다릅니다.</p>
<h2 id="함수-Scope의-Strict-모드-변경"><a href="#함수-Scope의-Strict-모드-변경" class="headerlink" title="함수 Scope의 Strict 모드 변경"></a>함수 Scope의 Strict 모드 변경</h2><p><em>strict</em> 모드가 ECMAScript 5에 도입되었을 때, ECMAScript 6의 변화보다 더 단순했습니다. 그럼에도 불구하고 ECMAScript 6에서는 전역 <em>Scope</em>(모든 코드가 <em>strict</em> 모드로 실행됨) 또는 함수 <em>Scope</em>에서(함수만 <em>strict</em> 모드로 실행됨) “use strict” 지시문을 사용하여 <em>strict</em> 모드를 지정할 수있었습니다. 후자는 ECMAScript 6에서 파라미터를 정의할 수있는 보다 복잡한 방법, 특히 <em>Destructuring</em> 및 <em>Default</em> 파라미터로 인해 문제가되었습니다. 아래 코드를 살펴 보겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">first = this</span>) </span>&#123;</div><div class="line"><span class="meta">    "use strict"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> first;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>여기서, 명명된 파라미터 <code>first</code>에는 <em>Default</em> 값으로 <code>this</code>가 할당됩니다. <code>first</code>의 값이 무엇이라고 기대 하시겠습니까? 이 경우, ECMAScript 6 사양은 <em>strict</em> 모드로 실행되는 파라미터를 처리하도록 JavaScript 엔진에 지시 했으므로 <code>this</code>는 <code>undefined</code>와 같아야합니다. 그러나 <em>strict</em> 모드에서 실행중인 파라미터를 구현할 때 “use strict” 기능이 있는 경우 파라미터 <em>Default</em>값이 기능을 수행할 수 있기 때문에 매우 어려웠습니다. 이러한 어려움으로 인해 대부분의 JavaScript 엔진은 이 기능을 구현하지 못했습니다 (따라서 <code>this</code>는 전역 객체와 동일합니다).</p>
<p>구현의 어려움으로 인해 ECMAScript 2016은 파라미터가 <em>Destructuring</em>되거나 <em>Default</em>값을 갖는 함수 내부에 “use strict” 지시문을 사용하는 것을 구문 오류로 판단합니다. 함수의 본문에 “use strict”가 있는 경우 <em>단순 파라미터 목록(simple parameter list)</em>, 즉 <em>Destructuring</em> 또는 <em>Default</em>값을 포함하지 않는 파라미터 목록만 허용됩니다. 아래 예제를 살펴보겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// okay - using simple parameter list</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">okay</span>(<span class="params">first, second</span>) </span>&#123;</div><div class="line"><span class="meta">    "use strict"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> first;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// syntax error</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">notOkay1</span>(<span class="params">first, second=first</span>) </span>&#123;</div><div class="line"><span class="meta">    "use strict"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> first;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// syntax error</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">notOkay2</span>(<span class="params">&#123; first, second &#125;</span>) </span>&#123;</div><div class="line"><span class="meta">    "use strict"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> first;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>단순 파라미터 목록에서 “use strict”를 사용할 수 있습니다. 따라서 <code>okay()</code>가 예상대로 작동합니다(ECMAScript 5에서와 동일). <code>notOkay1()</code> 함수는 <em>Default</em> 파라미터 값을 가진 함수라서 더 이상 “use strict”를 사용할 수 없으므로 구문 오류입니다. 비슷하게, <code>notOkay2()</code> 함수는 <em>Destructuring</em> 파라미터를 가진 함수라서 “use strict”를 사용할 수 없기 때문에 마찮가지로 구문 오류입니다.</p>
<p>전반적으로 이러한 변경으로 인해 JavaScript 개발자가 느끼는 혼란스러운 점과 JavaScript 엔진의 구현상 문제가 모두 제거됩니다.</p>
<hr>
<blockquote>
<p>이 내용은 나중에 참고하기 위해 제가 공부하며 정리한 내용입니다.<br>의역, 오역, 직역이 있을 수 있음을 알려드립니다.<br>This post is a translation of this original article [<a href="https://leanpub.com/understandinges6/read#leanpub-auto-appendix-b-understanding-ecmascript-7-2016" target="_blank" rel="external">https://leanpub.com/understandinges6/read#leanpub-auto-appendix-b-understanding-ecmascript-7-2016</a>]</p>
</blockquote>
<h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul>
<li><a href="https://infoscis.github.io/2018/01/24/ecmascript-6-block-binding/">ECMAScript 6 Block Binding</a></li>
<li><a href="https://infoscis.github.io/2018/01/24/ecmascript-6-strings-and-regular-expressions/">ECMAScript 6 문자열과 정규 표현식</a></li>
<li><a href="https://infoscis.github.io/2018/01/24/ecmascript-6-functions/">ECMAScript 6 함수</a></li>
<li><a href="https://infoscis.github.io/2018/01/25/ecmascript-6-expanded-object-functionality/">ECMAScript 6 객체의 확장된 기능</a></li>
<li><a href="https://infoscis.github.io/2018/01/26/ecmascript-6-destructuring-for-easier-data-access/">ECMAScript 6 쉬운 데이터 액세스를 위한 Destructuring</a></li>
<li><a href="https://infoscis.github.io/2018/01/27/ecmascript-6-symbols-and-symbol-properties/">ECMAScript 6 Symbol과 Symbol 프로퍼티</a></li>
<li><a href="https://infoscis.github.io/2018/01/27/ecmascript-6-sets-and-maps/">ECMAScript 6 Set과 Map</a></li>
<li><a href="https://infoscis.github.io/2018/01/31/ecmascript-6-iterators-and-generators/">ECMAScript 6 Iterator와 Generator</a></li>
<li><a href="https://infoscis.github.io/2018/02/13/ecmascript-6-introducing-javascript-classes/">ECMAScript 6 JavaScript 클래스 소개</a></li>
<li><a href="https://infoscis.github.io/2018/02/13/ecmascript-6-improved-array-capabilities/">ECMAScript 6 Array 기능 향상</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-promises-and-asynchronous-programming/">ECMAScript 6 Promise와 비동기 프로그램밍</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-proxies-and-the-reflection-api/">ECMAScript 6 프록시와 리플렉션 API</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-encapsulating-code-with-modules/">ECMAScript 6 Module로 코드 캡슐화하기</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-appendix-a-smaller-changes/">ECMAScript 6 부록 A. 작은 변경 사항</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-appendix-b-understanding-ecmascript-7/">ECMAScript 6 부록 B. ECMAScript 7(2016) 이해하기</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ECMAScript-6-부록-B-ECMAScript-7-2016-이해하기&quot;&gt;&lt;a href=&quot;#ECMAScript-6-부록-B-ECMAScript-7-2016-이해하기&quot; class=&quot;headerlink&quot; title=&quot;ECMAScript 6
    
    </summary>
    
      <category term="JavaScript" scheme="http://infoscis.github.io/categories/JavaScript/"/>
    
      <category term="ECMAScript 2015" scheme="http://infoscis.github.io/categories/JavaScript/ECMAScript-2015/"/>
    
    
      <category term="JavaScript" scheme="http://infoscis.github.io/tags/JavaScript/"/>
    
      <category term="ECMAScript 2015" scheme="http://infoscis.github.io/tags/ECMAScript-2015/"/>
    
  </entry>
  
  <entry>
    <title>ECMAScript 6 부록 A. 작은 변경 사항</title>
    <link href="http://infoscis.github.io/2018/02/27/ecmascript-6-appendix-a-smaller-changes/"/>
    <id>http://infoscis.github.io/2018/02/27/ecmascript-6-appendix-a-smaller-changes/</id>
    <published>2018-02-27T13:32:12.000Z</published>
    <updated>2018-02-27T14:11:33.451Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ECMAScript-6-부록-A-작은-변경-사항"><a href="#ECMAScript-6-부록-A-작은-변경-사항" class="headerlink" title="ECMAScript 6 부록 A. 작은 변경 사항"></a>ECMAScript 6 부록 A. 작은 변경 사항</h1><p>이 책에서 설명한 주요 변경 사항과 함께 ECMAScript 6은 작지만 JavaScript를 향상시키는데 도움이되는 몇가지 다른 변경 사항을 적용했습니다. 이러한 변경에는 정수를 더 쉽게 사용하고 계산하기 위한 새로운 메서드를 추가하였고, 유니 코드 식별자를 조정하고, <code>__proto__</code> 프로퍼티를 공식화하는 작업이 포함됩니다. 부록에서 이 모든 내용을 설명합니다.</p>
<h2 id="정수-Integer-작업"><a href="#정수-Integer-작업" class="headerlink" title="정수(Integer) 작업"></a>정수(Integer) 작업</h2><p>JavaScript는 IEEE 754 인코딩 시스템을 사용하여 정수와 부동 소수점을 모두 표현하므로 수년 동안 많은 혼란을 야기했습니다. JavaScript는 개발자가 숫자 인코딩의 세부사항에 대해 걱정할 필요가 없도록 하기위해 엄청난 노력을 기울였지만 문제는 계속되었습니다. ECMAScript 6은 정수를 쉽게 식별하고 사용할 수 있게함으로써 이 문제를 해결하려고 노력합니다.</p>
<h3 id="정수-확인하기"><a href="#정수-확인하기" class="headerlink" title="정수 확인하기"></a>정수 확인하기</h3><p>첫번째로, ECMAScript 6은 JavaScript에서 값(value)이 정수를 나타내는지 여부를 확인할 수있는 <code>Number.isInteger()</code> 메서드를 추가했습니다. JavaScript는 IEEE 754를 사용하여 두 타입의 숫자를 모두 나타내지만, 실수와 정수는 다르게 저장됩니다. <code>Number.isInteger()</code> 메서드는 이를 활용하여 메서드를 호출하면 JavaScript 엔진은 값의 기본 표현을 보고 해당 값이 정수인지 여부를 확인합니다. 즉, 실수처럼 보이는 숫자가 실제로 정수로 저장되어 있어도 <code>Number.isInteger()</code>가 <code>true</code>를 반환하도록 합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isInteger(<span class="number">25</span>));      <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isInteger(<span class="number">25.0</span>));    <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isInteger(<span class="number">25.1</span>));    <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p>이 코드에서 <code>Number.isInteger()</code>는 <code>25</code>와 <code>25.0</code> 모두에 대해 후자가 실수처럼 보일지라도 <code>true</code>를 반환합니다. 숫자에 소수점을 추가하는 것만으로 자동으로 JavaScript에서 부동 소수점을 차지하지 않습니다. <code>25.0</code>은 실제로 <code>25</code>와 같기 때문에 정수로 저장됩니다. 그러나 숫자 <code>25.1</code>는 분수 값이 있으므로 실수로 저장됩니다.</p>
<h3 id="안전한-정수"><a href="#안전한-정수" class="headerlink" title="안전한 정수"></a>안전한 정수</h3><p>IEEE 754는 -2^53와 2^53 사이의 정수만 정확하게 나타낼 수 있으며 이 “안전” 범위를 벗어나면 바이너리 표현은 여러개의 숫자 값으로 재사용됩니다. 즉, JavaScript는 IEEE 754 범위 내의 정수만 안전하게 나타낼 수 있습니다. 예를 들어 다음 코드를 살펴보겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>));      <span class="comment">// 9007199254740992</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) + <span class="number">1</span>);  <span class="comment">// 9007199254740992</span></div></pre></td></tr></table></figure>
<p>이 예제에서 두개의 다른 숫자가 동일한 JavaScript 정수로 표시됩니다. 값이 안전 범위를 벗어날수록 효과가 더 커집니다.</p>
<p>ECMAScript 6에서는 JavaScript가 정확하게 나타낼 수 있는 정수를 보다 잘 식별할 수 있도록 <code>Number.isSafeInteger()</code> 메서드를 도입했습니다. 또한 정수 범위의 상한과 하한을 각각 나타내는 <code>Number.MAX_SAFE_INTEGER</code> 및 <code>Number.MIN_SAFE_INTEGER</code> 프로퍼티를 추가했습니다. <code>Number.isSafeInteger()</code> 메서드는 값이 정수이고 아래의 예제에서와 같이 정수값의 안전한 범위내에 있는지 확인합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> inside = <span class="built_in">Number</span>.MAX_SAFE_INTEGER,</div><div class="line">    outside = inside + <span class="number">1</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isInteger(inside));          <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isSafeInteger(inside));      <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isInteger(outside));         <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isSafeInteger(outside));     <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p><code>inside</code>는 가장 큰 안전한 정수이므로 <code>Number.isInteger()</code>와 <code>Number.isSafeInteger()</code> 메서드 모두에 대해 <code>true</code>를 반환합니다. <code>outside</code>는 의심되는 첫 번째 정수값이며, 정수이지만 안전하지 않은 것으로 간주됩니다.</p>
<p>대부분의 경우, JavaScript에서 정수 연산 또는 비교를 수행할 때 안전한 정수를 처리하기를 원하므로 입력 유효성 검사의 일부로 <code>Number.isSafeInteger()</code>를 사용하는 것이 좋습니다.</p>
<h2 id="새로운-Math-메서드"><a href="#새로운-Math-메서드" class="headerlink" title="새로운 Math 메서드"></a>새로운 Math 메서드</h2><p>ECMAScript 6에서 <em>Typed array</em>가 JavaScript에 포함되어 게임 및 그래픽에 대한 JavaScript 엔진이 많은 수학적 계산을 보다 효율적으로 수행할 수 있다는 사실을 깨닫게됩니다. 그러나 asm.js와 같은 최적화 전략은 성능을 향상시키기 위해 JavaScript의 하위 집합에서 작동되고, 가능한 가장 빠른 방법으로 계산을 수행하는데 더 많은 정보가 필요합니다. 예를 들어, 숫자를 32비트 정수로 처리해야하는지 아니면 64비트 부동 소수점으로 처리해야하는지 여부를 아는 것이 중요하고, 소프트웨어 기반 연산보다 하드웨어 기반 연산이 훨씬 빠릅니다.</p>
<p>결과적으로, ECMAScript 6는 일반적인 수학적 계산의 속도를 향상시키기 위해 여러 가지 메서드를 <code>Math</code> 객체에 추가했습니다. 일반 계산 속도를 향상 시키면 그래픽 프로그램과 같이 많은 계산을 수행하는 응용 프로그램의 전체 속도가 향상됩니다. 새로운 메서드는 다음과 같습니다.</p>
<ul>
<li><code>Math.acosh(x)</code> <code>x</code>의 역쌍곡선 코사인을 반환합니다.</li>
<li><code>Math.asinh(x)</code> <code>x</code>의 역쌍곡선 사인을 돌려줍니다.</li>
<li><code>Math.atanh(x)</code> <code>x</code>의 역쌍곡선 탄젠트를 반환합니다.</li>
<li><code>Math.cbrt(x)</code> <code>x</code>의 세제곱근을 구합니다.</li>
<li><code>Math.clz32(x)</code> <code>x</code>의 32 비트 정수 표현으로 선두의 제로의 비트의 수를 돌려줍니다.</li>
<li><code>Math.cosh(x)</code> <code>x</code>의 쌍곡선 코사인을 반환합니다.</li>
<li><code>Math.expm1(x)</code> <code>x</code>의 지수 함수에서 1을 뺀 결과를 반환합니다.</li>
<li><code>Math.fround(x)</code> 가장 가까운 <code>x</code>의 단정도 float를 반환합니다.</li>
<li><code>Math.hypot(... values)</code> 각 인수의 제곱의 합계의 제곱근을 반환합니다.</li>
<li><code>Math.imul(x, y)</code> 2 개의 인수의 진정한 32 비트 승수를 실행 한 결과를 돌려줍니다.</li>
<li><code>Math.log1p(x)</code> <code>1 + x</code>의 자연 대수를 구합니다.</li>
<li><code>Math.log10(x)</code> <code>x</code>의 기본 10 로그를 구합니다.</li>
<li><code>Math.log2(x)</code> <code>x</code>의 기본 2 로그를 구합니다.</li>
<li><code>Math.sign(x)</code> <code>x</code>가 음수이면 -1을 반환하고 x가 +0 또는 -0이면 0을, x가 양수이면 1을 반환합니다.</li>
<li><code>Math.sinh(x)</code> <code>x</code>의 쌍곡선 사인을 돌려줍니다.</li>
<li><code>Math.tanh(x)</code> <code>x</code>의 쌍곡선 탄젠트를 반환합니다.</li>
<li><code>Math.trunc(x)</code> float에서 소수 자릿수를 제거하고 정수를 반환합니다.</li>
</ul>
<p>각각의 새로운 메서드의 자세한 설명은 이 책의 범위를 벗어납니다. 그러나 응용 프로그램에서 합리적으로 공통적인 계산을 수행해야하는 경우 직접 구현하기 전에 새로운 <code>Math</code> 메서드를 확인하십시오</p>
<h2 id="유니코드-식별자"><a href="#유니코드-식별자" class="headerlink" title="유니코드 식별자"></a>유니코드 식별자</h2><p>ECMAScript 6은 이전 버전의 JavaScript보다 더 나은 유니코드 지원을 제공하며 식별자로 사용할 수있는 문자도 변경합니다. ECMAScript 5에서는 이미 식별자에 유니코드 이스케이프 시퀀스를 사용할 수있었습니다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ECMAScript 5와 6에서 유효합니다.</span></div><div class="line"><span class="keyword">var</span> \u0061 = <span class="string">"abc"</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(\u0061);     <span class="comment">// "abc"</span></div><div class="line"></div><div class="line"><span class="comment">// 아래와 동일합니다.</span></div><div class="line"><span class="built_in">console</span>.log(a);          <span class="comment">// "abc"</span></div></pre></td></tr></table></figure></p>
<p>이 예제에서 <code>var</code> 문장 다음에 <code>\u0061</code> 또는 <code>a</code>를 사용하여 변수에 접근할 수 있습니다. ECMAScript 6에서는 다음과 같이 유니코드 코드포인트 이스케이프 시퀀스를 식별자로 사용할 수도 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ECMAScript 5와 6에서 유효합니다.</span></div><div class="line"><span class="keyword">var</span> \u&#123;<span class="number">61</span>&#125; = <span class="string">"abc"</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(\u&#123;<span class="number">61</span>&#125;);      <span class="comment">// "abc"</span></div><div class="line"></div><div class="line"><span class="comment">// 아래와 동일합니다.</span></div><div class="line"> <span class="built_in">console</span>.log(a);          <span class="comment">// "abc"</span></div></pre></td></tr></table></figure>
<p>이 예제는 단지 <code>\u0061</code>를 해당 코드포인트와 동일하게 대체합니다. 그리고 앞의 예제와 완전히 똑같습니다.</p>
<p>또한 ECMAScript 6은 유니코드 표준 <a href="http://unicode.org/reports/tr31/" target="_blank" rel="external">Annex # 31 : 유니 코드 식별자 및 패턴 구문</a>과 관련하여 유효한 식별자를 공식적으로 지정합니다. 이 식별자는 다음 규칙을 제공합니다.</p>
<ol>
<li>첫 번째 문자는 <code>$</code>, <code>_</code> 또는 <code>ID_Start</code>의 파생 코어 프로퍼티가 있는 모든 유니코드 여야합니다.</li>
<li>연속되는 각 문자는 <code>$</code>, <code>_</code>, <code>\u200c</code> (zero-width non-joiner), <code>\u200d</code> (zero-width joiner) 또는 <code>ID_Continue</code>의 파생 코어 프로퍼티가 있는 유니코드 여야합니다.</li>
</ol>
<p><code>ID_Start</code> 및 <code>ID_Continue</code>의 파생 코어 프로퍼티는 변수 및 도메인 이름과 같은 식별자에 사용하기 적합한 기호를 식별하는 방법으로 <a href="http://unicode.org/reports/tr31/" target="_blank" rel="external">유니 코드 식별자 및 패턴 구문</a>에서 정의됩니다. 이 사양은 JavaScript에만 해당되는 것이 아닙니다.</p>
<h2 id="proto-프로퍼티-공식화"><a href="#proto-프로퍼티-공식화" class="headerlink" title="__proto__ 프로퍼티 공식화"></a><code>__proto__</code> 프로퍼티 공식화</h2><p>ECMAScript 5가 완성되기 전에 여러 JavaScript 엔진이 이미 <code>[[Prototype]]</code> 프로퍼티를 가져오고 설정할 수있는 <code>__proto__</code>라는 사용자 정의 프로퍼티를 구현했습니다. <code>__proto__</code>는 <code>Object.getPrototypeOf()</code> 및 <code>Object.setPrototypeOf()</code> 메서드의 효과적인 초기 선행 도구였습니다. 모든 JavaScript 엔진에서 이 프로퍼티 제거를 기대하는것은 비현실적입니다(<code>__proto__</code>를 사용하는 인기있는 JavaScript 라이브러리가 있으므로). 그래서 ECMAScript 6은 <code>__proto__</code> 동작을 공식화합니다. 공식화는 아래의 경고와 함께 ECMA-262 부록 B에 설명되어 있습니다.</p>
<blockquote>
<p>이러한 기능은 핵심 ECMAScript 언어의 일부로 간주되지 않습니다. 프로그래머는 새로운 ECMAScript 코드를 작성할 때 이러한 기능 및 동작을 사용하거나 가정해서는 안됩니다. ECMAScript 구현은 구현이 웹 브라우저의 일부이거나 웹 브라우저에서 발생하는 것과 동일한 레거시 ECMAScript 코드를 실행해야하는 경우가 아니면 이러한 기능을 구현하지 않는 것이 좋습니다.</p>
</blockquote>
<p><code>__proto__</code>에는 다음과 같은 특성이 있으므로 ECMAScript 사양에서는 <code>Object.getPrototypeOf()</code> 및 <code>Object.setPrototypeOf()</code>를 대신 사용하도록 권장합니다.</p>
<ol>
<li>객체 리터럴에서는 <code>__proto__</code>를 한번만 지정할 수 있습니다. 두개의 <code>__proto__</code> 프로퍼티를 지정하면 오류가 발생합니다. 이것이 유일한 개체 리터럴 프로퍼티 제약입니다.</li>
<li>계산된 형식 <code>[&quot;__proto__&quot;]</code>는 일반 프로퍼티처럼 작동하며 현재 객체의 프로토 타입을 설정하거나 반환하지 않습니다. 객체 리터럴 프로퍼티와 관련된 모든 규칙이 이 형식으로 적용됩니다. 예외가있는 계산되지 않은 형식과는 대조적입니다.</li>
</ol>
<p><code>__proto__</code> 프로퍼티 사용을 피해야 하지만, 사양에서 정의한 방식은 흥미 롭습니다. ECMAScript 6 엔진에서 <code>Object.prototype.__ proto__</code>은 <code>get</code> 메서드가 <code>Object.getPrototypeOf()</code>를 호출하고 <code>set</code> 메서드가 <code>Object.setPrototypeOf()</code> 메서드를 호출하는 접근자 프로퍼티로 정의됩니다. 이것은 <code>__proto__</code>와 <code>Object.getPrototypeOf()</code> / <code>Object.setPrototypeOf()</code> 사이에 실제적인 차이를 남기지 않습니다. 단, <code>__proto__</code>를 사용하면 객체 리터럴의 프로토 타입을 직접 설정할 수 있습니다. 작동 방식은 다음과 같습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> person = &#123;</div><div class="line">    getGreeting() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"Hello"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> dog = &#123;</div><div class="line">    getGreeting() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"Woof"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// prototype is person</span></div><div class="line"><span class="keyword">let</span> friend = &#123;</div><div class="line">    <span class="attr">__proto__</span>: person</div><div class="line">&#125;;</div><div class="line"><span class="built_in">console</span>.log(friend.getGreeting());                      <span class="comment">// "Hello"</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(friend) === person);  <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(friend.__proto__ === person);               <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="comment">// set prototype to dog</span></div><div class="line">friend.__proto__ = dog;</div><div class="line"><span class="built_in">console</span>.log(friend.getGreeting());                      <span class="comment">// "Woof"</span></div><div class="line"><span class="built_in">console</span>.log(friend.__proto__ === dog);                  <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(friend) === dog);     <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>이 예는 <code>Object.create()</code>를 호출하여 <code>friend</code> 객체를 만드는 대신, <code>__proto__</code> 프로퍼티에 값을 할당하는 표준 객체 리터럴을 만듭니다. 반면에 <code>Object.create()</code> 메서드를 사용하여 객체를 만들때는 추가 객체 프로퍼티에 대해 전체 프로퍼티 descriptor를 지정해야합니다.</p>
<hr>
<blockquote>
<p>이 내용은 나중에 참고하기 위해 제가 공부하며 정리한 내용입니다.<br>의역, 오역, 직역이 있을 수 있음을 알려드립니다.<br>This post is a translation of this original article [<a href="https://leanpub.com/understandinges6/read#leanpub-auto-appendix-a-smaller-changes" target="_blank" rel="external">https://leanpub.com/understandinges6/read#leanpub-auto-appendix-a-smaller-changes</a>]</p>
</blockquote>
<h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul>
<li><a href="https://infoscis.github.io/2018/01/24/ecmascript-6-block-binding/">ECMAScript 6 Block Binding</a></li>
<li><a href="https://infoscis.github.io/2018/01/24/ecmascript-6-strings-and-regular-expressions/">ECMAScript 6 문자열과 정규 표현식</a></li>
<li><a href="https://infoscis.github.io/2018/01/24/ecmascript-6-functions/">ECMAScript 6 함수</a></li>
<li><a href="https://infoscis.github.io/2018/01/25/ecmascript-6-expanded-object-functionality/">ECMAScript 6 객체의 확장된 기능</a></li>
<li><a href="https://infoscis.github.io/2018/01/26/ecmascript-6-destructuring-for-easier-data-access/">ECMAScript 6 쉬운 데이터 액세스를 위한 Destructuring</a></li>
<li><a href="https://infoscis.github.io/2018/01/27/ecmascript-6-symbols-and-symbol-properties/">ECMAScript 6 Symbol과 Symbol 프로퍼티</a></li>
<li><a href="https://infoscis.github.io/2018/01/27/ecmascript-6-sets-and-maps/">ECMAScript 6 Set과 Map</a></li>
<li><a href="https://infoscis.github.io/2018/01/31/ecmascript-6-iterators-and-generators/">ECMAScript 6 Iterator와 Generator</a></li>
<li><a href="https://infoscis.github.io/2018/02/13/ecmascript-6-introducing-javascript-classes/">ECMAScript 6 JavaScript 클래스 소개</a></li>
<li><a href="https://infoscis.github.io/2018/02/13/ecmascript-6-improved-array-capabilities/">ECMAScript 6 Array 기능 향상</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-promises-and-asynchronous-programming/">ECMAScript 6 Promise와 비동기 프로그램밍</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-proxies-and-the-reflection-api/">ECMAScript 6 프록시와 리플렉션 API</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-encapsulating-code-with-modules/">ECMAScript 6 Module로 코드 캡슐화하기</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-appendix-a-smaller-changes/">ECMAScript 6 부록 A. 작은 변경 사항</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-appendix-b-understanding-ecmascript-7/">ECMAScript 6 부록 B. ECMAScript 7(2016) 이해하기</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ECMAScript-6-부록-A-작은-변경-사항&quot;&gt;&lt;a href=&quot;#ECMAScript-6-부록-A-작은-변경-사항&quot; class=&quot;headerlink&quot; title=&quot;ECMAScript 6 부록 A. 작은 변경 사항&quot;&gt;&lt;/a&gt;ECMAScr
    
    </summary>
    
      <category term="JavaScript" scheme="http://infoscis.github.io/categories/JavaScript/"/>
    
      <category term="ECMAScript 2015" scheme="http://infoscis.github.io/categories/JavaScript/ECMAScript-2015/"/>
    
    
      <category term="JavaScript" scheme="http://infoscis.github.io/tags/JavaScript/"/>
    
      <category term="ECMAScript 2015" scheme="http://infoscis.github.io/tags/ECMAScript-2015/"/>
    
  </entry>
  
  <entry>
    <title>ECMAScript 6 Module로 코드 캡슐화하기</title>
    <link href="http://infoscis.github.io/2018/02/27/ecmascript-6-encapsulating-code-with-modules/"/>
    <id>http://infoscis.github.io/2018/02/27/ecmascript-6-encapsulating-code-with-modules/</id>
    <published>2018-02-27T13:31:45.000Z</published>
    <updated>2018-02-27T14:11:26.929Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ECMAScript-6-Module로-코드-캡슐화하기"><a href="#ECMAScript-6-Module로-코드-캡슐화하기" class="headerlink" title="ECMAScript 6 Module로 코드 캡슐화하기"></a>ECMAScript 6 Module로 코드 캡슐화하기</h1><p>JavaScript의 “모든 공유” 방식의 코드 로드는 JavaScript를 오류가 발생하기 쉬운 가장 혼란스러운 언어 중 하나로 만듭니다. 다른 언어에서는 패키지와 같은 개념을 사용하여 코드 범위를 정의하지만 ECMAScript 6 이전에는 응용 프로그램의 모든 JavaScript 파일에 정의된 모든 것이 하나의 전역 <em>Scope</em>을 공유했습니다. 웹 애플리케이션이 더욱 복잡해지고 JavaScript 코드가 더많이 사용됨에 따라 이러한 접근 방식은 이름 충돌 및 보안 문제와 같은 문제를 야기했습니다. ECMAScript 6의 한가지 목표는 <em>Scope</em> 문제를 해결하고 JavaScript 응용 프로그램에 순서를 지정하는 것이 었습니다. 이것이 <em>Module</em>이 도입된 이유입니다.</p>
<h2 id="Module은-무엇일까요"><a href="#Module은-무엇일까요" class="headerlink" title="Module은 무엇일까요?"></a>Module은 무엇일까요?</h2><p><em>Module</em>은 다른 모드로 로드되는 JavaScript 파일입니다 (<em>Script</em>는 JavaScript가 작동하는 원래 방식으로 로드 됨). <em>Module</em>은 <em>Script</em>와 매우 다른 의미를 가지고 있기 때문에 다른 모드가 필요합니다.</p>
<ol>
<li><em>Module</em> 코드는 자동으로 strict 모드에서 실행되며 strict 모드를 거부 할 방법이 없습니다.</li>
<li><em>Module</em>의 최상위 레벨에서 작성된 변수는 공유된 전역 범위에 자동으로 추가되지 않습니다. <em>Module</em>의 최상위 범위에만 존재합니다.</li>
<li><em>Module</em>의 최상위 레벨에있는 <code>this</code>의 값은 `undefined ‘입니다.</li>
<li><em>Module</em>은 코드 내에서 HTML 스타일의 주석을 허용하지 않습니다 (JavaScript의 초기 브라우저 시절 남은 기능).</li>
<li><em>Module</em>은 <em>Module</em> 외부에서 사용할 수 있어야하는 모든 것을 export 해야합니다.</li>
<li><em>Module</em>은 다른 <em>Module</em>에서 바인딩을 가져올 수 있습니다.</li>
</ol>
<p>이 차이는 언뜻보기에 작게 보일 수 있지만 JavaScript 코드가 로드되고 평가되는 방식에 중요한 변화를 나타냅니다. 이것은 이장 전체에서  논의 할 것입니다. <em>Module</em>의 진정한 힘은 파일의 모든 것보다는 필요한 바인딩만 내보내고 가져 오는 기능입니다. <em>Module</em>이 <em>scripts</em>와 어떻게 다른지 이해하기 위해서는 내보내기(export)와 가져 오기(import)를 잘 이해해야합니다.</p>
<h2 id="export-기초"><a href="#export-기초" class="headerlink" title="export 기초"></a>export 기초</h2><p><code>export</code> 키워드를 사용하여 코드의 일부를 다른 <em>Module</em>에 노출할 수 있습니다. 가장 단순한 경우에, 변수, 함수 또는 클래스 선언 앞에<code>export</code>를 두어 다음과 같이 <em>Module</em>에서 내보낼 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// export data</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">var</span> color = <span class="string">"red"</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">let</span> name = <span class="string">"Nicholas"</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> magicNumber = <span class="number">7</span>;</div><div class="line"></div><div class="line"><span class="comment">// export function</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> num1 + num1;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// export class</span></div><div class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(length, width) &#123;</div><div class="line">        <span class="keyword">this</span>.length = length;</div><div class="line">        <span class="keyword">this</span>.width = width;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 이 함수는 Module에서 private입니다.</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">subtract</span>(<span class="params">num1, num2</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> num1 - num2;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 함수를 정의하고...</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">num1, num2</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> num1 * num2;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// ...나중에 내보낼수 있습니다.</span></div><div class="line"><span class="keyword">export</span> &#123; multiply &#125;;</div></pre></td></tr></table></figure>
<p>이 예에서 주의해야 할 몇가지 사항이 있습니다. 첫째, <code>export</code> 키워드를 제외하고 모든 선언은 다른 경우와 완전히 동일합니다. 내보낸 각 함수 또는 클래스에는 이름이 있습니다. 왜냐하면 내보낸 함수와 클래스 선언에는 이름이 필요하기 때문입니다. <code>default</code> 키워드를 사용하지 않는 이상 이구문을 사용하여 익명 함수나 클래스를 내보낼 수 없습니다 (“<em>Module</em>의 <em>Default</em>값” 섹션 참조).</p>
<p>다음으로, 정의되었을 때 <code>export</code>하지 않은 <code>multiply()</code> 함수를 생각해 보겠습니다. 이는 항상 선언에서 <code>export</code>할 필요가 없기 때문에 효과적입니다. 참조를 <code>export</code>할 수도 있습니다. 마지막으로 이 예제에서는 <code>subtract()</code> 함수를 <code>export</code>하지 않습니다. 명시적으로 <code>export</code>하지 않은 변수, 함수 또는 클래스는 <em>Module</em>에 비공개로 남아 있기 때문에 이 함수는 이 <em>Module</em> 외부에서 액세스할 수 없습니다.</p>
<h2 id="import-기초"><a href="#import-기초" class="headerlink" title="import 기초"></a>import 기초</h2><p><code>export</code>가 있는 <em>Module</em>이 있으면 <code>import</code> 키워드를 사용하여 다른 <em>Module</em>의 기능에 액세스할 수 있습니다. <code>import</code> 문의 두 부분은 가져올 식별자와 그 식별자를 가져올 <em>Module</em>입니다. 아래는 문장의 기본형태입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; identifier1, identifier2 &#125; <span class="keyword">from</span> <span class="string">"./example.js"</span>;</div></pre></td></tr></table></figure>
<p><code>import</code> 뒤의 중괄호는 주어진 <em>Module</em>로부터 가져올 바인딩을 나타냅니다. 키워드 <code>from</code>은 지정된 바인딩을 가져올 <em>Module</em>을 나타냅니다. <em>Module</em>은 경로를 나타내는 문자열로 지정됩니다 (<em>Module</em> 지정자라고 함). 브라우저는 <code>&lt;script&gt;</code> 요소에 전달할 동일한 경로 형식을 사용합니다. 즉, 파일 확장명을 포함해야합니다. 반대로, Node.js는 파일 시스템 접두사를 기반으로 로컬 파일과 패키지를 구별하는 전통적인 규칙을 따릅니다. 예를 들어 <code>example</code>은 패키지이고 <code>./example.js</code>는 로컬 파일입니다.</p>
<blockquote>
<p><code>import</code> 할 바인딩 목록은 Destructured 객체와 유사하지만 보이지는 않습니다.</p>
</blockquote>
<p><em>Module</em>로부터 바인딩을 <code>import</code>할 때 바인딩은 <code>const</code>를 사용하여 정의된 것처럼 동작합니다. 즉, 동일한 이름의 다른 변수를 정의할 수 없으며 (같은 이름의 다른 바인딩을 가져 오는 것을 포함하여), <code>import</code> 문 앞에 식별자를 사용하거나 값을 변경할 수 없다는 뜻입니다.</p>
<h3 id="단일-바인딩-import"><a href="#단일-바인딩-import" class="headerlink" title="단일 바인딩 import"></a>단일 바인딩 import</h3><p>“export 기초” 섹션의 첫 번째 예제가 파일 <code>example.js</code>의 <em>Module</em>에 있다고 가정합니다. 여러 가지 방법으로 해당 <em>Module</em>에서 바인딩을 가져오고 사용할 수 있습니다. 예를 들어 하나의 식별자만 가져올 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 하나만 가져 오기</span></div><div class="line"><span class="keyword">import</span> &#123; sum &#125; <span class="keyword">from</span> <span class="string">"./example.js"</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>, <span class="number">2</span>));     <span class="comment">// 3</span></div><div class="line"></div><div class="line">sum = <span class="number">1</span>;        <span class="comment">// error</span></div></pre></td></tr></table></figure>
<p><code>example.js</code>는 하나 이상의 함수를 <code>export</code>하지만, 이 예제는 <code>sum()</code>함수만 <code>import</code>합니다. <code>sum</code>에 새로운 값을 할당하려고하면, 가져온 바인딩을 재할당할 수 없기 때문에 결과는 오류입니다.</p>
<blockquote>
<p>브라우저와 Node.js간에 최상의 호환성을 위해 <code>import</code>하는 파일의 시작 부분에 <code>/</code>, <code>./</code> 또는 <code>../</code>을 포함시킵니다.</p>
</blockquote>
<h3 id="여러-바인딩-import"><a href="#여러-바인딩-import" class="headerlink" title="여러 바인딩 import"></a>여러 바인딩 import</h3><p>예제 <em>Module</em>에서 여러 바인딩을 <code>import</code>하기위해 다음과 같이 명시적으로 나열할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// import multiple</span></div><div class="line"><span class="keyword">import</span> &#123; sum, multiply, magicNumber &#125; <span class="keyword">from</span> <span class="string">"./example.js"</span>;</div><div class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>, magicNumber));   <span class="comment">// 8</span></div><div class="line"><span class="built_in">console</span>.log(multiply(<span class="number">1</span>, <span class="number">2</span>));        <span class="comment">// 2</span></div></pre></td></tr></table></figure>
<p>여기 예제 <em>Module</em>에서 <code>sum</code>, <code>multiply</code>, <code>magicNumber</code>의 세 가지 바인딩을 <code>import</code>합니다. 그런 다음 로컬에 정의된 것처럼 사용합니다.</p>
<h3 id="Module에서-모두-import"><a href="#Module에서-모두-import" class="headerlink" title="Module에서 모두 import"></a>Module에서 모두 import</h3><p>또한 <em>Module</em>의 전체를 단일 객체로 <code>import</code>할 수있는 특별한 경우가 있습니다. 그런 다음 해당 객체에서 <code>export</code>한 모든 것을 프로퍼티로로 사용할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// import everything</span></div><div class="line"><span class="keyword">import</span> * <span class="keyword">as</span> example <span class="keyword">from</span> <span class="string">"./example.js"</span>;</div><div class="line"><span class="built_in">console</span>.log(example.sum(<span class="number">1</span>,</div><div class="line">        example.magicNumber));          <span class="comment">// 8</span></div><div class="line"><span class="built_in">console</span>.log(example.multiply(<span class="number">1</span>, <span class="number">2</span>));    <span class="comment">// 2</span></div></pre></td></tr></table></figure>
<p>이 코드에서,<code>example.js</code>에 있는 <code>export</code>한 모든 바인딩은 <code>example</code>이라는 객체에 로드됩니다. 그러면 이름이 지정된 <code>export</code> (<code>sum()</code> 함수, <code>multiple()</code> 함수 및 <code>magicNumber</code>)는 <code>example</code>의 프로퍼티로 액세스할 수 있습니다. 이 <code>import</code> 형식을 <em>namespace import</em>라고합니다. 왜냐하면 <code>example</code> 객체는 <code>example.js</code> 파일안에 존재하지 않고 <code>example.js</code>의 <code>export</code>한 모든 멤버들에 대한 네임 스페이스 객체로 사용되기 위해 생성되기 때문입니다.</p>
<p>그러나 <code>import</code> 문에서 <em>Module</em>을 몇번이나 사용하더라도 <em>Module</em>은 한번만 실행됩니다. <em>Module</em>을 <code>import</code>한 코드가 실행된 후에, 인스턴스화된 <em>Module</em>은 메모리에 유지되고 다른 <code>import</code> 문이 그것을 참조할 때마다 재사용됩니다. 다음을 살펴보겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; sum &#125; <span class="keyword">from</span> <span class="string">"./example.js"</span>;</div><div class="line"><span class="keyword">import</span> &#123; multiply &#125; <span class="keyword">from</span> <span class="string">"./example.js"</span>;</div><div class="line"><span class="keyword">import</span> &#123; magicNumber &#125; <span class="keyword">from</span> <span class="string">"./example.js"</span>;</div></pre></td></tr></table></figure>
<p>이 <em>Module</em>에는 <code>import</code>문이 세개 있지만 <code>example.js</code>는 한번만 실행됩니다. 동일한 애플리케이션의 다른 <em>Module</em>이 <code>example.js</code>에서 바인딩을 <code>import</code>하는 경우 이 <em>Module</em>은 이 코드에서 사용하는 것과 동일한 <em>Module</em> 인스턴스를 사용합니다.</p>
<h3 id="Module-구문-제한-사항"><a href="#Module-구문-제한-사항" class="headerlink" title="Module 구문 제한 사항"></a>Module 구문 제한 사항</h3><p><code>export</code>와 <code>import</code>의 중요한 제한 사항은 구문과 함수 밖에서 사용해야한다는 것입니다. 예를 들어 이 코드는 구문 오류를 발생시킵니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (flag) &#123;</div><div class="line">    <span class="keyword">export</span> flag;    <span class="comment">// syntax error</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>export</code> 문장이 <code>if</code>문 안에 있습니다. 이것은 허용되지 않습니다. <code>export</code>는 어떤 방식으로든 조건부 이거나 동적일 수 없습니다. <em>Module</em> 구문이 존재하는 한가지 이유는 JavaScript 엔진이 <code>export</code>하는 것을 정적으로 결정하게 하기 위해서입니다. 따라서 <em>Module</em>의 최상위 레벨에서만 <code>export</code>를 사용할 수 있습니다.</p>
<p>마찬가지로 명령문 내부에서는 <code>import</code>를 사용할 수 없습니다. 최상위 레벨에서만 사용할 수 있습니다. 즉, 아래 코드는 구문 오류입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">tryImport</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">import</span> flag <span class="keyword">from</span> <span class="string">"./example.js"</span>;    <span class="comment">// syntax error</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>동적으로 바인딩을 <code>export</code>할 수 없는 것과 같은 이유로 동적으로 바인딩을 <code>import</code>할 수 없습니다. <code>export</code>와 <code>import</code> 키워드는 텍스트 편집기와 같은 도구가 <em>Module</em>에서 어떤 정보를 사용할 수 있는지 쉽게 알수있도록 정적으로 설계되었습니다.</p>
<h3 id="import한-바인딩의-미묘한-특성"><a href="#import한-바인딩의-미묘한-특성" class="headerlink" title="import한 바인딩의 미묘한 특성"></a>import한 바인딩의 미묘한 특성</h3><p>ECMAScript 6의 <code>import</code> 문은 일반 변수와 같이 원래 바인딩을 단순히 참조하는 것이 아니라 변수, 함수 및 클래스에 대한 읽기 전용 바인딩을 만듭니다. 바인딩을 <code>import</code>하는 <em>Module</em>은 값을 변경할 수 없지만 해당 식별자를 <code>export</code>하는 <em>Module</em>은 값을 변경할 수 있습니다. 예를 들어, 이 <em>Module</em>을 사용한다고 가정 해보겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">var</span> name = <span class="string">"Nicholas"</span>;</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">newName</span>) </span>&#123;</div><div class="line">    name = newName;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>이 두 바인딩을 <code>import</code>하면 <code>setName()</code> 함수는 <code>name</code>의 값을 바꿀 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; name, setName &#125; <span class="keyword">from</span> <span class="string">"./example.js"</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(name);       <span class="comment">// "Nicholas"</span></div><div class="line">setName(<span class="string">"Greg"</span>);</div><div class="line"><span class="built_in">console</span>.log(name);       <span class="comment">// "Greg"</span></div><div class="line"></div><div class="line">name = <span class="string">"Nicholas"</span>;       <span class="comment">// error</span></div></pre></td></tr></table></figure>
<p><code>setName(&quot;Greg&quot;)</code>에 대한 호출은 <code>setName()</code>을 <code>export</code>한 <em>Module</em>로 돌아가서 실행이 되고 <code>name</code>을 <code>&quot;Greg&quot;</code>로 설정합니다. 이 변경은 <code>import</code>한 <code>name</code> 바인딩에 자동으로 반영됩니다. <code>name</code>은 <code>export</code>한 <code>name</code> 식별자의 로컬 이름이기 때문입니다. 위의 코드에서 사용된 <code>name</code>과 <code>import</code>한 <em>Module</em>에서 사용된 <code>name</code>은 같지 않습니다.</p>
<h2 id="이름을-변경하여-export와-import"><a href="#이름을-변경하여-export와-import" class="headerlink" title="이름을 변경하여 export와 import"></a>이름을 변경하여 export와 import</h2><p>때로는 <em>Module</em>에서 <code>import</code>한 변수, 함수 또는 클래스의 원래 이름을 사용하지 않을 수도 있습니다. 다행히도 <code>export</code> 및 <code>import</code>하는 동안 <code>export</code>의 이름을 변경할 수 있습니다.</p>
<p>첫번째 경우, 다른 이름으로 <code>export</code>하려는 함수가 있다고 가정합니다. <code>as</code> 키워드를 사용하여 함수가 <em>Module</em> 외부로 알려진 이름을 지정할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> &#123; sum <span class="keyword">as</span> add &#125;;</div></pre></td></tr></table></figure>
<p>여기서 <code>sum()</code> 함수(<code>sum</code>은 로컬 이름입니다)는 <code>add()</code>(<code>add</code>는 <code>export</code>한 이름입니다)로 <code>export</code>됩니다. 즉, 다른 <em>Module</em>이 이 함수를 <code>import</code>하기 원할 때 <code>sum</code> 대신 <code>add</code>라는 이름을 사용해야 합니다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; add &#125; <span class="keyword">from</span> <span class="string">"./example.js"</span>;</div></pre></td></tr></table></figure>
<p>함수를 <code>import</code>하는 <em>Module</em>이 다른 이름을 사용하고 싶다면, <code>as</code>를 사용할 수도 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; add <span class="keyword">as</span> sum &#125; <span class="keyword">from</span> <span class="string">"./example.js"</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> add);            <span class="comment">// "undefined"</span></div><div class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>, <span class="number">2</span>));             <span class="comment">// 3</span></div></pre></td></tr></table></figure>
<p>이 코드는 <code>import name</code>을 사용하여 <code>add()</code> 함수를 <code>import</code>해서 <code>sum()</code>(로컬 이름)으로 이름을 바꿉니다. 즉, 이 <em>Module</em>에는 <code>add</code>라는 이름의 식별자가 없습니다.</p>
<h2 id="Module의-Default-값"><a href="#Module의-Default-값" class="headerlink" title="Module의 Default 값"></a>Module의 Default 값</h2><p><em>Module</em> 구문은 실제로 <em>Module</em>에서 <em>Default</em>값을 <code>export</code>하고 <code>import</code>하는데 최적화되어 있습니다. 이 패턴은 CommonJS(브라우저 외부에서 JavaScript를 사용하기위한 또 다른 사양)와 같이 다른 <em>Module</em> 시스템에서 상당히 일반적이었습니다. <em>Module</em>의 <em>Default</em>값은 <code>default</code> 키워드로 지정된 단일 변수, 함수 또는 클래스이며 <em>Module</em> 당 하나의 <em>Default</em> <code>export</code>만 설정할 수 있습니다. <code>default</code> 키워드를 다중 <code>export</code>와 함께 사용하는 것은 구문 오류입니다.</p>
<h3 id="Default-값-export"><a href="#Default-값-export" class="headerlink" title="Default 값 export"></a>Default 값 export</h3><p>다음은<code>default</code> 키워드를 사용하는 간단한 예제입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>이 <em>Module</em>은 함수를 <em>Default</em>값으로 <code>export</code>합니다. <code>default</code> 키워드는 이것이 <em>Default</em> <code>export</code> 임을 나타냅니다. 이 함수는 <em>Module</em> 자체가 함수를 나타내기 때문에 이름을 요구하지 않습니다.</p>
<p>다음과 같이 <code>export default</code> 다음에 식별자를 배치하여 식별자를 <em>Default</em> <code>export</code>로 지정할 수도 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> sum;</div></pre></td></tr></table></figure>
<p>여기에서 <code>sum()</code> 함수가 먼저 정의되고 나중에 <em>Module</em>의 <em>Default</em>값으로 <code>export</code>됩니다. <em>Default</em>값으로 계산을 사용해야하는 경우 이방법을 선택할 수 있습니다.</p>
<p>식별자를 <em>Default</em> <code>export</code>로 지정하는 세 번째 방법은 다음과 같이 이름 바꾸기 구문을 사용하는 것입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> &#123; sum <span class="keyword">as</span> <span class="keyword">default</span> &#125;;</div></pre></td></tr></table></figure>
<p>식별자 <code>default</code>는 이름 바꿔서 <code>export</code>에서 특별한 의미를 가지며 값이 <em>Module</em>의 <em>Default</em>값이어야 함을 나타냅니다. <code>default</code>는 JavaScript에서 키워드이기 때문에 변수, 함수 또는 클래스 이름으로 사용할 수 없습니다 (프로퍼티 이름으로 사용할 수 있음). 그래서 <code>export</code>의 이름을 바꾸기 위해 <code>default</code>를 사용하는 것은 <em>Default</em>값이 아닌 <code>export</code>에 정의된 방법과 일관성을 유지하는 특별한 경우입니다. 이 구문은 단일 <code>export</code> 문을 사용하여 <em>Default</em>값을 포함한 여러 <code>export</code>를 동시에 지정하려는 경우 유용합니다.</p>
<h3 id="Default-값-import"><a href="#Default-값-import" class="headerlink" title="Default 값 import"></a>Default 값 import</h3><p>다음 구문을 사용하여 <em>Module</em>에서 <em>Default</em>값을 <code>import</code>할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// import the default</span></div><div class="line"><span class="keyword">import</span> sum <span class="keyword">from</span> <span class="string">"./example.js"</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>, <span class="number">2</span>));     <span class="comment">// 3</span></div></pre></td></tr></table></figure>
<p>이 <code>import</code> 명령문은 <em>Module</em> <code>example.js</code>에서 <em>Default</em>값을 <code>import</code>합니다. <em>Default</em>가 아닌 <code>import</code>에서 볼 수있는 것과는 달리 중괄호는 사용되지 않습니다. 로컬 이름 <code>sum</code>은 <em>Module</em>이 <code>export</code>하는 <em>Default</em> 함수을 나타내는데 사용됩니다. 이 구문은 가장 깨끗하고, ECMAScript 6의 제작자는 이것이 웹상에서 가장 많이 사용되는 형식이기를 기대하며 이미 존재하는 객체를 사용할 수 있습니다.</p>
<p><em>Default</em> 바인딩과 하나 이상의 <em>Default</em>가 아닌 바인딩을 모두 <code>export</code>하는 <em>Module</em>의 경우 하나의 명령문으로 모든 <code>export</code> 바인딩을 가져올 수 있습니다. 예를 들어, 이 <em>Module</em>을 가지고 있다고 가정해 보겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">let</span> color = <span class="string">"red"</span>;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>다음의 <code>import</code> 문을 사용하여<code>color</code>와 <em>Default</em> 함수를 모두 <code>import</code>할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> sum, &#123; color &#125; <span class="keyword">from</span> <span class="string">"./example.js"</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>, <span class="number">2</span>));     <span class="comment">// 3</span></div><div class="line"><span class="built_in">console</span>.log(color);         <span class="comment">// "red"</span></div></pre></td></tr></table></figure>
<p>쉼표는 <em>Default</em> 로컬 이름을 중괄호로 묶인 <em>Default</em>값이 아닌 값과 구분합니다. <em>Default</em>값은 <code>import</code> 문에서 <em>Default</em>가 아닌값 앞에 와야한다는 것을 명심하십시오.</p>
<p><em>Default</em>값을 <code>export</code>하는 것과 마찬가지로, 이름 바꾸기 구문을 이용하여 <em>Default</em>값을 <code>import</code>할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 이전 예제와 동일합니다.</span></div><div class="line"><span class="keyword">import</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> sum, color &#125; <span class="keyword">from</span> <span class="string">"example"</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>, <span class="number">2</span>));     <span class="comment">// 3</span></div><div class="line"><span class="built_in">console</span>.log(color);         <span class="comment">// "red"</span></div></pre></td></tr></table></figure>
<p>이 코드에서 <em>Default</em> <code>export</code>(<code>default</code>)는 <code>sum</code>으로 이름이 바뀌고 추가적으로 <code>color</code> <code>export</code> 또한 가져옵니다. 이 예제는 앞의 예제와 동일합니다.</p>
<h2 id="바인딩을-다시-export"><a href="#바인딩을-다시-export" class="headerlink" title="바인딩을 다시 export"></a>바인딩을 다시 export</h2><p><em>Module</em>이 <code>import</code>한 내용을 다시 <code>export</code>하고 싶을 때가 있을 수 있습니다 (예 : 여러 개의 작은 <em>Module</em>로 라이브러리를 만드는 경우). 이 장에서 이미 설명한 패턴을 사용하여 <code>import</code>한 값을 다음과 같이 다시 <code>export</code>할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; sum &#125; <span class="keyword">from</span> <span class="string">"./example.js"</span>;</div><div class="line"><span class="keyword">export</span> &#123; sum &#125;</div></pre></td></tr></table></figure>
<p>이게 효과가 있지만, 하나의 문장으로 똑같은 일을 할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> &#123; sum &#125; <span class="keyword">from</span> <span class="string">"./example.js"</span>;</div></pre></td></tr></table></figure>
<p>이 형태의 <code>export</code>는 <code>sum</code>의 선언을 위해 지정된 <em>Module</em>을 <code>export</code>합니다. 물론 동일한 값에 대해 다른 이름을 <code>export</code>하도록 선택할 수도 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> &#123; sum <span class="keyword">as</span> add &#125; <span class="keyword">from</span> <span class="string">"./example.js"</span>;</div></pre></td></tr></table></figure>
<p>여기서 <code>sum</code>은 <code>&quot;./example.js&quot;</code>에서 <code>import</code>한 후 <code>add</code>라는 이름으로 <code>export</code>합니다.</p>
<p>다른 <em>Module</em>의 모든 것을 <code>export</code>하려면 <code>*</code> 패턴을 사용할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">"./example.js"</span>;</div></pre></td></tr></table></figure>
<p>모든 것을 <code>export</code>하면 이름이 있는 <code>export</code>뿐만 아니라 <em>Default</em>값도 포함되기 때문에 <em>Module</em>에서 <code>export</code>할 수있는 것에 영향을 줄 수 있습니다. 예를 들어, <code>example.js</code>에 <em>Default</em> <code>export</code>가 있는 경우 이 구문을 사용하면 새로운 <em>Default</em> <code>export</code>를 정의할 수 없습니다.</p>
<h2 id="바인딩없이-import"><a href="#바인딩없이-import" class="headerlink" title="바인딩없이 import"></a>바인딩없이 import</h2><p>일부 <em>Module</em>은 아무것도 <code>export</code>할 수 없으며 전역 범위의 객체만 수정하기도 합니다. <em>Module</em> 내의 최상위 변수, 함수 및 클래스가 전역 범위에서 자동으로 끝나지는 않지만 이것은 <em>Module</em>이 전역 범위에 액세스 할 수 없다는 것을 의미하지는 않습니다. <code>Array</code>와 <code>Object</code>와 같은 <em>Built-in</em> 객체의 공유된 정의는 <em>Module</em> 내에서 접근 가능하며, 그 객체에 대한 변경은 다른 <em>Module</em>에 반영됩니다.</p>
<p>예를 들어, 모든 <em>Array</em>에 <code>pushAll()</code> 메서드를 추가하려면 다음과 같이 <em>Module</em>을 정의할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// export 또는 import가 없는 module 코드</span></div><div class="line"><span class="built_in">Array</span>.prototype.pushAll = <span class="function"><span class="keyword">function</span>(<span class="params">items</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// items은 array여야만 합니다.</span></div><div class="line">    <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(items)) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Argument must be an array."</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Built-in된 push() 및 spread 연산자 사용</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.push(...items);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>이것은 <code>export</code> 또는 <code>import</code>가 없더라도 유효한 <em>Module</em>입니다. 이 코드는 <em>Module</em>과 script로 모두 사용할 수 있습니다. 아무 것도 <code>export</code>할 수 없기 때문에 <code>import</code>를 사용하여 바인딩을 가져 오지 않고 <em>Module</em> 코드를 실행할 수 있습니다.</p>
<p>이 코드는 <code>pushAll()</code> 메서드가 포함된 <em>Module</em>을 <code>import</code>해서 실행하므로 <code>pushAll()</code>이 <em>Array</em> 프로토 타입에 추가됩니다. 즉, 이 <em>Module</em> 내부의 모든 <em>Array</em>에서 <code>pushAll()</code>을 사용할 수 있습니다.</p>
<blockquote>
<p>바인딩이없는 <code>import</code>하는 대부분의 경우 polyfill과 shim을 만드는 데 사용됩니다.</p>
</blockquote>
<h2 id="Module-로딩"><a href="#Module-로딩" class="headerlink" title="Module 로딩"></a>Module 로딩</h2><p>ECMAScript 6에서는 <em>Module</em> 구문을 정의하지만 로드하는 방법은 정의하지 않습니다. 모든 JavaScript 환경에서 작동할 수있는 단일 사양을 작성하는 대신 ECMAScript 6은 구문만 지정하고 로드 메커니즘을 <code>HostResolveImportedModule</code>이라는 정의되지 않은 내부 작업으로 추상화합니다. 웹 브라우저와 Node.js는 각각의 환경에 적합한 방식으로 <code>HostResolveImportedModule</code>을 구현하는 방법을 결정해야합니다.</p>
<h3 id="웹-브라우저에서-Module-사용하기"><a href="#웹-브라우저에서-Module-사용하기" class="headerlink" title="웹 브라우저에서 Module 사용하기"></a>웹 브라우저에서 Module 사용하기</h3><p>ECMAScript 6 이전에도 웹 브라우저에는 웹 응용 프로그램에 JavaScript를 포함시키는 여러 가지 방법이 있었습니다. 이러한 script 로드 옵션은 다음과 같습니다.</p>
<ol>
<li>코드를 로드 할 위치를 지정하는 <code>src</code> Attribute와 함께 <code>&lt;script&gt;</code> 요소를 사용하여 JavaScript 코드 파일로드.</li>
<li><code>src</code> Attribute 없이 <code>&lt;script&gt;</code> 요소를 사용하여 JavaScript 코드를 인라인으로 포함.</li>
<li>웹 Worker 또는 서비스 Worker와 같이 Worker로 실행되는 JavaScript 코드 파일로드.</li>
</ol>
<p><em>Module</em>을 완벽하게 지원하려면 웹 브라우저가 이러한 각 메커니즘을 업데이트 해야했습니다. 이러한 세부 사항은 HTML 사양에 정의되어 있으며 이 섹션에서 설명합니다.</p>
<h4 id="로-Module-사용하기"><a href="#로-Module-사용하기" class="headerlink" title="로 Module 사용하기"></a><script>로 Module 사용하기</h4><p><code>&lt;script&gt;</code> 요소의 기본 동작은 JavaScript 파일에서 <em>Script</em>를 (<em>Module</em>이 아닌)로드하는 것입니다. 이것은 <code>type</code> Attribute가 없거나 <code>type</code> Attribute가 JavaScript 콘텐츠 유형 (예 : <code>&quot;text/javascript&quot;</code>)을 포함할 때 발생합니다. <code>&lt;script&gt;</code> 요소는 인라인 코드를 실행하거나 <code>src</code>에 지정된 파일을 로드할 수 있습니다. <em>Module</em>을 지원하기 위해 <code>&quot;module&quot;</code>값이 <code>type</code> 옵션으로 추가되었습니다. <code>type</code>을 <code>&quot;module&quot;</code>로 설정하면 브라우저가 <code>src</code>에 지정된 파일에 포함된 인라인 코드 또는 코드를 <em>Script</em> 대신 <em>Module</em>로 로드합니다. 다음은 간단한 예제입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;!-- JavaScript파일을 <span class="built_in">module</span>로 로드 --&gt;</div><div class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span> <span class="attr">src</span>=<span class="string">"module.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div><div class="line"></div><div class="line">&lt;!-- 인라인 <span class="built_in">module</span>로 가져옴 --&gt;</div><div class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span>&gt;</span><span class="javascript"></div><div class="line"></div><div class="line"><span class="keyword">import</span> &#123; sum &#125; <span class="keyword">from</span> <span class="string">"./example.js"</span>;</div><div class="line"></div><div class="line"><span class="keyword">let</span> result = sum(<span class="number">1</span>, <span class="number">2</span>);</div><div class="line"></div><div class="line"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure>
<p>이 예제의 첫 번째 <code>&lt;script&gt;</code> 엘리먼트는 <code>src</code> Attribute를 사용하여 외부 <em>Module</em> 파일을 로드합니다. <em>Script</em>를 로딩하는 것과 유일한 차이점은 <code>&quot;module&quot;</code>이 <code>type</code>의 값으로 주어진다는 것입니다. 두 번째 <code>&lt;script&gt;</code> 엘리먼트는 웹 페이지에 직접 삽입되는 형태로 <em>Module</em>을 포함합니다. 변수 <code>result</code>는 <em>Module</em> 내에서만 존재하기 때문에 (<code>&lt;script&gt;</code> 요소로 정의됨) 전역적으로 노출되지 않으므로 프로퍼티로 <code>window</code>에 추가되지 않습니다.</p>
<p>웹 페이지에 <em>Module</em>을 포함하는 것이 매우 간단하고, <em>Script</em>를 포함하는 것과 유사합니다. 그러나 <em>Module</em> 로드 방법에는 몇가지 차이점이 있습니다.</p>
<blockquote>
<p><code>&quot;module&quot;</code>이 <code>&quot;text/javascript&quot;</code>과 같은 타입이 아니라는 사실을 알고있을 것입니다. <em>Module</em> JavaScript 파일은 <em>Script</em> JavaScript 파일과 동일한 콘텐츠 유형으로 제공되므로 콘텐츠 유형에 따라 차별화할 수 없습니다. 또한 브라우저는 <code>type</code>이 인식되지 않을 때 <code>&lt;script&gt;</code> 요소를 무시하므로 <em>Module</em>을 지원하지 않는 브라우저는 자동으로 <code>&lt;script type=&quot;module&quot;&gt;</code> 행을 무시하므로 하위 호환성을 유지할 수 있습니다.</p>
</blockquote>
<h4 id="웹-브라우저에서-Module-로딩-순서"><a href="#웹-브라우저에서-Module-로딩-순서" class="headerlink" title="웹 브라우저에서 Module 로딩 순서"></a>웹 브라우저에서 Module 로딩 순서</h4><p><em>Script</em>와 달리 <em>Module</em>은 <code>import</code>를 사용하여 다른 파일에서 올바르게 실행되도록 지정해야한다는 점에서 독특합니다. 이 기능을 지원하기 위해 <code>&lt;script type=&quot;module&quot;&gt;</code>은 항상 <code>defer</code> Attribute가 적용된 것처럼 실행됩니다.</p>
<p><code>defer</code> Attribute는 <em>Script</em> 파일을 로딩할 때 선택 사항이지만 항상 <em>Module</em> 파일 로딩에 적용됩니다. HTML 파서가 <code>src</code> Attribute로<code>&lt;script type=&quot;module&quot;&gt;</code>을 만나면 Document가 완전히 파싱된 후에야 실행됩니다. <em>Module</em>은 HTML 파일에 나타나는 순서대로 실행됩니다. 즉, 첫 번째 <code>&lt;script type=&quot;module&quot;&gt;</code>은 <code>src</code>를 지정하는 대신 <em>Module</em>에 인라인 코드가 포함되어 있어도 두 번째 <em>Module</em>보다 먼저 실행되도록 보장됩니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 첫 번째로 실행됩니다. --&gt;</div><div class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span> <span class="attr">src</span>=<span class="string">"module1.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div><div class="line"></div><div class="line">&lt;!-- 두 번째로 실행됩니다. --&gt;</div><div class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span>&gt;</span><span class="javascript"></div><div class="line"><span class="keyword">import</span> &#123; sum &#125; <span class="keyword">from</span> <span class="string">"./example.js"</span>;</div><div class="line"></div><div class="line"><span class="keyword">let</span> result = sum(<span class="number">1</span>, <span class="number">2</span>);</div><div class="line"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div><div class="line"></div><div class="line">&lt;!-- 세 번째로 실행 됩니다. --&gt;</div><div class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span> <span class="attr">src</span>=<span class="string">"module2.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure>
<p>이 세개의 <code>&lt;script&gt;</code> 요소는 지정된 순서대로 실행되므로 <code>module1.js</code>는 인라인 <em>Module</em>보다 먼저 실행되도록 보장되며 인라인 <em>Module</em>은 <code>module2.js</code>보다 먼저 실행되도록 보장됩니다.</p>
<p>각 <em>Module</em>은 하나 이상의 다른 <em>Module</em>에서 가져올 수 있으므로 문제가 복잡해집니다. 그래서 <em>Module</em>은 모든 <code>import</code> 문을 식별하기 위해 완전히 파싱됩니다. 각각의 <code>import</code> 문은 (네트워크나 캐시로부터) 파일 내용을 모두 전송 받고, <code>import</code> 리소스가 모두 로드되어 실행될 때까지 <em>Module</em>은 실행되지 않습니다.</p>
<p><code>&lt;script type=&quot;module&quot;&gt;</code>을 사용하여 명시적으로 포함된 <em>Module</em>과 <code>import</code>를 사용하여 암시적으로 포함된 <em>Module</em> 모두 로드되고 순서대로 실행됩니다. 앞의 예제에서 전체 로드 순서는 다음과 같습니다.</p>
<ol>
<li><code>module1.js</code>를 다운로드하고 파싱합니다.</li>
<li><code>module1.js</code>에서 <code>import</code> 리소스를 반복적으로 다운로드하고 구문 분석합니다.</li>
<li>인라인 <em>Module</em>을 구문 분석합니다.</li>
<li>인라인 <em>Module</em>에서 <code>import</code> 리소스를 반복적으로 다운로드하고 구문 분석합니다.</li>
<li><code>module2.js</code>를 다운로드하고 파싱합니다.</li>
<li><code>module2.js</code>에서 <code>import</code> 리소스를 반복적으로 다운로드하고 구문 분석합니다.</li>
</ol>
<p>로딩이 완료되면 Document가 완전히 파싱될 때까지 아무 것도 실행되지 않습니다. Document 구문 분석이 완료되면 다음 작업이 수행됩니다.</p>
<ol>
<li><code>module1.js</code>에 대한 <code>import</code> 리소스를 반복적으로 실행합니다.</li>
<li><code>module1.js</code>를 실행합니다.</li>
<li>인라인 <em>Module</em>에 대한 <code>import</code> 리소스를 반복적으로 실행합니다.</li>
<li>인라인 <em>Module</em>을 실행합니다.</li>
<li><code>module2.js</code>에 <code>import</code> 오기 리소스를 반복적으로 실행합니다.</li>
<li><code>module2.js</code>를 실행합니다.</li>
</ol>
<p>인라인 <em>Module</em>은 코드를 먼저 다운로드 할 필요가 없다는 것을 제외하고는 다른 두 <em>Module</em>과 같이 작동합니다. <code>import</code> 리소스를 로드하고 <em>Module</em>을 실행하는 순서가 완전히 동일합니다.</p>
<blockquote>
<p><code>defer</code> Attribute는 <code>&lt;script type=&quot;module&quot;&gt;</code>에서 무시됩니다. 왜냐하면 이미 <code>defer</code>가 적용된 것처럼 행동하기 때문입니다.</p>
</blockquote>
<h4 id="웹-브라우저에서-비동기로-Module-로드"><a href="#웹-브라우저에서-비동기로-Module-로드" class="headerlink" title="웹 브라우저에서 비동기로 Module 로드"></a>웹 브라우저에서 비동기로 Module 로드</h4><p>여러분은 이미 <code>&lt;script&gt;</code> 요소에 <code>async</code> Attribute를 잘 알고있을 것입니다. <em>Script</em>와 함께 사용될 때, <code>async</code>는 파일이 완전히 다운로드되고 파싱 되자마자 <em>Script</em> 파일이 실행되도록합니다. 그러나 Document에서 <code>async</code> <em>Script</em>의 순서는 <em>Script</em>가 실행되는 순서에 영향을 미치지 않습니다. <em>Script</em>는 포함된 Document의 구문 분석을 기다리지 않고 다운로드가 끝나면 항상 실행됩니다.</p>
<p><code>async</code> Attribute는 <em>Module</em>에도 적용할 수 있습니다. <code>&lt;script type=&quot;module&quot;&gt;</code>에 <code>async</code>를 사용하면 <em>Module</em>이 <em>Script</em>와 비슷한 방식으로 실행됩니다. 유일한 차이점은 <em>Module</em> 자체가 실행되기 전에 <em>Module</em>에 대한 모든 <code>import</code> 리소스가 다운로드된다는 것입니다. <em>Module</em>을 실행하기 전에 <em>Module</em>이 작동하는데 필요한 모든 자원이 다운로드됩니다. <em>Module</em>이 언제 실행되는지는 보장 할 수 없습니다. 다음 코드를 살펴보겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 어떤것이 먼저 실행될지 보장할 수 없습니다. --&gt;</div><div class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">"module1.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div><div class="line">&lt;script type=<span class="string">"module"</span> <span class="keyword">async</span> src=<span class="string">"module2.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure>
<p>이 예제에서는 두개의 <em>Module</em> 파일이 비동기적으로 로드됩니다. 이 코드를 보면 어떤 <em>Module</em>이 먼저 실행되는지 알 수 없습니다. <code>module1.js</code>가 먼저 다운로드를 끝내면 (<code>import</code> 리소스 모두 포함), 먼저 실행될 것입니다. <code>module2.js</code>가 먼저 다운로드를 끝내면 그 <em>Module</em>이 먼저 실행됩니다.</p>
<h4 id="Module을-Worker로-로딩하기"><a href="#Module을-Worker로-로딩하기" class="headerlink" title="Module을 Worker로 로딩하기"></a>Module을 Worker로 로딩하기</h4><p>웹 <em>Worker</em> 및 서비스 <em>Worker</em>와 같은 <em>Worker</em>는 웹 페이지 컨텍스트 외부에서 JavaScript 코드를 실행합니다. 새로운 <em>Worker</em>를 생성하려면 새로운 인스턴스인 <code>Worker</code>(또는 클래스)를 생성하고 JavaScript 파일의 위치를 전달해야합니다. 기본 로딩 메커니즘은 다음과 같이 파일을 <em>Script</em>로 로드하는 것입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// script.js를 script로 로드.</span></div><div class="line"><span class="keyword">let</span> worker = <span class="keyword">new</span> Worker(<span class="string">"script.js"</span>);</div></pre></td></tr></table></figure>
<p><em>Module</em> 로드를 지원하기 위해 HTML 표준의 개발자는 두 번째 파라미터를 생성자에 추가했습니다. 두 번째 파라미터는 기본값이 <code>&quot;script&quot;</code>인<code>type</code> Attribute가 있는 객체입니다. <em>Module</em> 파일을 로드하기 위해 <code>type</code>을 “module”로 설정할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// module.js를 module로 로드</span></div><div class="line"><span class="keyword">let</span> worker = <span class="keyword">new</span> Worker(<span class="string">"module.js"</span>, &#123; <span class="attr">type</span>: <span class="string">"module"</span> &#125;);</div></pre></td></tr></table></figure>
<p>이 예제는 <code>module.js</code>를 <em>Script</em> 대신 <em>Module</em>로 로드합니다. 두 번째 파라미터에는 <em>Module</em>을 <code>type</code> 프로퍼티의 값으로 전달합니다. (<code>type</code> 프로퍼티는 <code>script</code>의 <code>type</code> Attribute가 <em>Module</em>과 <em>Script</em>를 구별하는 방법을 모방한 것입니다.) 두 번째 파라미터는 브라우저의 모든 <em>Worker</em> 타입에 지원됩니다.</p>
<p><em>Worker Module</em>은 일반적으로 <em>Worker</em> <em>Script</em>와 동일하지만 두가지 예외가 있습니다. 첫째, <em>Worker</em> <em>Script</em>는 참조되는 웹 페이지와 동일한 출처에서 로드되는 것으로 제한되지만 <em>Worker Module</em>은 제한되지 않습니다. <em>Worker Module</em>에도 동일한 기본 제한 사항이 있지만 CORS (Cross-Origin Resource Sharing) 헤더가있는 파일을 로드하여 액세스를 허용할 수도 있습니다. 둘째, <em>Worker</em> <em>Script</em>는<br> <code>self.importScripts()</code> 메서드를 사용하여 추가 <em>Script</em>를 <em>Worker</em>에 로드 할 수 있지만 <em>Worker Module</em>에서는<br> <code>self.importScripts()</code>가 실패합니다. 대신 <code>import</code>를 사용해야 합니다.</p>
<h3 id="브라우저-Module-지정자"><a href="#브라우저-Module-지정자" class="headerlink" title="브라우저 Module 지정자"></a>브라우저 Module 지정자</h3><p>이장의 모든 예제는 <code>&quot;./example.js&quot;</code>와 같이 <em>Module</em> 상대 지정자 경로를 사용했습니다. 브라우저는 <em>Module</em> 지정자가 다음 형식 중 하나에 있어야합니다.</p>
<ul>
<li><code>/</code>로 시작하면 루트 디렉토리에서 확인합니다.</li>
<li><code>./</code>로 시작하면 현재 디렉토리에서 확인합니다.</li>
<li><code>../</code>로 시작하면 상위 디렉토리에서 확인합니다.</li>
<li>URL 형식</li>
</ul>
<p>예를 들어 아래의 코드가 포함된 <a href="https://www.example.com/modules/module.js에">https://www.example.com/modules/module.js에</a> <em>Module</em> 파일이 있다고 가정합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// https://www.example.com/modules/example1.js에서 import 합니다.</span></div><div class="line"><span class="keyword">import</span> &#123; first &#125; <span class="keyword">from</span> <span class="string">"./example1.js"</span>;</div><div class="line"></div><div class="line"><span class="comment">// https://www.example.com/example2.js에서 import합니다.</span></div><div class="line"><span class="keyword">import</span> &#123; second &#125; <span class="keyword">from</span> <span class="string">"../example2.js"</span>;</div><div class="line"></div><div class="line"><span class="comment">// https://www.example.com/example3.js에서 import합니다.</span></div><div class="line"><span class="keyword">import</span> &#123; third &#125; <span class="keyword">from</span> <span class="string">"/example3.js"</span>;</div><div class="line"></div><div class="line"><span class="comment">// https://www2.example.com/example4.js에서 import합니다.</span></div><div class="line"><span class="keyword">import</span> &#123; fourth &#125; <span class="keyword">from</span> <span class="string">"https://www2.example.com/example4.js"</span>;</div></pre></td></tr></table></figure>
<p>이 예제의 각 <em>Module</em> 지정자는 브라우저에서 사용하기에 적합하며 최종행의 전체 URL을 포함합니다(www.example.com이 교차 도메인 로드를 허용하기 위해 Cross-Origin Resource Sharing (CORS) 헤더를 올바르게 구성했는지 확인해야합니다). 이것은 브라우저가 기본적으로 확인할 수 있는 유일한 <em>Module</em> 지정자 형식입니다 (아직 완성되지 않은 <em>Module</em> 로더 사양이 다른 형식을 해결할 수있는 방법을 제공 할지라도).즉, 정상적으로 보이는 일부 <em>Module</em> 지정자는 실제로 브라우저에서 유효하지 않으므로 다음과 같은 오류가 발생합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 오류 - /, ./, 또는 ../로 시작하지 않았습니다.</span></div><div class="line"><span class="keyword">import</span> &#123; first &#125; <span class="keyword">from</span> <span class="string">"example.js"</span>;</div><div class="line"></div><div class="line"><span class="comment">// 오류 - /, ./, 또는 ../로 시작하지 않았습니다.</span></div><div class="line"><span class="keyword">import</span> &#123; second &#125; <span class="keyword">from</span> <span class="string">"example/index.js"</span>;</div></pre></td></tr></table></figure>
<p>각 <em>Module</em> 지정자는 브라우저에서 로드할 수 없습니다. <code>&lt;script&gt;</code> 태그에서 <code>src</code>의 값으로 사용되더라도 두 <em>Module</em> 지정자가 모두 올바르지 않은 형식(올바른 시작 문자가 누락됨)이 아니기 때문에 오류입니다. 이것은 <code>&lt;script&gt;</code>와 <code>import</code> 사이의 의도적인 동작 차이입니다.</p>
<h2 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h2><p>ECMAScript 6은 함수를 패키지화하고 캡슐화하는 방법으로 언어에 <em>Module</em>을 추가했습니다. <em>Module</em>은 최상위 변수, 함수 및 클래스로 전역 범위를 수정하지 않으므로 <em>Script</em>와 다르게 동작합니다. <code>this</code>는 <code>undefined</code>입니다. 이러한 동작을 수행하기 위해 <em>Module</em>은 다른 모드를 사용하여 로드됩니다.</p>
<p><em>Module</em>을 사용자가 사용할 수 있게하려면 <code>export</code>해야 합니다. 변수, 함수 및 클래스를 <code>export</code>할 수 있으며 <em>Module</em>당 하나의 기본 <code>export</code>가 허용됩니다. <code>export</code> 후에 다른 <em>Module</em>은 export한 이름의 전부 또는 일부를 <code>import</code>할 수 있습니다. 이 이름은 <code>let</code>에 의해 정의된 것처럼 행동하고 동일한 <em>Module</em>에서 다시 선언할 수 없는 블록 바인딩으로 작동합니다.</p>
<p><em>Module</em>은 전역 범위에서 무언가를 조작하는 경우 아무 것도 <code>export</code>할 필요가 없습니다. 실제로 <em>Module Scope</em>에서 바인딩을 사용하지 않고 이러한 <em>Module</em>을 <code>import</code>할 수 있습니다.</p>
<p><em>Module</em>은 다른 모드에서 실행해야 하므로 브라우저는 소스 파일이나 인라인 코드를 <em>Module</em>로 실행해야 함을 알리기 위해 <code>&lt;script type=&quot;module&quot;&gt;</code>을 도입했습니다. <code>&lt;script type=&quot;module&quot;&gt;</code>로 로드된 <em>Module</em> 파일은 <code>defer</code> Attribute가 적용된 것처럼 로드됩니다. <em>Module</em>은 Document가 완전히 구문 분석되면 포함된 Document에 나타나는 순서대로 실행됩니다.</p>
<hr>
<blockquote>
<p>이 내용은 나중에 참고하기 위해 제가 공부하며 정리한 내용입니다.<br>의역, 오역, 직역이 있을 수 있음을 알려드립니다.<br>This post is a translation of this original article [<a href="https://leanpub.com/understandinges6/read#leanpub-auto-encapsulating-code-with-modules">https://leanpub.com/understandinges6/read#leanpub-auto-encapsulating-code-with-modules</a>]</p>
</blockquote>
<h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul>
<li><a href="https://infoscis.github.io/2018/01/24/ecmascript-6-block-binding/">ECMAScript 6 Block Binding</a></li>
<li><a href="https://infoscis.github.io/2018/01/24/ecmascript-6-strings-and-regular-expressions/">ECMAScript 6 문자열과 정규 표현식</a></li>
<li><a href="https://infoscis.github.io/2018/01/24/ecmascript-6-functions/">ECMAScript 6 함수</a></li>
<li><a href="https://infoscis.github.io/2018/01/25/ecmascript-6-expanded-object-functionality/">ECMAScript 6 객체의 확장된 기능</a></li>
<li><a href="https://infoscis.github.io/2018/01/26/ecmascript-6-destructuring-for-easier-data-access/">ECMAScript 6 쉬운 데이터 액세스를 위한 Destructuring</a></li>
<li><a href="https://infoscis.github.io/2018/01/27/ecmascript-6-symbols-and-symbol-properties/">ECMAScript 6 Symbol과 Symbol 프로퍼티</a></li>
<li><a href="https://infoscis.github.io/2018/01/27/ecmascript-6-sets-and-maps/">ECMAScript 6 Set과 Map</a></li>
<li><a href="https://infoscis.github.io/2018/01/31/ecmascript-6-iterators-and-generators/">ECMAScript 6 Iterator와 Generator</a></li>
<li><a href="https://infoscis.github.io/2018/02/13/ecmascript-6-introducing-javascript-classes/">ECMAScript 6 JavaScript 클래스 소개</a></li>
<li><a href="https://infoscis.github.io/2018/02/13/ecmascript-6-improved-array-capabilities/">ECMAScript 6 Array 기능 향상</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-promises-and-asynchronous-programming/">ECMAScript 6 Promise와 비동기 프로그램밍</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-proxies-and-the-reflection-api/">ECMAScript 6 프록시와 리플렉션 API</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-encapsulating-code-with-modules/">ECMAScript 6 Module로 코드 캡슐화하기</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-appendix-a-smaller-changes/">ECMAScript 6 부록 A. 작은 변경 사항</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-appendix-b-understanding-ecmascript-7/">ECMAScript 6 부록 B. ECMAScript 7(2016) 이해하기</a></li>
</ul>
</script></h4>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ECMAScript-6-Module로-코드-캡슐화하기&quot;&gt;&lt;a href=&quot;#ECMAScript-6-Module로-코드-캡슐화하기&quot; class=&quot;headerlink&quot; title=&quot;ECMAScript 6 Module로 코드 캡슐화하기&quot;&gt;&lt;/a
    
    </summary>
    
      <category term="JavaScript" scheme="http://infoscis.github.io/categories/JavaScript/"/>
    
      <category term="ECMAScript 2015" scheme="http://infoscis.github.io/categories/JavaScript/ECMAScript-2015/"/>
    
    
      <category term="JavaScript" scheme="http://infoscis.github.io/tags/JavaScript/"/>
    
      <category term="ECMAScript 2015" scheme="http://infoscis.github.io/tags/ECMAScript-2015/"/>
    
  </entry>
  
  <entry>
    <title>ECMAScript 6 프록시와 리플렉션 API</title>
    <link href="http://infoscis.github.io/2018/02/27/ecmascript-6-proxies-and-the-reflection-api/"/>
    <id>http://infoscis.github.io/2018/02/27/ecmascript-6-proxies-and-the-reflection-api/</id>
    <published>2018-02-27T13:31:03.000Z</published>
    <updated>2018-02-27T14:11:20.585Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ECMAScript-6-프록시와-리플렉션-API"><a href="#ECMAScript-6-프록시와-리플렉션-API" class="headerlink" title="ECMAScript 6 프록시와 리플렉션 API"></a>ECMAScript 6 프록시와 리플렉션 API</h1><p>ECMAScript 5와 ECMAScript 6 모두 명확한 JavaScript 기능을 염두에 두고 개발되었습니다. 예를 들어, ECMAScript 5 이전에는 JavaScript 환경에  nonenumerable , nonwritable 객체 속성이 있었지만 개발자는 자체적으로 nonenumerable 또는 nonwritable 속성을 정의할 수 없었습니다. ECMAScript 5에는 JavaScript 엔진이 할 수 있는 것을 개발자가 수행할 수 있도록 <code>Object.defineProperty()</code> 메서드가 포함되어 있습니다.</p>
<p>ECMAScript 6은 이전에 <em>Built-in</em> 객체에만 사용할 수 있었던 JavaScript 엔진 기능에 대한 개발자의 액세스를 제공합니다. JavaScript는 프록시를 통해 객체의 내부 동작을 노출할 수 있습니다. 프록시는 JavaScript 엔진의 저수준 동작을 가로 채고 변경할 수있는 래퍼입니다. 이 장에서는 프록시에서 세부적으로 다루어야 할 문제를 설명한 다음 프록시를 효과적으로 만들고 사용하는 방법에 대해 설명합니다.</p>
<h2 id="Array의-문제점"><a href="#Array의-문제점" class="headerlink" title="Array의 문제점"></a>Array의 문제점</h2><p>ECMAScript 6 이전에 JavaScript <em>Array</em> 객체는 개발자가 <em>Array</em> 객체를 모방할 수 없는 방식으로 동작합니다. <em>Array</em>의 <code>length</code> 프로퍼티는 특정 <em>Array</em> 항목에 값을 할당할 때 영향을 받으며 <code>length</code> 프로퍼티를 수정하여 <em>Array</em> 항목을 수정할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> colors = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>];</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(colors.length);         <span class="comment">// 3</span></div><div class="line"></div><div class="line">colors[<span class="number">3</span>] = <span class="string">"black"</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(colors.length);         <span class="comment">// 4</span></div><div class="line"><span class="built_in">console</span>.log(colors[<span class="number">3</span>]);             <span class="comment">// "black"</span></div><div class="line"></div><div class="line">colors.length = <span class="number">2</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(colors.length);         <span class="comment">// 2</span></div><div class="line"><span class="built_in">console</span>.log(colors[<span class="number">3</span>]);             <span class="comment">// undefined</span></div><div class="line"><span class="built_in">console</span>.log(colors[<span class="number">2</span>]);             <span class="comment">// undefined</span></div><div class="line"><span class="built_in">console</span>.log(colors[<span class="number">1</span>]);             <span class="comment">// "green"</span></div></pre></td></tr></table></figure>
<p><code>colors</code> <em>Array</em>는 3 개의 아이템으로 시작합니다. <code>&quot;black&quot;</code>을 <code>colors [3]</code>에 할당하면 <code>length</code> 프로퍼티가 <code>4</code>로 자동 증가합니다. <code>length</code> 프로퍼티를 <code>2</code>로 설정하면 <em>Array</em>의 마지막 두 항목이 제거되고 처음 두 항목만 남게됩니다. ECMAScript 5에서는 개발자가 작성한 객체에서 이러한 동작을 수행할 수 없지만 프록시는 이를 가능하게 합니다.</p>
<blockquote>
<p>이 비표준 동작이 ECMAScript 6에서 <em>Array</em>가 독특한 객체로 간주되는 이유입니다.</p>
</blockquote>
<h2 id="프록시와-리플렉션은-무엇인가"><a href="#프록시와-리플렉션은-무엇인가" class="headerlink" title="프록시와 리플렉션은 무엇인가?"></a>프록시와 리플렉션은 무엇인가?</h2><p><code>new Proxy()</code>를 호출하여 다른 객체(대상(Target)이라고 함) 대신 사용할 프록시를 생성할 수 있습니다. 프록시는 대상을 가상화하여 프록시와 대상이 사용하는 기능을 동일한 객체로 표시되도록합니다.</p>
<p>프록시를 사용하면 JavaScript 엔진의 내부에 있는 대상에서 하위 수준의 객체 작업을 가로 챌 수 있습니다. 이러한 하위 수준의 작업은 특정 작업에 응답하는 기능인 <em>Trap</em>을 사용하여 가로 채어집니다.</p>
<p><code>Reflect</code> 객체로 표현된 리플렉션 API는 프록시가 오버라이드 할 수있는 것과 동일한 로우 레벨 연산에 대한 기본 동작을 제공하는 메서드 컬렉션입니다. 모든 프록시 <em>Trap</em>에 대해 <code>Reflect</code> 메서드가 있습니다. 이러한 메서드는 동일한 이름을 가지며 각 프록시 <em>Trap</em>과 동일한 파라미터가 전달됩니다. 표 11-1에는 이 동작이 요약되어 있습니다.</p>
<p><strong>Table 11-1: JavaScript 안의 프록시 Trap</strong></p>
<table>
<thead>
<tr>
<th>프록시 Trap</th>
<th>동작을 재정의</th>
<th>기본 동작</th>
</tr>
</thead>
<tbody>
<tr>
<td>get</td>
<td>프로퍼티 값을 읽음</td>
<td>Reflect.get()</td>
</tr>
<tr>
<td>set</td>
<td>프로퍼티 값을 기록</td>
<td>Reflect.set()</td>
</tr>
<tr>
<td>has</td>
<td>in 연산자</td>
<td>Reflect.has()</td>
</tr>
<tr>
<td>deleteProperty</td>
<td>delete 연산자</td>
<td>Reflect.deleteProperty()</td>
</tr>
<tr>
<td>getPrototypeOf</td>
<td>Object.getPrototypeOf()</td>
<td>Reflect.getPrototypeOf()</td>
</tr>
<tr>
<td>setPrototypeOf</td>
<td>Object.setPrototypeOf()</td>
<td>Reflect.setPrototypeOf()</td>
</tr>
<tr>
<td>isExtensible</td>
<td>Object.isExtensible()</td>
<td>Reflect.isExtensible()</td>
</tr>
<tr>
<td>preventExtensions</td>
<td>Object.preventExtensions()</td>
<td>Reflect.preventExtensions()</td>
</tr>
<tr>
<td>getOwnPropertyDescriptor</td>
<td>Object.getOwnPropertyDescriptor()</td>
<td>Reflect.getOwnPropertyDescriptor()</td>
</tr>
<tr>
<td>defineProperty</td>
<td>Object.defineProperty()</td>
<td>Reflect.defineProperty</td>
</tr>
<tr>
<td>ownKeys</td>
<td>Object.keys, Object.getOwnPropertyNames(), Object.getOwnPropertySymbols()</td>
<td>Reflect.ownKeys()</td>
</tr>
<tr>
<td>apply</td>
<td>함수 호출</td>
<td>Reflect.apply()</td>
</tr>
<tr>
<td>construct</td>
<td>new를 이용한 함수 호출</td>
<td>Reflect.construct()</td>
</tr>
</tbody>
</table>
<p>각 Trap은 JavaScript 객체의 <em>Built-in</em> 동작을 재정의하므로 동작을 가로 채고 수정할 수 있습니다. 그래도 <em>Built-in</em> 동작을 사용해야하는 경우 해당하는 리플렉션 API 메서드를 사용할 수 있습니다. 프록시 생성과 리플렉션 API 간의 관계는 프록시 생성을 시작할 때 명확 해집니다. 그래서 몇 가지 예를 살펴보는 것이 가장 좋습니다.</p>
<blockquote>
<p>원래 ECMAScript 6 명세에는 <code>for-in</code>과 <code>Object.keys()</code>가 객체의 속성을 열거하는 방법을 변경하기 위해 고안된 <code>enumerate</code>라는 추가 Trap이 있습니다. 그러나 ECMAScript 7 (ECMAScript 2016이라고도 함)에서는 구현 중에 어려움이 발견되어 <code>enumerate</code> Trap이 제거되었습니다. <code>enumerate</code> Trap 더 이상 JavaScript 환경에 존재하지 않으므로 이 장에서 다루지 않습니다.</p>
</blockquote>
<h2 id="간단한-프록시-생성"><a href="#간단한-프록시-생성" class="headerlink" title="간단한 프록시 생성"></a>간단한 프록시 생성</h2><p><code>Proxy</code> 생성자를 사용하여 프록시를 만들 때, 두 개의 파라미터, 즉 대상과 핸들러를 넘깁니다. 핸들러는 하나 이상의 Trap을 정의하는 객체입니다. 프록시는 해당 작업에 대해 Trap이 정의된 경우를 제외하고 모든 작업에 대해 기본 동작을 사용합니다. 간단한 forwarding 프록시를 만들려면 Trap 없이 핸들러를 사용할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> target = &#123;&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;&#125;);</div><div class="line"></div><div class="line">proxy.name = <span class="string">"proxy"</span>;</div><div class="line"><span class="built_in">console</span>.log(proxy.name);        <span class="comment">// "proxy"</span></div><div class="line"><span class="built_in">console</span>.log(target.name);       <span class="comment">// "proxy"</span></div><div class="line"></div><div class="line">target.name = <span class="string">"target"</span>;</div><div class="line"><span class="built_in">console</span>.log(proxy.name);        <span class="comment">// "target"</span></div><div class="line"><span class="built_in">console</span>.log(target.name);       <span class="comment">// "target"</span></div></pre></td></tr></table></figure>
<p>이 예제에서 <code>proxy</code>는 모든 작업을 <code>target</code>에 직접 전달합니다. <code>&quot;proxy&quot;</code>가 <code>proxy.name</code> 프로퍼티에 할당되면 <code>name</code>이 <code>target</code>에 생성됩니다. 프록시 자체가 이 프로퍼티를 저장하지 않습니다. 이것은 단순히 작업을 <code>target</code>으로 전달하는 것입니다. 비슷하게, <code>proxy.name</code>과 <code>target.name</code>의 값은 <code>target.name</code>을 참조하기 때문에 동일합니다. 즉, <code>target.name</code>을 새로운 값으로 설정하면<br> <code>proxy.name</code>도 같은 변경을 반영합니다. 그리고 Trap이 없는 프록시는 별로 흥미롭지 않으므로 Trap을 정의하면 어떻게 될까요?</p>
<h2 id="set-Trap을-사용하여-프로퍼티-검증하기"><a href="#set-Trap을-사용하여-프로퍼티-검증하기" class="headerlink" title="set Trap을 사용하여 프로퍼티 검증하기"></a><code>set</code> Trap을 사용하여 프로퍼티 검증하기</h2><p>프로퍼티 값이 숫자여야 하는 객체를 만들고 싶다고 가정 해보겠습니다. 즉, 객체에 추가된 모든 새로운 프로퍼티에 대해 유효성 검사를 해야하며 값이 숫자가 아닌 경우 오류가 발생되어야 합니다. 이것을 달성하기 위해, 값을 설정하는 기본 동작을 무시하는 <code>set</code> Trap을 정의 할 수 있습니다. <code>set</code> Trap은 네개의 파라미터를 받습니다.</p>
<ol>
<li><code>trapTarget</code> - 프로퍼티를 수신하는 객체 (프록시의 타겟)</li>
<li><code>key</code> - 프로퍼티 키 (문자열 또는 <em>Symbol</em>)</li>
<li><code>value</code> - 프로퍼티 값</li>
<li><code>receiver</code> - 조작이 발생된 오브젝트 (일반적으로 프록시)</li>
</ol>
<p><code>Reflect.set()</code>은 <code>set</code> Trap에 대응하는 리플렉션 메서드이며, 이 연산의 기본 동작입니다. <code>Reflect.set()</code> 메서드는 <code>set</code> 프록시 Trap과 동일한 네개의 파라미터를 받아 Trap 내부에서 메서드를 사용하기 쉽게 만듭니다. Trap은 프로퍼티가 설정되면 <code>true</code>를 반환하고 그렇지 않으면 <code>false</code>를 반환합니다 (<code>Reflect.set()</code> 메서드는 작업이 성공했는지 여부에 따라 올바른 값을 반환합니다).</p>
<p>프로퍼티의 값을 검증하기 위해서는 <code>set</code> Trap을 사용하고 입력된 <code>value</code>를 검사 해야합니다. 다음은 그 예제입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> target = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">"target"</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</div><div class="line">    set(trapTarget, key, value, receiver) &#123;</div><div class="line"></div><div class="line">        <span class="comment">// 기존 프로퍼티를 무시하므로 영향을주지 않습니다.</span></div><div class="line">        <span class="keyword">if</span> (!trapTarget.hasOwnProperty(key)) &#123;</div><div class="line">            <span class="keyword">if</span> (<span class="built_in">isNaN</span>(value)) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Property must be a number."</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 프로퍼티를 추가합니다.</span></div><div class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(trapTarget, key, value, receiver);</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 새로운 프로퍼티를 추가합니다.</span></div><div class="line">proxy.count = <span class="number">1</span>;</div><div class="line"><span class="built_in">console</span>.log(proxy.count);       <span class="comment">// 1</span></div><div class="line"><span class="built_in">console</span>.log(target.count);      <span class="comment">// 1</span></div><div class="line"></div><div class="line"><span class="comment">// 이미 대상에 존재하기 때문에 name에 지정할 수 있습니다.</span></div><div class="line">proxy.name = <span class="string">"proxy"</span>;</div><div class="line"><span class="built_in">console</span>.log(proxy.name);        <span class="comment">// "proxy"</span></div><div class="line"><span class="built_in">console</span>.log(target.name);       <span class="comment">// "proxy"</span></div><div class="line"></div><div class="line"><span class="comment">// throws an error</span></div><div class="line">proxy.anotherName = <span class="string">"proxy"</span>;</div></pre></td></tr></table></figure>
<p>이 코드는 <code>target</code>에 추가되는 새로운 프로퍼티의 값을 확인하는 프록시 Trap을 정의합니다. <code>proxy.count=1</code>이 실행되면 <code>set</code> Trap이 호출됩니다. <code>trapTarget</code> 값은 <code>target</code>과 같고 <code>key</code>는 <code>count</code>, <code>value</code>는 <code>1</code>이며 <code>receiver</code>(이 예제에서는 사용되지 않음)는<code>proxy</code>입니다. <code>target</code>에 <code>count</code>라는 이름의 기존 프로퍼티가 없으므로 프록시는 <code>isNaN()</code>에 전달하여 값의 유효성을 검사합니다. 결과가 <code>NaN</code>의 경우, 숫자값이 아니기 때문에 에러가 발생됩니다. 이 코드는 <code>count</code>를 <code>1</code>로 설정하기 때문에, 프록시는 새 프로퍼티를 추가하기 위해 Trap에 전달된 네개의 파라미터를 사용하여 <code>Reflect.set()</code>을 호출합니다.</p>
<p><code>proxy.name</code>에 문자열이 지정되어도 작업은 성공적으로 완료됩니다. <code>target</code>은 이미 <code>name</code> 프로퍼티를 가지고 있기 때문에, <code>trapTarget.hasOwnProperty()</code> 메서드를 호출함으로써 유효성 체크에서 그 프라퍼티를 생략합니다. 이렇게 하면 기존의 비숫자 프로퍼티 값이 계속 지원됩니다.</p>
<p>그러나 <code>proxy.anotherName</code>에 문자열이 할당되면 오류가 발생합니다. <code>anotherName</code> 프로퍼티는 <code>target</code>에 없으므로 해당 값의 유효성을 검사 해야합니다. 유효성 검사에서 <code>&quot;proxy&quot;</code>가 숫자 값이 아니기 때문에 오류가 발생합니다.</p>
<p>프로퍼티가 쓰여질 때 <code>set</code> 프록시 Trap이 가로챌수 있고, <code>get</code> 프록시 Trap은 프로퍼티가 읽혀질 때 가로 챌 수있습니다.</p>
<h2 id="get-Trap을-사용하여-객체-모양-유효성-검사"><a href="#get-Trap을-사용하여-객체-모양-유효성-검사" class="headerlink" title="get Trap을 사용하여 객체 모양 유효성 검사"></a>get Trap을 사용하여 객체 모양 유효성 검사</h2><p>때때로 JavaScript의 흥미롭고 혼란스러운 부분 중 하나는 존재하지 않는 프로퍼티를 읽는 것이 오류를 발생시키지 않는다는 것입니다. 대신 다음 예와 같이 프로퍼티 값에 <code>undefined</code> 값이 사용됩니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> target = &#123;&#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(target.name);       <span class="comment">// undefined</span></div></pre></td></tr></table></figure>
<p>대부분의 다른 언어에서 <code>target.name</code>을 읽으려고 하면 프로퍼티가 존재하지 않기 때문에 오류가 발생합니다. 그러나 JavaScript는<br> <code>target.name</code> 프로퍼티 값에 <code>undefined</code>를 사용합니다. 대규모 코드 기반에서 작업한 적이 있다면, 특히 프로퍼티 이름에 오타가있을 때 이 동작이 어떻게 심각한 문제를 일으킬 수 있는지 보셨을 것입니다. 프록시를 사용하면 객체 모양의 유효성 검사를 통해 이 문제를 방지 할 수 있습니다.</p>
<p>객체 모양은 객체에서 사용할 수있는 프로퍼티 및 메서드의 모음입니다. JavaScript 엔진은 객체 모양을 사용하여 코드를 최적화하고 종종 객체를 나타내는 클래스를 만듭니다. 객체가 항상 동일한 프로퍼티 및 메서드 (<code>Object.preventExtensions()</code> 메서드, <code>Object.seal()</code> 메서드 또는 <code>Object.freeze()</code> 메서드로 적용 할 수있는 동작)를 항상 가지고 있다고 가정할 수 있는 경우, 존재하지 않는 프로퍼티에 액세스하려는 시도에 오류가 발생하면 도움이될 수 있습니다. 프록시는 객체 모양 유효성 검사를 쉽게 만들수 있게 합니다.</p>
<p>프로퍼티 검증은 프로퍼티가 읽혀질 때만 발생해야 하기때문에 <code>get</code> Trap을 사용합니다. <code>get</code> Trap은 프로퍼티가 객체 상에 존재하지 않더라도 프로퍼티가 읽힐 때 호출되며 세개의 파라미터를 받습니다.</p>
<ol>
<li><code>trapTarget</code> - 프로퍼티를 읽어내는 객체 (프록시의 타겟)</li>
<li><code>key</code> - 프로퍼티 키 (문자열 또는 <em>Symbol</em>)</li>
<li><code>receiver</code> - 조작이 발생된 오브젝트 (일반적으로 프록시)</li>
</ol>
<p>이 파라미터는 <code>set</code> Trap의 파라미터와 유사하며, 눈에 띄는 차이점이 하나 있습니다. <code>get</code> Trap은 값을 쓰지 않기 때문에 <code>value</code>는 여기서 아무런 가치가 없습니다. <code>Reflect.get()</code> 메서드는 <code>get</code> Trap과 동일한 세개의 파라미터를 받아들이고 프로퍼티의 기본값을 반환합니다.</p>
<p>다음과 같이 <code>get</code> Trap과 <code>Reflect.get()</code>를 사용하여 프로퍼티가 대상에 없을때 에러를 발생시킬 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</div><div class="line">        get(trapTarget, key, receiver) &#123;</div><div class="line">            <span class="keyword">if</span> (!(key <span class="keyword">in</span> receiver)) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Property "</span> + key + <span class="string">" doesn't exist."</span>);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(trapTarget, key, receiver);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line"><span class="comment">// 프로퍼티 추가는 잘 됩니다.</span></div><div class="line">proxy.name = <span class="string">"proxy"</span>;</div><div class="line"><span class="built_in">console</span>.log(proxy.name);            <span class="comment">// "proxy"</span></div><div class="line"></div><div class="line"><span class="comment">// 존재하지 않는 프로퍼티는 에러를 던집니다.</span></div><div class="line"><span class="built_in">console</span>.log(proxy.nme);             <span class="comment">// throws error</span></div></pre></td></tr></table></figure>
<p>이 예제에서, <code>get</code> Trap은 프로퍼티 읽기 연산을 가로 챕니다. <code>in</code> 연산자는 프로퍼티가 이미 <code>receiver</code>에 존재 하는지를 결정하는데 사용됩니다. <code>receiver</code>는 <code>receiver</code>가 <code>has</code> Trap을 가진 프록시인 경우에 <code>trapTarget</code> 대신에 <code>in</code>과 함께 사용됩니다. 다음 절에서 다루게될 타입입니다. 이 경우 <code>trapTarget</code>을 사용하면 <code>has</code> Trap을 회피하고 잠재적으로 잘못된 결과를 줄 수 있습니다. 프로퍼티가 없으면 오류가 발생하고 그렇지 않으면 기본 처리가 사용됩니다.</p>
<p>이 코드를 사용하면 <code>proxy.name</code>과 같은 새 프로퍼티는 아무 문제없이 추가하고 수정및 읽을 수 있습니다. 마지막 줄에는 오타가 있습니다. <code>proxy.nme</code>는 <code>proxy.name</code>이어야합니다. <code>nme</code>가 프로퍼티로 존재하지 않으므로 오류가 발생합니다.</p>
<h2 id="has-Trap을-사용하여-프로퍼티-숨기기"><a href="#has-Trap을-사용하여-프로퍼티-숨기기" class="headerlink" title="has Trap을 사용하여 프로퍼티 숨기기"></a>has Trap을 사용하여 프로퍼티 숨기기</h2><p><code>in</code> 연산자는 주어진 객체에 프로퍼티가 존재하는지 여부를 판단하고, 이름이나 <em>Symbol</em>과 일치하는 자체 프로퍼티나 프로토 타입 프로퍼티가 있으면 <code>true</code>를 반환합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> target = &#123;</div><div class="line">    <span class="attr">value</span>: <span class="number">42</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"value"</span> <span class="keyword">in</span> target);     <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"toString"</span> <span class="keyword">in</span> target);  <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p><code>value</code>와 <code>toString</code> 모두 <code>object</code>에 존재하기 때문에 <code>in</code> 연산자는 <code>true</code>를 리턴합니다. <code>value</code> 프로퍼티는 자신의 프로퍼티이고<code>toString</code>는 (Object<code>에서 상속받은) 프로토 타입 프로퍼티입니다. 프록시를 사용하면 이 작업을 가로 채고</code>has<code>Trap을 사용하여</code>in`에 다른 값을 반환할 수 있습니다.</p>
<p><code>has</code> Trap은 <code>in</code> 연산자가 사용될 때마다 호출됩니다. 호출될 때 두개의 파라미터가 <code>has</code> Trap에 전달됩니다.</p>
<ol>
<li><code>trapTarget</code> - 프로퍼티의 read 객체 (프록시의 타겟)</li>
<li><code>key</code> - 체크 대상의 프로퍼티 키 (문자열 또는 <em>Symbol</em>)</li>
</ol>
<p><code>Reflect.has()</code> 메서드는 동일한 파라미터를 받아 들여 <code>in</code> 연산자에 대한 기본 응답을 반환합니다. <code>has</code> Trap과 <code>Reflect.has()</code>를 사용하면 일부 프로퍼티는 <code>in</code>의 동작을 변경하고 다른 프로퍼티는 기본 동작으로 되돌릴 수 있습니다. 예를 들어, <code>value</code> 프로퍼티를 숨기고 싶다고 가정 해보십시오. 이렇게 할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> target = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">"target"</span>,</div><div class="line">    <span class="attr">value</span>: <span class="number">42</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</div><div class="line">    has(trapTarget, key) &#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (key === <span class="string">"value"</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="built_in">Reflect</span>.has(trapTarget, key);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"value"</span> <span class="keyword">in</span> proxy);      <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> proxy);       <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"toString"</span> <span class="keyword">in</span> proxy);   <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p><code>proxy</code>의 <code>has</code> Trap은 <code>key</code>가 <code>value</code>이면 <code>false</code>를 반환합니다. 그렇지 않으면 <code>Reflect.has()</code> 메서드를 호출하여 기본 동작을 사용합니다. 결과적으로 <code>in</code> 연산자는 <code>value</code>가 실제로 대상에 존재하더라도 <code>value</code> 프로퍼티에 대해 <code>false</code>를 반환합니다. <code>name</code>과<br> <code>toString</code>은 <code>in</code> 연산자와 함께 사용될 때 정확하게 <code>true</code>를 리턴합니다.</p>
<h2 id="deleteProperty-Trap을-사용하여-프로퍼티-삭제-방지"><a href="#deleteProperty-Trap을-사용하여-프로퍼티-삭제-방지" class="headerlink" title="deleteProperty Trap을 사용하여 프로퍼티 삭제 방지"></a>deleteProperty Trap을 사용하여 프로퍼티 삭제 방지</h2><p><code>delete</code> 연산자는 객체에서 프로퍼티를 제거하고, 성공하면 <code>true</code>를 실패하면 <code>false</code>를 반환합니다. strict 모드에서 <code>delete</code>는<code>nonconfigurable</code> 프로퍼티를 지울때 에러를 던집니다. nonstrict 모드에서 <code>delete</code>는 단순히 <code>false</code>를 반환합니다. 다음 예제를 참고하세요.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> target = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">"target"</span>,</div><div class="line">    <span class="attr">value</span>: <span class="number">42</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.defineProperty(target, <span class="string">"name"</span>, &#123; <span class="attr">configurable</span>: <span class="literal">false</span> &#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"value"</span> <span class="keyword">in</span> target);     <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> result1 = <span class="keyword">delete</span> target.value;</div><div class="line"><span class="built_in">console</span>.log(result1);               <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"value"</span> <span class="keyword">in</span> target);     <span class="comment">// false</span></div><div class="line"></div><div class="line"><span class="comment">// Note: 아래 라인은 strict 모드에서 에러가 발생합니다.</span></div><div class="line"><span class="keyword">let</span> result2 = <span class="keyword">delete</span> target.name;</div><div class="line"><span class="built_in">console</span>.log(result2);               <span class="comment">// false</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> target);      <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p><code>value</code> 프로퍼티는 <code>delete</code> 연산자를 사용하여 삭제되고 결과적으로 <code>in</code> 연산자는 세 번째 <code>console.log ()</code> 호출에서 <code>false</code>를 반환합니다. nonconfigurable  <code>name</code> 프로퍼티는 삭제될 수 없으므로 <code>delete</code> 연산자는 단순히 <code>false</code>를 반환합니다 (이 코드가 <code>strict</code> 모드로 실행되면 대신 에러가 발생합니다). 프록시에서 <code>deleteProperty</code> Trap을 사용하여 이 동작을 변경할 수 있습니다.</p>
<p><code>deleteProperty</code> Trap은 객체 속성에서 <code>delete</code> 연산자가 사용될 때마다 호출됩니다. Trap에는 두개의 파라미터가 전달됩니다.</p>
<ol>
<li><code>trapTarget</code> - 프로퍼티을 삭제해야 할 객체 (프록시의 대상)</li>
<li><code>key</code> - 삭제하는 프로퍼티 키 (문자열 또는 <em>Symbol</em>)</li>
</ol>
<p><code>Reflect.deleteProperty()</code> 메서드는 <code>deleteProperty</code> Trap의 기본 구현을 제공하고 동일한 두개의 파라미터를 받아들입니다. <code>Reflect.deleteProperty()</code>와 <code>deleteProperty</code> Trap을 결합하여 <code>delete</code> 연산자가 어떻게 동작 하는지를 변경할 수 있습니다. 예를 들어, <code>value</code> 프로퍼티를 삭제할수 없도록 할수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> target = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">"target"</span>,</div><div class="line">    <span class="attr">value</span>: <span class="number">42</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</div><div class="line">    deleteProperty(trapTarget, key) &#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (key === <span class="string">"value"</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="built_in">Reflect</span>.deleteProperty(trapTarget, key);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// Attempt to delete proxy.value</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"value"</span> <span class="keyword">in</span> proxy);      <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> result1 = <span class="keyword">delete</span> proxy.value;</div><div class="line"><span class="built_in">console</span>.log(result1);               <span class="comment">// false</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"value"</span> <span class="keyword">in</span> proxy);      <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="comment">// Attempt to delete proxy.name</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> proxy);       <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> result2 = <span class="keyword">delete</span> proxy.name;</div><div class="line"><span class="built_in">console</span>.log(result2);               <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> proxy);       <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p>이 코드는 <code>has</code> Trap 예제와 매우 비슷합니다. <code>deleteProperty</code> Trap은 <code>key</code>가 <code>&quot;value&quot;</code>인지 확인하고, 그렇다면 <code>false</code>를 리턴합니다. 그렇지 않으면 <code>Reflect.deleteProperty()</code> 메서드를 호출하여 기본 동작을 계속합니다. 연산이 Trap 되었기 때문에 <code>value</code> 프로퍼티는 프록시를 통해 삭제할 수 없지만 <code>name</code> 프로퍼티는 예상대로 삭제됩니다. 이 접근법은 strict 모드에서 오류를 던지지 않고 프로퍼티를 삭제되지 않도록 보호하려는 경우에 특히 유용합니다.</p>
<h2 id="Prototype-프록시-Trap"><a href="#Prototype-프록시-Trap" class="headerlink" title="Prototype 프록시 Trap"></a>Prototype 프록시 Trap</h2><p>4 장에서는 ECMAScript 5의 <code>Object.getPrototypeOf()</code> 메서드를 보완하기 위해 ECMAScript 6에 추가한 <code>Object.setPrototypeOf()</code> 메서드를 소개했습니다. 프록시를 사용하면 <code>setPrototypeOf</code>와 <code>getPrototypeOf</code> Trap을 통해 두 메서드의 실행을 가로챌 수 있습니다. 두 경우 모두<code>Object</code> 메서드는 프록시에서 해당 이름의 Trap을 호출하여 메서드의 동작을 변경할 수 있습니다.</p>
<p>프로토 타입 프록시와 관련된 두개의 Trap이 있고 각 Trap 유형과 관련된 메서드가 있습니다. <code>setPrototypeOf</code> Trap은 다음 파라미터를 받습니다.</p>
<ol>
<li><code>trapTarget</code> - 프로토 타입을 설정해야하는 객체 (프록시의 대상)</li>
<li><code>proto</code> - 프로토 타입으로 사용하는 객체</li>
</ol>
<p>이들은 <code>Object.setPrototypeOf()</code> 및 <code>Reflect.setPrototypeOf()</code> 메서드에 전달되는 동일한 파라미터입니다. 반면에 <code>getPrototypeOf</code> Trap은 <code>trapTarget</code> 파라미터만 받습니다. 파라미터는 <code>Object.getPrototypeOf()</code> 및 <code>Reflect.getPrototypeOf()</code> 메서드로 전달됩니다.</p>
<h3 id="프로토-타입-프록시-Trap의-작동-방식"><a href="#프로토-타입-프록시-Trap의-작동-방식" class="headerlink" title="프로토 타입 프록시 Trap의 작동 방식"></a>프로토 타입 프록시 Trap의 작동 방식</h3><p>이 Trap들에는 몇가지 제한 사항이 있습니다. 첫째, <code>getPrototypeOf</code> Trap은 객체 또는 <code>null</code>을 반환해야하고, 다른 반환 값은 런타임 오류를 발생시킵니다. 반환값 검사는 <code>Object.getPrototypeOf()</code>가 항상 예상값을 반환하도록 보장합니다. 비슷하게, 연산이 성공하지 못하면<br> <code>setPrototypeOf</code> Trap의 반환값은 <code>false</code>이어야합니다. <code>setPrototypeOf</code>가 <code>false</code>를 반환하면, <code>Object.setPrototypeOf()</code>는 에러를 던집니다. <code>setPrototypeOf</code>가 <code>false</code>가 아닌 다른 값을 반환하면 <code>Object.setPrototypeOf()</code>는 연산이 성공했다고 가정합니다.</p>
<p>다음 예제는 항상 <code>null</code>을 반환하여 프록시의 프로토 타입을 숨기며 프로토 타입을 변경할 수 없습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> target = &#123;&#125;;</div><div class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</div><div class="line">    getPrototypeOf(trapTarget) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">    &#125;,</div><div class="line">    setPrototypeOf(trapTarget, proto) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">let</span> targetProto = <span class="built_in">Object</span>.getPrototypeOf(target);</div><div class="line"><span class="keyword">let</span> proxyProto = <span class="built_in">Object</span>.getPrototypeOf(proxy);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(targetProto === <span class="built_in">Object</span>.prototype);      <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(proxyProto === <span class="built_in">Object</span>.prototype);       <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log(proxyProto);                            <span class="comment">// null</span></div><div class="line"></div><div class="line"><span class="comment">// succeeds</span></div><div class="line"><span class="built_in">Object</span>.setPrototypeOf(target, &#123;&#125;);</div><div class="line"></div><div class="line"><span class="comment">// throws error</span></div><div class="line"><span class="built_in">Object</span>.setPrototypeOf(proxy, &#123;&#125;);</div></pre></td></tr></table></figure>
<p>이 코드는 <code>target</code>과 <code>proxy</code>의 동작 사이의 차이점을 강조합니다. <code>Object.getPrototypeOf()</code>은 <code>target</code>에 대한 값을 반환하는 동안<br> <code>getPrototypeOf</code> Trap이 호출되기 때문에 <code>proxy</code>에 대해 <code>null</code>을 리턴합니다. 비슷하게 <code>Object.setPrototypeOf()</code>는 <code>target</code>에서 사용될 때 성공하지만 <code>setPrototypeOf</code> Trap으로 인해 <code>proxy</code>에서 사용될 때 에러를 던집니다.</p>
<p>이 두 Trap의 기본 동작을 사용하려면 <code>Reflect</code>에서 해당 메서드를 사용해야 합니다. 예를 들어, 이 코드는 <code>getPrototypeOf</code> 및<br> <code>setPrototypeOf</code> Trap의 기본 동작을 구현합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> target = &#123;&#125;;</div><div class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</div><div class="line">    getPrototypeOf(trapTarget) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.getPrototypeOf(trapTarget);</div><div class="line">    &#125;,</div><div class="line">    setPrototypeOf(trapTarget, proto) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.setPrototypeOf(trapTarget, proto);</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">let</span> targetProto = <span class="built_in">Object</span>.getPrototypeOf(target);</div><div class="line"><span class="keyword">let</span> proxyProto = <span class="built_in">Object</span>.getPrototypeOf(proxy);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(targetProto === <span class="built_in">Object</span>.prototype);      <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(proxyProto === <span class="built_in">Object</span>.prototype);       <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="comment">// succeeds</span></div><div class="line"><span class="built_in">Object</span>.setPrototypeOf(target, &#123;&#125;);</div><div class="line"></div><div class="line"><span class="comment">// also succeeds</span></div><div class="line"><span class="built_in">Object</span>.setPrototypeOf(proxy, &#123;&#125;);</div></pre></td></tr></table></figure>
<p>이 예에서, <code>getPrototypeOf</code> 및 <code>setPrototypeOf</code> Trap이 기본 실행을 사용하기 위해 통과하고 있기 때문에 <code>target</code>과 <code>proxy</code>를 교대로 사용할 수 있고 같은 결과를 얻을 수 있습니다. 이 예제는 몇가지 중요한 차이점 때문에 <code>Object</code>에서 같은 이름의 메서드보다는 <code>Reflect.getPrototypeOf()</code>와 <code>Reflect.setPrototypeOf()</code> 메서드를 사용하는 것이 중요합니다.</p>
<h3 id="왜-두개의-Set-메서드일까요"><a href="#왜-두개의-Set-메서드일까요" class="headerlink" title="왜 두개의 Set 메서드일까요?"></a>왜 두개의 Set 메서드일까요?</h3><p><code>Reflect.getPrototypeOf()</code> 및 <code>Reflect.setPrototypeOf()</code>의 혼란스러운 부분은 <code>Object.getPrototypeOf()</code> 및<br> <code>Object.setPrototypeOf()</code> 메서드와 유사하게 보입니다. 두 세트의 메서드가 유사한 기능을 수행하지만, 두 메서드 사이에 뚜렷한 차이점이 있습니다.</p>
<p>우선, <code>Object.getPrototypeOf()</code> 및 <code>Object.setPrototypeOf()</code>는 처음부터 개발자를 위해 만든 상위 수준의 기능입니다. <code>Reflect.getPrototypeOf()</code> 및 <code>Reflect.setPrototypeOf()</code> 메서드는 개발자가 이전의 내부 전용 <code>[[GetPrototypeOf]]</code> 및 <code>[[SetPrototypeOf]]</code> 작업에 액세스할 수 있도록하는 하위 수준의 기능입니다. <code>Reflect.getPrototypeOf()</code> 메서드는 내부 <code>[[GetPrototypeOf]]</code> 연산의 래퍼 (일부 입력 유효성 검사 포함)입니다. <code>Reflect.setPrototypeOf()</code> 메서드와 <code>[[SetPrototypeOf]]</code>은 같은 관계입니다. <code>Object</code>의 해당 메서드는 <code>[[GetPrototypeOf]]</code> 및 <code>[[SetPrototypeOf]]</code>를 호출하지만 호출 전에 몇 단계를 수행하고 반환 값을 검사하여 동작 방법을 결정합니다.</p>
<p><code>Reflect.getPrototypeOf()</code> 메서드는 파라미터가 객체가 아닌 경우 오류를 발생시키고 <code>Object.getPrototypeOf()</code>는 먼저 작업을 수행하기 전에 값을 객체에 강제 변환합니다. 각 메서드에 숫자를 전달하면 다른 결과가 나타납니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> result1 = <span class="built_in">Object</span>.getPrototypeOf(<span class="number">1</span>);</div><div class="line"><span class="built_in">console</span>.log(result1 === <span class="built_in">Number</span>.prototype);  <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="comment">// error가 발생</span></div><div class="line"><span class="built_in">Reflect</span>.getPrototypeOf(<span class="number">1</span>);</div></pre></td></tr></table></figure>
<p><code>Object.getPrototypeOf()</code> 메서드는 값을 <code>Number</code> 객체로 강제 변환한 다음 <code>Number.prototype</code>을 반환하기 때문에 <code>1</code>의 프로토 타입을 가져옵니다. <code>Reflect.getPrototypeOf()</code> 메서드는 값을 강제로 변환하지 않으며 <code>1</code>은 객체가 아니기 때문에 오류를 던집니다.</p>
<p><code>Reflect.setPrototypeOf()</code> 메서드는 <code>Object.setPrototypeOf()</code> 메서드와 몇가지 다른 점이 있습니다. 첫째로, <code>Reflect.setPrototypeOf()</code>는 작업이 성공했는지를 나타내는 부울 값을 반환합니다. 성공하면 <code>true</code> 값이 반환되고 실패하면 <code>false</code>가 반환됩니다. <code>Object.setPrototypeOf()</code>는 실패하면 에러를 발생합니다.</p>
<p>“프로토 타입 프록시 Trap의 작동 방식”의 첫 번째 예제에서 보듯이 <code>setPrototypeOf</code> 프록시 Trap이 <code>false</code>를 반환하면<br> <code>Object.setPrototypeOf()</code>는 오류를 발생시킵니다. <code>Object.setPrototypeOf()</code> 메서드는 첫 번째 인자를 값으로 반환하므로<code>setPrototypeOf</code> 프록시 Trap의 기본 실행을 구현하는데 적합하지 않습니다. 다음 코드는 이러한 차이점을 보여줍니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> target1 = &#123;&#125;;</div><div class="line"><span class="keyword">let</span> result1 = <span class="built_in">Object</span>.setPrototypeOf(target1, &#123;&#125;);</div><div class="line"><span class="built_in">console</span>.log(result1 === target1);                   <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> target2 = &#123;&#125;;</div><div class="line"><span class="keyword">let</span> result2 = <span class="built_in">Reflect</span>.setPrototypeOf(target2, &#123;&#125;);</div><div class="line"><span class="built_in">console</span>.log(result2 === target2);                   <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log(result2);                               <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>이 예제에서 <code>Object.setPrototypeOf()</code>는 <code>target1</code>을 값으로 반환하지만 <code>Reflect.setPrototypeOf()</code>는 <code>true</code>를 반환합니다. 이 미묘한 차이는 매우 중요합니다. <code>Object</code>와 <code>Reflect</code>에 중복된 메서드가 더많이 보일것입니다. 항상 프록시 Trap 내에서 <code>Reflect</code> 메서드를 사용해야합니다.</p>
<blockquote>
<p>두 메서드는 프록시에서 사용될 때 <code>getPrototypeOf</code> 및 <code>setPrototypeOf</code> 프록시 Trap을 호출합니다.</p>
</blockquote>
<h2 id="Object-확장-Trap"><a href="#Object-확장-Trap" class="headerlink" title="Object 확장 Trap"></a>Object 확장 Trap</h2><p>ECMAScript 5는 <code>Object.preventExtensions()</code> 및 <code>Object.isExtensible()</code> 메서드를 통해 객체 확장성 수정을 추가했으며 ECMAScript 6을 사용하면 프록시가 <code>preventExtensions</code> 및 <code>isExtensible</code> Trap을 통해 기본 객체에 대한 메서드 호출을 차단할 수 있습니다. 두 Trap 모두 메서드가 호출된 객체인 <code>trapTarget</code>이라는 단일 파라미터를 받습니다. <code>isExtensible</code> Trap은 객체가 확장 가능한지 여부를 나타내는 부울값을 반환해야 하고 <code>preventExtensions</code> Trap은 작업이 성공했는지를 나타내는 부울값을 반환해야합니다.</p>
<p>또한 기본 동작을 구현하기 위해 <code>Reflect.preventExtensions()</code>와 <code>Reflect.isExtensible()</code> 메서드가 있습니다. 둘 다 부울값을 반환하므로 해당 Trap에서 직접 사용할 수 있습니다.</p>
<h3 id="기본-예제-두개"><a href="#기본-예제-두개" class="headerlink" title="기본 예제 두개"></a>기본 예제 두개</h3><p>작업에서 객체 확장성 Trap을 확인 하기위해 <code>isExtensible</code> 및 <code>preventExtensions</code> Trap에 대한 기본 동작을 구현하는 다음 코드를 살펴보겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> target = &#123;&#125;;</div><div class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</div><div class="line">    isExtensible(trapTarget) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.isExtensible(trapTarget);</div><div class="line">    &#125;,</div><div class="line">    preventExtensions(trapTarget) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.preventExtensions(trapTarget);</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(target));       <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(proxy));        <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="built_in">Object</span>.preventExtensions(proxy);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(target));       <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(proxy));        <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p>이 예제는 <code>Object.preventExtensions()</code>와 <code>Object.isExtensible()</code> 모두 <code>proxy</code>에서 <code>target</code>으로 정확하게 전달되는 것을 보여줍니다. 물론 동작을 바꿀 수도 있습니다. 예를 들어 <code>Object.preventExtensions()</code>가 프록시에서 성공하지 못하도록하려는 경우<br> <code>preventExtensions</code> Trap에서 <code>false</code>를 반환할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> target = &#123;&#125;;</div><div class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</div><div class="line">    isExtensible(trapTarget) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.isExtensible(trapTarget);</div><div class="line">    &#125;,</div><div class="line">    preventExtensions(trapTarget) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(target));       <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(proxy));        <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="built_in">Object</span>.preventExtensions(proxy);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(target));       <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(proxy));        <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p><code>preventExtensions</code> Trap이 <code>false</code>를 반환하기 때문에 <code>Object.preventExtensions(proxy)</code>에 대한 호출이 무시됩니다. 작업은 기본<br> <code>target</code>으로 전달되지 않으므로 <code>Object.isExtensible()</code>은 <code>true</code>를 반환합니다.</p>
<h3 id="중복-확장-메서드"><a href="#중복-확장-메서드" class="headerlink" title="중복 확장 메서드"></a>중복 확장 메서드</h3><p>다시 한번, <code>Object</code>와 <code>Reflect</code>에 중복된 메서드가 있다는 것을 눈치챘을 것입니다. 이 경우에는 더 유사합니다. <code>Object.isExtensible()</code> 및 <code>Reflect.isExtensible()</code> 메서드는 비객체 값이 전달된 경우를 제외하고는 서로 비슷합니다. 이 경우 <code>Reflect.isExtensible()</code>이 오류를 발생하고 <code>Object.isExtensible()</code>은 항상 <code>false</code>를 반환합니다. 다음은 그 동작의 예제입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> result1 = <span class="built_in">Object</span>.isExtensible(<span class="number">2</span>);</div><div class="line"><span class="built_in">console</span>.log(result1);                       <span class="comment">// false</span></div><div class="line"></div><div class="line"><span class="comment">// error 발생</span></div><div class="line"><span class="keyword">let</span> result2 = <span class="built_in">Reflect</span>.isExtensible(<span class="number">2</span>);</div></pre></td></tr></table></figure>
<p>이 제한은 <code>Object.getPrototypeOf()</code>와 <code>Reflect.getPrototypeOf()</code> 메서드의 차이와 유사합니다. 하위 레벨 기능의 메서드는 상위 레벨 기능보다 더 엄격한 오류 확인 기능을 가지고 있기 때문입니다.</p>
<p><code>Object.preventExtensions()</code> 및 <code>Reflect.preventExtensions()</code> 메서드도 매우 비슷합니다. <code>Object.preventExtensions()</code> 메서드는 값이 객체가 아닌 경우에 파라미터로 전달된 값을 항상 반환합니다. 반대로 <code>Reflect.preventExtensions()</code> 메서드는 파라미터가 객체가 아닌 경우 오류를 발생시킵니다. 파라미터가 객체인 경우 <code>Reflect.preventExtensions()</code>는 작업이 성공하면 <code>true</code>를 반환하고 그렇지 않으면 <code>false</code>를 반환합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> result1 = <span class="built_in">Object</span>.preventExtensions(<span class="number">2</span>);</div><div class="line"><span class="built_in">console</span>.log(result1);                               <span class="comment">// 2</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> target = &#123;&#125;;</div><div class="line"><span class="keyword">let</span> result2 = <span class="built_in">Reflect</span>.preventExtensions(target);</div><div class="line"><span class="built_in">console</span>.log(result2);                               <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="comment">// throws error</span></div><div class="line"><span class="keyword">let</span> result3 = <span class="built_in">Reflect</span>.preventExtensions(<span class="number">2</span>);</div></pre></td></tr></table></figure>
<p>여기서 <code>Object.preventExtensions()</code>는 <code>2</code>가 객체가 아니더라도 <code>2</code>를 통과 시킵니다. <code>Reflect.preventExtensions()</code> 메서드는 객체가 전달될 때 <code>true</code>를 반환하고 <code>2</code>를 전달하면 오류를 발생시킵니다.</p>
<h2 id="프로퍼티-Descriptor-Trap"><a href="#프로퍼티-Descriptor-Trap" class="headerlink" title="프로퍼티 Descriptor Trap"></a>프로퍼티 Descriptor Trap</h2><p>ECMAScript 5의 가장 중요한 기능중 하나는 <code>Object.defineProperty()</code> 메서드를 사용하여 프로퍼티 속성을 정의하는 기능이었습니다. 이전 버전의 JavaScript에서는 Accessor 프로퍼티를 정의하거나, 속성을 Read-only로 만들거나, 속성을 Nonenumerable하게 만들 수있는 방법이 없었습니다. 이 모든 작업은 <code>Object.defineProperty()</code> 메서드를 사용하여 수행할 수 있으며 <code>Object.getOwnPropertyDescriptor()</code> 메서드를 사용하여 이러한 속성을 검색할 수 있습니다.</p>
<p>프록시를 사용하면 <code>defineProperty</code> 및 <code>getOwnPropertyDescriptor</code> Trap을 각각 사용하여 <code>Object.defineProperty()</code> 및 <code>Object.getOwnPropertyDescriptor()</code>에 대한 호출을 가로 채게할 수 있습니다. <code>defineProperty</code> Trap은 다음 파라미터를 받습니다.</p>
<ol>
<li><code>trapTarget</code> - 프로퍼티을 정의 할 필요가있는 객체 (프록시의 대상)</li>
<li><code>key</code> - 프로퍼티의 문자열 또는 <em>Symbol</em></li>
<li><code>descriptor</code> - 프로퍼티 설명 객체</li>
</ol>
<p><code>defineProperty</code> Trap은 작업이 성공하면 <code>true</code>를, 그렇지 않으면 <code>false</code>를 반환합니다. <code>getOwnPropertyDescriptor</code> Trap은<br> <code>trapTarget</code>과 <code>key</code>만 받으며, Descriptor를 리턴해야합니다. 상응하는 <code>Reflect.defineProperty()</code>와<br> <code>Reflect.getOwnPropertyDescriptor()</code> 메서드는 프록시 Trap과 동일한 파라미터를 받습니다. 다음은 각 Trap의 기본 동작을 구현하는 예제입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</div><div class="line">    defineProperty(trapTarget, key, descriptor) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.defineProperty(trapTarget, key, descriptor);</div><div class="line">    &#125;,</div><div class="line">    getOwnPropertyDescriptor(trapTarget, key) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.getOwnPropertyDescriptor(trapTarget, key);</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"></div><div class="line"><span class="built_in">Object</span>.defineProperty(proxy, <span class="string">"name"</span>, &#123;</div><div class="line">    <span class="attr">value</span>: <span class="string">"proxy"</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(proxy.name);            <span class="comment">// "proxy"</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(proxy, <span class="string">"name"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(descriptor.value);      <span class="comment">// "proxy"</span></div></pre></td></tr></table></figure>
<p>이 코드는 <code>Object.defineProperty()</code> 메서드를 사용하여 프록시에서 <code>&quot;name&quot;</code>이라는 프로퍼티를 정의합니다. 그런 다음 해당 프로퍼티의 Descriptor가 <code>Object.getOwnPropertyDescriptor()</code> 메서드에 의해 검색됩니다.</p>
<h3 id="Object-defineProperty-잠그기"><a href="#Object-defineProperty-잠그기" class="headerlink" title="Object.defineProperty() 잠그기"></a>Object.defineProperty() 잠그기</h3><p><code>defineProperty</code> Trap은 조작이 성공했는지 여부를 나타내기 위해 부울 값을 리턴하도록 요구합니다. <code>true</code>가 리턴되면, <code>Object.defineProperty()</code>는 평소대로 성공합니다; <code>false</code>가 리턴되면 <code>Object.defineProperty()</code>는 에러를 발생시킵니다. 이 기능을 사용하여 <code>Object.defineProperty()</code> 메서드가 정의할 수있는 프로퍼티의 종류를 제한할 수 있습니다. 예를 들어 <em>Symbol</em> 프로퍼티가 정의되지 않도록하려면 <code>key</code>가 문자열인지 확인하고 그렇지 않으면 <code>false</code>를 반환합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</div><div class="line">    defineProperty(trapTarget, key, descriptor) &#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> key === <span class="string">"symbol"</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.defineProperty(trapTarget, key, descriptor);</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"></div><div class="line"><span class="built_in">Object</span>.defineProperty(proxy, <span class="string">"name"</span>, &#123;</div><div class="line">    <span class="attr">value</span>: <span class="string">"proxy"</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(proxy.name);                    <span class="comment">// "proxy"</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> nameSymbol = <span class="built_in">Symbol</span>(<span class="string">"name"</span>);</div><div class="line"></div><div class="line"><span class="comment">// error 발생</span></div><div class="line"><span class="built_in">Object</span>.defineProperty(proxy, nameSymbol, &#123;</div><div class="line">    <span class="attr">value</span>: <span class="string">"proxy"</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><code>defineProperty</code> 프록시 Trap은 <code>key</code>가 <em>Symbol</em> 일 때 <code>false</code>를 리턴하고 그렇지 않으면 기본 동작을 진행합니다. <code>name</code>을 <code>key</code>로<br> 하여 <code>Object.defineProperty()</code>를 호출하면, <code>key</code>가 문자열이기 때문에 메서드가 성공합니다. <code>Object.defineProperty()</code>가<br> <code>nameSymbol</code>과 함께 호출되면 <code>defineProperty</code> Trap이 <code>false</code>를 반환하기 때문에 에러가 발생합니다.</p>
<blockquote>
<p>또한 <code>Reflect.defineProperty()</code> 메서드를 호출하지 않고 <code>true</code>를 리턴함으로써 <code>Object.defineProperty()</code>가 자동으로 실패하도록 할 수 있습니다. 실제로 프로퍼티를 정의하지 않는 동안 오류가 표시되지 않습니다.</p>
</blockquote>
<h3 id="Descriptor-객체-제한-사항"><a href="#Descriptor-객체-제한-사항" class="headerlink" title="Descriptor 객체 제한 사항"></a>Descriptor 객체 제한 사항</h3><p><code>Object.defineProperty()</code> 및 <code>Object.getOwnPropertyDescriptor()</code> 메서드를 사용할 때 일관된 동작을 보장하기 위해<br> <code>defineProperty</code> Trap에 전달된 Descriptor 객체가 정규화됩니다. <code>getOwnPropertyDescriptor</code> Trap에서 반환된 객체는 같은 이유로 항상 유효성이 검사됩니다.</p>
<p>어떤 객체가 <code>Object.defineProperty()</code> 메서드의 세 번째 파라미터로 전달 되더라도, <code>enumerable</code>, <code>configurable</code>, <code>value</code>, <code>writable</code>, <code>get</code> 및 <code>set</code> 속성들만 <code>defineProperty</code> Trap로 전달된 Descrptor 객체에 있을수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</div><div class="line">    defineProperty(trapTarget, key, descriptor) &#123;</div><div class="line">        <span class="built_in">console</span>.log(descriptor.value);              <span class="comment">// "proxy"</span></div><div class="line">        <span class="built_in">console</span>.log(descriptor.name);               <span class="comment">// undefined</span></div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.defineProperty(trapTarget, key, descriptor);</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"></div><div class="line"><span class="built_in">Object</span>.defineProperty(proxy, <span class="string">"name"</span>, &#123;</div><div class="line">    <span class="attr">value</span>: <span class="string">"proxy"</span>,</div><div class="line">    <span class="attr">name</span>: <span class="string">"custom"</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>여기서, <code>Object.defineProperty()</code>는 세 번째 파라미터에 비표준 <code>name</code> 프로퍼티를 가지고 호출됩니다. <code>defineProperty</code> Trap이 호출되면, <code>descriptor</code> 객체는 <code>name</code> 프로퍼티를 갖지 않고 <code>value</code> 프로퍼티는 갖습니다. 왜냐하면 <code>descriptor</code>는 <code>Object.defineProperty()</code> 메서드에 전달된 실제 세 번째 파라미터에 대한 참조가 아니라 허용 가능한 프로퍼티만을 포함하는 새로운 객체이기 때문입니다. <code>Reflect.defineProperty()</code> 메서드는 또한 Descriptor의 비표준 특성을 무시합니다.</p>
<p><code>getOwnPropertyDescriptor</code> Trap은 반환값이 <code>null</code>, <code>undefined</code> 또는 객체가되도록 약간 다른 제한이 있습니다. 객체가 반환되면 객체의 자체 프로퍼티로 <code>enumerable</code>, <code>configurable</code>, <code>value</code>, <code>writable</code>, <code>get</code> 및 <code>set</code> 만 허용됩니다. 아래 코드와 같이 허용되지 않는 자체 프로퍼티를 가진 객체를 반환하면 오류가 발생합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</div><div class="line">    getOwnPropertyDescriptor(trapTarget, key) &#123;</div><div class="line">        <span class="keyword">return</span> &#123;</div><div class="line">            <span class="attr">name</span>: <span class="string">"proxy"</span></div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// error 발생</span></div><div class="line"><span class="keyword">let</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(proxy, <span class="string">"name"</span>);</div></pre></td></tr></table></figure>
<p>프로퍼티 Descriptor에서 <code>name</code> 프로퍼티를 사용할 수 없으므로 <code>Object.getOwnPropertyDescriptor()</code>가 호출되면<br> <code>getOwnPropertyDescriptor</code> 반환값은 오류를 발생시킵니다. 이 제약은, <code>Object.getOwnPropertyDescriptor()</code>에 의해 돌려 주어지는 값이, 프록시상에서의 사용에 관계없이 항상 신뢰할 수있는 구조를 가지는 것을 보증합니다.</p>
<h3 id="중복된-Descriptor-메서드"><a href="#중복된-Descriptor-메서드" class="headerlink" title="중복된 Descriptor 메서드"></a>중복된 Descriptor 메서드</h3><p>다시 한번, ECMAScript 6는 <code>Object.defineProperty()</code> 및<code>Object.getOwnPropertyDescriptor()</code> 메서드가 <code>Reflect.defineProperty()</code> 및 <code>Reflect.getOwnPropertyDescriptor()</code> 메서드와 동일한 기능을 수행하는 것처럼 혼동을 불러 일으키는 유사한 메서드를 가지고 있습니다. 이 장의 앞 부분에서 논의된 다른 메서드와 마찬가지로, 이들은 미묘하지만 중요한 차이점이 있습니다.</p>
<h4 id="defineProperty-메서드"><a href="#defineProperty-메서드" class="headerlink" title="defineProperty() 메서드"></a>defineProperty() 메서드</h4><p><code>Object.defineProperty()</code> 및 <code>Reflect.defineProperty()</code> 메서드는 반환 값을 제외하고 완전히 동일합니다. <code>Object.defineProperty()</code> 메서드는 첫 번째 피라미터를 반환하고 <code>Reflect.defineProperty()</code>는 작업이 성공하면 <code>true</code>를 반환하고 그렇지 않으면 <code>false</code>를 반환합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> target = &#123;&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> result1 = <span class="built_in">Object</span>.defineProperty(target, <span class="string">"name"</span>, &#123; <span class="attr">value</span>: <span class="string">"target "</span>&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(target === result1);        <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> result2 = <span class="built_in">Reflect</span>.defineProperty(target, <span class="string">"name"</span>, &#123; <span class="attr">value</span>: <span class="string">"reflect"</span> &#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(result2);                   <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p><code>target</code>에서 <code>Object.defineProperty()</code>가 호출되면 반환값은 <code>target</code>입니다. <code>Reflect.defineProperty()</code>가 <code>target</code>에서 호출되면 반환값은 연산이 성공했음을 나타내는 <code>true</code>입니다. <code>defineProperty</code> 프록시 Trap은 반환될 부울 값을 필요로하기 때문에 필요할 때<br> <code>Reflect.defineProperty()</code>를 사용하여 기본 동작을 구현하는 것이 좋습니다.</p>
<h4 id="getOwnPropertyDescriptor-메서드"><a href="#getOwnPropertyDescriptor-메서드" class="headerlink" title="getOwnPropertyDescriptor() 메서드"></a>getOwnPropertyDescriptor() 메서드</h4><p><code>Object.getOwnPropertyDescriptor()</code> 메서드는 <em>Primitive</em> 값이 전달될 때 첫 번째 파라미터를 객체로 강제 변환한 다음 작업을 계속합니다. 반면에 첫 번째 파라미터가 <em>Primitive</em> 값이면 <code>Reflect.getOwnPropertyDescriptor()</code> 메서드는 오류를 발생시킵니다. 다음은 이 두 가지를 보여주는 예입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> descriptor1 = <span class="built_in">Object</span>.getOwnPropertyDescriptor(<span class="number">2</span>, <span class="string">"name"</span>);</div><div class="line"><span class="built_in">console</span>.log(descriptor1);       <span class="comment">// undefined</span></div><div class="line"></div><div class="line"><span class="comment">// throws an error</span></div><div class="line"><span class="keyword">let</span> descriptor2 = <span class="built_in">Reflect</span>.getOwnPropertyDescriptor(<span class="number">2</span>, <span class="string">"name"</span>);</div></pre></td></tr></table></figure>
<p><code>Object.getOwnPropertyDescriptor()</code> 메서드는 <code>2</code>를 객체로 강제변환하고 객체에는 <code>name</code> 프로퍼티가 없기 때문에  <code>undefined</code>를 반환합니다. 주어진 이름을 가진 프로퍼티가 객체에서 발견되지 않을때의 메서드 표준 동작입니다. 그러나 <code>Reflect.getOwnPropertyDescriptor()</code>가 호출되면 해당 메서드가 첫 번째 파라미터에 대한 <em>Primitive</em> 값을 허용하지 않기 때문에 오류가 즉시 발생합니다.</p>
<h2 id="ownKeys-Trap"><a href="#ownKeys-Trap" class="headerlink" title="ownKeys Trap"></a>ownKeys Trap</h2><p><code>ownKeys</code> 프록시 Trap은 내부 메서드 <code>[[OwnPropertyKeys]]</code>를 가로 채고, 여러분이 값의 <em>Array</em>를 반환함으로써 동작을 오버라이드할 수 있도록합니다. 이 <em>Array</em>는 <code>Object.keys()</code>, <code>Object.getOwnPropertyNames()</code>, <code>Object.getOwnPropertySymbols()</code> 및 <code>Object.assign()</code>의 네 가지 메서드를 사용합니다. <code>Object.assign()</code> 메서드는 <em>Array</em>를 사용하여 복사할 프로퍼티를 결정합니다.</p>
<p><code>ownKeys</code> Trap의 기본 동작은 <code>Reflect.ownKeys()</code> 메서드에 의해 구현되고 문자열과 <em>Symbol</em>을 포함한 모든 고유한 프로퍼티 키의 <em>Array</em>를 반환합니다. <code>Object.getOwnProperyNames()</code> 메서드 및 <code>Object.keys()</code> 메서드는 <em>Array</em>에서 <em>Symbol</em>을 필터링하고 결과를 반환하며 <code>Object.getOwnPropertySymbols()</code>는 <em>Array</em>에서 문자열을 필터링하여 결과를 반환합니다. <code>Object.assign()</code> 메서드는 문자열과 <em>Symbol</em>이 모두 포함된 <em>Array</em>를 사용합니다.</p>
<p><code>ownKeys</code> Trap은 대상을 하나의 파라미터로 받고, 항상 <em>Array</em>이나 유사 <em>Array</em>와 같은 객체를 반환해야합니다; 그렇지 않으면 오류가 발생합니다. <code>OwnKeys</code> Trap을 사용하면, 예를 들어, <code>Object.getOwnPropertyNames()</code>, <code>Object.getOwnPropertySymbols()</code>, <code>Object.getOwnPropertyNames()</code>, 또는 <code>Object.assign()</code> 메서드가 사용됩니다. JavaScript에서 필드가 비공개임을 나타내는 일반적인 표기법인 밑줄 문자(underscore)로 시작하는 프로퍼티 이름은 포함하지 않으려는 경우로 가정하여 <code>ownKeys</code> Trap을 사용하여 다음과 같이 키를 걸러낼 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</div><div class="line">    ownKeys(trapTarget) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.ownKeys(trapTarget).filter(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">typeof</span> key !== <span class="string">"string"</span> || key[<span class="number">0</span>] !== <span class="string">"_"</span>;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">let</span> nameSymbol = <span class="built_in">Symbol</span>(<span class="string">"name"</span>);</div><div class="line"></div><div class="line">proxy.name = <span class="string">"proxy"</span>;</div><div class="line">proxy._name = <span class="string">"private"</span>;</div><div class="line">proxy[nameSymbol] = <span class="string">"symbol"</span>;</div><div class="line"></div><div class="line"><span class="keyword">let</span> names = <span class="built_in">Object</span>.getOwnPropertyNames(proxy),</div><div class="line">    keys = <span class="built_in">Object</span>.keys(proxy);</div><div class="line">    symbols = <span class="built_in">Object</span>.getOwnPropertySymbols(proxy);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(names.length);      <span class="comment">// 1</span></div><div class="line"><span class="built_in">console</span>.log(names[<span class="number">0</span>]);          <span class="comment">// "name"</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(keys.length);      <span class="comment">// 1</span></div><div class="line"><span class="built_in">console</span>.log(keys[<span class="number">0</span>]);          <span class="comment">// "name"</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(symbols.length);    <span class="comment">// 1</span></div><div class="line"><span class="built_in">console</span>.log(symbols[<span class="number">0</span>]);        <span class="comment">// "Symbol(name)"</span></div></pre></td></tr></table></figure>
<p>이 예제는 <code>Reflect.ownKeys()</code>를 먼저 호출하여 대상의 기본 리스트를 얻는 <code>ownKeys</code> Trap을 사용합니다. 그런 다음 <code>filter()</code> 메서드는 문자열이며 밑줄 문자로 시작하는 키를 필터링하는데 사용됩니다. 그런 다음 <code>proxy</code> 객체에 세가지 프로퍼티가 추가됩니다.(<code>name</code>, <code>_name</code> 및 <code>nameSymbol</code>). <code>Object.getOwnPropertyNames()</code>와 <code>Object.keys()</code>가 <code>proxy</code>에서 호출되면 <code>name</code> 프로퍼티만 반환됩니다. 비슷하게 <code>Object.getOwnPropertySymbols()</code>가 <code>proxy</code>에서 호출될 때 <code>nameSymbol</code>만 반환됩니다. <code>_name</code> 프로퍼티는 필터링되어서 어느 결과에도 나타나지 않습니다.</p>
<blockquote>
<p><code>ownKeys</code> Trap은 또한 <code>for-in</code> 루프에 영향을 미칩니다.이 루프는 Trap을 호출하여 루프 내부에서 사용할 키를 결정합니다.</p>
</blockquote>
<h2 id="apply와-construct-Trap을-이용한-Function-프록시"><a href="#apply와-construct-Trap을-이용한-Function-프록시" class="headerlink" title="apply와 construct Trap을 이용한 Function 프록시"></a>apply와 construct Trap을 이용한 Function 프록시</h2><p>모든 프록시 Trap 중, <code>apply</code>와 <code>construct</code>만이 프록시 대상으로 함수가 필요합니다. 3장에서 함수는 각각 <code>new</code> 연산자를 사용하지 않고 함수를 호출할 때 실행되는 <code>[[Call]]</code> 및 <code>[[Construct]]</code>라는 두가지 내부 메서드를 가지고 있음을 설명했습니다. <code>apply</code> 및 <code>construct</code> Trap은 해당 내부 메서드를 재정의 하도록합니다. 함수가 <code>new</code> 없이 호출되면, <code>apply</code> Trap은 <code>Reflect.apply()</code>에 다음 파라미터가 필요합니다.</p>
<ol>
<li><code>trapTarget</code> - 실행중인 함수 (프록시의 대상)</li>
<li><code>thisArg</code> - 호출 중 함수 안에있는 <code>this</code>의 값</li>
<li><code>argumentsList</code> - 함수에게 건네진 파라미터 <em>Array</em></li>
</ol>
<p><code>new</code>를 사용하여 함수가 실행될 때 호출되는 <code>construct</code> Trap은 다음 파라미터를 받습니다.</p>
<ol>
<li><code>trapTarget</code> - 실행중인 함수 (프록시의 대상)</li>
<li><code>argumentsList</code> - 함수에게 건네진 파라미터 <em>Array</em></li>
</ol>
<p><code>Reflect.construct()</code> 메서드는 또한 이 두개의 파라미터를 받아들이며 <code>newTarget</code>이라는 선택적인 세 번째 파라미터를 받습니다. 주어진 경우, <code>newTarget</code> 파라미터는 함수 안에 <code>new.target</code>의 값을 지정합니다.</p>
<p><code>apply</code>와<code>construct</code> Trap은 모든 프록시 대상 함수의 동작을 완벽하게 제어합니다. 함수의 기본 동작을 모방하려면 다음과 같이 하면됩니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> target = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">42</span> &#125;,</div><div class="line">    proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</div><div class="line">        <span class="attr">apply</span>: <span class="function"><span class="keyword">function</span>(<span class="params">trapTarget, thisArg, argumentList</span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="built_in">Reflect</span>.apply(trapTarget, thisArg, argumentList);</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">construct</span>: <span class="function"><span class="keyword">function</span>(<span class="params">trapTarget, argumentList</span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="built_in">Reflect</span>.construct(trapTarget, argumentList);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line"><span class="comment">// 함수를 대상으로하는 프록시는 함수처럼 보입니다.</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> proxy);                  <span class="comment">// "function"</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(proxy());                       <span class="comment">// 42</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> proxy();</div><div class="line"><span class="built_in">console</span>.log(instance <span class="keyword">instanceof</span> proxy);     <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(instance <span class="keyword">instanceof</span> target);    <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>이 예제에서 숫자 42를 반환하는 함수를 가지고 있습니다. 이 함수의 프록시는 <code>apply</code>와 <code>construct</code> Trap을 사용하여 그 동작을 각각 <code>Reflect.apply()</code>와 <code>Reflect.construct()</code> 메서드에 위임합니다. 결과적으로 프록시 함수는 <code>typeof</code>가 사용될 때 함수로 자신을 식별하는 것을 포함하여 대상 함수와 똑같이 동작합니다. 프록시는 42를 반환하기 위해 <code>new</code> 없이 호출합니다. 그리고 <code>new</code>를 호출하여 <code>instance</code>라는 객체를 만듭니다. <code>instance</code> 객체는 프로토 타입 체인을 사용하여 이 정보를 결정하기 때문에 <code>proxy</code>와 <code>target</code>의 인스턴스로 간주됩니다. 프로토 타입 체인 조회는 이 프록시의 영향을 받지 않으므로 프록시와 대상이 JavaScript 엔진과 동일한 프로토 타입을 사용하는 것으로 보여집니다.</p>
<h3 id="함수-파라미터-유효성-검사"><a href="#함수-파라미터-유효성-검사" class="headerlink" title="함수 파라미터 유효성 검사"></a>함수 파라미터 유효성 검사</h3><p><code>apply</code>와 <code>construct</code> Trap은 함수가 실행되는 방식을 변경하는 많은 가능성을 열어줍니다. 예를 들어 모든 파라미터가 특정 타입인지 확인하려고 한다고 가정해 보겠습니다. <code>apply</code> Trap에서 파라미터를 확인할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 모든 파라미터를 더합니다.</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">...values</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> values.reduce(<span class="function">(<span class="params">previous, current</span>) =&gt;</span> previous + current, <span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> sumProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(sum, &#123;</div><div class="line">        <span class="attr">apply</span>: <span class="function"><span class="keyword">function</span>(<span class="params">trapTarget, thisArg, argumentList</span>) </span>&#123;</div><div class="line"></div><div class="line">            argumentList.forEach(<span class="function">(<span class="params">arg</span>) =&gt;</span> &#123;</div><div class="line">                <span class="keyword">if</span> (<span class="keyword">typeof</span> arg !== <span class="string">"number"</span>) &#123;</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"All arguments must be numbers."</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line"></div><div class="line">            <span class="keyword">return</span> <span class="built_in">Reflect</span>.apply(trapTarget, thisArg, argumentList);</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">construct</span>: <span class="function"><span class="keyword">function</span>(<span class="params">trapTarget, argumentList</span>) </span>&#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"This function can't be called with new."</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(sumProxy(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>));          <span class="comment">// 10</span></div><div class="line"></div><div class="line"><span class="comment">// error를 발생시킵니다.</span></div><div class="line"><span class="built_in">console</span>.log(sumProxy(<span class="number">1</span>, <span class="string">"2"</span>, <span class="number">3</span>, <span class="number">4</span>));</div><div class="line"></div><div class="line"><span class="comment">// 역시 error를 발생시킵니다.</span></div><div class="line"><span class="keyword">let</span> result = <span class="keyword">new</span> sumProxy();</div></pre></td></tr></table></figure>
<p>이 예제는 <code>apply</code> Trap을 사용하여 모든 파라미터가 숫자임을 확인합니다. <code>sum()</code> 함수는 전달된 모든 파라미터를 더합니다. 숫자가 아닌 값이 전달되면 이 함수는 계속 작업을 시도하므로 예기치 않은 결과가 발생할 수 있습니다. <code>sum()</code>을 <code>sumProxy()</code> 프록시 안에 넣음으로써 이 코드는 함수 호출을 가로 채고 호출이 진행되기 전에 각 파라미터가 숫자인지 확인합니다. 안전을 위해, 코드는 <code>construct</code> Trap을 사용하여 <code>new</code> 함수를 호출할 수 없도록합니다.</p>
<p>함수를 <code>new</code>로 호출하고 파라미터가 숫자인지 확인해야합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Numbers</span>(<span class="params">...values</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.values = values;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> NumbersProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(Numbers, &#123;</div><div class="line"></div><div class="line">        <span class="attr">apply</span>: <span class="function"><span class="keyword">function</span>(<span class="params">trapTarget, thisArg, argumentList</span>) </span>&#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"This function must be called with new."</span>);</div><div class="line">        &#125;,</div><div class="line"></div><div class="line">        <span class="attr">construct</span>: <span class="function"><span class="keyword">function</span>(<span class="params">trapTarget, argumentList</span>) </span>&#123;</div><div class="line">            argumentList.forEach(<span class="function">(<span class="params">arg</span>) =&gt;</span> &#123;</div><div class="line">                <span class="keyword">if</span> (<span class="keyword">typeof</span> arg !== <span class="string">"number"</span>) &#123;</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"All arguments must be numbers."</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line"></div><div class="line">            <span class="keyword">return</span> <span class="built_in">Reflect</span>.construct(trapTarget, argumentList);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> NumbersProxy(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</div><div class="line"><span class="built_in">console</span>.log(instance.values);               <span class="comment">// [1,2,3,4]</span></div><div class="line"></div><div class="line"><span class="comment">// throws error</span></div><div class="line">NumbersProxy(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</div></pre></td></tr></table></figure>
<p>여기서 <code>construct</code> Trap이 <code>Reflect.construct()</code> 메서드를 사용하여 입력값을 검증하고 새로운 인스턴스를 리턴할 때 <code>apply</code> Trap은 오류를 던집니다. 물론, 대신에 <code>new.target</code>을 사용하여 프록시없이 동일한 것을 수행할 수 있습니다.</p>
<h3 id="new가-없는-생성자-호출"><a href="#new가-없는-생성자-호출" class="headerlink" title="new가 없는 생성자 호출"></a><code>new</code>가 없는 생성자 호출</h3><p>3 장에서 <code>new.target</code> 메타 프로퍼티를 소개했습니다. <code>new.target</code>은 <code>new</code>가 호출되는 함수에 대한 참조입니다. 즉, <code>new.target</code>의 값을 다음과 같이 검사하여 <code>new</code>를 사용하여 함수를 호출했는지 여부를 알 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Numbers</span>(<span class="params">...values</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">new</span>.target === <span class="string">"undefined"</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"This function must be called with new."</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.values = values;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> Numbers(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</div><div class="line"><span class="built_in">console</span>.log(instance.values);               <span class="comment">// [1,2,3,4]</span></div><div class="line"></div><div class="line"><span class="comment">// throws error</span></div><div class="line">Numbers(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</div></pre></td></tr></table></figure>
<p>이 예제는 “함수 파라미터 유효성 검사” 섹션의 프록시를 사용하지 않는 예제와 유사하며, <code>new</code>를 사용하지 않고 <code>Numbers</code>가 호출될 때 에러를 던집니다. 유일한 목적이 <code>new</code>없이 함수를 호출하는 것을 방지하는 것이라면 이와 같은 코드를 작성하는 것은 프록시를 사용하는 것보다 훨씬 간단하며 바람직합니다. 그러나 때로는 동작을 수정해야하는 함수를 제어하지 못하는 경우가 있습니다. 이 경우 프록시를 사용하는 것이 좋습니다.</p>
<p><code>Numbers</code> 함수가 수정할 수 없는 코드에 정의되었다고 가정해 보겠습니다. 이 코드는 <code>new.target</code>에 의존하고 있으며 여전히 함수를 호출할 때 체크를 피하기를 원합니다. <code>new</code>를 사용할 때의 동작은 이미 설정되어 있으므로 <code>apply</code> Trap을 사용할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Numbers</span>(<span class="params">...values</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">new</span>.target === <span class="string">"undefined"</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"This function must be called with new."</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.values = values;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">let</span> NumbersProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(Numbers, &#123;</div><div class="line">        <span class="attr">apply</span>: <span class="function"><span class="keyword">function</span>(<span class="params">trapTarget, thisArg, argumentsList</span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="built_in">Reflect</span>.construct(trapTarget, argumentsList);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">let</span> instance = NumbersProxy(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</div><div class="line"><span class="built_in">console</span>.log(instance.values);               <span class="comment">// [1,2,3,4]</span></div></pre></td></tr></table></figure>
<p><code>NumbersProxy</code> 함수는 <code>new</code>를 사용하지 않고 <code>Numbers</code>를 호출하고 <code>new</code>가 사용된 것처럼 행동하게합니다. 그렇게하기 위해, <code>apply</code> Trap은 <code>Reflect.construct()</code>를 호출하고 <code>apply</code>에 전달된 파라미터를 사용합니다. <code>Numbers</code> 내부의 <code>new.target</code>은 <code>Numbers</code> 자체와 동일하며 에러는 발생하지 않습니다. 이것은 <code>new.target</code>을 변경하는 간단한 예제이지만, 더 직접적으로 할 수도 있습니다.</p>
<h3 id="추상-기본-클래스-생성자-Abstract-Base-Class-Constructor-재정의"><a href="#추상-기본-클래스-생성자-Abstract-Base-Class-Constructor-재정의" class="headerlink" title="추상 기본 클래스 생성자 (Abstract Base Class Constructor) 재정의"></a>추상 기본 클래스 생성자 (Abstract Base Class Constructor) 재정의</h3><p>한 걸음 더 나아가 <code>new.target</code>에 할당할 특정 값으로 <code>Reflect.construct()</code>의 세 번째 파라미터를 지정할 수 있습니다. 이는 함수가 추상 기본 클래스 생성자를 생성할 때(9 장에서 설명)와 같이 알려진 값에 대해 <code>new.target</code>을 검사할 때 유용합니다. 추상 기본 클래스 생성자에서, <code>new.target</code>은 이 예제에서와 같이 클래스 생성자 그 자체가 아닌 다른 것으로 예상됩니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractNumbers</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">constructor</span>(...values) &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">new</span>.target === AbstractNumbers) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"This function must be inherited from."</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.values = values;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Numbers</span> <span class="keyword">extends</span> <span class="title">AbstractNumbers</span> </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> Numbers(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</div><div class="line"><span class="built_in">console</span>.log(instance.values);           <span class="comment">// [1,2,3,4]</span></div><div class="line"></div><div class="line"><span class="comment">// throws error</span></div><div class="line"><span class="keyword">new</span> AbstractNumbers(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</div></pre></td></tr></table></figure>
<p><code>new AbstractNumbers()</code>가 호출되면, <code>new.target</code>은 <code>AbstractNumbers</code>와 같기 때문에 에러를 발생 시킵니다. <code>new.target</code>이 <code>Numbers</code>와 같기 때문에 <code>new Numbers()</code>는 여전히 작동합니다. 수동으로 <code>new.target</code>에 프록시를 할당함으로써 이 제약을 우회할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractNumbers</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">constructor</span>(...values) &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">new</span>.target === AbstractNumbers) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"This function must be inherited from."</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.values = values;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> AbstractNumbersProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(AbstractNumbers, &#123;</div><div class="line">        <span class="attr">construct</span>: <span class="function"><span class="keyword">function</span>(<span class="params">trapTarget, argumentList</span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="built_in">Reflect</span>.construct(trapTarget, argumentList, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> AbstractNumbersProxy(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</div><div class="line"><span class="built_in">console</span>.log(instance.values);               <span class="comment">// [1,2,3,4]</span></div></pre></td></tr></table></figure>
<p><code>AbstractNumbersProxy</code>는 <code>construct</code> Trap을 사용하여 <code>new AbstractNumbersProxy()</code> 메서드에 대한 호출을 가로챕니다. 그런 다음, <code>Reflect.construct()</code> 메서드가 Trap의 파라미터와 함께 호출되고 빈 함수를 세 번째 파라미터로 추가합니다. 그 빈 함수는 생성자 내부의 <code>new.target</code>의 값으로 사용됩니다. <code>new.target</code>이 <code>AbstractNumbers</code>와 같지 않기 때문에 오류가 발생하지 않고 생성자가 완전히 실행됩니다.</p>
<h3 id="호출가능한-클래스-생성자"><a href="#호출가능한-클래스-생성자" class="headerlink" title="호출가능한 클래스 생성자"></a>호출가능한 클래스 생성자</h3><p>9 장에서는 클래스 생성자가 항상 <code>new</code>로 호출되어야 한다고 설명했다. 이는 클래스 생성자에 대한 내부 <code>[[Call]]</code> 메서드가 오류를 throw 하도록 지정 되었기 때문에 발생합니다. 그러나 프록시는 <code>[[Call]]</code> 메서드에 대한 호출을 가로챌 수 있습니다. 즉, 프록시를 사용하여 호출 가능한 클래스 생성자를 효과적으로 만들 수 있습니다. 예를 들어, 클래스 생성자가 <code>new</code>를 사용하지 않고 동작하게 하려면, <code>apply</code> Trap을 사용하여 새로운 인스턴스를 생성 할 수 있습니다. 다음은 몇 가지 샘플 코드입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(name) &#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> PersonProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(Person, &#123;</div><div class="line">        <span class="attr">apply</span>: <span class="function"><span class="keyword">function</span>(<span class="params">trapTarget, thisArg, argumentList</span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> trapTarget(...argumentList);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">let</span> me = PersonProxy(<span class="string">"Nicholas"</span>);</div><div class="line"><span class="built_in">console</span>.log(me.name);                   <span class="comment">// "Nicholas"</span></div><div class="line"><span class="built_in">console</span>.log(me <span class="keyword">instanceof</span> Person);      <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(me <span class="keyword">instanceof</span> PersonProxy); <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p><code>PersonProxy</code> 객체는 <code>Person</code> 클래스 생성자의 프록시입니다. 클래스 생성자는 단지 함수이므로 프록시에서 사용될 때 함수처럼 작동합니다. <code>apply</code> Trap은 기본 동작을 재정의하고 대신 <code>Person</code>과 같은 <code>trapTarget</code>의 새로운 인스턴스를 반환합니다(이 예제에서 <code>trapTarget</code>을 사용하여 클래스를 수동으로 지정하지 않아도 된다는 것을 보여주기 위해 사용했습니다). <code>argumentList</code>는 <em>Spread</em> 연산자를 사용하여 각 파라미터가 개별적으로trapTarget<code>에 전달됩니다.</code>new<code>를 사용하지 않고</code>PersonProxy()<code>를 호출하면</code>Person<code>의 인스턴스를 반환합니다(</code>new<code>없이</code>Person()`을 호출하려고 하면 생성자는 여전히 오류를 던질 것입니다). 호출 가능한 클래스 생성자를 만드는 것은 프록시를 사용하는 경우에만 가능합니다.</p>
<h2 id="취소-가능한-프록시"><a href="#취소-가능한-프록시" class="headerlink" title="취소 가능한 프록시"></a>취소 가능한 프록시</h2><p>일반적으로 프록시가 생성되면 프록시는 대상에서 재배치할 수 없습니다. 이장의 모든 예제는 재배치할 수 없는 프록시를 사용했습니다. 그러나 더이상 사용할 수 없도록 프록시를 취소하려는 경우가 있을 수 있습니다. 보안을 위해 API를 통해 객체를 제공하고 언제든지 일부 기능에 대한 액세스를 차단할 수 있는 기능을 유지하려는 경우 프록시를 해지하는 것이 유용합니다.</p>
<p><code>Proxy.revocable()</code> 메서드로 취소 가능한 프록시를 생성할 수 있습니다. 이 메서드는 대상 객체와 프록시 핸들러인 <code>Proxy</code> 생성자와 같은 파라미터를 사용합니다. 반환 값은 다음과 같은 프로퍼티를 가진 객체입니다.</p>
<ol>
<li><code>proxy</code> - 취소할 수 있는 프록시 객체</li>
<li><code>revoke</code> - 프록시를 취소하기 위해서 호출하는 함수</li>
</ol>
<p><code>revoke()</code> 함수가 호출될 때, <code>proxy</code>를 통해 더 이상의 연산을 수행할 수 없습니다. 프록시 Trap을 발생시키는 방식으로 프록시 오브젝트와 상호 작용하려는 모든 시도는 오류를 발생시킵니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> target = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">"target"</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> &#123; proxy, revoke &#125; = <span class="built_in">Proxy</span>.revocable(target, &#123;&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(proxy.name);        <span class="comment">// "target"</span></div><div class="line"></div><div class="line">revoke();</div><div class="line"></div><div class="line"><span class="comment">// error 발생</span></div><div class="line"><span class="built_in">console</span>.log(proxy.name);</div></pre></td></tr></table></figure>
<p>이 예제는 취소 가능한 프록시를 만듭니다. <code>Proxy.revocable()</code> 메서드에 의해 반환된 객체에서 같은 이름의 프로퍼티에 <code>proxy</code>와 <code>revoke</code> 변수를 할당하기 위해 <em>Destructuring</em>을 사용합니다. 그 후, <code>proxy</code> 객체는 취소가 불가능한(nonrevocable) 프록시 객체처럼 사용될 수 있습니다. 그래서 <code>proxy.name</code>은 <code>target.name</code>을 그대로 통과하기 때문에 <code>&quot;target&quot;</code>을 리턴합니다. 그러나 일단 <code>revoke()</code> 함수가 호출되면, 프록시는 더이상 함수가 아닙니다. <code>proxy.name</code>에 접근하려고 시도하면 에러가 발생하고, 프록시에서 Trap을 발생시키는 다른 동작도 마찬가지입니다.</p>
<h2 id="Array의-문제점-해결하기"><a href="#Array의-문제점-해결하기" class="headerlink" title="Array의 문제점 해결하기"></a>Array의 문제점 해결하기</h2><p>이장의 시작 부분에서 개발자가 ECMAScript 6 이전의 JavaScript에서 <em>Array</em>의 동작을 정확하게 모방할 수 없다는 것을 설명했습니다. 프록시와 리플렉션 API를 사용하면 프로퍼티가 추가되고 제거될 때 <em>Built-in</em> <code>Array</code> 타입과 같은 방식으로 동작하는 객체를 생성할 수 있습니다. 기억을 되새겨 아래 예제는 프록시가 <em>Array</em>를 모방하는데 도움이되는 동작을 보여주는 예입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> colors = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>];</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(colors.length);         <span class="comment">// 3</span></div><div class="line"></div><div class="line">colors[<span class="number">3</span>] = <span class="string">"black"</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(colors.length);         <span class="comment">// 4</span></div><div class="line"><span class="built_in">console</span>.log(colors[<span class="number">3</span>]);             <span class="comment">// "black"</span></div><div class="line"></div><div class="line">colors.length = <span class="number">2</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(colors.length);         <span class="comment">// 2</span></div><div class="line"><span class="built_in">console</span>.log(colors[<span class="number">3</span>]);             <span class="comment">// undefined</span></div><div class="line"><span class="built_in">console</span>.log(colors[<span class="number">2</span>]);             <span class="comment">// undefined</span></div><div class="line"><span class="built_in">console</span>.log(colors[<span class="number">1</span>]);             <span class="comment">// "green"</span></div></pre></td></tr></table></figure>
<p>위 예제에서 주의해야할 두가지 중요한 동작이 있습니다.</p>
<ol>
<li><code>colors[3]</code>에 값이 할당되면 <code>length</code> 프로퍼티가 4로 증가합니다.</li>
<li><code>length</code> 프로퍼티가 2로 설정되면 <em>Array</em>의 마지막 두 항목이 삭제됩니다.</li>
</ol>
<p>이 두가지 동작은 <em>Built-in Array</em>의 작동 방식을 정확하게 재현하기 위해 모방되어야하는 중요한 동작입니다. 다음 몇 섹션에서는 올바르게 <em>Array</em> 객체를 모방하는 방법을 설명합니다.</p>
<h3 id="Array-색인-찾기"><a href="#Array-색인-찾기" class="headerlink" title="Array 색인 찾기"></a>Array 색인 찾기</h3><p>정수형 프로퍼티 키에 할당하는 것은 비 정수형 키와 다르게 취급되는 <em>Array</em>의 특별한 경우입니다. ECMAScript 6 사양에서는 프로퍼티 키가 <em>Array</em> 인덱스인지 확인하는 방법에 대한 지침을 제공합니다.</p>
<blockquote>
<p><code>toString(ToUint32(P))</code>이 <code>P</code>이고 <code>ToUint32(P)</code>가 <code>2 ^ 32-1</code>이 아니면 String 프로퍼티 이름 <code>P</code>는 <em>Array</em> 인덱스입니다.</p>
</blockquote>
<p>이  연산자는 다음과 같이 JavaScript로 구현될 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">toUint32</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.abs(<span class="built_in">Number</span>(value))) % <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">32</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArrayIndex</span>(<span class="params">key</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> numericKey = toUint32(key);</div><div class="line">    <span class="keyword">return</span> <span class="built_in">String</span>(numericKey) == key &amp;&amp; numericKey &lt; (<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">32</span>) - <span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>toUint32()</code> 함수는 사양에 설명된 알고리즘을 사용하여 주어진 값을 부호없는 32비트 정수로 변환합니다. <code>isArrayIndex()</code> 함수는 먼저 키를 uint32로 변환한 다음 비교를 수행하여 키가 <em>Array</em> 인덱스인지 여부를 확인합니다. 이러한 유틸리티 함수를 사용할 수 있으면 <em>Built-in Array</em>를 모방할 객체를 구현할 수 있습니다.</p>
<h3 id="새로운-요소를-추가할-때-length-증가"><a href="#새로운-요소를-추가할-때-length-증가" class="headerlink" title="새로운 요소를 추가할 때 length 증가"></a>새로운 요소를 추가할 때 <code>length</code> 증가</h3><p>설명한 두<em>Array</em>의 동작이 프로퍼티 할당에 의존한다는 것을 눈치 챘을 것입니다. 즉, 두가지 동작을 모두 수행하려면 <code>set</code> 프록시 Trap을 사용해야합니다. 먼저 <code>length-1</code>보다 큰 <em>Array</em> 인덱스가 사용되면 <code>length</code> 프로퍼티를 증가시켜 첫 번째 두가지 동작을 구현하는 예제를 보겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">toUint32</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.abs(<span class="built_in">Number</span>(value))) % <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">32</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArrayIndex</span>(<span class="params">key</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> numericKey = toUint32(key);</div><div class="line">    <span class="keyword">return</span> <span class="built_in">String</span>(numericKey) == key &amp;&amp; numericKey &lt; (<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">32</span>) - <span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createMyArray</span>(<span class="params">length=<span class="number">0</span></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123; length &#125;, &#123;</div><div class="line">        set(trapTarget, key, value) &#123;</div><div class="line"></div><div class="line">            <span class="keyword">let</span> currentLength = <span class="built_in">Reflect</span>.get(trapTarget, <span class="string">"length"</span>);</div><div class="line"></div><div class="line">            <span class="comment">// the special case</span></div><div class="line">            <span class="keyword">if</span> (isArrayIndex(key)) &#123;</div><div class="line">                <span class="keyword">let</span> numericKey = <span class="built_in">Number</span>(key);</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (numericKey &gt;= currentLength) &#123;</div><div class="line">                    <span class="built_in">Reflect</span>.set(trapTarget, <span class="string">"length"</span>, numericKey + <span class="number">1</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// always do this regardless of key type</span></div><div class="line">            <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(trapTarget, key, value);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> colors = createMyArray(<span class="number">3</span>);</div><div class="line"><span class="built_in">console</span>.log(colors.length);         <span class="comment">// 3</span></div><div class="line"></div><div class="line">colors[<span class="number">0</span>] = <span class="string">"red"</span>;</div><div class="line">colors[<span class="number">1</span>] = <span class="string">"green"</span>;</div><div class="line">colors[<span class="number">2</span>] = <span class="string">"blue"</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(colors.length);         <span class="comment">// 3</span></div><div class="line"></div><div class="line">colors[<span class="number">3</span>] = <span class="string">"black"</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(colors.length);         <span class="comment">// 4</span></div><div class="line"><span class="built_in">console</span>.log(colors[<span class="number">3</span>]);             <span class="comment">// "black"</span></div></pre></td></tr></table></figure>
<p>이 예제는 <code>set</code> 프록시 Trap을 사용하여 <em>Array</em> 인덱스의 설정을 가로챕니다. 키가 <em>Array</em> 인덱스인 경우 키는 항상 문자열로 전달되기 때문에 숫자로 변환됩니다. 그 숫자 값이 현재 <code>length</code> 프로퍼티보다 크거나 같으면 <code>length</code> 프로퍼티가 숫자 키보다 하나 더 업데이트됩니다 (위치 3의 항목 설정은 <code>length</code>가 4 여야 함을 의미합니다). 그 후에 프로퍼티를 설정하기위한 기본 동작은 <code>Reflect.set()</code>를 통해 사용됩니다. 프로퍼티가 지정된 값을 받기를 원하기 때문입니다.</p>
<p>최초의 커스텀 <em>Array</em>는 <code>length</code>가 3인 <code>createMyArray()</code>를 호출하여 생성되며, 그 세항목의 값은 바로 뒤에 추가됩니다. <code>length</code> 프로퍼티는 3번 위치에 <code>&quot;black&quot;</code>값이 할당될 때까지 정확히 3을 유지합니다. 그 시점에서 <code>length</code>는 4로 설정됩니다.</p>
<p>첫번째 동작이 작동하면 두 번째 동작으로 이동할 시간입니다.</p>
<h3 id="length-줄이기에-대한-요소-삭제"><a href="#length-줄이기에-대한-요소-삭제" class="headerlink" title="length 줄이기에 대한 요소 삭제"></a>length 줄이기에 대한 요소 삭제</h3><p>모방을 위한 첫 번째 <em>Array</em> 동작은 <em>Array</em> 인덱스가 <code>length</code> 프로퍼티보다 크거나 같은 경우에만 사용됩니다. 두 번째 동작은 <code>length</code>  프로퍼티가 이전에 포함된 값보다 작은 값으로 설정되면 값을 줄이고 남은 <em>Array</em> 항목을 제거합니다. 이는 <code>length</code> 프로퍼티를 변경하는 것뿐만 아니라 존재하지 않는 모든 항목을 삭제하는 것을 포함합니다. 예를 들어, <code>length</code>가 4인 <em>Array</em>가 <code>length</code>를 2로 설정하면, 2와 3 위치의 항목은 삭제됩니다. 첫 번째 동작과 함께 <code>set</code> 프록시 Trap에서 이것을 수행 할 수 있습니다. 아래 예제는 앞의 예제를 업데이트한<code>createMyArray</code> 메서드 입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">toUint32</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.abs(<span class="built_in">Number</span>(value))) % <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">32</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArrayIndex</span>(<span class="params">key</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> numericKey = toUint32(key);</div><div class="line">    <span class="keyword">return</span> <span class="built_in">String</span>(numericKey) == key &amp;&amp; numericKey &lt; (<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">32</span>) - <span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createMyArray</span>(<span class="params">length=<span class="number">0</span></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123; length &#125;, &#123;</div><div class="line">        set(trapTarget, key, value) &#123;</div><div class="line"></div><div class="line">            <span class="keyword">let</span> currentLength = <span class="built_in">Reflect</span>.get(trapTarget, <span class="string">"length"</span>);</div><div class="line"></div><div class="line">            <span class="comment">// the special case</span></div><div class="line">            <span class="keyword">if</span> (isArrayIndex(key)) &#123;</div><div class="line">                <span class="keyword">let</span> numericKey = <span class="built_in">Number</span>(key);</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (numericKey &gt;= currentLength) &#123;</div><div class="line">                    <span class="built_in">Reflect</span>.set(trapTarget, <span class="string">"length"</span>, numericKey + <span class="number">1</span>);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key === <span class="string">"length"</span>) &#123;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (value &lt; currentLength) &#123;</div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">let</span> index = currentLength - <span class="number">1</span>; index &gt;= value; index\</div><div class="line">--) &#123;</div><div class="line">                        <span class="built_in">Reflect</span>.deleteProperty(trapTarget, index);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 항상 키 타입에 관계없이 이 작업을 수행합니다.</span></div><div class="line">            <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(trapTarget, key, value);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> colors = createMyArray(<span class="number">3</span>);</div><div class="line"><span class="built_in">console</span>.log(colors.length);         <span class="comment">// 3</span></div><div class="line"></div><div class="line">colors[<span class="number">0</span>] = <span class="string">"red"</span>;</div><div class="line">colors[<span class="number">1</span>] = <span class="string">"green"</span>;</div><div class="line">colors[<span class="number">2</span>] = <span class="string">"blue"</span>;</div><div class="line">colors[<span class="number">3</span>] = <span class="string">"black"</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(colors.length);         <span class="comment">// 4</span></div><div class="line"></div><div class="line">colors.length = <span class="number">2</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(colors.length);         <span class="comment">// 2</span></div><div class="line"><span class="built_in">console</span>.log(colors[<span class="number">3</span>]);             <span class="comment">// undefined</span></div><div class="line"><span class="built_in">console</span>.log(colors[<span class="number">2</span>]);             <span class="comment">// undefined</span></div><div class="line"><span class="built_in">console</span>.log(colors[<span class="number">1</span>]);             <span class="comment">// "green"</span></div><div class="line"><span class="built_in">console</span>.log(colors[<span class="number">0</span>]);             <span class="comment">// "red"</span></div></pre></td></tr></table></figure>
<p>이 코드의 <code>set</code> 프록시 Trap은 나머지 객체를 정확하게 조정하기 위해 <code>key</code>가 <code>&quot;length&quot;</code>인지를 검사합니다. 이 경우 현재 <code>length</code>가<br> <code>Reflect.get()</code>을 사용하여 먼저 검색되고 새 값과 비교됩니다. 새로운 값이 현재 <code>length</code>보다 작으면 <code>for</code> 루프는 더이상 사용할 수 없는 대상의 모든 프로퍼티를 삭제합니다. <code>for</code> 루프는 현재 <em>Array</em>의 크기(currentLength)에서 뒤로 이동하고 새로운 <em>Array</em> 크기(value)에 도달할 때까지 각 프로퍼티를 삭제합니다.</p>
<p>이 예제는 네가지 색상을 <code>colors</code>에 추가한 다음 <code>length</code> 프로퍼티를 2로 설정합니다. 이렇게 하면 위치 2와 3의 항목을 효과적으로 제거하므로 액세스하려고할 때 <code>undefined</code>를 반환합니다. <code>length</code> 프로퍼티는 정확하게 2로 설정되고 위치 0과 1의 아이템은 여전히 접근 가능합니다.</p>
<p>두가지 동작을 모두 구현하면 <em>Built-in Array</em>의 동작을 모방한 객체를 쉽게 만들수 있습니다. 그러나 함수를 사용하여 이렇게하는 것은 이 동작을 캡슐화하는 클래스를 만드는 것보다 바람직하지 않습니다. 따라서 다음 단계는 이 함수를 클래스로 구현하는 것입니다.</p>
<h3 id="MyArray-클래스-구현"><a href="#MyArray-클래스-구현" class="headerlink" title="MyArray 클래스 구현"></a>MyArray 클래스 구현</h3><p>프록시를 사용하는 클래스를 만드는 가장 간단한 방법은 클래스를 평소대로 정의한 다음 생성자에서 프록시를 반환하는 것입니다. 이렇게하면 클래스가 인스턴스화될 때 반환되는 객체는 인스턴스가 아닌 프록시가됩니다. (인스턴스는 생성자 내의 `this ‘값입니다.) 인스턴스는 프록시의 대상이되고 프록시는 인스턴스인 것처럼 반환됩니다. 인스턴스는 완전히 비공개이며 직접 액세스할 수는 없지만 프록시를 통해 간접적으로 액세스할 수 있습니다.</p>
<p>다음은 클래스 생성자에서 프록시를 반환하는 간단한 예입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thing</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(<span class="keyword">this</span>, &#123;&#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> myThing = <span class="keyword">new</span> Thing();</div><div class="line"><span class="built_in">console</span>.log(myThing <span class="keyword">instanceof</span> Thing);      <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>이 예제에서 <code>Thing</code> 클래스는 생성자에서 프록시를 반환합니다. 프록시 대상은 <code>this</code>이며 프록시는 생성자에서 반환됩니다. 즉, <code>Thing</code> 생성자를 호출하여 <code>myThing</code>을 만들었지만 실제로 <code>myThing</code>은 프록시입니다. 프록시는 자신의 동작을 대상에 전달하기 때문에 <code>myThing</code>은 여전히 <code>Thing</code> 클래스로 간주되며 프록시는 <code>Thing</code> 클래스를 사용하는 모든 사람에게 완전히 투명합니다.</p>
<p>이를 염두에두고 상대적으로 간단한 방식으로 프록시를 사용하여 맞춤 <em>Array</em> 클래스를 만듭니다. 코드는 “length 줄이기에 대한 요소 삭제”절의 코드와 거의 같습니다. 동일한 프록시 코드가 사용되지만 이번에는 클래스 생성자 내부에 있습니다. 전체 예제는 다음과 같습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">toUint32</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.abs(<span class="built_in">Number</span>(value))) % <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">32</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArrayIndex</span>(<span class="params">key</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> numericKey = toUint32(key);</div><div class="line">    <span class="keyword">return</span> <span class="built_in">String</span>(numericKey) == key &amp;&amp; numericKey &lt; (<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">32</span>) - <span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(length=0) &#123;</div><div class="line">        <span class="keyword">this</span>.length = length;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(<span class="keyword">this</span>, &#123;</div><div class="line">            set(trapTarget, key, value) &#123;</div><div class="line"></div><div class="line">                <span class="keyword">let</span> currentLength = <span class="built_in">Reflect</span>.get(trapTarget, <span class="string">"length"</span>);</div><div class="line"></div><div class="line">                <span class="comment">// the special case</span></div><div class="line">                <span class="keyword">if</span> (isArrayIndex(key)) &#123;</div><div class="line">                    <span class="keyword">let</span> numericKey = <span class="built_in">Number</span>(key);</div><div class="line"></div><div class="line">                    <span class="keyword">if</span> (numericKey &gt;= currentLength) &#123;</div><div class="line">                        <span class="built_in">Reflect</span>.set(trapTarget, <span class="string">"length"</span>, numericKey + <span class="number">1</span>);</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key === <span class="string">"length"</span>) &#123;</div><div class="line"></div><div class="line">                    <span class="keyword">if</span> (value &lt; currentLength) &#123;</div><div class="line">                        <span class="keyword">for</span> (<span class="keyword">let</span> index = currentLength - <span class="number">1</span>; index &gt;= value; i\</div><div class="line">ndex--) &#123;</div><div class="line">                            <span class="built_in">Reflect</span>.deleteProperty(trapTarget, index);</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="comment">// always do this regardless of key type</span></div><div class="line">                <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(trapTarget, key, value);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">let</span> colors = <span class="keyword">new</span> MyArray(<span class="number">3</span>);</div><div class="line"><span class="built_in">console</span>.log(colors <span class="keyword">instanceof</span> MyArray);     <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(colors.length);         <span class="comment">// 3</span></div><div class="line"></div><div class="line">colors[<span class="number">0</span>] = <span class="string">"red"</span>;</div><div class="line">colors[<span class="number">1</span>] = <span class="string">"green"</span>;</div><div class="line">colors[<span class="number">2</span>] = <span class="string">"blue"</span>;</div><div class="line">colors[<span class="number">3</span>] = <span class="string">"black"</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(colors.length);         <span class="comment">// 4</span></div><div class="line"></div><div class="line">colors.length = <span class="number">2</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(colors.length);         <span class="comment">// 2</span></div><div class="line"><span class="built_in">console</span>.log(colors[<span class="number">3</span>]);             <span class="comment">// undefined</span></div><div class="line"><span class="built_in">console</span>.log(colors[<span class="number">2</span>]);             <span class="comment">// undefined</span></div><div class="line"><span class="built_in">console</span>.log(colors[<span class="number">1</span>]);             <span class="comment">// "green"</span></div><div class="line"><span class="built_in">console</span>.log(colors[<span class="number">0</span>]);             <span class="comment">// "red"</span></div></pre></td></tr></table></figure>
<p>이 코드는 생성자에서 프록시를 반환하는 <code>MyArray</code> 클래스를 만듭니다. <code>length</code> 프로퍼티는 생성자에 추가되고 (전달된 값이나 기본값 0으로 초기화 됨) 프록시가 생성되어 반환됩니다. 이것은 <code>colors</code> 변수에 <code>MyArray</code>의 인스턴스를 대입하는 모양이 되며 <em>Array</em>의 주요 동작을 구현합니다.</p>
<p>클래스 생성자에서 프록시를 반환하는 것은 쉽지만 모든 인스턴스에 대해 새 프록시가 만들어 짐을 의미합니다. 그러나 모든 인스턴스가 하나의 프록시를 공유하는 방법이 있습니다. 프록시를 프로토 타입으로 사용할 수 있습니다.</p>
<h2 id="프로토-타입으로-프록시-사용"><a href="#프로토-타입으로-프록시-사용" class="headerlink" title="프로토 타입으로 프록시 사용"></a>프로토 타입으로 프록시 사용</h2><p>프록시는 프로토 타입으로 사용될 수 있지만, 이장의 앞의 예제보다 약간 복잡합니다. 프록시가 프로토 타입일 때, 프록시 Trap은 기본 동작이 정상적으로 프로토 타입에 계속될 때만 호출되며, 프록시의 기능을 프로토 타입으로 제한합니다. 다음 예제를 살펴 보겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> target = &#123;&#125;;</div><div class="line"><span class="keyword">let</span> newTarget = <span class="built_in">Object</span>.create(<span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</div><div class="line"></div><div class="line">    <span class="comment">// never called</span></div><div class="line">    defineProperty(trapTarget, name, descriptor) &#123;</div><div class="line"></div><div class="line">        <span class="comment">// would cause an error if called</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;));</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.defineProperty(newTarget, <span class="string">"name"</span>, &#123;</div><div class="line">    <span class="attr">value</span>: <span class="string">"newTarget"</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(newTarget.name);                    <span class="comment">// "newTarget"</span></div><div class="line"><span class="built_in">console</span>.log(newTarget.hasOwnProperty(<span class="string">"name"</span>));  <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p><code>newTarget</code> 객체는 프록시를 프로토 타입으로 하여 생성됩니다. <code>target</code>을 프록시 타겟으로 만들면 프록시가 투명하기 때문에 효과적으로 <code>target</code>을<code>newTarget</code>의 프로토 타입으로 만듭니다. 이제, 프록시 Trap은 <code>newTarget</code>에 대한 연산이 <code>target</code>에서 일어날 연산을 통과할 때만 호출됩니다.</p>
<p><code>Object.defineProperty()</code> 메서드는 <code>newTarget</code>에 호출되어 <code>name</code>이라는 자체 프로퍼티를 생성합니다. 객체상에 프로퍼티를 정의하는 것은 일반적으로 객체의 프로토 타입으로 계속되는 연산이 아니기 때문에 프록시상의 <code>defineProperty</code> Trap은 결코 호출되지 않고 <code>name</code> 프로퍼티는 자신의 프로퍼티로 <code>newTarget</code>에 추가됩니다.</p>
<p>프로토 타입으로 사용할 경우 프록시가 심각하게 제한되지만 여전히 유용한 몇가지 Trap이 있습니다.</p>
<h3 id="프로토-타입에서-get-Trap-사용하기"><a href="#프로토-타입에서-get-Trap-사용하기" class="headerlink" title="프로토 타입에서 get Trap 사용하기"></a>프로토 타입에서 get Trap 사용하기</h3><p>내부 <code>[[Get]]</code> 메서드가 호출되어 프로퍼티를 읽으면 연산은 먼저 자신의 프로퍼티를 찾습니다. 지정된 이름을 가진 자체 프로퍼티를 찾을 수 없는 경우 연산은 프로토 타입을 계속 진행하고 거기에서 프로퍼티를 찾습니다. 검사할 프로토 타입이 더이상 없을 때까지 프로세스가 계속됩니다.</p>
<p>이 프로세스 덕분에, <code>get</code> 프록시 Trap을 설정하면 주어진 이름의 자체 프로퍼티가 존재하지 않을 때마다 프로토 타입에서 Trap이 호출됩니다. <code>get</code> Trap을 사용하면 존재한다고 보장할 수 없는 프로퍼티에 액세스할 때 예기치 않은 동작을 방지할 수 있습니다. 단지 존재하지 않는 프로퍼티에 액세스하려고 할 때마다 오류가 발생하는 객체를 만들면 됩니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> target = &#123;&#125;;</div><div class="line"><span class="keyword">let</span> thing = <span class="built_in">Object</span>.create(<span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</div><div class="line">    get(trapTarget, key, receiver) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">ReferenceError</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span> doesn't exist`</span>);</div><div class="line">    &#125;</div><div class="line">&#125;));</div><div class="line"></div><div class="line">thing.name = <span class="string">"thing"</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(thing.name);        <span class="comment">// "thing"</span></div><div class="line"></div><div class="line"><span class="comment">// error 발생</span></div><div class="line"><span class="keyword">let</span> unknown = thing.unknown;</div></pre></td></tr></table></figure>
<p>이 코드에서, <code>thing</code> 객체는 프록시를 프로토 타입으로 하여 생성됩니다. <code>get</code> Trap은 주어진 키가 <code>thing</code> 객체에 존재하지 않은 호출에 대해 에러를 발생시킵니다. <code>thing.name</code>을 읽을 때, 프로퍼티가 <code>thing</code>에 존재하기 때문에 연산은 결코 프로토 타입에서 <code>get</code> Trap을 호출하지 않습니다. <code>get</code> Trap은 존재하지 않는 <code>thing.unknown</code> 프로퍼티에 접근할 때에만 호출됩니다.</p>
<p>마지막 줄이 실행될 때 <code>unknown</code>은 <code>thing</code>의 자체 속성이 아니므로 연산은 프로토 타입으로 계속됩니다. 그리고 <code>get</code> Trap은 오류를 던집니다. 이러한 유형의 동작은 JavaScript에서 매우 유용할 수 있습니다. JavaScript는 알려지지 않은 프로퍼티는 오류를 발생(다른 언어에서처럼)하는 대신 <code>undefined</code>를 자동으로 반환합니다.</p>
<p>이 예제에서 <code>trapTarget</code>과 <code>receiver</code>는 다른 객체라는 것을 이해하는 것이 중요합니다. 프록시가 프로토 타입으로 사용될 때, <code>trapTarget</code>은 프로토 타입 객체 자체이고 <code>receiver</code>는 인스턴스 객체입니다. 이 경우 <code>trapTarget</code>은 <code>target</code>과 같고 <code>receiver</code>는 <code>thing</code>과 같습니다. 이렇게하면 원래 프록시 대상과 작업을 수행할 대상에 모두 액세스할 수 있습니다.</p>
<h3 id="프로토-타입에서-set-Trap-사용하기"><a href="#프로토-타입에서-set-Trap-사용하기" class="headerlink" title="프로토 타입에서 set Trap 사용하기"></a>프로토 타입에서 set Trap 사용하기</h3><p>내부 <code>[[Set]]</code> 메서드는 자체 프로퍼티를 확인한 다음 필요에 따라 프로토 타입을 계속 진행합니다. 오브젝트 프로퍼티에 값을 할당하면, 같은 이름의 프로퍼티에 값이 할당됩니다. 지정된 이름의 프로퍼티가 없는 경우 연산은 프로토 타입으로 계속 진행됩니다. 까다로운 부분은 할당 작업이 프로토 타입으로 계속 되더라도 해당 프로퍼티에 값을 할당하면 해당 이름의 프로퍼티가 프로토 타입에 있는지 여부에 관계없이 기본적으로 프로토 타입이 아닌 인스턴스에 대한 프로퍼티가 만들어집니다.</p>
<p>프로토 타입에<code>set</code>Trap이 호출될 때와 그렇지 않을 때를 더 잘 이해하려면, 기본 동작을 보여주는 다음 예제를 살펴보십시오.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> target = &#123;&#125;;</div><div class="line"><span class="keyword">let</span> thing = <span class="built_in">Object</span>.create(<span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</div><div class="line">    set(trapTarget, key, value, receiver) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(trapTarget, key, value, receiver);</div><div class="line">    &#125;</div><div class="line">&#125;));</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(thing.hasOwnProperty(<span class="string">"name"</span>));      <span class="comment">// false</span></div><div class="line"></div><div class="line"><span class="comment">// triggers the `set` proxy trap</span></div><div class="line">thing.name = <span class="string">"thing"</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(thing.name);                        <span class="comment">// "thing"</span></div><div class="line"><span class="built_in">console</span>.log(thing.hasOwnProperty(<span class="string">"name"</span>));      <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="comment">// does not trigger the `set` proxy trap</span></div><div class="line">thing.name = <span class="string">"boo"</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(thing.name);                        <span class="comment">// "boo"</span></div></pre></td></tr></table></figure>
<p>이 예제에서, <code>target</code>은 자신의 프로퍼티가 없이 시작됩니다. <code>thing</code> 객체는 새로운 프로퍼티의 생성을 위한 <code>set</code> Trap을 정의하는 프록시를 프로토 타입으로 가지고 있습니다. <code>thing.name</code>에 값으로 <code>&quot;thing&quot;</code>이 지정되면 <code>thing</code>에 <code>name</code>이라는 자체 프로퍼티가 없으므로<code>set</code> 프록시 Trap이 호출됩니다. <code>set</code> Trap 내에서 <code>trapTarget</code>은 <code>target</code>과 같고 <code>receiver</code>는 <code>thing</code>과 같습니다. 연산은 궁극적으로 <code>thing</code>에 새로운 프로퍼티를 만들어야하며, 다행히 <code>Reflect.set()</code>는 네 번째 파라미터로 <code>receiver</code>를 전달하면 이 기본 동작을 구현합니다.</p>
<p><code>name</code> 프로퍼티가 <code>thing</code>에 생성되면 <code>thing.name</code>을 다른 값으로 설정해도 더이상 <code>set</code> 프록시 Trap을 호출하지 않습니다. 이 시점에서, <code>name</code>은 자체 프로퍼티이므로 <code>[[Set]]</code> 연산은 프로토 타입으로 계속되지 않습니다.</p>
<h3 id="프로토-타입에서-has-Trap-사용하기"><a href="#프로토-타입에서-has-Trap-사용하기" class="headerlink" title="프로토 타입에서 has Trap 사용하기"></a>프로토 타입에서 has Trap 사용하기</h3><p><code>has</code> Trap은 객체에서 <code>in</code> 연산자의 사용을 가로챈다는 것을 설명했습니다. <code>in</code> 연산자는 먼저 주어진 이름을 가진 객체 자신의 프로퍼티를 검색합니다. 이름이 같은 자체 프로퍼티가 없으면 연산이 프로토 타입으로 계속 진행됩니다. 프로토 타입에 자체 프로퍼티가 없으면 프로토<br> 타입을 찾거나 검색할 프로토 타입이 더 이상 없을 때까지 프로토 타입 체인을 통해 검색이 계속됩니다.</p>
<p>따라서 <code>has</code> Trap은 검색이 프로토 타입 체인에서 프록시 객체에 도달할 때만 호출됩니다. 프로토 타입으로 프록시를 사용하는 경우 지정된 이름의 자체 프로퍼티가 없을 때만 발생합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> target = &#123;&#125;;</div><div class="line"><span class="keyword">let</span> thing = <span class="built_in">Object</span>.create(<span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</div><div class="line">    has(trapTarget, key) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.has(trapTarget, key);</div><div class="line">    &#125;</div><div class="line">&#125;));</div><div class="line"></div><div class="line"><span class="comment">// triggers the `has` proxy trap</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> thing);                   <span class="comment">// false</span></div><div class="line"></div><div class="line">thing.name = <span class="string">"thing"</span>;</div><div class="line"></div><div class="line"><span class="comment">// does not trigger the `has` proxy trap</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> thing);                   <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>이 코드는 <code>thing</code> 프로토 타입에 <code>has</code> 프록시 Trap을 만듭니다. <code>has</code> Trap은 <code>in</code> 연산자가 사용될 때 프로토 타입을 자동으로 검색하기 때문에 <code>get</code> 및 <code>set</code> Trap처럼 <code>receiver</code> 객체를 통과하지 않습니다. 대신, <code>has</code> Trap은 <code>target</code>과 같은 <code>trapTarget</code>에서만 작동해야합니다. 이 예제에서 처음으로 <code>in</code> 연산자가 사용되면, 프로퍼티 이름이 <code>thing</code>의 자체 프로퍼티로 존재하지 않기 때문에 <code>has</code> Trap이 호출됩니다. <code>thing.name</code>에 값이 주어지고 <code>in</code> 연산자가 다시 사용될 때 <code>has</code>에 자신의 프로퍼티 <code>name</code>을 찾은 후에 연산이 멈추기 때문에 <code>has</code> Trap이 호출되지 않습니다.</p>
<p>이 시점의 프로토 타입 예제는 <code>Object.create()</code> 메서드를 사용하여 생성된 객체를 중심으로 이루어졌습니다. 그러나 프록시를 프로토 타입으로 사용하는 클래스를 만들려면 프로세스가 좀 더 복잡합니다.</p>
<h3 id="클래스의-프로토-타입으로서의-프록시"><a href="#클래스의-프로토-타입으로서의-프록시" class="headerlink" title="클래스의 프로토 타입으로서의 프록시"></a>클래스의 프로토 타입으로서의 프록시</h3><p>프로토 타입 프로퍼티가 non-writable이기 때문에 클래스를 프록시 <code>prototype</code>으로 사용하도록 직접 수정할 수 없습니다. 그러나 상속을 사용하여 프록시를 프로토 타입으로 사용하는 클래스를 약간  다르게 사용할 수 있습니다. 시작하려면 생성자 함수를 사용하여 ECMAScript 5 스타일 형식 정의를 만들어야합니다. 그런 다음 프로토 타입을 프록시로 덮어 쓸수 있습니다. 다음은 그 예제입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">NoSuchProperty</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// empty</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">NoSuchProperty.prototype = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</div><div class="line">    get(trapTarget, key, receiver) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">ReferenceError</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span> doesn't exist`</span>);</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">let</span> thing = <span class="keyword">new</span> NoSuchProperty();</div><div class="line"></div><div class="line"><span class="comment">// `get` 프록시 Trap으로 인해 오류가 발생합니다.</span></div><div class="line"><span class="keyword">let</span> result = thing.name;</div></pre></td></tr></table></figure>
<p><code>NoSuchProperty</code> 함수는 클래스가 상속하는 기반을 나타냅니다. 함수의 프로토 타입 프로퍼티에는 제한이 없으므로 프록시로 이를 덮어 쓸 수 있습니다. <code>get</code> Trap은 프로퍼티가 존재하지 않을 때 오류를 던지기 위해 사용됩니다. <code>thing</code> 객체는 <code>NoSuchProperty</code> 인스턴스로 생성되고 존재하지 않는 <code>name</code> 프로퍼티에 접근할 때 오류를 던집니다.</p>
<p>다음 단계는 <code>NoSuchProperty</code>를 상속받은 클래스를 만드는 것입니다. 9장에서 논의된 <code>extends</code> 문법을 사용하여 클래스 프로토 타입 체인에 프록시를 도입 할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">NoSuchProperty</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// empty</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">NoSuchProperty.prototype = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</div><div class="line">    get(trapTarget, key, receiver) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">ReferenceError</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span> doesn't exist`</span>);</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">NoSuchProperty</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(length, width) &#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">        <span class="keyword">this</span>.length = length;</div><div class="line">        <span class="keyword">this</span>.width = width;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> shape = <span class="keyword">new</span> Square(<span class="number">2</span>, <span class="number">6</span>);</div><div class="line"></div><div class="line"><span class="keyword">let</span> area1 = shape.length * shape.width;</div><div class="line"><span class="built_in">console</span>.log(area1);                         <span class="comment">// 12</span></div><div class="line"></div><div class="line"><span class="comment">// "wdth"가 존재하지 않기 때문에 에러가 발생합니다.</span></div><div class="line"><span class="keyword">let</span> area2 = shape.length * shape.wdth;</div></pre></td></tr></table></figure>
<p><code>Square</code> 클래스는 <code>NoSuchProperty</code>를 상속받습니다. 그래서 프록시는 <code>Square</code> 클래스의 프로토 타입 체인에 있습니다. <code>shape</code> 객체는<code>Square</code>의 새로운 인스턴스로 생성되고 <code>length</code>와 <code>width</code>라는 두개의 프로퍼티를 갖습니다. <code>get</code> 프록시 Trap이 결코 호출되지 않기 때문에 이들 프로퍼티의 값을 읽는 것은 성공합니다. <code>shape</code>에 존재하지 않는 프로퍼티(<code>shape.wdth</code>, 명백한 오타)에 접근할 때만 <code>get</code> 프록시 Trap 트리거가 발생하고 오류가 발생합니다.</p>
<p>이는 프록시가 <code>shape</code>의 프로토 타입 체인에 있음을 증명하지만 프록시가 <code>shape</code>의 직접 프로토 타입이 아니라는 점은 분명하지 않을 수 있습니다. 실제로, 프록시는 <code>shape</code>에서 프로토 타입 체인까지 두단계입니다. 앞의 예를 약간 변경하면 더 명확하게 알 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">NoSuchProperty</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// empty</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 프로토 타입이 될 프록시에 대한 참조를 저장</span></div><div class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</div><div class="line">    get(trapTarget, key, receiver) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">ReferenceError</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span> doesn't exist`</span>);</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">NoSuchProperty.prototype = proxy;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">NoSuchProperty</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(length, width) &#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">        <span class="keyword">this</span>.length = length;</div><div class="line">        <span class="keyword">this</span>.width = width;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> shape = <span class="keyword">new</span> Square(<span class="number">2</span>, <span class="number">6</span>);</div><div class="line"></div><div class="line"><span class="keyword">let</span> shapeProto = <span class="built_in">Object</span>.getPrototypeOf(shape);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(shapeProto === proxy);                  <span class="comment">// false</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> secondLevelProto = <span class="built_in">Object</span>.getPrototypeOf(shapeProto);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(secondLevelProto === proxy);            <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>이 버전의 코드는 프록시를 <code>proxy</code>라는 변수에 저장하므로 나중에 쉽게 식별할 수 있습니다. <code>shape</code>의 프로토 타입은 <code>Shape.prototype</code>이고 프록시가 아닙니다. 그러나 <code>Shape.prototype</code>의 프로토 타입은 <code>NoSuchProperty</code>에서 상속된 프록시입니다.</p>
<p>상속은 프로토 타입 체인에 또 다른 단계를 추가합니다. 프록시에 <code>get</code> Trap을 호출할 때 발생할 수 있는 작업으로 인해 하나의 추가 단계가 필요하기 때문에 중요합니다. <code>Shape.prototype</code>에 프로퍼티가 있으면 다음과 같이 <code>get</code> 프록시 Trap이 호출되지 않습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">NoSuchProperty</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// empty</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">NoSuchProperty.prototype = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</div><div class="line">    get(trapTarget, key, receiver) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">ReferenceError</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span> doesn't exist`</span>);</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">NoSuchProperty</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(length, width) &#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">        <span class="keyword">this</span>.length = length;</div><div class="line">        <span class="keyword">this</span>.width = width;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    getArea() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.length * <span class="keyword">this</span>.width;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> shape = <span class="keyword">new</span> Square(<span class="number">2</span>, <span class="number">6</span>);</div><div class="line"></div><div class="line"><span class="keyword">let</span> area1 = shape.length * shape.width;</div><div class="line"><span class="built_in">console</span>.log(area1);                         <span class="comment">// 12</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> area2 = shape.getArea();</div><div class="line"><span class="built_in">console</span>.log(area2);                         <span class="comment">// 12</span></div><div class="line"></div><div class="line"><span class="comment">// "wdth"가 존재하지 않기 때문에 에러가 발생됩니다.</span></div><div class="line"><span class="keyword">let</span> area3 = shape.length * shape.wdth;</div></pre></td></tr></table></figure>
<p>여기에서 <code>Square</code> 클래스는 <code>getArea()</code> 메서드를 가지고 있습니다. <code>getArea()</code> 메서드는 <code>Square.prototype</code>에 자동으로 추가되므로<br> <code>shape.getArea()</code>가 호출되면 <code>getArea()</code> 메서드에 대한 검색은 <code>shape</code> 인스턴스에서 시작한 후 프로토 타입으로 진행됩니다. 프로토 타입에 <code>getArea ()</code>가 있기 때문에 검색이 멈추고 프록시는 호출되지 않습니다. <code>getArea()</code>가 호출됐을때 오류를 잘못 던지는 것을 원하지 않기 때문에 실제로 이 상황에서 우리가 원하는 동작입니다.</p>
<p>프로토 타입 체인에 프록시가있는 클래스를 만드는 데 약간의 추가 코드가 필요하지만 이러한 기능이 필요한 경우에는 노력할 가치가 있습니다.</p>
<h2 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h2><p>ECMAScript 6 이전에는 특정 객체(예 : <em>Array</em>)가 개발자가 복제할 수없는 비표준 동작을 표현했습니다. 프록시가 그것을 바꿉니다. 프록시를 사용하면 여러 저수준 JavaScript 작업에 대한 비표준 동작을 정의할 수 있으므로 프록시 Trap을 통해 <em>Built-in</em> JavaScript 객체의 모든 동작을 가로챌 수 있습니다. 이러한 Trap은 <code>in</code> 연산자를 사용하는 것처럼 다양한 작업이 수행되는 뒤에서 호출됩니다.</p>
<p>개발자가 각 프록시 Trap에 대한 기본 동작을 구현할 수 있도록 ECMAScript 6에 리플렉션 API도 도입되었습니다. 각 프록시 Trap에는 <code>Reflect</code> 객체에 동일한 이름의 해당 메서드가 있으며 ECMAScript 6에 추가되었습니다. 프록시 Trap 및 리플렉션 API 메서드의 조합을 사용하면 일부 동작만 필터링하여 특정 조건에서만 다르게 동작하도록 할 수 있으며 <em>Built-in</em> 동작을 기본값으로 사용할 수 있습니다.</p>
<p>취소 가능한 프록시는 <code>revoke()</code> 함수를 사용하여 효과적으로 비활성화 할 수있는 특수 프록시입니다. <code>revoke()</code> 함수는 프록시의 모든 기능을 종료하므로 <code>revoke()</code>가 호출된 후 프록시의 프로퍼티와 상호 작용하려는 동작은 오류가 발생합니다. 취소 가능한 프록시는 Third-party 개발자가 지정된 시간 동안 특정 객체에 액세스해야하는 응용 프로그램의 보안에 중요합니다.</p>
<p>프록시를 직접 사용하는 것이 가장 강력한 유스 케이스이지만 프록시를 다른 객체의 프로토 타입으로 사용할 수도 있습니다. 이 경우 효과적으로 사용할 수 있는 프록시 Trap 수가 크게 제한됩니다. 프로토 타입으로 사용될 때 프록시에서 <code>get</code>, <code>set</code> 및 <code>has</code> 프록시 Trap만 호출되어 사용가능 사례를 훨씬 더 좁힙니다.</p>
<hr>
<blockquote>
<p>이 내용은 나중에 참고하기 위해 제가 공부하며 정리한 내용입니다.<br>의역, 오역, 직역이 있을 수 있음을 알려드립니다.<br>This post is a translation of this original article [<a href="https://leanpub.com/understandinges6/read#leanpub-auto-proxies-and-the-reflection-api" target="_blank" rel="external">https://leanpub.com/understandinges6/read#leanpub-auto-proxies-and-the-reflection-api</a>]</p>
</blockquote>
<h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul>
<li><a href="https://infoscis.github.io/2018/01/24/ecmascript-6-block-binding/">ECMAScript 6 Block Binding</a></li>
<li><a href="https://infoscis.github.io/2018/01/24/ecmascript-6-strings-and-regular-expressions/">ECMAScript 6 문자열과 정규 표현식</a></li>
<li><a href="https://infoscis.github.io/2018/01/24/ecmascript-6-functions/">ECMAScript 6 함수</a></li>
<li><a href="https://infoscis.github.io/2018/01/25/ecmascript-6-expanded-object-functionality/">ECMAScript 6 객체의 확장된 기능</a></li>
<li><a href="https://infoscis.github.io/2018/01/26/ecmascript-6-destructuring-for-easier-data-access/">ECMAScript 6 쉬운 데이터 액세스를 위한 Destructuring</a></li>
<li><a href="https://infoscis.github.io/2018/01/27/ecmascript-6-symbols-and-symbol-properties/">ECMAScript 6 Symbol과 Symbol 프로퍼티</a></li>
<li><a href="https://infoscis.github.io/2018/01/27/ecmascript-6-sets-and-maps/">ECMAScript 6 Set과 Map</a></li>
<li><a href="https://infoscis.github.io/2018/01/31/ecmascript-6-iterators-and-generators/">ECMAScript 6 Iterator와 Generator</a></li>
<li><a href="https://infoscis.github.io/2018/02/13/ecmascript-6-introducing-javascript-classes/">ECMAScript 6 JavaScript 클래스 소개</a></li>
<li><a href="https://infoscis.github.io/2018/02/13/ecmascript-6-improved-array-capabilities/">ECMAScript 6 Array 기능 향상</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-promises-and-asynchronous-programming/">ECMAScript 6 Promise와 비동기 프로그램밍</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-proxies-and-the-reflection-api/">ECMAScript 6 프록시와 리플렉션 API</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-encapsulating-code-with-modules/">ECMAScript 6 Module로 코드 캡슐화하기</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-appendix-a-smaller-changes/">ECMAScript 6 부록 A. 작은 변경 사항</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-appendix-b-understanding-ecmascript-7/">ECMAScript 6 부록 B. ECMAScript 7(2016) 이해하기</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ECMAScript-6-프록시와-리플렉션-API&quot;&gt;&lt;a href=&quot;#ECMAScript-6-프록시와-리플렉션-API&quot; class=&quot;headerlink&quot; title=&quot;ECMAScript 6 프록시와 리플렉션 API&quot;&gt;&lt;/a&gt;ECMAScri
    
    </summary>
    
      <category term="JavaScript" scheme="http://infoscis.github.io/categories/JavaScript/"/>
    
      <category term="ECMAScript 2015" scheme="http://infoscis.github.io/categories/JavaScript/ECMAScript-2015/"/>
    
    
      <category term="JavaScript" scheme="http://infoscis.github.io/tags/JavaScript/"/>
    
      <category term="ECMAScript 2015" scheme="http://infoscis.github.io/tags/ECMAScript-2015/"/>
    
  </entry>
  
  <entry>
    <title>ECMAScript 6 Promise와 비동기 프로그램밍</title>
    <link href="http://infoscis.github.io/2018/02/27/ecmascript-6-promises-and-asynchronous-programming/"/>
    <id>http://infoscis.github.io/2018/02/27/ecmascript-6-promises-and-asynchronous-programming/</id>
    <published>2018-02-27T13:30:33.000Z</published>
    <updated>2018-02-27T14:11:08.031Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ECMASCript-6-Promise와-비동기-프로그램밍"><a href="#ECMASCript-6-Promise와-비동기-프로그램밍" class="headerlink" title="ECMASCript 6 Promise와 비동기 프로그램밍"></a>ECMASCript 6 Promise와 비동기 프로그램밍</h1><p>JavaScript의 가장 강력한 부분중 하나는 비동기 프로그래밍을 쉽게 처리할 수 있다는 것입니다. 웹용으로 작성된 언어로서 JavaScript는 처음부터 클릭및 키누름과 같은 비동기 사용자 상호 작용에 응답할 수 있어야 했습니다. Node.js는 <em>Event</em> 대신에 <em>Callback</em>을 사용하여 JavaScript에서 비동기 프로그래밍을 대중화했습니다. 비동기 프로그래밍을 사용하는 프로그램이 점점 더 많아짐에 따라 <em>Event</em> 및 <em>Callback</em>은 더 이상 개발자가 원하는 모든 것을 지원할만큼 강력하지 않았습니다. <em>Promise</em>는 이러한 문제에 대한 해결책입니다.</p>
<p><em>Promise</em>는 비동기 프로그래밍의 또 다른 옵션이며 다른 언어의 <em>Future</em>와 <em>Deferred</em>와 같이 작동합니다. <em>Promise</em>는 나중에 (<em>Event</em> 및 <em>Callback</em>과 같이) 실행될 코드를 지정하고 작업에서 코드의 성공 또는 실패 여부를 명시적으로 나타냅니다. 코드를 이해하고 디버그하기 쉽게 만드는 방법으로 성공 또는 실패를 기반으로 <em>Promise</em>를 연결할 수 있습니다.</p>
<p><em>Promise</em>가 어떻게 작동하는지 잘 이해하려면 처음 생성되었을 때의 기본 개념을 이해하는 것이 매우 중요합니다.</p>
<h2 id="비동기-프로그래밍-배경"><a href="#비동기-프로그래밍-배경" class="headerlink" title="비동기 프로그래밍 배경"></a>비동기 프로그래밍 배경</h2><p>JavaScript 엔진은 단일 스레드 <em>Event Loop</em> 개념을 기반으로 합니다. 단일 스레드는 한번에 하나의 코드만 실행한다는 것을 의미합니다. 이것을 스레드가 여러 다른 코드를 동시에 실행할 수 있는 Java 또는 C++과 같은 언어와 비교됩니다. 여러 코드가 특정 <em>State</em>를 액세스하여 변경할 수 있을때 <em>State</em>를 유지 및 보호하는 것은 어려운 문제이며 스레드 기반 소프트웨어의 빈번한 버그의 원인이 됩니다.</p>
<p>JavaScript 엔진은 한번에 하나의 코드만 실행할 수 있으므로 실행할 코드를 추적할 수 있어야 합니다. 이 코드는 <em>Job Queue(작업 대기열)</em>에 보관됩니다. 코드 조각은 실행할 준비가되면 <em>Job Queue</em>에 추가됩니다. JavaScript 엔진이 코드 실행을 완료하면 <em>Event Loop</em>는 <em>Queue</em>의 다음 작업을 실행합니다. <em>Event Loop</em>는 코드 실행을 모니터링하고 <em>Job Queue</em>를 관리하는 JavaScript 엔진 내부의 프로세스입니다. <em>Queue</em>의 작업 실행은 <em>Queue</em>의 첫 번째 작업에서 마지막 작업까지 실행됩니다</p>
<h3 id="Event-모델"><a href="#Event-모델" class="headerlink" title="Event 모델"></a>Event 모델</h3><p>사용자가 버튼을 클릭하거나 키보드의 키를 누르면 <code>onclick</code>과 같은 <em>Event</em>가 발생됩니다. 이 <em>Event</em>는 <em>Job Queue</em> 뒤쪽에 새 작업을 추가하여 상호 작용에 응답할 수 있습니다. 이것이 JavaScript의 가장 기본적인 비동기 프로그래밍 형식입니다. <em>Event</em> 핸들러 코드는 <em>Event</em>가 발생할 때까지 실행되지 않으며 작업이 실행될 때 적절한 컨텍스트를 갖습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> button = <span class="built_in">document</span>.getElementById(<span class="string">"my-btn"</span>);</div><div class="line">button.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Clicked"</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>이 코드에서,<code>console.log(&quot;Clicked&quot;)</code>는 <code>button</code>이 클릭될 때까지 실행되지 않습니다. <code>button</code>을 클릭하면 <code>onclick</code>에 할당된 기능이 <em>Job Queue</em>의 뒤쪽에 추가되고 이전 모든 작업이 완료되면 실행됩니다.</p>
<p><em>Event</em>는 간단한 상호 작용에는 잘 작동하지만 여러 개의 개별 비동기 호출을 함께 연결해야 할때, 각 <em>Event</em>에 대한 <em>Event</em> 대상 (앞의 예제에서 <code>button</code>)을 추적해야하기 때문에 더 복잡합니다. 또한 <em>Event</em>가 처음 발생하기 전에 모든 적절한 <em>Event</em> 핸들러를 추가 해야합니다. 예를 들어 <code>onclick</code>이 지정되기 전에 <code>button</code>이 클릭되면 아무 일도 일어나지 않을 것입니다. <em>Event</em>가 사용자 상호 작용 및 이와 유사한 기능에 대한 응답에 유용하기는 하지만 보다 복잡한 요구에 대해서는 매우 유연하지 않습니다.</p>
<h3 id="Callback-패턴"><a href="#Callback-패턴" class="headerlink" title="Callback 패턴"></a>Callback 패턴</h3><p>Node.js가 만들어지고 <em>Callback</em> 패턴 프로프래밍이 대중화하여 비동기 프로그래밍 모델을 발전 시킬수 있었습니다. 비동기 코드는 나중 시점까지 실행되지 않기 때문에 <em>Callback</em> 패턴은 <em>Event</em> 모델과 유사합니다. <em>Callback</em> 패턴은 다음과 같이 호출할 함수가 파라미터로 전달되기 때문에 <em>Event</em> 모델과 다릅니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">readFile(<span class="string">"example.txt"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, contents</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (err) &#123;</div><div class="line">        <span class="keyword">throw</span> err;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">console</span>.log(contents);</div><div class="line">&#125;);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"Hi!"</span>);</div></pre></td></tr></table></figure>
<p>이 예제는 기존 Node.js <em>Error-first Callback</em> 스타일을 사용합니다. <code>readFile()</code> 함수는 디스크의 파일 (첫 번째 파라미터로 지정된 파일)을 읽은 다음 완료될 때 <em>Callback</em>(두 번째 파라미터)을 실행하기 위한것입니다. 오류가 있으면 콜백의 <code>err</code> 파라미터는 오류 객체입니다. 그렇지 않은 경우, <code>contents</code> 파라미터는 파일 내용을 문자열로 포함합니다.</p>
<p><em>Callback</em> 패턴을 사용하여 <code>readFile()</code>은 즉시 실행을 시작하고 디스크에서 읽기를 시작할 때 일시 중지합니다. 즉, <code>console.log(contents)</code>가 어떤 것도 출력하기 전 <code>readFile()</code>이 호출된 직후에 <code>console.log( &quot;Hi!&quot;)</code>가 출력됩니다. <code>readFile()</code>이 끝나면 <em>Callback</em> 함수와 파라미터는 <em>Job Queue</em>의 끝에 추가됩니다. 그리고 그 앞에있는 다른 모든 작업이 완료되면 실행됩니다.</p>
<p><em>Callback</em> 패턴은 <em>Event</em>보다 융통성이 있습니다. <em>Callback</em>을 통해 여러개의 호출을 함께 연결하는 것이 쉬워지기 때문입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">readFile(<span class="string">"example.txt"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, contents</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (err) &#123;</div><div class="line">        <span class="keyword">throw</span> err;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    writeFile(<span class="string">"example.txt"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (err) &#123;</div><div class="line">            <span class="keyword">throw</span> err;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"File was written!"</span>);</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>이 코드에서 <code>readFile()</code>을 성공적으로 호출하면 또 다른 비동기 호출이 발생하며 이번에는 <code>writeFile()</code> 함수를 호출합니다. <code>err</code>을 검사하는 것과 같은 기본 패턴이 두 함수 모두에 존재한다는 것에 유의하십시오. <code>readFile()</code>이 완료되면 호출되는 <em>Job Queue</em>에 <code>writeFile()</code>을 호출하는 작업을 추가합니다 (오류가 없다고 가정). 그런 다음 <code>writeFile()</code>이 끝날때 <em>Job Queue</em>에 작업을 추가합니다.</p>
<p>이 패턴은 꽤 잘 작동하지만 여러분은 바로 <em>Callback hell</em>에 빠졌다는 것을 알게됩니다. <em>Callback hell</em>은 다음과 같이 너무 많은 <em>Callback</em>을 중첩할 때 발생합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">method1(<span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (err) &#123;</div><div class="line">        <span class="keyword">throw</span> err;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    method2(<span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (err) &#123;</div><div class="line">            <span class="keyword">throw</span> err;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        method3(<span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (err) &#123;</div><div class="line">                <span class="keyword">throw</span> err;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            method4(<span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (err) &#123;</div><div class="line">                    <span class="keyword">throw</span> err;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                method5(result);</div><div class="line">            &#125;);</div><div class="line"></div><div class="line">        &#125;);</div><div class="line"></div><div class="line">    &#125;);</div><div class="line"></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>이 예제는 여러개의 메서드 호출을 중첩하여 복잡하고, 이해 및 디버그가 어려운 웹을 만듭니다. <em>Callback</em>은 복잡한 기능을 구현하려는 경우에도 문제가 발생합니다. 두 개의 비동기 작업을 병렬로 실행하고 두 비동기 작업이 모두 완료될 때 알려주려면 어떻게 해야할까요? 한번에 두개의 비동기 작업을 시작하고 첫 번째 작업의 결과만 가져 오려면 어떻게 해야할까요?</p>
<p>이러한 경우 여러 <em>Callback</em> 및 <em>Cleanup</em> 작업을 추적해야 합니다. <em>Promise</em>는 이러한 상황을 크게 향상시킬 수 있습니다.</p>
<h2 id="Promise-기본"><a href="#Promise-기본" class="headerlink" title="Promise 기본"></a>Promise 기본</h2><p>Promise는 비동기 연산의 결과를 위한 Placeholder입니다. <em>Event</em>를 구독하거나 함수에 <em>Callback</em>을 전달하는 대신 함수는 다음과 같이 <em>Promise</em>을 리턴할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// readFile은 미래의 어떤 시점에서 완료할 것을 약속합니다.</span></div><div class="line"><span class="keyword">let</span> promise = readFile(<span class="string">"example.txt"</span>);</div></pre></td></tr></table></figure>
<p>이 코드에서 <code>readFile()</code>은 실제로 파일 읽기를 즉시 시작하지 않습니다. 그것은 나중에 일어날 일입니다. 대신이 함수는 비동기 읽기 작업을 나타내는 <em>Promise</em> 객체를 리턴하므로 향후 이 작업을 수행할 수 있습니다. 그 결과로 정확하게 일할 수 있는 때는 전적으로 <em>Promise</em>의 <em>Lifecycle</em>이 어떻게 진행되는지에 달려 있습니다.</p>
<h3 id="Promise-수명주기"><a href="#Promise-수명주기" class="headerlink" title="Promise 수명주기"></a>Promise 수명주기</h3><p>각 <em>Promise</em>는 <em>Pending State</em>에서 시작하는 짧은 <em>Lifecycle</em>을 거치며 비동기 작업이 아직 완료되지 않았음을 나타냅니다. <em>Pending State</em>의 <em>Promise</em>는 <em>불안정(unsettled)</em>한 것으로 간주됩니다. 마지막 예제의 <em>Promise</em>는 <code>readFile()</code> 함수가 리턴하는 즉시 <em>Pending State</em>입니다. 비동기 작업이 완료되면 <em>Promise</em>가 <em>확정(settled)</em>된 것으로 간주되어 두가지 상태중 하나가 됩니다.</p>
<ol>
<li><em>Fulfilled(완료됨)</em> : <em>Promise</em>의 비동기 작업이 성공적으로 완료되었습니다.</li>
<li><em>Rejected(거절됨)</em> : <em>Promise</em>의 비동기 작업이 오류 또는 다른 원인으로 인해 성공적으로 완료되지 않았습니다.</li>
</ol>
<p><em>Promise State</em>를 반영하기 위해 내부 <code>[[PromiseState]]</code> 프로퍼티가 <code>&quot;pending&quot;</code>, <code>&quot;fulfilled&quot;</code> 또는 <code>&quot;rejected&quot;</code>로 설정됩니다. 이 프로퍼티는 <em>Promise</em> 개체에 노출되지 않으므로 프로그래밍 방식으로 <em>Promise State</em>를 확인할 수 없습니다. 그러나 `then() 메서드를 사용하여 <em>Promise</em>의 <em>State</em>가 바꿀때 특정 동작을 취할 수 있습니다.</p>
<p><code>then()</code> 메서드는 모든 <em>Promise</em>에 존재하며 두개의 파라미터를 받습니다. 첫 번째 파라미터는 <em>Promise</em>가 수행될 때 호출할 함수입니다. 비동기 작업과 관련된 추가 데이터가 이 처리 함수에 전달됩니다. 두 번째 파라미터는 <em>Promise</em>가 거부될 때 호출할 함수입니다. 수행 기능과 마찬가지로 거부 기능에는 거부와 관련된 추가 데이터가 전달됩니다.</p>
<blockquote>
<p>이런 식으로 <code>then()</code> 메서드를 구현하는 객체를 모두 <em>Thenable</em>이라고 합니다. 모든 <em>Promise</em>는 <em>Thenable</em>이지만, 모든 <em>Thenable</em>이 <em>Promise</em>인 것은 아닙니다.</p>
</blockquote>
<p><code>then()</code>에 대한 두 파라미터는 모두 선택 사항이므로 수행 및 거부의 조합을 만들수 있습니다. 예를 들어, 다음의 <code>then()</code> 호출 집합을 보겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> promise = readFile(<span class="string">"example.txt"</span>);</div><div class="line"></div><div class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">contents</span>) </span>&#123;</div><div class="line">    <span class="comment">// fulfillment</span></div><div class="line">    <span class="built_in">console</span>.log(contents);</div><div class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</div><div class="line">    <span class="comment">// rejection</span></div><div class="line">    <span class="built_in">console</span>.error(err.message);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">contents</span>) </span>&#123;</div><div class="line">    <span class="comment">// fulfillment</span></div><div class="line">    <span class="built_in">console</span>.log(contents);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">promise.then(<span class="literal">null</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</div><div class="line">    <span class="comment">// rejection</span></div><div class="line">    <span class="built_in">console</span>.error(err.message);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>세번 모두 <code>then()</code> 호출은 같은 <em>Promise</em>에 작동합니다. 첫 번째 호출은 수행과 거절을 모두 받습니다. 두 번째는 수행만 받고 오류는 보고되지 않습니다. 세 번째는 거절을 받고 수행을 보고하지 않습니다.</p>
<p>또한 <em>Promise</em>는 거절 처리만 전달할 때 <code>then()</code>과 동일한 동작을하는 <code>catch()</code> 메서드가 있습니다. 예를 들어 다음과 같은 <code>catch()</code> 및 <code>then()</code> 호출은 기능적으로 동일합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">promise.catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</div><div class="line">    <span class="comment">// rejection</span></div><div class="line">    <span class="built_in">console</span>.error(err.message);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// is the same as:</span></div><div class="line"></div><div class="line">promise.then(<span class="literal">null</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</div><div class="line">    <span class="comment">// rejection</span></div><div class="line">    <span class="built_in">console</span>.error(err.message);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><code>then()</code>과 <code>catch()</code>의 목적은 비동기 작업의 결과를 적절하게 처리하기 위해 이들을 조합하여 사용하는 것입니다. 이 시스템은 작업이 성공했는지 또는 실패했는지를 확인하기 때문에 <em>Event</em>와 <em>Callback</em>보다 낫습니다. (<em>Event</em>는 오류가있을 때 실행되지 않는 경향이 있고 <em>Callback</em>은 오류 파라미터를 항상 확인해야합니다.) <em>Promise</em>에 거절를 추가하지 않으면 모든 실패가 조용히 발생합니다. 핸들러가 단지 실패만을 기록하는 경우라도 항상 거절 처리가 필요합니다.</p>
<p>수행 또는 거절 핸들러는 <em>Promise</em>가 이미 완료된 후에 <em>Job Queue</em>에 추가 되더라도 여전히 실행됩니다. 이를 통해 언제든지 새로운 수행 처리 및 거절 처리를 추가하고 호출을 보장 할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> promise = readFile(<span class="string">"example.txt"</span>);</div><div class="line"></div><div class="line"><span class="comment">// 원래의 수행 처리</span></div><div class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">contents</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(contents);</div><div class="line"></div><div class="line">    <span class="comment">// 새로운 처리를 추가</span></div><div class="line">    promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">contents</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(contents);</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>이 코드에서, 수행 핸들러는 동일한 수행 <em>Promise</em>에 또 다른 수행 핸들러를 추가합니다. <em>Promise</em>는 이 시점에서 이미 완료되었으므로 새 수행 핸들러가 작업 대기열에 추가되고 준비가되면 호출됩니다. 거절 핸들러도 같은 방식으로 작동합니다.</p>
<p><code>then()</code> 또는 <code>catch()</code>를 호출할 때마다 <em>Promise</em>가 해결될 때 실행될 새 <em>Job</em>이 만들어집니다. 그러나 이러한 <em>Job</em>은 <em>Promise</em>을 위해 엄격하게 예약된 별도의 <em>Job Queue</em>에서 끝납니다. 이 두 번째 <em>Job Queue</em>의 정확한 세부 사항은 일반적인 <em>Job Queue</em>가 작동하는 방식을 이해하는 정도면 됩니다. 이 사항은 <em>Promise</em> 사용 방법을 이해하는 데 중요하지 않습니다.</p>
<h3 id="Unsettled-불확실한-Promise-생성하기"><a href="#Unsettled-불확실한-Promise-생성하기" class="headerlink" title="Unsettled(불확실한) Promise 생성하기"></a><em>Unsettled(불확실한) Promise</em> 생성하기</h3><p>새로운 <em>Promise</em>는 <code>Promise</code> 생성자를 사용하여 생성됩니다. 이 생성자는 <em>Promise</em>를 초기화하는 코드를 포함하는 Executor라는 함수를 파라미터로 받아들입니다. Executor에는 <code>resolve()</code> 및 <code>reject()</code>라는 두개의 함수가 파라미터로 전달됩니다. <code>resolve()</code> 함수는 Executor가 성공적으로 완료되면 <em>Promise</em>가 해결될 준비가되었음을 알리기 위해 호출되고 <code>reject()</code> 함수는 Executor가 실패했음을 나타냅니다.</p>
<p>이 장의 앞 부분에서 보여주었던 <code>readFile()</code> 함수를 Node.js의 <em>Promise</em>을 사용하여 구현하는 예제를 살펴 보겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Node.js example</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">filename</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">// 비동기 동작 트리거</span></div><div class="line">        fs.readFile(filename, &#123; <span class="attr">encoding</span>: <span class="string">"utf8"</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err, contents</span>) </span>&#123;</div><div class="line"></div><div class="line">            <span class="comment">// check for errors</span></div><div class="line">            <span class="keyword">if</span> (err) &#123;</div><div class="line">                reject(err);</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// the read succeeded</span></div><div class="line">            resolve(contents);</div><div class="line"></div><div class="line">        &#125;);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> promise = readFile(<span class="string">"example.txt"</span>);</div><div class="line"></div><div class="line"><span class="comment">// 수행과 거절 모두를 처리한다.</span></div><div class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">contents</span>) </span>&#123;</div><div class="line">    <span class="comment">// 수행</span></div><div class="line">    <span class="built_in">console</span>.log(contents);</div><div class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</div><div class="line">    <span class="comment">// 거절</span></div><div class="line">    <span class="built_in">console</span>.error(err.message);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>이 예제는 Node.js의 기본 <code>fs.readFile()</code> 비동기 호출이 <em>Promise</em>로 래핑됩니다. Executor는 error 오브젝트를 <code>reject()</code> 함수에 전달하거나 파일 내용을 <code>resolve()</code> 함수에 전달합니다.</p>
<p><code>readFile()</code>이 호출되면 Executor가 즉시 실행된다는 점에 유의하십시오. Executor <code>resolve()</code> 또는 <code>reject()</code>가 호출되면 <em>Promise</em>을 해결하기 위해 작업이 <em>Job Queue</em>에 추가됩니다. 이를 <em>Job Scheduling</em>이라고하며, <code>setTimeout()</code> 또는 <code>setInterval()</code> 함수를 사용한 적이 있다면 이미 익숙한 것입니다. <em>Job Scheduling</em>에서 새로운 작업을 <em>Job Queue</em>에 추가하여 “지금 당장 실행하지 말고 나중에 실행하십시오.”라고 말합니다. 예를 들어 <code>setTimeout()</code> 함수를 사용하면 작업이 대기열에 추가되기 전에 지연을 지정할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 500ms가 지난 후에 이 함수를 작업 대기열에 추가하십시오.</span></div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Timeout"</span>);</div><div class="line">&#125;, <span class="number">500</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"Hi!"</span>);</div></pre></td></tr></table></figure>
<p>이 코드는 500ms 후에 <em>Job Queue</em>에 추가될 작업을 예약합니다. 두개의 <code>console.log()</code> 호출은 다음과 같은 내용을 출력합니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Hi!</div><div class="line">Timeout</div></pre></td></tr></table></figure>
<p>500ms 지연 덕분에 <code>console.log( &quot;Hi!&quot;)</code> 호출의 출력 후에 <code>setTimeout()</code>에 전달된 함수가 표시되었습니다.</p>
<p><em>Promise</em>도 비슷하게 작동합니다. <em>Promise</em> Executor는 소스 코드에서 그 이후에 나타나는 것보다 먼저 실행됩니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Promise"</span>);</div><div class="line">    resolve();</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"Hi!"</span>);</div></pre></td></tr></table></figure>
<p>이 코드의 출력은 다음과 같습니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Promise</div><div class="line">Hi!</div></pre></td></tr></table></figure>
<p><code>resolve()</code>를 호출하면 비동기 작업이 트리거됩니다. <code>then()</code> 및 <code>catch()</code>에 전달된 함수는 비동기적으로 실행됩니다. 이러한 함수도 <em>Job Queue</em>에 추가됩니다. 다음은 그 예입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Promise"</span>);</div><div class="line">    resolve();</div><div class="line">&#125;);</div><div class="line"></div><div class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Resolved."</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"Hi!"</span>)</div></pre></td></tr></table></figure>
<p>이 예제의 결과는 다음과 같습니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Promise</div><div class="line">Hi!</div><div class="line">Resolved</div></pre></td></tr></table></figure>
<p><code>then()</code>에 대한 호출이 <code>console.log( &quot;Hi!&quot;)</code> 행 앞에 나타나더라도 실제로 먼저(Executor와 달리) 실행되지는 않습니다. 이는 Executor가 완료된 후 수행 및 거절 핸들러가 <em>Job Queue</em>의 끝에 추가되기 때문입니다.</p>
<h3 id="Settled-확정된-Promise-생성하기"><a href="#Settled-확정된-Promise-생성하기" class="headerlink" title="Settled(확정된) Promise 생성하기"></a>Settled(확정된) Promise 생성하기</h3><p><code>Promise</code> 생성자는 <em>Promise</em> Executor의 역동적인 특성 때문에 불확실한 <em>Promise</em>를 만드는 가장 좋은 방법입니다. 그러나 알려진 단일 값을 나타내는 <em>Promise</em>를 원한다면 <code>resolve()</code> 함수에 값을 전달하는 <em>Job</em>을 스케쥴하는 것은 의미가 없습니다. 대신, 구체적인 가치를 부여한 Settled <em>Promise</em>를 만드는 두가지 방법이 있습니다.</p>
<h4 id="Promise-resolve-사용하기"><a href="#Promise-resolve-사용하기" class="headerlink" title="Promise.resolve() 사용하기"></a>Promise.resolve() 사용하기</h4><p><code>Promise.resolve()</code> 메서드는 단일 파라미터를 받아들이고 <em>Fulfilled State</em>의 <em>Promise</em>를 리턴합니다. 이는 <em>Job Scheduling</em>이 발생하지 않으며, 값을 검색하기 위한 <em>Promise</em>에 하나 이상의 수행 핸들러를 추가해야 함을 의미합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> promise = <span class="built_in">Promise</span>.resolve(<span class="number">42</span>);</div><div class="line"></div><div class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(value);         <span class="comment">// 42</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>이 코드는 수행 핸들러가 <code>value</code>로 42를 설정 하도록 수행 <em>Promise</em>를 작성합니다. 이 <em>Promise</em>는 절대 <em>Rejected State</em>가 되지 않기<br> 때문에 거절 핸들러가 추가되어도 호출되지 않습니다.</p>
<h4 id="Promise-reject-사용하기"><a href="#Promise-reject-사용하기" class="headerlink" title="Promise.reject() 사용하기"></a>Promise.reject() 사용하기</h4><p><code>Promise.reject()</code> 메서드를 사용하여 거절된 <em>Promise</em>를 만들수도 있습니다. <code>Promise.resolve()</code>와 같이 작동합니다. 단, 생성된 <em>Promise</em>는 다음과 같이 <em>Rejected State</em>입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> promise = <span class="built_in">Promise</span>.reject(<span class="number">42</span>);</div><div class="line"></div><div class="line">promise.catch(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(value);         <span class="comment">// 42</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>이 <em>Promise</em>에 추가된 모든 거절 핸들러는 호출되지만 수행 핸들러는 호출되지 않습니다.</p>
<blockquote>
<p><em>Promise</em>를 <code>Promise.resolve()</code> 또는 <code>Promise.reject()</code> 메서드에 전달하면 변경 내용없이 <em>Promise</em>가 리턴됩니다.</p>
</blockquote>
<h4 id="Promise가-아닌-Thenable"><a href="#Promise가-아닌-Thenable" class="headerlink" title="Promise가 아닌 Thenable"></a>Promise가 아닌 Thenable</h4><p><code>Promise.resolve()</code> 및 <code>Promise.reject()</code>는 Non-promise Thenable을 파라미터로 받을수 있습니다. Non-promise Thenable을 전달하면 이 메서드는 <code>then()</code> 함수 다음에 호출되는 새로운 <em>Promise</em>를 만듭니다.</p>
<p>Non-promise Thenable은 객체가 다음과 같이 <code>resolve</code>와 <code>reject</code> 파라미터를 받아들이는 <code>then()</code> 메서드를 가질 때 생성됩니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> thenable = &#123;</div><div class="line">    <span class="attr">then</span>: <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">        resolve(<span class="number">42</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>이 예제에서 <code>thenable</code> 객체는 <code>then()</code> 메서드 이외의 <em>Promise</em>와 관련된 특징이 없습니다. 여러분은 <code>Promise.resolve()</code>를 호출하여 다음과 같이 <code>thenable</code>을 수행된 <em>Promise</em>로 변환할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> thenable = &#123;</div><div class="line">    <span class="attr">then</span>: <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">        resolve(<span class="number">42</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(thenable);</div><div class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(value);     <span class="comment">// 42</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>이 예에서, <code>Promise.resolve()</code>는 <em>Promise</em> State를 결정할 수 있도록 <code>thenable.then()</code>을 호출합니다. <code>then()</code>메서드 내에서 <code>resolve(42)</code>가 호출되기 때문에 <code>thenable</code>에 대한 <em>Promise</em> State가 <em>Fulfilled</em>입니다. 새로운 <code>p1</code> <em>Promise</em>는 <code>thenable</code>(즉, 42)에서 전달된 값으로 <em>Fulfilled state</em>에서 생성되고 <code>p1</code>의 수행 핸들러는 값으로 42를 받습니다.</p>
<p>같은 프로세스를 <code>Promise.resolve()</code>와 함께 사용하여 다음과 같은 <em>Promise</em>을 거절할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> thenable = &#123;</div><div class="line">    <span class="attr">then</span>: <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">        reject(<span class="number">42</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(thenable);</div><div class="line">p1.catch(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(value);     <span class="comment">// 42</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>이 예제는 <code>thenable</code>이 거부된다는 것을 제외하고는 이전 예제와 유사합니다. <code>thenable.then()</code>이 실행되면, 값이 42 인 <em>Rejected State</em>에서 새로운 <em>Promise</em>가 생성됩니다. 그 값은 <code>p1</code>의 거절 처리기로 전달됩니다.</p>
<p><code>Promise.resolve()</code> 및 <code>Promise.reject()</code>는 이와 같이 동작하여 Non-promise Thenable에 대해 쉽게 작업할 수 있도록 합니다. 많은 라이브러리는 <em>Promise</em>가 ECMAScript 6에 도입되기 전에 <em>Promise</em>을 구현하기 위해 Thenable을 사용 했으므로, Thenable을 공식 <em>Promise</em>로 변환할 수 있는 이 기능은 기존 라이브러리와의 하위 호환성을 위해 중요합니다. 오브젝트가 <em>Promise</em>인지 확신 할 수 없을 때 <em>Promise</em>가 변경되지 않고 통과하기 하는 <code>Promise.resolve()</code> 또는 <code>Promise.reject()</code>(예상 결과에 따라 다름)를 통해 오브젝트를 전달하는 것이 가장 좋은 방법입니다.</p>
<h3 id="Executor-오류"><a href="#Executor-오류" class="headerlink" title="Executor 오류"></a>Executor 오류</h3><p>Executor 내에서 오류가 발생하면 <em>Promise</em>의 거절 핸들러가 호출됩니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Explosion!"</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">promise.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(error.message);     <span class="comment">// "Explosion!"</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>이 코드에서, Executor는 의도적으로 오류를 던집니다. 모든 Executor 내부에는 암묵적인 <code>try-catch</code>가 있어 오류가 포착된 다음 거절 처리기로 전달됩니다. 이전 예는 다음과 같습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Explosion!"</span>);</div><div class="line">    &#125; <span class="keyword">catch</span> (ex) &#123;</div><div class="line">        reject(ex);</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">promise.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(error.message);     <span class="comment">// "Explosion!"</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>Executor는 던져진 오류를 잡아서 이러한 일반적인 유스 케이스를 간소화하고, Executor에서 발생한 오류는 거절 처리기가 있을때만 보고됩니다. 그렇지 않으면 오류가 표시되지 않습니다. 이것은 개발자가 <em>Promise</em>를 사용하는 초기 단계에서 문제가되었고, JavaScript environment는 거절된 <em>Promise</em>를 잡아 내기 위해 Hook을 제공함으로써 문제를 해결합니다.</p>
<h2 id="Global-Promise-거절-처리"><a href="#Global-Promise-거절-처리" class="headerlink" title="Global Promise 거절 처리"></a>Global Promise 거절 처리</h2><p><em>Promise</em>의 가장 논란이되는 측면중 하나는 거절 핸들러 없이 <em>Promise</em>가 거절될 때 발생하는 침묵의 실패입니다. 어떤 이들은 JavaScript 언어에서 오류를 명백히 드러내지 않는 유일한 부분이기 때문에 이것이 사양의 가장 큰 결함이라고 생각하는 사람도 있습니다.</p>
<p><em>Promise</em> 거절이 처리되었는지 여부를 결정하는 것은 <em>Promise</em>의 본질 때문에 간단하지 않습니다. 예를 들어 다음 예제를 살펴보겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> rejected = <span class="built_in">Promise</span>.reject(<span class="number">42</span>);</div><div class="line"></div><div class="line"><span class="comment">// 이 시점에서 거절은 처리되지 않습니다.</span></div><div class="line"></div><div class="line"><span class="comment">// 잠시 후...</span></div><div class="line">rejected.catch(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="comment">// 이제 거절을 처리합니다.</span></div><div class="line">    <span class="built_in">console</span>.log(value);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>어떤 시점에서 <code>then()</code> 또는 <code>catch()</code>를 호출하여 <em>Promise</em>가 확정(settled) 되었는지 여부에 관계없이 올바르게 작동하게 함으로써 <em>Promise</em>를 처리할 때를 정확하게 알기가 어렵습니다. 이 경우 <em>Promise</em>는 즉시 거절되지만 나중에 처리될 때까지 처리되지 않습니다.</p>
<p>ECMAScript의 다음 버전이 이 문제를 해결할 가능성은 있지만, 브라우저와 Node.js는 이 문제점을 해결하기 위해 변경 사항을 구현했습니다. 이는 ECMAScript 6 사양의 일부는 아니지만 <em>Promise</em>를 사용할 때 유용한 도구가 됩니다.</p>
<h3 id="Node-js의-거절-핸들링"><a href="#Node-js의-거절-핸들링" class="headerlink" title="Node.js의 거절 핸들링"></a>Node.js의 거절 핸들링</h3><p>Node.js에는 <em>Promise</em> 거절 핸들링과 관련된 <code>process</code> 객체에 두개의 <em>Event</em>가 있습니다.</p>
<ul>
<li><code>unhandledRejection</code> : <em>Promise</em>가 거절되고 한회의 <em>Event Loop</em>에서 거절 핸들러가 호출되지 않은 경우에 발생합니다.</li>
<li><code>rejectionHandled</code> : <em>Promise</em>가 거절되고 한회의 <em>Event Loop</em> 후 거절 핸들러가 호출되면 발생합니다.</li>
</ul>
<p>이러한 <em>Event</em>는 거절되고 처리되지 않는 <em>Promise</em>를 식별하는데 도움이되도록 설계되었습니다.</p>
<p><code>unhandledRejection</code> <em>Event</em> 핸들러는 거절 이유 (흔히 오류 객체)와 파라미터로 거절된 <em>Promise</em>가 전달됩니다. 다음 코드는 실행중인 <code>unhandledRejection</code>을 보여줍니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> rejected;</div><div class="line"></div><div class="line">process.on(<span class="string">"unhandledRejection"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">reason, promise</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(reason.message);            <span class="comment">// "Explosion!"</span></div><div class="line">    <span class="built_in">console</span>.log(rejected === promise);      <span class="comment">// true</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line">rejected = <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Explosion!"</span>));</div></pre></td></tr></table></figure>
<p>이 예에서 오류 객체와 함께 거절된 <em>Promise</em>를 만들고 <code>unhandledRejection</code> <em>Event</em>를 수신합니다. <em>Event</em> 핸들러는 첫 번째 파라미터로 오류 객체를 받고 두 번째 파라미터로 <em>Promise</em>를 받습니다.</p>
<p><code>rejectionHandled</code> <em>Event</em> 핸들러에는 거절된 <em>Promise</em>인 하나의 파라미터만 받습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> rejected;</div><div class="line"></div><div class="line">process.on(<span class="string">"rejectionHandled"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">promise</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(rejected === promise);              <span class="comment">// true</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line">rejected = <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Explosion!"</span>));</div><div class="line"></div><div class="line"><span class="comment">// 거절 핸들러를 추가 할 때까지 기다립니다.</span></div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    rejected.catch(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(value.message);     <span class="comment">// "Explosion!"</span></div><div class="line">    &#125;);</div><div class="line">&#125;, <span class="number">1000</span>);</div></pre></td></tr></table></figure>
<p>여기서 <code>rejectionHandled</code> <em>Event</em>는 거절 핸들러가 최종적으로 호출될 때 생성됩니다. 거절 핸들러가 <code>rejected</code>가 생성된 후<br> <code>rejected</code>에 바로 첨부된 경우 <em>Event</em>가 발생하지 않습니다. 거절 핸들러가 <code>rejected</code>를 생성한 동일한 <em>Event Loop</em>에서<br> 호출 되는 것은 유용하지 않습니다.</p>
<p>잠재적으로 처리되지 않은 거절을 올바르게 추적하려면 <code>rejectionHandled</code> 및 <code>unhandledRejection</code> <em>Event</em>를 사용하여 처리되지 않은 거절 가능성이 있는 목록을 유지합니다.그리고 일정 기간 동안 목록을 검사합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> possiblyUnhandledRejections = <span class="keyword">new</span> <span class="built_in">Map</span>();</div><div class="line"></div><div class="line"><span class="comment">// 거절이 처리되지 않으면 Map에 추가합니다.</span></div><div class="line">process.on(<span class="string">"unhandledRejection"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">reason, promise</span>) </span>&#123;</div><div class="line">    possiblyUnhandledRejections.set(promise, reason);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">process.on(<span class="string">"rejectionHandled"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">promise</span>) </span>&#123;</div><div class="line">    possiblyUnhandledRejections.delete(promise);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">    possiblyUnhandledRejections.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">reason, promise</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(reason.message ? reason.message : reason);</div><div class="line"></div><div class="line">        <span class="comment">// 이 거절을 처리하기 위해 뭔가를 합니다.</span></div><div class="line">        handleRejection(promise, reason);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    possiblyUnhandledRejections.clear();</div><div class="line"></div><div class="line">&#125;, <span class="number">60000</span>);</div></pre></td></tr></table></figure>
<p>이코드는 처리되지 않는 거절을 추적하는 간단한 추적기입니다. 코드에서 <em>Map</em>을 사용하여 <em>Promise</em>와 거절 사유를 저장합니다. 각 <em>Promise</em>는 키이며, <em>Promise</em>의 이유는 연관된 값입니다. <code>unhandledRejection</code>이 발생할 때마다 <em>Promise</em>와 거절 이유가 <em>Map</em>에 추가됩니다. 그리고 <code>rejectionHandled</code>가 발생될 때마다 처리된 <em>Promise</em>가 <em>Map</em>에서 제거됩니다. 따라서 <em>Event</em>가 호출될 때 <code>possibleUnhandledRejections</code>가 커지고 축소됩니다. <code>setInterval()</code> 호출은 처리되지 않은 거절 목록을 주기적으로 검사하여 정보를 console에 출력합니다.(실제로는 로그를 남기거나 다른 방식으로 거절을 처리하기 위해 뭔가 다른 작업을 수행하려고합니다). 이 예제에서<br> <em>Weak Map</em>대신 <em>Map</em>을 사용합니다. <em>Map</em>을 주기적으로 검사하여 어떤 <em>Promise</em>가 있는지 확인해야 하지만 <em>Weak Map</em>은 가능하지 않습니다.</p>
<p>이 예제는 Node.js에만 해당 하고, 브라우저도 처리되지 않은 거절에 대해 개발자에게 알리는 비슷한 메커니즘을 구현했습니다.</p>
<h3 id="브라우저의-거절-핸들러"><a href="#브라우저의-거절-핸들러" class="headerlink" title="브라우저의 거절 핸들러"></a>브라우저의 거절 핸들러</h3><p>브라우저는 처리되지 않은 거절을 식별하는데 도움이되는 두가지 <em>Event</em>를 발생 시킵니다. 이러한 <em>Event</em>는 <code>window</code> 객체에 의해 발생되고 Node.js와 동일합니다.</p>
<ul>
<li><code>unhandledrejection</code> : <em>Promise</em>가 거절되고 한회의 <em>Event Loop</em>에서 거절 핸들러가 호출되지 않은 경우에 발생합니다.</li>
<li><code>rejectionhandled</code> : <em>Promise</em>가 거절되고 한회의 <em>Event Loop</em>가 실행된 후 거절 핸들러가 호출되면 발생합니다.</li>
</ul>
<p>Node.js의 구현은 개별 파라미터를 <em>Event</em> 핸들러에 전달하는 하지만, 브라우저의 <em>Event</em> 핸들러는 다음과 같은 프로퍼티를 갖는 <em>Event</em> 객체를 받습니다.</p>
<ul>
<li><code>type</code> : 이벤트 이름 ( <code>&quot;unhandledrejection&quot;</code> 또는 <code>&quot;rejectionhandled&quot;</code>).</li>
<li><code>promise</code> : 거절된 <em>Promise</em> 객체.</li>
<li><code>reason</code> : <em>Promise</em>의 거절된 값</li>
</ul>
<p>브라우저 구현의 다른점은 두 <em>Event</em> 모두에서 거절값(<code>reason</code>)을 사용할 수 있다는 것입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> rejected;</div><div class="line"></div><div class="line"><span class="built_in">window</span>.onunhandledrejection = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(event.type);                    <span class="comment">// "unhandledrejection"</span></div><div class="line">    <span class="built_in">console</span>.log(event.reason.message);          <span class="comment">// "Explosion!"</span></div><div class="line">    <span class="built_in">console</span>.log(rejected === event.promise);    <span class="comment">// true</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">window</span>.onrejectionhandled = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(event.type);                    <span class="comment">// "rejectionhandled"</span></div><div class="line">    <span class="built_in">console</span>.log(event.reason.message);          <span class="comment">// "Explosion!"</span></div><div class="line">    <span class="built_in">console</span>.log(rejected === event.promise);    <span class="comment">// true</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line">rejected = <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Explosion!"</span>));</div></pre></td></tr></table></figure>
<p>이 코드는 <code>onunhandledrejection</code> 및 <code>onrejectionhandled</code>의 DOM Level 0 표현식을 사용하여 두 <em>Event</em> 핸들러를 할당합니다. 원하는 경우 <code>addEventListener( &quot;unhandledrejection&quot;)</code> 및 <code>addEventListener(&quot;rejectionhandled&quot;)</code>를 사용할 수도 있습니다. 각 <em>Event</em> 핸들러는 거절된 <em>Promise</em>에 대한 정보를 포함하는 <em>Event</em> 객체를 받습니다. <code>type</code>, <code>promise</code> 및 <code>reason</code> 프로퍼티는 모두 두 <em>Event</em> 핸들러에서 사용할 수 있습니다.</p>
<p>브라우저에서 처리되지 않은 거절을 추적하는 코드는 Node.js 코드와 매우 유사합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> possiblyUnhandledRejections = <span class="keyword">new</span> <span class="built_in">Map</span>();</div><div class="line"></div><div class="line"><span class="comment">// 거절이 처리되지 않으면 Map에 추가합니다.</span></div><div class="line"><span class="built_in">window</span>.onunhandledrejection = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">    possiblyUnhandledRejections.set(event.promise, event.reason);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">window</span>.onrejectionhandled = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">    possiblyUnhandledRejections.delete(event.promise);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">    possiblyUnhandledRejections.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">reason, promise</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(reason.message ? reason.message : reason);</div><div class="line"></div><div class="line">        <span class="comment">// 이 거절을 처리하기 위해 뭔가를 합니다.</span></div><div class="line">        handleRejection(promise, reason);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    possiblyUnhandledRejections.clear();</div><div class="line"></div><div class="line">&#125;, <span class="number">60000</span>);</div></pre></td></tr></table></figure>
<p>이 구현은 Node.js 구현과 거의 동일합니다. <em>Promise</em>와 거절 값을 <em>Map</em>에 저장한 다음 나중에 검사하는 것과 같은 접근 방식을 사용합니다. 유일한 실제 차이점은 <em>Event</em> 핸드러에서 정보를 검색하는 위치입니다.</p>
<p><em>Promise</em> 거절을 처리하는 것은 까다로울 수 있지만, 실제로 얼마나 강력한 <em>Promise</em>가 될 수 있는지를 이제 알기 시작했습니다. 이제 다음 단계로 몇개의 <em>Promise</em>를 연결해서 처리할 때입니다.</p>
<h2 id="Promise-연결하기"><a href="#Promise-연결하기" class="headerlink" title="Promise 연결하기"></a>Promise 연결하기</h2><p>이 시점에서 <em>Promise</em>는 <em>Callback</em>과 <code>setTimeout()</code> 함수를 이용한 조합보다 조금더 개선된 것으로 보이지만, 눈에 보이는 것보다 훨씬더 많은 <em>Promise</em>가 있습니다. 보다 구체적으로, 보다 복잡한 비동기 동작을 수행하기 위해 <em>Promise</em>를 서로 연결하는 여러 가지 방법이 있습니다.</p>
<p><code>then()</code> 또는 <code>catch()</code>를 호출할 때마다 실제로 또 다른 <em>Promise</em>가 만들어지고 리턴됩니다. 이 두 번째 <em>Promise</em>는 첫 번째 <em>Promise</em>가 수행되거나 거절된 후에만 처리됩니다. 다음 예제를 살펴보겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    resolve(<span class="number">42</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(value);</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Finished"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>위 코드의 결과는 다음과 같습니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">42</div><div class="line">Finished</div></pre></td></tr></table></figure>
<p><code>p1.then()</code>에 대한 호출은 두 번째 <em>Promise</em>를 리턴하고 <code>then()</code>이 호출됩니다. 두 번째 <code>then()</code> 수행 핸들러는 첫 번째 <em>Promise</em>가 해결된 후에만 호출됩니다. 이 예제의 연결을 해제하면 다음과 같이 보입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    resolve(<span class="number">42</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">let</span> p2 = p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(value);</div><div class="line">&#125;)</div><div class="line"></div><div class="line">p2.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Finished"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>이 연결되지 않은 코드 버전에서 <code>p1.then()</code>의 결과는 <code>p2</code>에 저장되고 <code>p2.then()</code>은 최종 수행 핸들러를 추가하기 위해 호출됩니다. 여러분이 짐작 했겠지만, <code>p2.then()</code> 호출도 <em>Promise</em>를 리턴하지만 그 <em>Promise</em>는 사용하지 않습니다.</p>
<h3 id="Error-포착하기"><a href="#Error-포착하기" class="headerlink" title="Error 포착하기"></a>Error 포착하기</h3><p><em>Promise</em> 체인을 사용하면 이전 <em>Promise</em>에서 수행 또는 거절 핸들러에서 발생할 수 있는 에러를 포착 할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    resolve(<span class="number">42</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Boom!"</span>);</div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(error.message);     <span class="comment">// "Boom!"</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>이 코드에서 <code>p1</code>의 수행 핸들러는 에러를 던집니다. 두 번째 <em>Promise</em>인 <code>catch()</code> 메서드에 대한 연결된 호출은 거절 핸들러를 통해 해당 에러를 수신할 수 있습니다. 거절 핸들러가 에러를 throw 하는 경우에도 마찬가지입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Explosion!"</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">p1.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(error.message);     <span class="comment">// "Explosion!"</span></div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Boom!"</span>);</div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(error.message);     <span class="comment">// "Boom!"</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>여기에서 Executor가 오류를 발생시켜 다음 <code>p1</code> <em>Promise</em>의 거절 핸들러를 트리거합니다. 그 핸들러는 두 번째 <em>Promise</em>의 거절 핸들러가 포착할 또 다른 에러를 발생시킵니다. 연결된 <em>Promise</em> 호출은 체인의 다른 <em>Promise</em>의 에러를 인식합니다.</p>
<blockquote>
<p>에러가 발생할 때 올바르게 처리할 수 있도록 <em>Promise</em> 체인의 끝부분에는 항상 거절 핸들러가 있어야합니다.</p>
</blockquote>
<h3 id="Promise-체인의-리턴-값"><a href="#Promise-체인의-리턴-값" class="headerlink" title="Promise 체인의 리턴 값"></a>Promise 체인의 리턴 값</h3><p><em>Promise</em> 체인의 또 다른 중요한 부분은 하나의 <em>Promise</em>에서 다음 <em>Promise</em>로 데이터를 전달할 수 있다는 것입니다. Executor 내에서 <code>resolve()</code> 핸들러로 전달된 값이 해당 <em>Promise</em>에 대한 수행 핸들러로 전달되는 것을 이미 보았습니다. 수행 핸들러에서 리턴값을 지정하여 체인을 따라 데이터를 계속 전달할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    resolve(<span class="number">42</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(value);         <span class="comment">// "42"</span></div><div class="line">    <span class="keyword">return</span> value + <span class="number">1</span>;</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(value);         <span class="comment">// "43"</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><code>p1</code>에 대한 수행 핸들러는 실행될 때 <code>value + 1</code>을 리턴합니다. <code>value</code>는 Executor로부터 42를 입력 받고, 수행 핸들러는 43을 리턴합니다. 이 값은 두 번째 <em>Promise</em>의 수행 핸들러로 전달되어 콘솔로 출력됩니다.</p>
<p>거절 핸들러로도 똑같이 할 수 있습니다. 거절 핸들러가 호출되면 값을 리턴할 수 있습니다. 만약 그렇다면, 그 값은 다음과 같이 체인의 다음 <em>Promise</em>를 수행하는데 사용될수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    reject(<span class="number">42</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">p1.catch(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="comment">// first fulfillment handler</span></div><div class="line">    <span class="built_in">console</span>.log(value);         <span class="comment">// "42"</span></div><div class="line">    <span class="keyword">return</span> value + <span class="number">1</span>;</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="comment">// second fulfillment handler</span></div><div class="line">    <span class="built_in">console</span>.log(value);         <span class="comment">// "43"</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>여기서 Executor는 42로 <code>reject()</code>를 호출합니다. 이 값은 <em>Promise</em>의 거절 핸들러로 전달되며 여기서 <code>value + 1</code>이 리턴됩니다. 이 리턴 값은 거절 핸들러에서 가져오지만 체인에서 다음 <em>Promise</em>의 수행 핸들러에서 계속 사용됩니다. 만약 필요하다면 한 <em>Promise</em>의 실패는<br> 전체 체인에서 복구할 수 있습니다.</p>
<h3 id="Promise-체인에서-Promise-리턴하기"><a href="#Promise-체인에서-Promise-리턴하기" class="headerlink" title="Promise 체인에서 Promise 리턴하기"></a>Promise 체인에서 Promise 리턴하기</h3><p>수행 및 거절 핸들러에서 <em>Primitive</em> 값을 리턴하면 <em>Promise</em> 사이에 데이터를 전달할 수 있지만 객체를 리턴하려면 어떻게 해야 할까요? 객체가 <em>Promise</em>라면 진행 방법을 결정하기위한 추가 단계가 필요합니다. 다음 예제를 살펴보겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    resolve(<span class="number">42</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    resolve(<span class="number">43</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="comment">// first fulfillment handler</span></div><div class="line">    <span class="built_in">console</span>.log(value);     <span class="comment">// 42</span></div><div class="line">    <span class="keyword">return</span> p2;</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="comment">// second fulfillment handler</span></div><div class="line">    <span class="built_in">console</span>.log(value);     <span class="comment">// 43</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>이 코드에서 <code>p1</code>은 42로 해결(Resolve)되는 작업을 스케쥴합니다. <code>p1</code>의 수행 핸들러는 이미 해결된 상태인 <em>Promise</em>인 <code>p2</code>를 리턴합니다. <code>p2</code>가 완료되었으므로 두 번째 수행 핸들러가 호출됩니다. <code>p2</code>가 거부되면 두 번째 수행 핸들러 대신 거절 핸들러(있는 경우)가 호출됩니다.</p>
<p>이 패턴에 대해 알아야 할 중요한 점은 두 번째 수행 핸들러가 <code>p2</code>에 추가되지 않고 오히려 세 번째 <em>Promise</em>에 추가된다는 것입니다. 따라서 두 번째 수행 핸들러는 세 번째 <em>Promise</em>에 첨부되며, 앞의 예제를 다음과 같이 만들수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    resolve(<span class="number">42</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    resolve(<span class="number">43</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">let</span> p3 = p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="comment">// first fulfillment handler</span></div><div class="line">    <span class="built_in">console</span>.log(value);     <span class="comment">// 42</span></div><div class="line">    <span class="keyword">return</span> p2;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">p3.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="comment">// second fulfillment handler</span></div><div class="line">    <span class="built_in">console</span>.log(value);     <span class="comment">// 43</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>여기에서 두 번째 수행 처리기가 <code>p2</code>보다는 <code>p3</code>에 연결되어 있음이 명확합니다. <code>p2</code>가 거절되는 경우 두 번째 수행 핸들러가 호출되지 않으므로 이것은 미묘하지만 중요한 차이점입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    resolve(<span class="number">42</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    reject(<span class="number">43</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="comment">// first fulfillment handler</span></div><div class="line">    <span class="built_in">console</span>.log(value);     <span class="comment">// 42</span></div><div class="line">    <span class="keyword">return</span> p2;</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="comment">// second fulfillment handler</span></div><div class="line">    <span class="built_in">console</span>.log(value);     <span class="comment">// 절대 호출되지 않음</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>이 예제에서는 <code>p2</code>가 거절되므로 두 번째 이행 핸들러가 호출되지 않습니다. 하지만 대신 거절 핸들러를 연결할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    resolve(<span class="number">42</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    reject(<span class="number">43</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="comment">// first fulfillment handler</span></div><div class="line">    <span class="built_in">console</span>.log(value);     <span class="comment">// 42</span></div><div class="line">    <span class="keyword">return</span> p2;</div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="comment">// rejection handler</span></div><div class="line">    <span class="built_in">console</span>.log(value);     <span class="comment">// 43</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>여기서, 거절 핸들러는 <code>p2</code>가 거절된 결과 호출됩니다. <code>p2</code>에서 거절된 값 43은 해당 거절 핸들러로 전달됩니다.</p>
<p><em>Promise</em> Executor가 실행될 때 수행 또는 거절 핸들러로부터 <em>Thenable</em>을 리턴하는 것은 변하지 않습니다. 첫 번째 정의된 <em>Promise</em>는 먼저 Executor를 실행한 다음 두 번째 <em>Promise</em>의 Executor를 실행합니다. <em>Thenable</em>를 반환하면 간단하게 <em>Promise</em> 결과에 대한 추가 응답을 정의할 수 있습니다. 수행 핸들러 내에서 새로운 <em>Promise</em>를 작성하여 수행 핸들러의 실행을 연기할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    resolve(<span class="number">42</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(value);     <span class="comment">// 42</span></div><div class="line"></div><div class="line">    <span class="comment">// create a new promise</span></div><div class="line">    <span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">        resolve(<span class="number">43</span>);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> p2</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(value);     <span class="comment">// 43</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>이 예제에서 <code>p1</code>의 수행 핸들러에 새 <em>Promise</em>가 생성됩니다. 즉, 두 번째 수행 핸들러는 <code>p2가</code> 수행될 때까지 실행되지 않습니다. 이 패턴은 이전 <em>Promise</em>가 확정될 때까지 <em>Promise</em>가 기다리길 원할때 유용합니다.</p>
<h2 id="Multiple-Promise에-대한-대응"><a href="#Multiple-Promise에-대한-대응" class="headerlink" title="Multiple Promise에 대한 대응"></a>Multiple Promise에 대한 대응</h2><p>지금까지 이 장의 각 예제에서는 한번에 하나의 <em>Promise</em>에 응답하는 방법을 다루었습니다. 그러나 때로는 다음 작업을 결정하기 위해 여러 <em>Promise</em>의 진행 상태를 모니터링 해야할 수도 있습니다. ECMAScript 6은 <code>Promise.all()</code> 및 <code>Promise.race()</code>와 같이 여러 <em>Promise</em>를 모니터링하는 두가지 메서드를 제공합니다.</p>
<h3 id="Promise-all-메서드"><a href="#Promise-all-메서드" class="headerlink" title="Promise.all() 메서드"></a>Promise.all() 메서드</h3><p><code>Promise.all()</code> 메서드는 모니터링 할 <em>Promise</em>들을 <em>Iterable</em>(<em>Array</em>와 같은)하게 만든 단일 파라미터를 받아들이고 <em>Iterable</em>의 모든 <em>Promise</em>가 해결되었을 때 해결된 <em>Promise</em>를 리턴합니다. 리턴된 <em>Promise</em>는 아래 예제처럼 <em>Iterable</em>의 모든 <em>Promise</em>가 충족될 때 수행됩니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    resolve(<span class="number">42</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    resolve(<span class="number">43</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">let</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    resolve(<span class="number">44</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">let</span> p4 = <span class="built_in">Promise</span>.all([p1, p2, p3]);</div><div class="line"></div><div class="line">p4.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(value));  <span class="comment">// true</span></div><div class="line">    <span class="built_in">console</span>.log(value[<span class="number">0</span>]);              <span class="comment">// 42</span></div><div class="line">    <span class="built_in">console</span>.log(value[<span class="number">1</span>]);              <span class="comment">// 43</span></div><div class="line">    <span class="built_in">console</span>.log(value[<span class="number">2</span>]);              <span class="comment">// 44</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>각각의 <em>Promise</em>는 숫자로 Resolve됩니다. <code>Promise.all()</code>에 대한 호출은 <em>Promise</em> <code>p4</code>를 생성합니다. 이것은 <code>p1</code>, <code>p2</code> 및 <code>p3</code> <em>Promise</em>가 충족될 때 수행됩니다. <code>p4</code>의 수행 핸들러에 전달된 결과는 각 Resolve된 값 <code>42</code>, <code>43</code> 및 <code>44</code>를 포함하는 <em>Array</em>입니다. 값은 <em>Promise</em>가 <code>Promise.all</code>에 전달된 순서대로 저장되므로 <em>Promise</em> 결과를 Resolve한 <em>Promise</em>와 일치시킬 수 있습니다.</p>
<p><code>Promise.all()</code>에 전달된 <em>Promise</em>가 거절되면 다른 <em>Promise</em>가 완료될 때까지 기다리지 않고 즉시 반환된 <em>Promise</em>는 거절됩니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    resolve(<span class="number">42</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    reject(<span class="number">43</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">let</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    resolve(<span class="number">44</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">let</span> p4 = <span class="built_in">Promise</span>.all([p1, p2, p3]);</div><div class="line"></div><div class="line">p4.catch(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(value))   <span class="comment">// false</span></div><div class="line">    <span class="built_in">console</span>.log(value);                 <span class="comment">// 43</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>이 예제에서 <code>p2</code>는 43의 값을 사용하여 거절됩니다. <code>p4</code>에 대한 거절 핸들러는 <code>p1</code> 또는 <code>p3</code>가 실행 완료될 때까지 기다리지 않고 즉시 호출됩니다(여전히 실행은 완료하지만, <code>p4</code>가 대기하지 않습니다).</p>
<p>거절 핸들러는 항상 <em>Array</em>가 아닌 단일값을 받으며 그값은 거절된 <em>Promise</em>의 거절값입니다. 이 경우, 거절 핸들러에는 <code>p2</code>로부터의 거절을 반영하기 위해 43이 입력됩니다.</p>
<h3 id="Promise-race-메서드"><a href="#Promise-race-메서드" class="headerlink" title="Promise.race() 메서드"></a>Promise.race() 메서드</h3><p><code>Promise.race()</code> 메서드는 약간 다른 방법으로 여러 <em>Promise</em>를 모니터링하는 방법을 제공합니다. 이 메서드 또한 <em>Promise</em>의 <em>Iterable</em>을 파라미터로 받고 <em>Promise</em>를 리턴하지만, 리턴된 <em>Promise</em>는 입력된 <em>Iterable</em> <em>Promise</em>들 중 어떤 <em>Promise</em>가 처음으로 확정(settled) 되자마자 확정(settled) 됩니다. <code>Promise.all()</code> 메서드처럼 모든 <em>Promise</em>가 수행되기를 기다리는 대신 <code>Promise.race()</code> 메서드는 <em>Iterable</em> <em>Promise</em>가 수행되는 즉시 적절한 <em>Promise</em>를 리턴합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="number">42</span>);</div><div class="line"></div><div class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    resolve(<span class="number">43</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">let</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    resolve(<span class="number">44</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">let</span> p4 = <span class="built_in">Promise</span>.race([p1, p2, p3]);</div><div class="line"></div><div class="line">p4.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(value);     <span class="comment">// 42</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>이 코드에서 <code>p1</code>은 수행된 <em>Promise</em>로 만들어지며 다른것들은 스케쥴 작업으로 생성됩니다. <code>p4</code>에 대한 수행 핸들러는 <code>42</code>라는 값으로 호출되고 다른 <em>Promise</em>를 무시합니다. <code>Promise.race()</code>에 전달된 <em>Promise</em>는 어느 것이 먼저 확정(settled)되는지 보기위한 경쟁입니다. 첫 번째 <em>Promise</em>가 확정되면 리턴된 <em>Promise</em>가 수행됩니다. 첫 <em>Promise</em>의 확정이 거절되면 리턴된 <em>Promise</em>는 거절됩니다. 다음은 거절 사례입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    resolve(<span class="number">42</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">let</span> p2 = <span class="built_in">Promise</span>.reject(<span class="number">43</span>);</div><div class="line"></div><div class="line"><span class="keyword">let</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    resolve(<span class="number">44</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">let</span> p4 = <span class="built_in">Promise</span>.race([p1, p2, p3]);</div><div class="line"></div><div class="line">p4.catch(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(value);     <span class="comment">// 43</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><code>Promise.race()</code>가 호출될 때 이미 <code>p2</code>가 거절된 상태이므로 <code>p4</code>가 거절됩니다. <code>p1</code>과 <code>p3</code>가 수행 되더라도 <code>p2</code>가 거절된 후에 발생하므로 무시됩니다</p>
<h2 id="Promise에서-상속-받기"><a href="#Promise에서-상속-받기" class="headerlink" title="Promise에서 상속 받기"></a>Promise에서 상속 받기</h2><p>다른 <em>Built-in</em> 타입과 마찬가지로 파생 클래스의 기반으로 <em>Promise</em>를 사용할 수 있습니다. 이를 통해 자신만의 객체를 정의하여 <em>Built-in Promise</em>를 확장할 수 있습니다. 예를 들어, 일반적인 <code>then()</code> 및 <code>catch()</code> 메서드 외에도 <code>success()</code> 및 <code>failure()</code>라는 메서드를 사용할 수 있는 <em>Promise</em>를 만들고 싶다고 가정 해보십시오. 다음과 같이 <em>Promise</em> 타입을 작성할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> <span class="keyword">extends</span> <span class="title">Promise</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 기본 생성자를 사용</span></div><div class="line"></div><div class="line">    success(resolve, reject) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.then(resolve, reject);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    failure(reject) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.catch(reject);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    resolve(<span class="number">42</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">promise.success(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(value);             <span class="comment">// 42</span></div><div class="line">&#125;).failure(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(value);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>이 예에서 <code>MyPromise</code>는 <code>Promise</code>에서 파생되었으며 두가지 추가 메서드가 있습니다. <code>success()</code> 메서드는 <code>resolve()</code>를 모방하고 <code>failure()</code>는 <code>reject()</code> 메서드를 모방합니다.</p>
<p>추가된 각 메서드는 이를 사용하여 모방하는 메서드를 호출합니다. 파생된 <em>Promise</em>는 <em>Built-in Promise</em>와 동일하게 작동하지만 원하는 경우 <code>success()</code> 및 <code>failure()</code>를 호출할 수 있습니다.</p>
<p>정적 메서드도 상속되므로 <code>MyPromise.resolve()</code>, <code>MyPromise.reject()</code>, <code>MyPromise.race()</code> 및 <code>MyPromise.all()</code> 메서드는 파생된 <em>Promise</em>에도 있습니다. 마지막 두 메서드는 기본 제공 메서드와 동일하게 동작하지만 처음 두 메서드는 약간 다릅니다.</p>
<p><code>MyPromise.resolve()</code>와 <code>MyPromise.reject()</code>는 전달된 값에 관계없이 <code>MyPromise</code>의 인스턴스를 리턴합니다. 리턴할 <em>Promise</em>의 타입을 결정하기 위해 <code>Symbol.species</code> 프로퍼티(9 장에서 다뤘습니다.)를 사용하기 때문에 전달된 값에 관계없이 <code>MyPromise</code>의 인스턴스를 리턴합니다. <em>Built-in Promise</em>가 두 메서드 중 하나에 전달되면 <em>Promise</em>가 수행되거나 거절되고 메서드는 새로운 <code>MyPromise</code>를 반환하여 수행 및 거절 핸들러를 할당할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    resolve(<span class="number">42</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">let</span> p2 = MyPromise.resolve(p1);</div><div class="line">p2.success(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(value);         <span class="comment">// 42</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(p2 <span class="keyword">instanceof</span> MyPromise);   <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>여기에서 <code>p1</code>은 <code>MyPromise.resolve()</code> 메서드로 전달되는 <em>Built-in Promise</em>입니다. 결과 <code>p2</code>는 <code>p1</code>의 Resolve된 값이 수행 핸들러로 전달되는 <code>MyPromise</code>의 인스턴스입니다.</p>
<p><code>MyPromise</code> 인스턴스가 <code>MyPromise.resolve()</code> 또는 <code>MyPromise.reject()</code> 메서드에 전달되면 Resolve되지 않고 바로 리턴됩니다. 하지만 이 두 메서드의 다른 모든 실행은 <code>Promise.resolve()</code> 및 <code>Promise.reject()</code>와 동일하게 동작합니다.</p>
<h3 id="비동기-작업-실행"><a href="#비동기-작업-실행" class="headerlink" title="비동기 작업 실행"></a>비동기 작업 실행</h3><p>8 장에서는 <em>Generator</em>를 소개하고 이를 비동기 작업 실행에 사용할 수있는 방법을 보여주었습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">taskDef</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// iterator를 만들고 다른곳에서 사용할수 있게 만든다.</span></div><div class="line">    <span class="keyword">let</span> task = taskDef();</div><div class="line"></div><div class="line">    <span class="comment">// task 시작</span></div><div class="line">    <span class="keyword">let</span> result = task.next();</div><div class="line"></div><div class="line">    <span class="comment">// next() 호출을 유지하는 재귀 함수</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">// 할일이 더 있다면</span></div><div class="line">        <span class="keyword">if</span> (!result.done) &#123;</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> result.value === <span class="string">"function"</span>) &#123;</div><div class="line">                result.value(<span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</div><div class="line">                    <span class="keyword">if</span> (err) &#123;</div><div class="line">                        result = task.throw(err);</div><div class="line">                        <span class="keyword">return</span>;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    result = task.next(data);</div><div class="line">                    step();</div><div class="line">                &#125;);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                result = task.next(result.value);</div><div class="line">                step();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// process 시작</span></div><div class="line">    step();</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// task runner와 함께 사용할 함수를 정의</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">filename</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</div><div class="line">        fs.readFile(filename, callback);</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// task 실행</span></div><div class="line"></div><div class="line">run(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> contents = <span class="keyword">yield</span> readFile(<span class="string">"config.json"</span>);</div><div class="line">    doSomethingWith(contents);</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Done"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>이 구현에는 몇가지 문제점이 있습니다. 첫째, 함수를 리턴하는 함수에서 모든 함수를 래핑하는 것은 다소 혼란 스럽습니다 (이 문장조차 혼란 스럽습니다). 둘째, Task runner의 <em>Callback</em>으로 의도된 함수 리턴값과 <em>Callback</em>이 아닌 리턴값을 구별할 수있는 방법이 없습니다.</p>
<p><em>Promise</em>를 통해 각 비동기 작업이 <em>Promise</em>를 반환하도록 함으로써 이 프로세스를 크게 단순화하고 일반화할 수 있습니다. 공통 인터페이스는 비동기 코드를 크게 단순화할 수 있음을 의미합니다. Task runner를 단순화 할 수있는 방법은 다음과 같습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">taskDef</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// iterator 생성</span></div><div class="line">    <span class="keyword">let</span> task = taskDef();</div><div class="line"></div><div class="line">    <span class="comment">// task 시작</span></div><div class="line">    <span class="keyword">let</span> result = task.next();</div><div class="line"></div><div class="line">    <span class="comment">// 반복하는 재귀 함수</span></div><div class="line">    (<span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">// 할일이 더 있다면</span></div><div class="line">        <span class="keyword">if</span> (!result.done) &#123;</div><div class="line"></div><div class="line">            <span class="comment">// promise를 resolve 하면 쉽게 해결됩니다.</span></div><div class="line">            <span class="keyword">let</span> promise = <span class="built_in">Promise</span>.resolve(result.value);</div><div class="line">            promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">                result = task.next(value);</div><div class="line">                step();</div><div class="line">            &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</div><div class="line">                result = task.throw(error);</div><div class="line">                step();</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// task runner에서 사용할 함수를 정의</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">filename</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">        fs.readFile(filename, <span class="function"><span class="keyword">function</span>(<span class="params">err, contents</span>) </span>&#123;</div><div class="line">            <span class="keyword">if</span> (err) &#123;</div><div class="line">                reject(err);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                resolve(contents);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// task 실행</span></div><div class="line"></div><div class="line">run(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> contents = <span class="keyword">yield</span> readFile(<span class="string">"config.json"</span>);</div><div class="line">    doSomethingWith(contents);</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Done"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>이 버전의 코드에서 범용 <code>run()</code> 함수는 <em>Generator</em>를 실행하여 <em>Iterator</em>를 만듭니다. 작업을 시작하기 위해 <code>task.next()</code>를 호출하고 <em>Iterator</em>가 완료될 때까지 <code>step()</code>을 재귀적으로 호출합니다.</p>
<p><code>step()</code> 함수안에서 할일이 더 있다면 <code>result.done</code>은 <code>false</code>입니다. 그 시점에서 result.value는 <em>Promise</em>이어야합니다. 그러나 문제의 함수가 <em>Promise</em>를 반환하지 않은 경우 <code>Promise.resolve()</code>가 호출됩니다.(<code>Promise.resolve()</code>는 전달된 <em>Promise</em>는 통과시키고 <em>Non-promise</em>는 <em>Promise</em>로 래핑한다는 것을 기억하세요). 그런 다음 <em>Promise</em> 값을 검색하고 이 값을 <em>Iterator</em>에 전달하는 수행 핸들러가 추가됩니다. 그 후, <code>result</code>는 <code>step()</code> 함수가 스스로를 호출하기 전에 다음 <code>yield</code> 결과에 할당됩니다.</p>
<p>거절 핸들러는 거절 결과를 오류 객체에 저장합니다. <code>task.throw()</code> 메서드는 에러 객체를 <em>Iterator</em>로 되돌려 보내고, 만약 태스크에 에러가 잡히면 <code>result</code>가 다음 <code>yield</code> 결과에 할당됩니다. 마지막으로 <code>step()</code>은 <code>catch()</code> 내부에서 호출하여 계속 진행합니다.</p>
<p>이 <code>run()</code> 함수는 개발자에게 <em>Promise</em>(또는 <em>Callback</em>)을 노출시키지 않고 비동기 코드를 얻기 위해 <code>yield</code>를 사용하는 모든 <em>Generator</em>를 실행할 수 있습니다. 사실 함수 호출의 리턴 값은 항상 <em>Promise</em>로 래핑되어 있기 때문에 함수는 <em>Promise</em> 이외의 것을 리턴할 수도 있습니다. 즉, <code>yield</code>를 사용하여 호출할 때 동기및 비동기 메서드가 모두 올바르게 작동한다는 것을 의미하므로 리턴값이 <em>Promise</em>임을 확인할 필요가 없습니다.</p>
<p>유일한 관심사는 <code>readFile()</code>과 같은 비동기 함수가 해당 State를 올바르게 식별하는 <em>Promise</em>를 리턴하는지 확인하는 것입니다. Node.js <em>Built-in</em> 메서드의 경우 <em>Callback</em>을 사용하지 않고 <em>Promise</em>를 리턴하도록 이러한 메서드를 변환해야합니다.</p>
<h3 id="미래의-비동기-Task-실행"><a href="#미래의-비동기-Task-실행" class="headerlink" title="미래의 비동기 Task 실행"></a>미래의 비동기 Task 실행</h3><p>필자가 글을 쓰고있는 지금 JavaScript로 실행되는 비동기 태스크에 간단한 구문을 사용하는 작업이 진행중입니다. 이전 섹션의 <em>Promise</em> 기반 예제와 유사한 <code>await</code>구문으로 진행 중입니다. 기본적인 아이디어는 <em>Generator</em> 대신에 <code>async</code>로 표시된 함수를 사용하고 함수를 호출할 때 <code>yield</code> 대신에 <code>await</code>을 사용하는 것입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> contents = <span class="keyword">await</span> readFile(<span class="string">"config.json"</span>);</div><div class="line">    doSomethingWith(contents);</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Done"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><code>async</code> 키워드가 <code>function</code>보다 먼저 나오면 함수가 비동기 방식으로 실행된다는 의미입니다. <code>await</code> 키워드는 <code>readFile(&quot;config.json&quot;)</code> 함수 호출이 <em>Promise</em>를 리턴해야 한다는 것을 알려주고, 그렇지 않을 경우 응답을 <em>Promise</em>로 감싸야합니다. 앞절에서 <code>run()</code>을 구현한 것과 마찬가지로, <code>await</code>는 <em>Promise</em>가 거절되면 에러를 던지고 그렇지 않을 경우 값을 반환합니다. 최종 결과는 <em>Iterator</em> 기반 상태 시스템을 관리하는 오버 헤드없이 동기식인 것처럼 비동기 코드를 작성하는 것입니다.</p>
<p><code>await</code> 구문은 ECMAScript 2017 (ECMAScript 8)에서 완성될 것으로 예상됩니다.</p>
<h2 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h2><p><em>Promise</em>는 JavaScript에서 비동기 프로그래밍을 개선하기 위해 설계되었습니다. <em>Event</em> 및 <em>Callback</em>보다 비동기 작업에 대한 제어력과 합성 가능성을 향상시켜줍니다. <em>Promise</em> 스케줄 작업은 JavaScript 엔진의 <em>Job Queue</em>에 추가되어 나중에 실행될 수 있습니다. 그리고 두 번째 <em>Job Queue</em>는 적절한 실행을 보장하기 위해 <em>Promise</em> 수행 및 거절 핸들러를 추적합니다.</p>
<p><em>Promise</em>에는 Pending(보류), Fulfilled(수행), Rejected(거절)이라는 세가지 상태가 있습니다. <em>Promise</em>는 보류중 상태에서 시작하여 성공적인 실행에서 수행되거나 실패로 인해 거부됩니다. 두경우 모두 <em>Promise</em>가 확정(settled)되는 시점을 나타내는 핸들러를 추가할 수 있습니다. <code>then()</code> 메서드를 사용하면 수행 및 거절 핸들러를 할당할 수 있으며 <code>catch()</code> 메서드를 사용하면 거절 핸들러만 할당할 수 있습니다.</p>
<p><em>Promise</em>를 여러 가지 방식으로 연결하여 정보를 전달할 수 있습니다. <code>then()</code>을 호출할 때마다 이전 <em>Promise</em>가 Resolve될 때 Resolve<br>되는 새로운 <em>Promise</em>가 만들어지고 리턴됩니다. 이러한 체인을 사용하여 일련의 비동기 이벤트에 대한 응답을 트리거할 수 있습니다. 또한 <code>Promise.race()</code> 및 <code>Promise.all()</code>을 사용하여 여러 <em>Promise</em>의 진행 상황을 모니터링하고 그에 따라 응답할 수 있습니다.</p>
<p><em>Promise</em>는 비동기 작업이 리턴할 수 있는 공통 인터페이스를 제공하므로 <em>Generator</em>와 <em>Promise</em>를 결합할 때 비동기 작업 실행이 더 쉽습니다. <em>Generator</em>와 <code>yield</code> 연산자를 사용하여 비동기 응답을 기다리고 적절하게 응답할 수 있습니다.</p>
<p>대부분의 새로운 웹 API는 <em>Promise</em>를 바탕으로 구축되고 있으며 향후 더 많은 것을 기대할 수 있습니다.</p>
<hr>
<blockquote>
<p>이 내용은 나중에 참고하기 위해 제가 공부하며 정리한 내용입니다.<br>의역, 오역, 직역이 있을 수 있음을 알려드립니다.<br>This post is a translation of this original article [<a href="https://leanpub.com/understandinges6/read#leanpub-auto-promises-and-asynchronous-programming" target="_blank" rel="external">https://leanpub.com/understandinges6/read#leanpub-auto-promises-and-asynchronous-programming</a>]</p>
</blockquote>
<h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul>
<li><a href="https://infoscis.github.io/2018/01/24/ecmascript-6-block-binding/">ECMAScript 6 Block Binding</a></li>
<li><a href="https://infoscis.github.io/2018/01/24/ecmascript-6-strings-and-regular-expressions/">ECMAScript 6 문자열과 정규 표현식</a></li>
<li><a href="https://infoscis.github.io/2018/01/24/ecmascript-6-functions/">ECMAScript 6 함수</a></li>
<li><a href="https://infoscis.github.io/2018/01/25/ecmascript-6-expanded-object-functionality/">ECMAScript 6 객체의 확장된 기능</a></li>
<li><a href="https://infoscis.github.io/2018/01/26/ecmascript-6-destructuring-for-easier-data-access/">ECMAScript 6 쉬운 데이터 액세스를 위한 Destructuring</a></li>
<li><a href="https://infoscis.github.io/2018/01/27/ecmascript-6-symbols-and-symbol-properties/">ECMAScript 6 Symbol과 Symbol 프로퍼티</a></li>
<li><a href="https://infoscis.github.io/2018/01/27/ecmascript-6-sets-and-maps/">ECMAScript 6 Set과 Map</a></li>
<li><a href="https://infoscis.github.io/2018/01/31/ecmascript-6-iterators-and-generators/">ECMAScript 6 Iterator와 Generator</a></li>
<li><a href="https://infoscis.github.io/2018/02/13/ecmascript-6-introducing-javascript-classes/">ECMAScript 6 JavaScript 클래스 소개</a></li>
<li><a href="https://infoscis.github.io/2018/02/13/ecmascript-6-improved-array-capabilities/">ECMAScript 6 Array 기능 향상</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-promises-and-asynchronous-programming/">ECMAScript 6 Promise와 비동기 프로그램밍</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-proxies-and-the-reflection-api/">ECMAScript 6 프록시와 리플렉션 API</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-encapsulating-code-with-modules/">ECMAScript 6 Module로 코드 캡슐화하기</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-appendix-a-smaller-changes/">ECMAScript 6 부록 A. 작은 변경 사항</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-appendix-b-understanding-ecmascript-7/">ECMAScript 6 부록 B. ECMAScript 7(2016) 이해하기</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ECMASCript-6-Promise와-비동기-프로그램밍&quot;&gt;&lt;a href=&quot;#ECMASCript-6-Promise와-비동기-프로그램밍&quot; class=&quot;headerlink&quot; title=&quot;ECMASCript 6 Promise와 비동기 프로그램
    
    </summary>
    
      <category term="JavaScript" scheme="http://infoscis.github.io/categories/JavaScript/"/>
    
      <category term="ECMAScript 2015" scheme="http://infoscis.github.io/categories/JavaScript/ECMAScript-2015/"/>
    
    
      <category term="JavaScript" scheme="http://infoscis.github.io/tags/JavaScript/"/>
    
      <category term="ECMAScript 2015" scheme="http://infoscis.github.io/tags/ECMAScript-2015/"/>
    
  </entry>
  
  <entry>
    <title>Array 기능 향상</title>
    <link href="http://infoscis.github.io/2018/02/13/ecmascript-6-improved-array-capabilities/"/>
    <id>http://infoscis.github.io/2018/02/13/ecmascript-6-improved-array-capabilities/</id>
    <published>2018-02-13T14:50:12.000Z</published>
    <updated>2018-02-27T14:12:39.181Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Array-기능-향상"><a href="#Array-기능-향상" class="headerlink" title="Array 기능 향상"></a>Array 기능 향상</h1><p><em>Array</em>는 JavaScript의 기본 객체입니다. 그러나 JavaScript의 다른 부분은 시간이 지남에 따라 진화해 왔지만 <em>Array</em>는 ECMAScript 5가 사용하기 쉽도록 여러 가지 메서드를 도입할 때까지 동일하게 유지되었습니다. ECMAScript 6은 새로운 생성 메서드, 몇 가지 유용하고 편리한 메서드, <em>Typed Array</em> 작성 기능과 같이 많은 기능을 추가하여 <em>Array</em>를 개선합니다.</p>
<h2 id="Array-생성하기"><a href="#Array-생성하기" class="headerlink" title="Array 생성하기"></a>Array 생성하기</h2><p>ECMAScript 6 이전에 <em>Array</em>를 생성하는 두 가지 기본 방법인 <code>Array</code> 생성자와 리터럴 구문이있었습니다. 두 방법 모두 <em>Array</em> 항목을 개별적으로 나열 해야하며 그렇지 않으면 상당히 제한적입니다. <em>Array</em>와 같은 객체 (즉, 숫자 인덱스와 <code>length</code> 프로퍼티를 가진 객체)를 <em>Array</em>로 변환하는 옵션도 제한되어 있으며 종종 추가 코드가 필요했습니다. JavaScript <em>Array</em>를 보다 쉽게 만들기 위해 ECMAScript 6은 <code>Array.of()</code>와 <code>Array.from ()</code> 메서드를 추가했습니다.</p>
<h3 id="Array-of-메서드"><a href="#Array-of-메서드" class="headerlink" title="Array.of() 메서드"></a>Array.of() 메서드</h3><p>ECMAScript 6이 JavaScript에 새로운 생성 메서드를 추가한 이유중 하나는 개발자가 <code>Array</code> 생성자를 사용하여 <em>Array</em>를 생성하는 것을 방지할 수 있다는 것입니다. <code>new Array()</code> 생성자는 실제로 전달된 인자의 타입과 개수에 따라 다르게 동작합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> items = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">2</span>);</div><div class="line"><span class="built_in">console</span>.log(items.length);          <span class="comment">// 2</span></div><div class="line"><span class="built_in">console</span>.log(items[<span class="number">0</span>]);              <span class="comment">// undefined</span></div><div class="line"><span class="built_in">console</span>.log(items[<span class="number">1</span>]);              <span class="comment">// undefined</span></div><div class="line"></div><div class="line">items = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"2"</span>);</div><div class="line"><span class="built_in">console</span>.log(items.length);          <span class="comment">// 1</span></div><div class="line"><span class="built_in">console</span>.log(items[<span class="number">0</span>]);              <span class="comment">// "2"</span></div><div class="line"></div><div class="line">items = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>, <span class="number">2</span>);</div><div class="line"><span class="built_in">console</span>.log(items.length);          <span class="comment">// 2</span></div><div class="line"><span class="built_in">console</span>.log(items[<span class="number">0</span>]);              <span class="comment">// 1</span></div><div class="line"><span class="built_in">console</span>.log(items[<span class="number">1</span>]);              <span class="comment">// 2</span></div><div class="line"></div><div class="line">items = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>, <span class="string">"2"</span>);</div><div class="line"><span class="built_in">console</span>.log(items.length);          <span class="comment">// 2</span></div><div class="line"><span class="built_in">console</span>.log(items[<span class="number">0</span>]);              <span class="comment">// 3</span></div><div class="line"><span class="built_in">console</span>.log(items[<span class="number">1</span>]);              <span class="comment">// "2"</span></div></pre></td></tr></table></figure>
<p><code>Array</code> 생성자가 하나의 숫자 값을 전달 받으면 <em>Array</em>의 <code>length</code> 프로퍼티는 그 값으로 설정됩니다. 숫자가 아닌 단일 값이 전달되면 해당 값은 <em>Array</em>의 유일한 항목이됩니다. 여러 값이 전달되면 (숫자 든 아니든) 해당 값은 <em>Array</em>의 항목이 됩니다. 전달되는 데이터의 유형을 항상 알지 못하기 때문에 이 동작은 혼란스럽고 위험합니다.</p>
<p>ECMAScript 6은 이 문제를 해결하기 위해 <code>Array.of()</code>를 도입했습니다. <code>Array.of ()</code> 메서드는 <code>Array</code> 생성자와 비슷하게 작동하지만 하나의 숫자 값에 대해서 특별한 경우가 없습니다. <code>Array.of()</code> 메서드는 파라미터의 개수나 타입에 상관없이 항상 파라미터를 포함하는 <em>Array</em>를 생성합니다. 다음은 <code>Array.of()</code> 메서드를 사용하는 예제들입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> items = <span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>);</div><div class="line"><span class="built_in">console</span>.log(items.length);          <span class="comment">// 2</span></div><div class="line"><span class="built_in">console</span>.log(items[<span class="number">0</span>]);              <span class="comment">// 1</span></div><div class="line"><span class="built_in">console</span>.log(items[<span class="number">1</span>]);              <span class="comment">// 2</span></div><div class="line"></div><div class="line">items = <span class="built_in">Array</span>.of(<span class="number">2</span>);</div><div class="line"><span class="built_in">console</span>.log(items.length);          <span class="comment">// 1</span></div><div class="line"><span class="built_in">console</span>.log(items[<span class="number">0</span>]);              <span class="comment">// 2</span></div><div class="line"></div><div class="line">items = <span class="built_in">Array</span>.of(<span class="string">"2"</span>);</div><div class="line"><span class="built_in">console</span>.log(items.length);          <span class="comment">// 1</span></div><div class="line"><span class="built_in">console</span>.log(items[<span class="number">0</span>]);              <span class="comment">// "2"</span></div></pre></td></tr></table></figure>
<p><code>Array.of()</code> 메서드로 <em>Array</em>를 생성하려면 <em>Array</em>에 원하는 값을 전달하면 됩니다. 여기서 첫 번째 예제는 두 개의 숫자를 포함하는 <em>Array</em>를 만들고 두 번째 <em>Array</em>는 한 개의 숫자를 포함하고 마지막 <em>Array</em>는 한 개의 문자열을 포함합니다. 이것은 <em>Array</em> 리터럴을 사용하는 것과 비슷하며, 대부분 네이티브 <em>Array</em> <code>Array.of()</code> 대신 <em>Array</em> 리터럴을 사용할 수 있습니다. 그러나 <code>Array</code> 생성자를 함수에 전달해야 한다면 일관된 동작을 보장하기 위해<code>Array.of()</code>를 대신 전달할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createArray</span>(<span class="params">arrayCreator, value</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> arrayCreator(value);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> items = createArray(<span class="built_in">Array</span>.of, value);</div></pre></td></tr></table></figure>
<p>이 코드에서 <code>createArray()</code> 함수는 <code>Array</code> 생성자 함수와 <em>Array</em>에 삽입할 값을 받아 들입니다. <code>Array.of()</code>를 <code>createArray()</code>의 첫번째 파라미터로 전달하여 새로운 <em>Array</em>를 만들 수 있습니다. <code>value</code>가 숫자가 아닐 것이라는 것을 보장할 수 없다면 <code>Array</code>를 직접 전달하는 것은 위험합니다.</p>
<blockquote>
<p><code>Array.of()</code> 메서드는 반환 값의 타입을 결정하기 위해 <code>Symbol.species</code> 프로퍼티 (9 장에서 설명됨)를 사용하지 않습니다. 대신 현재의 생성자 (<code>of()</code>메서드 내에 있는 <code>this</code>)를 사용하여 반환할 올바른 데이터 타입을 결정합니다.</p>
</blockquote>
<h3 id="Array-from-메서드"><a href="#Array-from-메서드" class="headerlink" title="Array.from() 메서드"></a>Array.from() 메서드</h3><p><em>Array</em>가 아닌 객체를 실제 <em>Array</em>로 변환하는 것은 JavaScript에서 항상 번거로운 작업이었습니다. 예를 들어, <em>Array</em>와 유사한<br> <code>arguments</code> 객체를 가지고 있고 <em>Array</em>처럼 사용하고 싶다면 먼저 변환해야합니다. <em>Array</em>와 유사한 객체를 ECMAScript 5의 <em>Array</em>로 변환하려고 다음 예제와 같은 함수를 작성합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeArray</span>(<span class="params">arrayLike</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> result = [];</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = arrayLike.length; i &lt; len; i++) &#123;</div><div class="line">        result.push(arrayLike[i]);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> args = makeArray(<span class="built_in">arguments</span>);</div><div class="line"></div><div class="line">    <span class="comment">// use args</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>이 방법은 수동으로 <code>result</code> <em>Array</em>를 만들고 <code>arguments</code>의 각 항목을 새로운 <em>Array</em>에 복사합니다. 이 방법이 효과가 있지만 비교적 간단한 작업을 수행하기 위해서 상당한 양의 코드가 필요합니다. 결국, 개발자들은 다음과 같이 <em>Array</em>와 유사한 객체에 <em>Array</em>의 Native <code>slice()</code> 메서드를 호출함으로써 코드의 양을 줄일 수 있다는 것을 발견했습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeArray</span>(<span class="params">arrayLike</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.slice.call(arrayLike);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> args = makeArray(<span class="built_in">arguments</span>);</div><div class="line"></div><div class="line">    <span class="comment">// use args</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>이 코드는 이전 예제와 기능적으로 동일하며, <code>slice()</code>에 대한 <code>this</code> 값을 <em>Array</em>와 유사한 객체로 설정하기 때문에 작동합니다. <code>slice()</code>는 숫자 인덱스와 <code>length</code> 프로퍼티만 있으면 올바르게 작동하기 때문에 <em>Array</em>와 유사한 객체가 잘 작동합니다.</p>
<p>이 기술은 타이핑이 덜 필요하지만 <code>Array.prototype.slice.call(arrayLike)</code> 호출은 분명히 <code>arrayLike</code>를 <em>Array</em>로 변환하지 않습니다. “다행히 ECMAScript 6은 <code>Array.from()</code> 메서드를 이용하여 객체를 <em>Array</em>로 변환하는 명백하고도 깨끗한 방법을 제공합니다.</p>
<p><em>Iterable</em> 또는 <em>Array</em>와 유사한 객체가 첫 번째 파라미터로 주어지면 <code>Array.from()</code> 메서드는 <em>Array</em>를 반환합니다. 다음은 간단한 예제입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>);</div><div class="line"></div><div class="line">    <span class="comment">// use args</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Array.from()</code> 호출은 <code>arguments</code>에 있는 항목을 기반으로 새로운 <em>Array</em>를 만듭니다. 그래서 <code>args</code>는 <code>arguments</code>와 같은 위치에 같은 값을 갖는 <code>Array</code>의 인스턴스입니다.</p>
<blockquote>
<p><code>Array.from()</code> 메서드는 <code>this</code>를 사용하여 반환할 <em>Array</em> 타입을 결정합니다.</p>
</blockquote>
<h4 id="매핑-변환-Mapping-Conversion"><a href="#매핑-변환-Mapping-Conversion" class="headerlink" title="매핑 변환 (Mapping Conversion)"></a>매핑 변환 (Mapping Conversion)</h4><p>한단계 더 나아가서 <em>Array</em> 변환을 원한다면 <code>Array.from()</code>에 매핑 함수를 두 번째 파라미터로 제공할 수 있습니다. 이 함수는 <em>Array</em>와 유사한 객체의 각 값에 대해 연산을 수행하고 결과를 최종 <em>Array</em>의 적절한 색인에 저장하기 전에 변환합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">translate</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>, (value) =&gt; value + <span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> numbers = translate(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(numbers);               <span class="comment">// 2,3,4</span></div></pre></td></tr></table></figure>
<p>여기서 <code>Array.from()</code>는 매핑 함수로 <code>(value) =&gt; value + 1</code>을 넘겨 주므로 항목을 저장하기 전에 <em>Array</em>의 각 항목에 1을 더합니다. 매핑 함수가 객체 상에 있다면, 매핑 함수를 위한 <code>this</code> 값을 <code>Array.from()</code>의 세 번째 파라미터에 선택적으로 전달할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> helper = &#123;</div><div class="line">    <span class="attr">diff</span>: <span class="number">1</span>,</div><div class="line"></div><div class="line">    add(value) &#123;</div><div class="line">        <span class="keyword">return</span> value + <span class="keyword">this</span>.diff;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">translate</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>, helper.add, helper);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> numbers = translate(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(numbers);               <span class="comment">// 2,3,4</span></div></pre></td></tr></table></figure>
<p>이 예제는 변환을 위한 매핑 함수로 <code>helper.add()</code>를 전달합니다. <code>helper.add()</code>는 <code>this.diff</code> 프로퍼티를 사용하기 때문에, <code>this</code>의 값을 지정하는 <code>Array.from()</code>에 세 번째 파라미터를 제공해야합니다. 세번째 파라미터 덕분에, <code>Array.from()</code>은 <code>bind()</code>를 호출하지 않거나 다른 방식으로 <code>this</code> 값을 지정하지 않고 쉽게 데이터를 변환할 수 있습니다.</p>
<h4 id="Iterables에서-사용하기"><a href="#Iterables에서-사용하기" class="headerlink" title="Iterables에서 사용하기"></a>Iterables에서 사용하기</h4><p><code>Array.from()</code> 메서드는 <em>Array</em>와 유사한 객체와 <em>Iterable</em>에서 실행가능합니다. 즉, 메서드는 <code>Symbol.iterator</code> 프로퍼티를 가진 객체를 <em>Array</em>로 변환할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> numbers = &#123;</div><div class="line">    *[<span class="built_in">Symbol</span>.iterator]() &#123;</div><div class="line">        <span class="keyword">yield</span> <span class="number">1</span>;</div><div class="line">        <span class="keyword">yield</span> <span class="number">2</span>;</div><div class="line">        <span class="keyword">yield</span> <span class="number">3</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> numbers2 = <span class="built_in">Array</span>.from(numbers, (value) =&gt; value + <span class="number">1</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(numbers2);              <span class="comment">// 2,3,4</span></div></pre></td></tr></table></figure>
<p><code>numbers</code> 객체는 <em>Iterable</em>이기 때문에 <code>numbers</code>를 직접 <code>Array.from()</code>에 전달하여 그 값을 <em>Array</em>로 변환할 수 있습니다. 매핑 함수는 각 숫자에 1을 더하여 결과 <em>Array</em>에 1, 2, 3 대신 2, 3, 4가 포함됩니다.</p>
<blockquote>
<p>객체가 <em>Array</em>와 유사하거나 <em>Iterable</em>한 경우 <code>Array.from()</code>에서 <em>Iterator</em>를 사용하여 변환할 값을 결정할 수 있습니다.</p>
</blockquote>
<h2 id="모든-Array에-대한-새로운-메서드"><a href="#모든-Array에-대한-새로운-메서드" class="headerlink" title="모든 Array에 대한 새로운 메서드"></a>모든 <em>Array</em>에 대한 새로운 메서드</h2><p>ECMAScript 5의 추세를 이어 가면서 ECMAScript 6는 <em>Array</em>에 몇가지 새로운 메서드를 추가했습니다. <code>find()</code> 및 <code>findIndex()</code> 메서드는 개발자가 <em>Array</em> 값을 사용하는 것을 돕기위한 것이지만, <code>fill()</code> 및 <code>copyWithin()</code>은 <em>Typed array</em>에 대한 유스 케이스에서 영감을 얻어 ECMAScript 6에 도입된 숫자만 사용하는 <em>Array</em> 형식입니다.</p>
<h3 id="find-및-findIndex-메서드"><a href="#find-및-findIndex-메서드" class="headerlink" title="find() 및 findIndex() 메서드"></a>find() 및 findIndex() 메서드</h3><p>ECMAScript 5 이전에는 <em>Array</em>를 검색하는 Built-in 메서드가 없었기 때문에 번거로운 작업이었습니다. ECMAScript 5에는 <code>indexOf()</code> 및 <code>lastIndexOf()</code> 메서드가 추가되었고, 개발자가 <em>Array</em> 내부의 특정 값을 검색할 수 있게되었습니다. 하지만 이 두가지 메서드는 크게 개선되었지만 한번에 하나의 값만 검색할 수 있어 상당히 제한적이었습니다. 예를 들어 일련의 숫자에서 첫번째 짝수를 찾으려면 코드를 직접 작성해야합니다. ECMAScript 6에서는 <code>find()</code> 및 <code>findIndex()</code> 메서드를 도입하여 이 문제를 해결했습니다.</p>
<p><code>find()</code>와 <code>findIndex()</code>는 두개의 파라미터를 받습니다(콜백함수와 콜백 함수 내에서 <code>this</code>에 사용할 선택적 값). 콜백 함수는 <em>Array</em>요소, <em>Array</em>에있는 해당 요소의 인덱스, <code>map()</code>과 <code>forEach()</code>와 같이 <em>Array</em> 자신을 전달하는 동일한 파라미터를 가집니다. 주어진 값이 당신이 정의한 어떤 기준과 일치하면 콜백은 <code>true</code>를 리턴해야합니다. <code>find()</code>와 <code>findIndex()</code>는 콜백 함수가 처음으로 <code>true</code>를 반환할 때 <em>Array</em> 검색을 중지합니다.</p>
<p>두 메서드의 유일한 차이점은 <code>find()</code>는 값을 반환하고 <code>findIndex()</code>는 값이 발견된 인덱스를 반환한다는 것입니다. 다음은 그 예를 보여줍니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> numbers = [<span class="number">25</span>, <span class="number">30</span>, <span class="number">35</span>, <span class="number">40</span>, <span class="number">45</span>];</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(numbers.find(<span class="function"><span class="params">n</span> =&gt;</span> n &gt; <span class="number">33</span>));         <span class="comment">// 35</span></div><div class="line"><span class="built_in">console</span>.log(numbers.findIndex(<span class="function"><span class="params">n</span> =&gt;</span> n &gt; <span class="number">33</span>));    <span class="comment">// 2</span></div></pre></td></tr></table></figure>
<p>이 <code>numbers</code> <em>Array</em>에서 33보다 큰 첫 번째 값을 찾기 위해 <code>find()</code>와 <code>findIndex()</code>를 호출합니다. <code>find()</code> 호출은 35를 반환하고<code>findIndex()</code>는 <code>numbers</code> <em>Array</em>에서 35의 위치인 2를 반환합니다.</p>
<p><code>find()</code>와 <code>findIndex()</code>는 값이 아닌 조건과 일치하는 <em>Array</em> 요소를 찾는 데 유용합니다. 하지만 값만을 찾고 싶다면 <code>indexOf()</code>와 <code>lastIndexOf()</code>가 더좋은 선택입니다.</p>
<h3 id="fill-메서드"><a href="#fill-메서드" class="headerlink" title="fill() 메서드"></a>fill() 메서드</h3><p><code>fill()</code> 메서드는 하나 이상의 <em>Array</em> 요소를 특정 값으로 채웁니다. 값이 전달되면, <code>fill()</code>은 <em>Array</em>의 모든 값을 그 값으로 덮어 씁니다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</div><div class="line"></div><div class="line">numbers.fill(<span class="number">1</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(numbers.toString());    <span class="comment">// 1,1,1,1</span></div></pre></td></tr></table></figure>
<p><code>numbers.fill(1)</code>을 호출하면 <code>numbers</code>의 모든 값이 1로 변경됩니다. 모든 요소가 아닌 일부 요소만 변경하려는 경우 시작 인덱스와 배타적 종료 인덱스(종료 인덱스는 포함되지 않음.)를 추가할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</div><div class="line"></div><div class="line">numbers.fill(<span class="number">1</span>, <span class="number">2</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(numbers.toString());    <span class="comment">// 1,2,1,1</span></div><div class="line"></div><div class="line">numbers.fill(<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(numbers.toString());    <span class="comment">// 1,0,0,1</span></div></pre></td></tr></table></figure>
<p><code>numbers.fill(1,2)</code>호출에서 2는 인덱스 2의 요소부터 채우는 것을 시작한다는 것을 나타냅니다. 배타적 종료 인덱스가 세 번째 파라미터로 지정되지 않으므로 <code>numbers.length</code>가 종료 인덱스로 사용됩니다 <code>numbers.fill(0, 1, 3)</code> 연산은 인덱스 1과 2의 <em>Array</em>요소를 0으로 채웁니다. 두 번째와 세 번째 인자로 <code>fill()</code>을 호출하면 전체 <em>Array</em>를 덮어 쓰지 않고 한 번에 여러 <em>Array</em> 요소를 채울 수 있습니다.</p>
<blockquote>
<p>시작 또는 끝 인덱스가 음수이면 <em>Array</em>의 길이에 해당 값이 추가되어 최종 위치가 결정됩니다. 예를 들어, <code>array</code>가 <code>fill()</code>이 호출되는 <em>Array</em>이고, 시작 인덱스가 <code>-1</code>이면 인덱스는 <code>array.length - 1</code>입니다.</p>
</blockquote>
<h3 id="copyWithin-메서드"><a href="#copyWithin-메서드" class="headerlink" title="copyWithin() 메서드"></a>copyWithin() 메서드</h3><p><code>copyWithin()</code> 메서드는 <em>Array</em>의 여러 요소를 동시에 변경한다는 점에서 <code>fill()</code>과 유사합니다. 그러나 <em>Array</em> 요소에 할당할 단일 값을 지정하는 대신 <code>copyWithin()</code>을 사용하면 <em>Array</em> 자체에서 <em>Array</em> 요소 값을 복사할 수 있습니다. 이를 수행하려면 <code>copyWithin()</code> 메서드에 두개의 파라미터, 즉 메서드가 값을 채우기 시작할 인덱스와 복사할 값이 시작되는 인덱스를 전달해야합니다.</p>
<p>예를 들어 <em>Array</em>의 처음 두 요소의 값을 <em>Array</em>의 마지막 두 항목에 복사하려면 다음 코드를 실행합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</div><div class="line"></div><div class="line"><span class="comment">// 인덱스 2부터 인덱스 0에 있는 값을 붙여 넣습니다.</span></div><div class="line">numbers.copyWithin(<span class="number">2</span>, <span class="number">0</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(numbers.toString());    <span class="comment">// 1,2,1,2</span></div></pre></td></tr></table></figure>
<p>이 코드는 인덱스 2에서 시작하는 값을 <code>numbers</code>에 붙여 넣기 때문에 인덱스 2와 3이 모두 덮어 쓰여집니다. <code>copyWithin()</code>의 두번째 파라미터로 <code>0</code>을 전달하면 인덱스 0에서 값을 복사하기 시작하고 복사할 요소가 없어질 때까지 계속 진행됩니다.</p>
<p>기본적으로, <code>copyWithin()</code>은 항상 <em>Array</em>의 끝까지 값을 복사하지만 선택적인 세번째 파라미터를 제공하면 덮어쓸 요소의 개수를 제한할 수 있습니다. 세번째 파라미터는 값 복사가 중지되는 배타적 종료 인덱스(종료 인덱스는 포함되지 않음.)입니다. 다음은 그 예제입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</div><div class="line"></div><div class="line"><span class="comment">// 인덱스 2번부터, 인덱스 0에 있는 값부터 인덱스 1번 이전 지점(0번 인덱스까지)까지의 값으로 채워 넣습니다.</span></div><div class="line">numbers.copyWithin(<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(numbers.toString());    <span class="comment">// 1,2,1,4</span></div></pre></td></tr></table></figure>
<p>이 예제에서는 선택적 종료 인덱스가 <code>1</code>로 설정되어 있기 때문에 인덱스 0의 값만 복사됩니다. <em>Array</em>의 마지막 요소는 변경되지 않습니다.</p>
<blockquote>
<p><code>fill()</code> 메서드와 마찬가지로 <code>copyWithin()</code> 메서드의 파라미터에 음수를 전달하면 <em>Array</em>의 길이가 자동으로 해당 값에 추가되어 인덱스를 결정합니다.</p>
</blockquote>
<p>이 시점에서 <code>fill()</code>과 <code>copyWithin()</code> 메서드의 이용 사례는 여러분에게 명확하지 않을 수도 있습니다. 이 메서드들은 <em>Typed array</em>에서 유래되었고 일관성을 위해 일반 <em>Array</em>에 추가 되었기 때문입니다. 그러나 다음 절에서 배우 겠지만, 숫자의 비트를 조작하기 위해 <em>Typed array</em>를 사용하면, 이 메서드들은 훨씬 더 유용합니다.</p>
<h2 id="Typed-Array"><a href="#Typed-Array" class="headerlink" title="Typed Array"></a>Typed Array</h2><p><em>Typed array</em>는 숫자 타입 (이름에서 암시하듯이 모든 타입이 아닌)을 처리하도록 설계된 특수 용도의 <em>Array</em>입니다. <em>Typed array</em>의 기원은 OpenGL ES 2.0의 port인 WebGL이며, <code>&lt;canvas&gt;</code> 엘리먼트가 있는 웹 페이지에서 사용하도록 설계되었습니다. <em>Typed array</em>는 JavaScript에서 빠른 비트 연산을 제공하기 위해 만들어졌습니다.</p>
<p>Native JavaScript의 대한 숫자 계산 연산은 WebGL에서 너무 느렸습니다. 왜냐하면 숫자가 64 비트 부동 소수점 포맷으로 저장되고 필요에 따라 32 비트 정수로 변환 되었기 때문입니다. 이 제한 사항을 우회하고 계산 연산에 더 나은 성능을 제공하기 위해 <em>Typed array</em>가 도입되었습니다. 개념은 모든 단일 숫자를 비트 <em>Array</em>처럼 취급할 수 있으므로 JavaScript <em>Array</em>에서 사용할 수있는 익숙한 메서드를 사용할 수 있다는 것입니다.</p>
<p>ECMAScript 6는 JavaScript 엔진 전반에 걸친 더 나은 호환성과 JavaScript <em>Array</em>와의 상호 운용성을 보장하기 위해 <em>Typed array</em>를 언어의 공식적인 부분으로 채택했습니다. ECMAScript 6 버전의 <em>Typed array</em>는  WebGL 버전과 완전히 똑같지는 않고, ECMAScript 6 버전을 WebGL 버전의 확장 버전으로 생각할 수 있습니다.</p>
<h3 id="숫자-데이터-타입-Numeric-Data-Types"><a href="#숫자-데이터-타입-Numeric-Data-Types" class="headerlink" title="숫자 데이터 타입(Numeric Data Types)"></a>숫자 데이터 타입(Numeric Data Types)</h3><p>JavaScript 숫자는 64 비트를 사용하여 숫자의 부동 소수점 표현을 저장하는 IEEE 754 형식으로 저장됩니다. 이 형식은 JavaScript에서 정수 및 부동 소수점을 모두 나타내며 두 형식 간의 변환은 숫자가 바뀌면서 자주 발생합니다. <em>Typed array</em>를 사용하면 아래의 8 가지 숫자 타입을 저장하고 조작할 수 있습니다.</p>
<ol>
<li>Signed 8-bit integer (int8)</li>
<li>Unsigned 8-bit integer (uint8)</li>
<li>Signed 16-bit integer (int16)</li>
<li>Unsigned 16-bit integer (uint16)</li>
<li>Signed 32-bit integer (int32)</li>
<li>Unsigned 32-bit integer (uint32)</li>
<li>32-bit float (float32)</li>
<li>64-bit float (float64)</li>
</ol>
<p>int8에 맞는 숫자를 일반적인 JavaScript Number 타입으로 나타내면 56 비트가 낭비됩니다. 이러한 비트는 추가 int8 값 또는 56 비트 미만을 필요로하는 다른 숫자를 저장하는 데 사용하는 것이 좋습니다. 비트를 보다 효율적으로 사용하는 것은 <em>Typed array</em>의 사용 예중 하나입니다.</p>
<p><em>Typed array</em>와 관련된 모든 연산 및 객체는 이 8 가지 데이터 타입을 중심으로 배치됩니다. 그러나 이들을 사용하려면 <em>Array Buffer</em>를 만들어 데이터를 저장해야합니다.</p>
<blockquote>
<p>이 책에서는 괄호 안에 보여준 약어들로 이 타입들을 언급할 것입니다. 이러한 약어는 실제 JavaScript 코드에는 나타나지 않습니다. 단지<br> 더 긴 설명들에 대한 약어 일뿐입니다.</p>
</blockquote>
<h3 id="Array-Buffer"><a href="#Array-Buffer" class="headerlink" title="Array Buffer"></a>Array Buffer</h3><p>모든 <em>Typed array</em>의 기초는 <em>Array Buffer</em>입니다. <em>Array Buffer</em>는 지정된 바이트 수를 포함할 수있는 메모리입니다. <em>Array Buffer</em>를 만드는 것은 C 언어에서 <code>malloc()</code>을 호출하여 메모리를 할당하는 것과 비슷합니다. 다음과 같이 <code>ArrayBuffer</code> 생성자를 사용하여 <em>Array Buffer</em>를 생성할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">10</span>);   <span class="comment">// 10 bytes 할당</span></div></pre></td></tr></table></figure>
<p><em>Array Buffer</em>가 생성자를 호출할 때 포함해야하는 바이트 수를 전달합니다. <code>let</code> 문장은 10 바이트 길이의 <em>Array Buffer</em>를 생성합니다. <em>Array Buffer</em>가 생성되면, <code>byteLength</code> 프로퍼티를 체크함으로써 바이트 수를 확인할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">10</span>);   <span class="comment">// 10 bytes 할당</span></div><div class="line"><span class="built_in">console</span>.log(buffer.byteLength);     <span class="comment">// 10</span></div></pre></td></tr></table></figure>
<p>또한 <code>slice()</code> 메서드를 사용하여 기존 <em>Array Buffer</em>의 일부를 포함하는 새로운 <em>Array Buffer</em>를 생성할 수 있습니다. <code>slice()</code> 메서드는 <em>Array</em>의 <code>slice()</code> 메서드와 같이 작동합니다. 여러분은 시작 인덱스와 끝 인덱스를 파라미터로 넘기고, 원래의 요소로 구성된 새로운 <code>ArrayBuffer</code> 인스턴스를 얻을수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">10</span>);   <span class="comment">// allocate 10 bytes</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">let</span> buffer2 = buffer.slice(<span class="number">4</span>, <span class="number">6</span>);</div><div class="line"><span class="built_in">console</span>.log(buffer2.byteLength);    <span class="comment">// 2</span></div></pre></td></tr></table></figure>
<p>위 코드에서, <code>buffer2</code>는 인덱스 4와 5에서 바이트를 추출하여 생성됩니다. 이 메소드의 <em>Array</em> 버전을 호출할 때와 마찬가지로 <code>slice()</code>의 두 번째 파라미터는 배타적(포함되지 않습니다.)입니다.</p>
<p>이렇게 저장 위치를 만들었지만 데이터를 쓸 수 없으면 별로 도움이되지 않습니다. 데이터를 쓰려면 <em>View</em>를 만들어야합니다.</p>
<blockquote>
<p><em>Array Buffer</em>는 항상 생성될 때 지정된 정확한 바이트 수를 나타냅니다. <em>Array Buffer</em> 내에 포함된 데이터는 변경할 수 있지만 <em>Array Buffer</em> 자체의 크기는 변경할 수 없습니다.</p>
</blockquote>
<h3 id="View를-사용하여-Array-Buffer-조작하기"><a href="#View를-사용하여-Array-Buffer-조작하기" class="headerlink" title="View를 사용하여 Array Buffer 조작하기"></a><em>View</em>를 사용하여 <em>Array Buffer</em> 조작하기</h3><p><em>Array Buffer</em>는 메모리 위치를 나타내며, <em>View</em>는 해당 메모리를 조작하는 데 사용할 인터페이스입니다. <em>View</em>는 <em>Array Buffer</em> 또는 <em>Array Buffer</em>의 하위 집합에서 작동하며 숫자 데이터 타입중 하나에 데이터를 읽고 씁니다. <code>DataView</code> 타입은 8개의 모든 숫자 데이터 타입에 대해 조작할 수있는 <em>Array Buffer</em>의 일반 <em>View</em>입니다.</p>
<p><code>DataView</code>를 사용하려면 먼저 <code>ArrayBuffer</code>의 인스턴스를 생성하고 그것을 사용하여 새로운 <code>DataView</code>를 만듭니다. 다음 예제를 살펴보겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">10</span>),</div><div class="line">    view = <span class="keyword">new</span> <span class="built_in">DataView</span>(buffer);</div></pre></td></tr></table></figure>
<p>이 예제의 <code>view</code> 객체는 <code>buffer</code>의 10 바이트 모두에 접근할 수 있습니다. 그리고 <em>Buffer</em>의 일부분에만 <em>View</em>를 생성할 수도 있습니다. 바이트의 시작 오프셋과 포함할 바이트 수를 선택적으로 입력가능합니다. 포함할 바이트 수를 입력하지 않으면, <code>DataView</code>는 기본적으로 시작 오프셋에서 버퍼 끝까지 선택됩니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">10</span>),</div><div class="line">    view = <span class="keyword">new</span> <span class="built_in">DataView</span>(buffer, <span class="number">5</span>, <span class="number">2</span>);      <span class="comment">// 5, 6번째 바이트를 포함합니다.</span></div></pre></td></tr></table></figure>
<p>여기서 <code>view</code>는 인덱스 5와 6의 바이트에서만 작동합니다. 이 방법을 사용하면 동일한 <em>Array Buffer</em>를 통해 여러 <em>View</em>를 만들 수 있습니다. 이는 전체 응용프로그램에서 필요에 따라 동적이 아닌 단일 메모리 위치를 사용하려는 경우 유용할 수 있습니다.</p>
<h4 id="View-정보-가져-오기"><a href="#View-정보-가져-오기" class="headerlink" title="View 정보 가져 오기"></a><em>View</em> 정보 가져 오기</h4><p>다음과 같은 읽기 전용 속성을 가져 와서 뷰에 대한 정보를 검색할 수 있습니다.</p>
<ul>
<li><code>buffer</code> - <em>View</em>가 연결된 <em>Array Buffer</em>입니다.</li>
<li><code>byteOffset</code> - 제공된 경우 <code>DataView</code> 생성자에 대한 두 번째 파라미터(기본값 : 0).</li>
<li><code>byteLength</code> - 제공된 경우 <code>DataView</code> 생성자에 대한 세 번째 파라미터(기본적으로 버퍼의 <code>byteLength</code>).</li>
</ul>
<p>이러한 프로퍼티를 사용하면 다음과 같이 <em>View</em>가 작동중인 위치를 정확하게 검사할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">10</span>),</div><div class="line">    view1 = <span class="keyword">new</span> <span class="built_in">DataView</span>(buffer),           <span class="comment">// cover all bytes</span></div><div class="line">    view2 = <span class="keyword">new</span> <span class="built_in">DataView</span>(buffer, <span class="number">5</span>, <span class="number">2</span>);     <span class="comment">// cover bytes 5 and 6</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(view1.buffer === buffer);       <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(view2.buffer === buffer);       <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(view1.byteOffset);              <span class="comment">// 0</span></div><div class="line"><span class="built_in">console</span>.log(view2.byteOffset);              <span class="comment">// 5</span></div><div class="line"><span class="built_in">console</span>.log(view1.byteLength);              <span class="comment">// 10</span></div><div class="line"><span class="built_in">console</span>.log(view2.byteLength);              <span class="comment">// 2</span></div></pre></td></tr></table></figure>
<p>이 코드는 전체 <em>Array Buffer</em>에 대한 <em>View</em>인 <code>view1</code>과 <em>Array Buffer</em>의 작은 섹션에 대해 작동하는 <code>view2</code>를 생성합니다. 이 <em>View</em>는 모두 동일한 <em>Array Buffer</em>에서 작동하기 때문에 동일한 <code>buffer</code> 프로퍼티를 갖습니다. 그러나 <code>byteOffset</code>과 <code>byteLength</code>는 각 <em>View</em>마다 다릅니다. 각 <em>View</em>가 작동하는 <em>Array Buffer</em> 부분을 반영합니다.</p>
<p>물론 메모리에 대한 정보만 읽는 것은 그다지 유용하지 않습니다. 이점을 얻으려면 해당 메모리에 데이터를 쓰고 해당 메모리에서 데이터를 읽을 수 있어야합니다.</p>
<h4 id="데이터-읽고-쓰기"><a href="#데이터-읽고-쓰기" class="headerlink" title="데이터 읽고 쓰기"></a>데이터 읽고 쓰기</h4><p>JavaScript의 8가지 숫자 데이터 타입 각각에 대해 <code>DataView</code> 프로토 타입에는 <em>Array Buffer</em>에서 데이터를 쓰는 메서드와 읽는 메서드가 있습니다. 메서드 이름은 모두 “set”또는 “get”로 시작하고 그 뒤에 데이터 타입 약어가 옵니다. 예를 들어 다음은 int8 및 uint8 값에서 작동할 수있는 읽기 및 쓰기 메서드 목록입니다.</p>
<ul>
<li><code>getInt8(byteOffset, littleEndian)</code> - <code>byteOffset</code>에서 시작하는 int8 읽기</li>
<li><code>setInt8(byteOffset, value, littleEndian)</code> - <code>byteOffset</code>에서 시작하는 int8 쓰기</li>
<li><code>getUint8(byteOffset, littleEndian)</code> - <code>byteOffset</code>에서 시작하는 uint8 읽기</li>
<li><code>setUint8(byteOffset, value, littleEndian)</code> - <code>byteOffset</code>에서 시작하는 uint8 쓰기</li>
</ul>
<p>“get” 메서드는 두개의 파라미터, 즉 읽을 바이트 오프셋과 값을 리틀 엔디안으로 읽어야하는지 여부를 나타내는 선택적 값을 사용합니다. (리틀 엔디안은 최하위 바이트가 마지막 바이트 대신에 바이트 0에 있음을 의미합니다.) “set” 메서드는 3 개의 파라미터, 즉 쓸 바이트 오프셋, 쓸 값, 그리고 값이 리틀 엔디안 형식으로 저장되어야 하는지를 나타냅니다.</p>
<p>8 비트 값과 함께 사용할 수있는 메서드만 보여 주었지만 16 비트 값과 32 비트 값에서 동일한 메서드를 사용할 수 있습니다. 각 이름의 <code>8</code>을 <code>16</code>또는 <code>32</code>로 바꾸면 됩니다. 모든 정수 메서드와 함께, <code>DataView</code>는 또한 부동 소수점 수에 대해 다음과 같은 읽기 및 쓰기 메서드를 가지고 있습니다.</p>
<ul>
<li><code>getFloat32(byteOffset, littleEndian)</code> - <code>byteOffset</code>에서 시작하는 float32 읽기</li>
<li><code>setFloat32(byteOffset, value, littleEndian)</code> - <code>byteOffset</code>에서 시작하는 float32 쓰기</li>
<li><code>getFloat64(byteOffset, littleEndian)</code> - <code>byteOffset</code>에서 시작하는 float64 읽기</li>
<li><code>setFloat64(byteOffset, value, littleEndian)</code> - <code>byteOffset</code>에서 시작하는 float64 쓰기</li>
</ul>
<p>“set”및 “get” 메서드는 다음 예제를 참고하십시오.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">2</span>),</div><div class="line">    view = <span class="keyword">new</span> <span class="built_in">DataView</span>(buffer);</div><div class="line"></div><div class="line">view.setInt8(<span class="number">0</span>, <span class="number">5</span>);</div><div class="line">view.setInt8(<span class="number">1</span>, <span class="number">-1</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(view.getInt8(<span class="number">0</span>));       <span class="comment">// 5</span></div><div class="line"><span class="built_in">console</span>.log(view.getInt8(<span class="number">1</span>));       <span class="comment">// -1</span></div></pre></td></tr></table></figure>
<p>이 코드는 2바이트 <em>Array Buffer</em>를 사용하여 두개의 int8 값을 저장합니다. 첫번째 값은 오프셋 0에서 설정되고 두번째 값은 오프셋 1에서 각 값이 전체 바이트 (8 비트)에 걸쳐 반영됩니다. 이러한 값은 나중에 <code>getInt8()</code> 메서드로 위치에서 읽을 수 있습니다. 이 예제에서는 int8 값을 사용하지만 8가지 숫자 타입중 하나를 해당 메서드와 함께 사용할 수 있습니다.</p>
<p><em>View</em>는 데이터가 이전에 저장된 방식에 관계없이 언제든지 어떤 형식으로든 읽고 쓸수 있기 때문에 흥미롭습니다. 예를 들어 두개의 int8 값을 쓰고 int16 메서드로 <em>Buffer</em>를 읽는 다음 예제를 살펴보겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">2</span>),</div><div class="line">    view = <span class="keyword">new</span> <span class="built_in">DataView</span>(buffer);</div><div class="line"></div><div class="line">view.setInt8(<span class="number">0</span>, <span class="number">5</span>);</div><div class="line">view.setInt8(<span class="number">1</span>, <span class="number">-1</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(view.getInt16(<span class="number">0</span>));      <span class="comment">// 1535</span></div><div class="line"><span class="built_in">console</span>.log(view.getInt8(<span class="number">0</span>));       <span class="comment">// 5</span></div><div class="line"><span class="built_in">console</span>.log(view.getInt8(<span class="number">1</span>));       <span class="comment">// -1</span></div></pre></td></tr></table></figure>
<p><code>view.getInt16(0)</code>에 대한 호출은 <em>View</em>의 모든 바이트를 읽고 그 바이트를 숫자 1535로 해석합니다. 왜 이런 일이 발생하는지 이해하려면 예제에서 각 <code>setInt8()</code>이 <em>Array Buffer</em>에 어떤 작업을 하는지 살펴 보면 됩니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">2</span>)      <span class="comment">// 0000000000000000</span></div><div class="line">view.setInt8(<span class="number">0</span>, <span class="number">5</span>);     <span class="comment">// 0000010100000000</span></div><div class="line">view.setInt8(<span class="number">1</span>, <span class="number">-1</span>);    <span class="comment">// 0000010111111111</span></div></pre></td></tr></table></figure>
<p><em>Array Buffer</em>는 모두 0 인 16비트로 시작합니다. <code>setInt8()</code>으로 첫번째 바이트에 <code>5</code>를 쓰면 8 비트 표현으로 00000101 입력됩니다. 두번째 바이트에 -1을 쓰면 해당 바이트의 모든 비트가 1로 설정되며, 이는 -1의 2의 보수 표현입니다. 두번째 <code>setInt8()</code>호출 후에, <em>Array Buffer</em>는 16비트를 포함하고, <code>getInt16()</code>은 그 비트들을 십진수로 1535인 하나의 16비트 정수로 읽습니다.</p>
<p><code>DataView</code> 객체는 이런식으로 다른 데이터 타입을 혼합하여 사용하는 경우에 유용합니다. 그러나 하나의 특정 데이터 타입만 사용하는 경우 타입 특화 <em>View</em>가 더 나은 선택일 수 있습니다.</p>
<h4 id="Typed-Array는-View입니다"><a href="#Typed-Array는-View입니다" class="headerlink" title="Typed Array는 View입니다."></a><em>Typed Array</em>는 <em>View</em>입니다.</h4><p>ECMAScript 6 <em>Typed Array</em>는 실제로 <em>Array Buffer</em>의 타입별 <em>View</em>입니다. 일반 <code>DataView</code> 객체를 사용하여 <em>Array Buffer</em>를 조작하는 대신 특정 데이터 타입을 적용하는 객체를 사용할 수 있습니다. 8 개의 숫자 데이터 타입에 해당하는 8 개의 타입별 <em>View</em>와 <code>uint8</code> 값에 대한 추가 옵션이 있습니다.</p>
<p>아래 표에서는 ECMAScript 6 사양의 타입별 <em>View</em>의 전체 목록을 간략하게 보여줍니다.</p>
<table>
<thead>
<tr>
<th>생성자 이름</th>
<th>크기 (byte)</th>
<th>설명</th>
<th>C언어의 동일 타입</th>
</tr>
</thead>
<tbody>
<tr>
<td>Int8Array</td>
<td>1</td>
<td>8-bit 부호있는 정수</td>
<td>signed char</td>
</tr>
<tr>
<td>Uint8Array</td>
<td>1</td>
<td>8-bit 부호없는 정수</td>
<td>unsigned char</td>
</tr>
<tr>
<td>Uint8ClampedArray</td>
<td>1</td>
<td>8-bit 부호없는 정수 (값 범위가 0~255로 제한됨)</td>
<td>unsigned char</td>
</tr>
<tr>
<td>Int16Array</td>
<td>2</td>
<td>16-bit 부호있는 정수</td>
<td>short</td>
</tr>
<tr>
<td>Uint16Array</td>
<td>2</td>
<td>16-bit 부호없는 정수</td>
<td>unsigned short</td>
</tr>
<tr>
<td>Int32Array</td>
<td>4</td>
<td>32-bit 부호있는 정수</td>
<td>int</td>
</tr>
<tr>
<td>Uint32Array</td>
<td>4</td>
<td>32-bit 부호없는 정수</td>
<td>int</td>
</tr>
<tr>
<td>Float32Array</td>
<td>4</td>
<td>32-bit IEEE 부동 소수점</td>
<td>float</td>
</tr>
<tr>
<td>Float64Array</td>
<td>8</td>
<td>64-bit IEEE 부동 소수점</td>
<td>double</td>
</tr>
</tbody>
</table>
<p>왼쪽 열은 <em>Typed Array</em> 생성자를 나열하고 다른 열은 <em>Typed Array</em>에 포함할 수있는 데이터를 설명합니다. <code>Uint8ClampedArray</code>는 <em>Array Buffer</em>의 값이 0보다 작거나 255보다 크지 않으면 <code>Uint8Array</code>와 같습니다. <code>Uint8ClampedArray</code>는 0보다 작은 값을 0으로 변환하고(-1은 0이되고) 255보다 큰 값은 255로 변환합니다(300은 255가됩니다).</p>
<p><em>Typed Array</em> 연산은 특정 타입의 데이터에서만 작동합니다. 예를 들어 <code>Int8Array</code>의 모든 연산은 <code>int8</code> 값을 사용합니다. <em>Typed Array</em>의 요소 크기는 <em>Array</em>의 타입에 따라 다릅니다. <code>Int8Array</code>의 요소는 한 바이트 길이이고, <code>Float64Array</code> 요소는 8바이트를 사용합니다. 다행스럽게도 요소는 일반 <em>Array</em>처럼 숫자 인덱스를 사용하여 액세스하므로 <code>DataView</code>의 “set”및 “get” 메서드에 대한 다소 어색한 호출을 피할 수 있습니다.</p>
<h4 id="요소-크기"><a href="#요소-크기" class="headerlink" title="요소 크기"></a>요소 크기</h4><p><em>Typed Array</em>는 여러 요소로 구성되며 요소 크기는 각 요소가 나타내는 바이트 수입니다. 이 값은 각 생성자 및 각 인스턴스의 <code>BYTES_PER_ELEMENT</code> 프로퍼티에 저장되므로 요소 크기를 쉽게 확인할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(UInt8Array.BYTES_PER_ELEMENT);      <span class="comment">// 1</span></div><div class="line"><span class="built_in">console</span>.log(UInt16Array.BYTES_PER_ELEMENT);     <span class="comment">// 2</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> ints = <span class="keyword">new</span> <span class="built_in">Int8Array</span>(<span class="number">5</span>);</div><div class="line"><span class="built_in">console</span>.log(ints.BYTES_PER_ELEMENT);            <span class="comment">// 1</span></div></pre></td></tr></table></figure>
<h4 id="타입-특화-View-만들기"><a href="#타입-특화-View-만들기" class="headerlink" title="타입 특화 View 만들기"></a>타입 특화 <em>View</em> 만들기</h4><p><em>Typed Array</em> 생성자는 여러개의 파라미터를 허용하므로 <em>Typed Array</em>를 만드는 데는 몇 가지 방법이 있습니다. 먼저, <code>DataView</code>에서 사용하는 것과 동일한 파라미터 (<em>Array Buffer</em>, 선택적 바이트 오프셋 및 선택적 바이트 길이)를 전달하여 새로운 <em>Typed Array</em>를 만들 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">10</span>),</div><div class="line">    view1 = <span class="keyword">new</span> <span class="built_in">Int8Array</span>(buffer),</div><div class="line">    view2 = <span class="keyword">new</span> <span class="built_in">Int8Array</span>(buffer, <span class="number">5</span>, <span class="number">2</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(view1.buffer === buffer);       <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(view2.buffer === buffer);       <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(view1.byteOffset);              <span class="comment">// 0</span></div><div class="line"><span class="built_in">console</span>.log(view2.byteOffset);              <span class="comment">// 5</span></div><div class="line"><span class="built_in">console</span>.log(view1.byteLength);              <span class="comment">// 10</span></div><div class="line"><span class="built_in">console</span>.log(view2.byteLength);              <span class="comment">// 2</span></div></pre></td></tr></table></figure>
<p>이 코드에서 두 개의 <em>View</em>는 모두 <code>buffer</code>를 사용하는 두 개의 <code>Int8Array</code> 인스턴스입니다. <code>view1</code>과 <code>view2</code>는 <code>DataView</code> 인스턴스 상에 존재하는<code>buffer</code>, <code>byteOffset</code>, <code>byteLength</code> 프로퍼티와 같습니다. 하나의 숫자 타입으로만 작업하면 <code>DataView</code>를 사용할 때 <em>Typed Array</em>를 사용하는 것으로 쉽게 전환할 수 있습니다.</p>
<p><em>Typed Array</em>를 만드는 두 번째 방법은 숫자 하나를 생성자에 전달하는 것입니다. 이 숫자는 <em>Array</em>에 할당할 요소 개수 (바이트가 아님)를 나타냅니다. 생성자는 <em>Array</em> 요소의 개수를 나타내는 올바른 바이트 수를 가진 새로운 <em>Buffer</em>를 만들고 <code>length</code> 프로퍼티를 사용하여 <em>Array</em>의 요소 개수를 액세스할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> ints = <span class="keyword">new</span> <span class="built_in">Int16Array</span>(<span class="number">2</span>),</div><div class="line">    floats = <span class="keyword">new</span> <span class="built_in">Float32Array</span>(<span class="number">5</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(ints.byteLength);       <span class="comment">// 4</span></div><div class="line"><span class="built_in">console</span>.log(ints.length);           <span class="comment">// 2</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(floats.byteLength);     <span class="comment">// 20</span></div><div class="line"><span class="built_in">console</span>.log(floats.length);         <span class="comment">// 5</span></div></pre></td></tr></table></figure>
<p><code>ints</code> <em>Array</em>는 두 요소를 위한 공간을 가지고 생성됩니다. 각 16 비트 정수는 값 당 2바이트를 필요로하므로 <em>Array</em>에는 4 바이트가 할당됩니다. <code>floats</code> <em>Array</em>는 5개의 원소를 저장하기 위해 만들어지므로 필요한 바이트 수는 20개 (요소 당 4 바이트)입니다. 두 경우 모두 새로운 <em>Buffer</em>가 생성되고 필요할 경우 <code>buffer</code> 프로퍼티를 사용하여 액세스 할 수 있습니다.</p>
<blockquote>
<p><em>Typed Array</em> 생성자에 파라미터가 전달되지 않으면 생성자는 <code>0</code>이 전달된 것처럼 작동합니다. 이렇게하면 0바이트가 <em>Buffer</em>에 할당되므로 데이터를 저장할 수 없는 <em>Typed Array</em>가 만들어집니다.</p>
</blockquote>
<p><em>Typed Array</em>을 만드는 세 번째 방법은 객체를 파라미터로 생성자에 전달하는 것입니다. 객체는 다음 중 하나일 수 있습니다.</p>
<ul>
<li><em>Typed Array</em> - 각 요소는 입력된 새로운 <em>Array</em>의 새 요소에 복사됩니다. 예를 들어 int8을 <code>Int16Array</code> 생성자에 전달하면 int8 값이 int16 <em>Array</em>에 복사됩니다. 새 <em>Typed Array</em>에는 전달된 <em>Array Buffer</em>와 다른 <em>Array Buffer</em>가 사용됩니다.</li>
<li><em>Iterable</em> - 객체의 <em>Iterator</em>가 호출되어 입력된 <em>Array</em>에 삽입할 항목을 검색합니다. <em>View</em> 타입에 대해 유효하지 않은 요소가 있으면 생성자에서 오류가 발생합니다.</li>
<li><em>Array</em> - <em>Array</em> 요소가 새로운 <em>Typed Array</em>로 복사됩니다. 타입에 대해 유효하지 않은 요소가 있으면 생성자에서 오류가 발생합니다.</li>
<li>유사 <em>Array</em> 객체 - <em>Array</em>와 동일하게 작동합니다.</li>
</ul>
<p>이 경우 각각 소스 객체의 데이터로 새로운 <em>Typed Array</em>가 만들어집니다. 이것은 다음과 같이 일부 값으로 입력된 <em>Array</em>를 초기화하려는 경우에 특히 유용할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> ints1 = <span class="keyword">new</span> <span class="built_in">Int16Array</span>([<span class="number">25</span>, <span class="number">50</span>]),</div><div class="line">    ints2 = <span class="keyword">new</span> <span class="built_in">Int32Array</span>(ints1);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(ints1.buffer === ints2.buffer);     <span class="comment">// false</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(ints1.byteLength);      <span class="comment">// 4</span></div><div class="line"><span class="built_in">console</span>.log(ints1.length);          <span class="comment">// 2</span></div><div class="line"><span class="built_in">console</span>.log(ints1[<span class="number">0</span>]);              <span class="comment">// 25</span></div><div class="line"><span class="built_in">console</span>.log(ints1[<span class="number">1</span>]);              <span class="comment">// 50</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(ints2.byteLength);      <span class="comment">// 8</span></div><div class="line"><span class="built_in">console</span>.log(ints2.length);          <span class="comment">// 2</span></div><div class="line"><span class="built_in">console</span>.log(ints2[<span class="number">0</span>]);              <span class="comment">// 25</span></div><div class="line"><span class="built_in">console</span>.log(ints2[<span class="number">1</span>]);              <span class="comment">// 50</span></div></pre></td></tr></table></figure>
<p>이 예제는 <code>Int16Array</code>를 생성하고 두개의 값을 가지는 <em>Array</em>로 초기화합니다. 그런 다음 <code>Int32Array</code>가 만들어지고 <code>Int16Array</code>가 전달됩니다. 값 25와 50은 두 개의 <em>Typed Array</em>가 완전히 별도의 <em>Buffer</em>를 가지므로 <code>ints1</code>에서 <code>ints2</code>로 복사됩니다. 동일한 숫자는 두 입력된 <em>Array</em> 모두에 표시되지만 <code>ints2</code>는 데이터를 나타내는 데 8바이트를 사용하고 <code>ints1</code>는 4바이트를 사용합니다.</p>
<h2 id="Typed-Array와-기존-Array의-유사점"><a href="#Typed-Array와-기존-Array의-유사점" class="headerlink" title="Typed Array와 기존 Array의 유사점"></a><em>Typed Array</em>와 기존 <em>Array</em>의 유사점</h2><p><em>Typed Array</em>와 일반 <em>Array</em>는 여러 가지면에서 비슷합니다. 이 장에서 이미 살펴본 것처럼 많은 경우 <em>Typed Array</em>를 일반 <em>Array</em> 처럼 사용할 수 있습니다. 예를 들어 <code>length</code> 프로퍼티를 사용하여 입력된 <em>Array</em>에 있는 요소의 수를 확인할 수 있으며 숫자 인덱스를 사용하여 입력된 <em>Array</em>의 요소에 직접 액세스할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> ints = <span class="keyword">new</span> <span class="built_in">Int16Array</span>([<span class="number">25</span>, <span class="number">50</span>]);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(ints.length);          <span class="comment">// 2</span></div><div class="line"><span class="built_in">console</span>.log(ints[<span class="number">0</span>]);              <span class="comment">// 25</span></div><div class="line"><span class="built_in">console</span>.log(ints[<span class="number">1</span>]);              <span class="comment">// 50</span></div><div class="line"></div><div class="line">ints[<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">ints[<span class="number">1</span>] = <span class="number">2</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(ints[<span class="number">0</span>]);              <span class="comment">// 1</span></div><div class="line"><span class="built_in">console</span>.log(ints[<span class="number">1</span>]);              <span class="comment">// 2</span></div></pre></td></tr></table></figure>
<p>이 코드에서는 두개의 요소가 있는 새로운 <code>Int16Array</code>이 만들어집니다. 요소은 숫자 인덱스를 사용하여 읽고 쓰며 작업의 일부로 값이 자동으로 저장되고 int16 값으로 변환됩니다. 유사점은 거기서 끝나지 않습니다.</p>
<blockquote>
<p>일반 <em>Array</em>와 달리 <code>length</code> 프로퍼티를 사용하여 입력된 <em>Array</em>의 크기를 변경할 수 없습니다. <code>length</code> 프로퍼티는 쓰기가 가능하지 않으므로 이를 변경하려는 시도는 non-strict 모드에서 무시되고 strict 모드에서 오류가 발생합니다.</p>
</blockquote>
<h3 id="공통-메서드"><a href="#공통-메서드" class="headerlink" title="공통 메서드"></a>공통 메서드</h3><p><em>Typed Array</em>에는 일반 <em>Array</em> 메서드와 기능적으로 동일한 많은 메서드가 포함되어 있습니다. <em>Typed Array</em>에서도 다음 <em>Array</em> 메서드를 사용할 수 있습니다.</p>
<ul>
<li><code>copyWithin()</code></li>
<li><code>entries()</code></li>
<li><code>fill()</code></li>
<li><code>filter()</code></li>
<li><code>find()</code></li>
<li><code>findIndex()</code></li>
<li><code>forEach()</code></li>
<li><code>indexOf()</code></li>
<li><code>join()</code></li>
<li><code>keys()</code></li>
<li><code>lastIndexOf()</code></li>
<li><code>map()</code></li>
<li><code>reduce()</code></li>
<li><code>reduceRight()</code></li>
<li><code>reverse()</code></li>
<li><code>slice()</code></li>
<li><code>some()</code></li>
<li><code>sort()</code></li>
<li><code>values()</code></li>
</ul>
<p>이 메서드들은 <code>Array.prototype</code>과 유사하지만 정확히 동일하지는 않습니다. <em>Typed Array</em> 메서드는 숫자 타입 안전성에 대한 추가 검사를 수행하며 <em>Array</em>가 반환되면 일반 <em>Array</em> 대신 <em>Typed Array</em>를 반환합니다 (<code>Symbol.species</code> 때문에). 다음은 그 차이를 보여주는 간단한 예입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> ints = <span class="keyword">new</span> <span class="built_in">Int16Array</span>([<span class="number">25</span>, <span class="number">50</span>]),</div><div class="line">    mapped = ints.map(<span class="function"><span class="params">v</span> =&gt;</span> v * <span class="number">2</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(mapped.length);        <span class="comment">// 2</span></div><div class="line"><span class="built_in">console</span>.log(mapped[<span class="number">0</span>]);            <span class="comment">// 50</span></div><div class="line"><span class="built_in">console</span>.log(mapped[<span class="number">1</span>]);            <span class="comment">// 100</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(mapped <span class="keyword">instanceof</span> <span class="built_in">Int16Array</span>);  <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>이 코드는 <code>map()</code> 메서드를 사용하여 <code>ints</code>의 값을 기반으로 새로운 <em>Array</em>를 만듭니다. 매핑 함수는 <em>Array</em>의 각 값을 두 배로 늘리고 새로운 <code>Int16Array</code>를 반환합니다.</p>
<h3 id="동일한-Iterator"><a href="#동일한-Iterator" class="headerlink" title="동일한 Iterator"></a>동일한 <em>Iterator</em></h3><p><em>Typed Array</em>에는 일반 <em>Array</em>와 동일한 3 개의 <em>Iterator</em>가 있습니다. 그것들은 <code>entries()</code>, <code>keys()</code>, <code>values()</code> 메서드입니다. 즉 일반 <em>Array</em>에서와 마찬가지로 <em>Spread</em> 연산자와 <code>for-of</code> 루프를 사용할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> ints = <span class="keyword">new</span> <span class="built_in">Int16Array</span>([<span class="number">25</span>, <span class="number">50</span>]),</div><div class="line">    intsArray = [...ints];</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(intsArray <span class="keyword">instanceof</span> <span class="built_in">Array</span>);    <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(intsArray[<span class="number">0</span>]);                  <span class="comment">// 25</span></div><div class="line"><span class="built_in">console</span>.log(intsArray[<span class="number">1</span>]);                  <span class="comment">// 50</span></div></pre></td></tr></table></figure>
<p>이 코드는 <em>Typed Array</em> <code>ints</code>와 동일한 데이터를 포함하는 새로운 <em>Array</em> <code>intsArray</code>를 만듭니다. 다른 <em>Iterable</em>과 마찮가지로 <em>Spread</em> 연산자는 <em>Typed Array</em>를 일반 <em>Array</em>로 쉽게 변환합니다.</p>
<h3 id="of-와-from-메서드"><a href="#of-와-from-메서드" class="headerlink" title="of()와 from() 메서드"></a>of()와 from() 메서드</h3><p>마지막으로, 모든 <em>Typed Array</em>에는 <code>Array.of()</code> 및 <code>Array.from()</code> 메서드와 같은 정적 메서드 <code>of()</code> 및 <code>from()</code>이 있습니다. 차이점은 <em>Typed Array</em>의 메서드는 일반 <em>Array</em> 대신 <em>Typed Array</em>를 반환한다는 것입니다. 다음은 이러한 메서드를 사용하여 <em>Typed Array</em>를 만드는 몇 가지 예제입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> ints = <span class="built_in">Int16Array</span>.of(<span class="number">25</span>, <span class="number">50</span>),</div><div class="line">    floats = <span class="built_in">Float32Array</span>.from([<span class="number">1.5</span>, <span class="number">2.5</span>]);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(ints <span class="keyword">instanceof</span> <span class="built_in">Int16Array</span>);        <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(floats <span class="keyword">instanceof</span> <span class="built_in">Float32Array</span>);    <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(ints.length);       <span class="comment">// 2</span></div><div class="line"><span class="built_in">console</span>.log(ints[<span class="number">0</span>]);           <span class="comment">// 25</span></div><div class="line"><span class="built_in">console</span>.log(ints[<span class="number">1</span>]);           <span class="comment">// 50</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(floats.length);     <span class="comment">// 2</span></div><div class="line"><span class="built_in">console</span>.log(floats[<span class="number">0</span>]);         <span class="comment">// 1.5</span></div><div class="line"><span class="built_in">console</span>.log(floats[<span class="number">1</span>]);         <span class="comment">// 2.5</span></div></pre></td></tr></table></figure>
<p>이 예제의 <code>of()</code> 및 <code>from()</code> 메서드는 각각 <code>Int16Array</code> 및 <code>Float32Array</code>를 만드는데 사용합니다. 이러한 방법을 통해 <em>Typed Array</em>를 일반 <em>Array</em>처럼 쉽게 만들 수 있습니다.</p>
<h2 id="Typed-Array와-기존-Array의-차이점"><a href="#Typed-Array와-기존-Array의-차이점" class="headerlink" title="Typed Array와 기존 Array의 차이점"></a><em>Typed Array</em>와 기존 <em>Array</em>의 차이점</h2><p><em>Typed Array</em>와 일반 <em>Array</em>의 가장 중요한 차이점은 <em>Typed Array</em>는 일반 <em>Array</em>가 아니라는 것입니다. <em>Typed Array</em>는 <code>Array</code>로부터 상속받지 않으며 <code>Array.isArray()</code>는 <em>Typed Array</em>를 전달할 때 <code>false</code>를 반환합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> ints = <span class="keyword">new</span> <span class="built_in">Int16Array</span>([<span class="number">25</span>, <span class="number">50</span>]);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(ints <span class="keyword">instanceof</span> <span class="built_in">Array</span>);     <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(ints));       <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p><code>ints</code> 변수는 <em>Typed Array</em>이므로 <code>Array</code>의 인스턴스가 아니며 그렇기 때문에 <em>Array</em>로 식별될 수 없습니다. <em>Typed Array</em>와 일반 <em>Array</em>는 비슷하지만 <em>Typed Array</em>가 다르게 동작하는 몇가지 메서드가 있기 때문에 이 구분은 매우 중요합니다.</p>
<h3 id="작동-방법상의-차이점"><a href="#작동-방법상의-차이점" class="headerlink" title="작동 방법상의 차이점"></a>작동 방법상의 차이점</h3><p>일반 <em>Array</em>는 상호 작용할 때 확장 및 축소될 수 있지만 <em>Typed Array</em>는 항상 동일한 크기를 유지합니다. 일반 <em>Array</em> 처럼 <em>Typed Array</em>의 존재하지 않는 숫자 인덱스에 값을 할당할 때 그 작업은 무시됩니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> ints = <span class="keyword">new</span> <span class="built_in">Int16Array</span>([<span class="number">25</span>, <span class="number">50</span>]);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(ints.length);          <span class="comment">// 2</span></div><div class="line"><span class="built_in">console</span>.log(ints[<span class="number">0</span>]);              <span class="comment">// 25</span></div><div class="line"><span class="built_in">console</span>.log(ints[<span class="number">1</span>]);              <span class="comment">// 50</span></div><div class="line"></div><div class="line">ints[<span class="number">2</span>] = <span class="number">5</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(ints.length);          <span class="comment">// 2</span></div><div class="line"><span class="built_in">console</span>.log(ints[<span class="number">2</span>]);              <span class="comment">// undefined</span></div></pre></td></tr></table></figure>
<p>이 예제에서 숫자 인덱스 <code>2</code>에 <code>5</code>를 할당하더라도 <code>ints</code> <em>Array</em>는 전혀 증가하지 않습니다. <code>length</code>는 동일하게 유지되고 값은 버려집니다.</p>
<p><em>Typed Array</em>에는 유효한 데이터 타입만 사용되는지 확인하는 검사 기능도 있습니다. 유효하지 않은 값은 대신 0이 사용됩니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> ints = <span class="keyword">new</span> <span class="built_in">Int16Array</span>([<span class="string">"hi"</span>]);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(ints.length);       <span class="comment">// 1</span></div><div class="line"><span class="built_in">console</span>.log(ints[<span class="number">0</span>]);           <span class="comment">// 0</span></div></pre></td></tr></table></figure>
<p>이 코드는 <code>Int16Array</code>에 문자열 값 <code>&quot;hi&quot;</code>를 사용하려고 시도합니다. 물론 문자열은 <em>Typed Array</em>에서 유효하지 않은 데이터 타입이므로 값은 대신 <code>0</code>으로 삽입됩니다. <em>Array</em>의 <code>length</code>는 여전히 하나이며, <code>ints[0]</code> 슬롯이 존재하더라도 <code>0</code> 값만 있습니다.</p>
<p><em>Typed Array</em>의 값을 수정하는 모든 메서드는 동일한 제한을 적용받습니다. 예를 들어 <code>map()</code>에 전달된 함수가 <em>Typed Array</em>에 대해 유효하지 않은 값을 반환하면 대신에 <code>0</code>이 사용됩니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> ints = <span class="keyword">new</span> <span class="built_in">Int16Array</span>([<span class="number">25</span>, <span class="number">50</span>]),</div><div class="line">    mapped = ints.map(<span class="function"><span class="params">v</span> =&gt;</span> <span class="string">"hi"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(mapped.length);        <span class="comment">// 2</span></div><div class="line"><span class="built_in">console</span>.log(mapped[<span class="number">0</span>]);            <span class="comment">// 0</span></div><div class="line"><span class="built_in">console</span>.log(mapped[<span class="number">1</span>]);            <span class="comment">// 0</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(mapped <span class="keyword">instanceof</span> <span class="built_in">Int16Array</span>);  <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(mapped <span class="keyword">instanceof</span> <span class="built_in">Array</span>);       <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p>문자열 값 <code>&quot;hi&quot;</code>는 16 비트 정수가 아니므로 결과 <em>Array</em>에서 <code>0</code>으로 바뀝니다. 이 오류 수정 동작으로 인해 <em>Typed Array</em>에는 항상 잘못된 데이터가 없기 때문에 잘못된 데이터가 있을때 오류를 던지는 것에 대해 걱정할 필요가 없습니다.</p>
<h3 id="누락된-메서드"><a href="#누락된-메서드" class="headerlink" title="누락된 메서드"></a>누락된 메서드</h3><p><em>Typed Array</em>에는 일반 <em>Array</em>와 동일한 메서드가 많이 있지만 <em>Array</em> 메서드중 몇개는 없습니다. <em>Typed Array</em>에서 다음 메서드는 사용할 수 없습니다.</p>
<ul>
<li><code>concat()</code></li>
<li><code>pop()</code></li>
<li><code>push()</code></li>
<li><code>shift()</code></li>
<li><code>splice()</code></li>
<li><code>unshift()</code></li>
</ul>
<p><code>concat()</code> 메서드를 제외하고 이 목록의 메서드는 크기를 변경할 수 있습니다. <em>Typed Array</em>는 크기를 변경할 수 없으므로 <em>Typed Array</em>에서 사용할 수 없습니다. 두 개의 <em>Typed Array</em>를 연결한 결과(특히 서로 다른 데이터 타입을 처리하는 경우)가 불확실할 수 있기 때문에 <code>concat()</code> 메서드를 사용할 수 없습니다. 이것은 처음에 <em>Typed Array</em>를 사용하는 이유에 반대되는 개념입니다.</p>
<h3 id="추가된-메서드"><a href="#추가된-메서드" class="headerlink" title="추가된 메서드"></a>추가된 메서드</h3><p>마지막으로 <em>Typed Array</em>는 <code>set()</code>과 <code>subarray()</code> 메서드와 같이 일반 <em>Array</em>에는 존재하지 않는 두가지 메서드를 가지고 있습니다. 이 두가지 메서드중 <code>set()</code>은 다른 <em>Array</em>를 기존의 <em>Typed Array</em>로 복사하는 반면 <code>subarray()</code>는 기존의 <em>Typed Array</em>의 일부를 새로운 <em>Typed Array</em>로 추출합니다.</p>
<p><code>set()</code> 메서드는 <em>Array</em>(<em>Typed Array</em> 또는 일반 <em>Array</em>)와 데이터를 선택적으로 삽입할 오프셋을 받습니다. 아무 것도 전달하지 않으면 오프셋의 기본값은 0입니다. 유효한 데이터 타입만 사용되도록 보장되며 <em>Array</em> 파라미터의 데이터는 대상 <em>Typed Array</em>에 복사됩니다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> ints = <span class="keyword">new</span> <span class="built_in">Int16Array</span>(<span class="number">4</span>);</div><div class="line"></div><div class="line">ints.set([<span class="number">25</span>, <span class="number">50</span>]);</div><div class="line">ints.set([<span class="number">75</span>, <span class="number">100</span>], <span class="number">2</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(ints.toString());   <span class="comment">// 25,50,75,100</span></div></pre></td></tr></table></figure>
<p>이 코드는 네 개의 요소가있는 <code>Int16Array</code>를 만듭니다. <code>set()</code>을 처음 호출하면 <em>Typed Array</em>의 첫번째와 두번째 요소에 두개의 값이 복사됩니다. <code>set()</code>에 대한 두번째 호출은 오프셋 <code>2</code>를 이용하여 호출이 되고, 이것은 세번째 요소에서부터 배치되어야 함을 나타냅니다.</p>
<p><code>subarray()</code> 메서드는 선택적인 시작 및 종료 인덱스 (<code>slice()</code> 메서드에서와 같이 종료 인덱스는 배타적입니다.)를 받아 들여 새로운 <em>Typed Array</em>를 반환합니다. 그리고, 두 파라미터를 모두 생략하여 <em>Typed Array</em>의 복제본을 만들 수도 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> ints = <span class="keyword">new</span> <span class="built_in">Int16Array</span>([<span class="number">25</span>, <span class="number">50</span>, <span class="number">75</span>, <span class="number">100</span>]),</div><div class="line">    subints1 = ints.subarray(),</div><div class="line">    subints2 = ints.subarray(<span class="number">2</span>),</div><div class="line">    subints3 = ints.subarray(<span class="number">1</span>, <span class="number">3</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(subints1.toString());   <span class="comment">// 25,50,75,100</span></div><div class="line"><span class="built_in">console</span>.log(subints2.toString());   <span class="comment">// 75,100</span></div><div class="line"><span class="built_in">console</span>.log(subints3.toString());   <span class="comment">// 50,75</span></div></pre></td></tr></table></figure>
<p>이 예제에서는 3 개의 <em>Typed Array</em>가 원래 <code>ints</code>에서 만들어집니다. <code>subints1</code> <em>Typed Array</em>는 동일한 정보를 포함하는 <code>ints</code>의 복사본입니다. <code>subints2</code> <em>Typed Array</em>는 인덱스 2에서 시작하는 데이터를 복사하기 때문에 <code>ints</code>의 마지막 두 요소만(75 및 100) 복사합니다. <code>subints3</code> <em>Typed Array</em>는 <code>subarray()</code>에서 시작 인덱스와 종료 인덱스가 모두 입력되어 호출되므로 <code>ints</code>의 가운데 두 요소만 복사됩니다.</p>
<h2 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h2><p>ECMAScript 6는 <em>Array</em>를 보다 유용하게 만드는 ECMAScript 5의 작업을 승계합니다. <em>Array</em>를 만드는 방법에는 <code>Array.of()</code> 및 <code>Array.from()</code> 메서드 두가지가 더 추가되었습니다. <code>Array.from()</code> 메서드는 <em>Iterable</em> 및 유사 <em>Array</em> 객체를 <em>Array</em>로 변환할 수<br> 있습니다. 두 메서드 모두 파생 <em>Array</em> 클래스에 상속되며 <code>Symbol.species</code> 프로퍼티를 사용하여 반환할 값 타입을 결정합니다.(다른 상속된 메서드 또한 <em>Array</em>를 반환할 때 <code>Symbol.species</code>를 사용합니다.)</p>
<p><em>Array</em>에는 몇가지 새로운 메서드가 있습니다. <code>fill()</code> 및 <code>copyWithin()</code> 메서드를 사용하면 <em>Array</em> 요소를 현재 위치에서 변경할 수 있습니다. <code>find()</code> 및 <code>findIndex()</code> 메서드는 일부 조건과 일치하는 <em>Array</em>의 첫번째 요소를 찾는데 유용합니다. 전자는 기준에 맞는 첫번째 요소를 반환하고 후자는 요소의 인덱스를 반환합니다.</p>
<p><em>Typed Array</em>는 기술적으로 <em>Array</em>가 아니며 <em>Array</em>를 상속하지 않지만, <em>Array</em>처럼 보이고 동작합니다. <em>Typed Array</em>는 8 개의 다른 숫자 데이터 타입중 하나를 포함하며 숫자 또는 일련의 숫자의 기본 비트를 나타내는 <code>ArrayBuffer</code> 객체를 기반으로 작성됩니다. <em>Typed Array</em>는 JavaScript 숫자 타입의 경우처럼 타입이 앞뒤로 변환되지 않기 때문에 비트 연산을 보다 효율적으로 수행하는 방법입니다.</p>
<hr>
<blockquote>
<p>이 내용은 나중에 참고하기 위해 제가 공부하며 정리한 내용입니다.<br>의역, 오역, 직역이 있을 수 있음을 알려드립니다.<br>This post is a translation of this original article [<a href="https://leanpub.com/understandinges6/read#leanpub-auto-improved-array-capabilities" target="_blank" rel="external">https://leanpub.com/understandinges6/read#leanpub-auto-improved-array-capabilities</a>]</p>
</blockquote>
<h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul>
<li><a href="https://infoscis.github.io/2018/01/24/ecmascript-6-block-binding/">ECMAScript 6 Block Binding</a></li>
<li><a href="https://infoscis.github.io/2018/01/24/ecmascript-6-strings-and-regular-expressions/">ECMAScript 6 문자열과 정규 표현식</a></li>
<li><a href="https://infoscis.github.io/2018/01/24/ecmascript-6-functions/">ECMAScript 6 함수</a></li>
<li><a href="https://infoscis.github.io/2018/01/25/ecmascript-6-expanded-object-functionality/">ECMAScript 6 객체의 확장된 기능</a></li>
<li><a href="https://infoscis.github.io/2018/01/26/ecmascript-6-destructuring-for-easier-data-access/">ECMAScript 6 쉬운 데이터 액세스를 위한 Destructuring</a></li>
<li><a href="https://infoscis.github.io/2018/01/27/ecmascript-6-symbols-and-symbol-properties/">ECMAScript 6 Symbol과 Symbol 프로퍼티</a></li>
<li><a href="https://infoscis.github.io/2018/01/27/ecmascript-6-sets-and-maps/">ECMAScript 6 Set과 Map</a></li>
<li><a href="https://infoscis.github.io/2018/01/31/ecmascript-6-iterators-and-generators/">ECMAScript 6 Iterator와 Generator</a></li>
<li><a href="https://infoscis.github.io/2018/02/13/ecmascript-6-introducing-javascript-classes/">ECMAScript 6 JavaScript 클래스 소개</a></li>
<li><a href="https://infoscis.github.io/2018/02/13/ecmascript-6-improved-array-capabilities/">ECMAScript 6 Array 기능 향상</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-promises-and-asynchronous-programming/">ECMAScript 6 Promise와 비동기 프로그램밍</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-proxies-and-the-reflection-api/">ECMAScript 6 프록시와 리플렉션 API</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-encapsulating-code-with-modules/">ECMAScript 6 Module로 코드 캡슐화하기</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-appendix-a-smaller-changes/">ECMAScript 6 부록 A. 작은 변경 사항</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-appendix-b-understanding-ecmascript-7/">ECMAScript 6 부록 B. ECMAScript 7(2016) 이해하기</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Array-기능-향상&quot;&gt;&lt;a href=&quot;#Array-기능-향상&quot; class=&quot;headerlink&quot; title=&quot;Array 기능 향상&quot;&gt;&lt;/a&gt;Array 기능 향상&lt;/h1&gt;&lt;p&gt;&lt;em&gt;Array&lt;/em&gt;는 JavaScript의 기본 객체입
    
    </summary>
    
      <category term="JavaScript" scheme="http://infoscis.github.io/categories/JavaScript/"/>
    
      <category term="ECMAScript 2015" scheme="http://infoscis.github.io/categories/JavaScript/ECMAScript-2015/"/>
    
    
      <category term="JavaScript" scheme="http://infoscis.github.io/tags/JavaScript/"/>
    
      <category term="ECMAScript 2015" scheme="http://infoscis.github.io/tags/ECMAScript-2015/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 클래스 소개</title>
    <link href="http://infoscis.github.io/2018/02/13/ecmascript-6-introducing-javascript-classes/"/>
    <id>http://infoscis.github.io/2018/02/13/ecmascript-6-introducing-javascript-classes/</id>
    <published>2018-02-13T14:49:26.000Z</published>
    <updated>2018-02-27T14:12:45.040Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript-클래스-소개"><a href="#JavaScript-클래스-소개" class="headerlink" title="JavaScript 클래스 소개"></a>JavaScript 클래스 소개</h1><p>대부분의 공식적인 객체 지향 프로그래밍 언어와는 달리 JavaScript는 만들어질 때 부터 유사 객체 및 관련 객체를 정의하는 주요 방법으로 클래스와 클래스 상속을 지원하지 않았습니다. 이로 인해 많은 개발자들이 혼란 스러웠고, ECMAScript 1 이전 버전부터 ECMAScript 5 까지 많은 라이브러리가 클래스를 지원하는 것처럼 보이게하는 유틸리티를 만들었습니다. 일부 JavaScript 개발자는 JavaScript에 클래스는 필요하지 않다고 강력하게 느낄수도 있지만, 클래스 지원을 목적으로 하는 많은 수의 라이브러리는 클래스를 ECMAScript 6에 포함 시키도록 했습니다.</p>
<p>클래스가 사용하는 기본 메커니즘을 이해하는 것이 ECMAScript 6 클래스를 공부하는데 도움이되므로 이 장에서는 ECMAScript 5 개발자가 클래스와 비슷한 동작을 하는 방법에 대해 논의함으로써 시작합니다. 그러나 나중에 보게 되겠지만, ECMAScript 6 클래스는 다른 언어의 클래스와 완전히 동일하지 않습니다. JavaScript의 동적 특성을 반영하는 독창적인 기능이 있습니다.</p>
<h2 id="ECMAScript-5의-클래스와-비슷한-구조"><a href="#ECMAScript-5의-클래스와-비슷한-구조" class="headerlink" title="ECMAScript 5의 클래스와 비슷한 구조"></a>ECMAScript 5의 클래스와 비슷한 구조</h2><p>ECMAScript 5 이전 버전의 JavaScript에는 클래스가 없었습니다. 클래스에 가장 가까운 방법은 생성자를 생성한 다음 생성자의 프로토 타입에 메서드를 할당하는 것으로, 일반적으로 사용자 정의 타입 생성이라고 하는 접근 방식입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">PersonType</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">PersonType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> PersonType(<span class="string">"Nicholas"</span>);</div><div class="line">person.sayName();   <span class="comment">// outputs "Nicholas"</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> PersonType);  <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> <span class="built_in">Object</span>);      <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>이 코드에서 <code>PersonType</code>은 <code>name</code>이라는 단일 프로퍼티를 생성하는 생성자 함수입니다. <code>sayName()</code> 메서드는 프로토 타입에 할당되어 동일한 함수가 <code>PersonType</code> 객체의 모든 인스턴스에 의해 공유됩니다. 그런 다음, <code>Person</code>의 새로운 인스턴스가 <code>new</code> 연산자를 통해 생성됩니다. <code>person</code> 객체는 프로토 타입 상속을 통해 <code>PersonType</code>과 <code>Object</code> 인스턴스로 간주됩니다.</p>
<p>이 기본 패턴은 클래스를 모방하는 많은 JavaScript 라이브러리의 근간을 이루며 ECMAScript 6 클래스가 시작됩니다.</p>
<h2 id="클래스-선언"><a href="#클래스-선언" class="headerlink" title="클래스 선언"></a>클래스 선언</h2><p>ECMAScript 6에서 가장 간단한 클래스 형식은 다른 언어의 클래스와 비슷한 클래스 선언입니다.</p>
<h3 id="클래스-선언의-기본"><a href="#클래스-선언의-기본" class="headerlink" title="클래스 선언의 기본"></a>클래스 선언의 기본</h3><p>클래스 선언은 <code>class</code> 키워드와 클래스의 이름으로 시작됩니다. 구문의 나머지 부분은 객체 리터럴의 간결한 메서드와 비슷하지만 쉼표가 필요하지 않습니다. 예를 들어, 다음은 간단한 클래스 선언입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonClass</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// PersonType 생성자와 동일합니다.</span></div><div class="line">    <span class="keyword">constructor</span>(name) &#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// PersonType.prototype.sayName과 동일합니다.</span></div><div class="line">    sayName() &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> PersonClass(<span class="string">"Nicholas"</span>);</div><div class="line">person.sayName();   <span class="comment">// outputs "Nicholas"</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> PersonClass);     <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> <span class="built_in">Object</span>);          <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> PersonClass);                    <span class="comment">// "function"</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> PersonClass.prototype.sayName);  <span class="comment">// "function"</span></div></pre></td></tr></table></figure>
<p><code>PersonClass</code> 클래스 선언은 이전 예제의 <code>PersonType</code>과 매우 유사하게 동작합니다. 그러나 함수를 생성자로 정의하는 대신 클래스 선언을 사용하면 특수한 <code>constructor</code> 메서드 이름을 사용하여 클래스 내부에 직접 생성자를 정의할 수 있습니다. 클래스 메서드는 간결한 구문을 사용하기 때문에 <code>function</code> 키워드를 사용할 필요가 없습니다. 그리고 다른 메서드 이름에는 특별한 의미가 없으므로 원하는 만큼 메서드를 추가할 수 있습니다.</p>
<blockquote>
<p><em>Own property</em>는 프로토 타입이 아닌 인스턴스에서 보여지는 프로퍼티는 클래스 생성자 또는 메서드 내부에서만 만들 수 있습니다. 이 예제에서 <code>name</code>은 <em>Own Property</em>입니다. 생성자 함수 내에서 가능한 모든 프로퍼티를 만드는 것이 좋습니다. 왜냐하면 클래스의 한 장소에서 모든 프로퍼티가 표현되기 때문입니다.</p>
</blockquote>
<p>흥미롭게도, 클래스 선언은 기존 사용자 정의 타입 선언의 Syntactic sugar입니다. <code>PersonClass</code> 선언은 실제로 <code>constructor</code> 메서드의 동작을 갖는 함수를 생성합니다. 이것이 <code>typeof PersonClass</code>가 “<code>function</code>“을 결과로 주는 이유입니다. <code>sayName()</code> 메서드는 앞의 예제에서 <code>sayName()</code>과 <code>PersonType.prototype</code> 사이의 관계와 비슷하게 이 예제에서 <code>PersonClass.prototype</code>에 대한 메서드로 끝납니다. 이러한 유사점을 사용하면 사용자가 사용하는 타입에 대해 너무 많이 걱정하지 않고도 사용자 정의 타입 및 클래스를 혼합할 수 있습니다.</p>
<h3 id="클래스-구문을-사용해야하는-이유"><a href="#클래스-구문을-사용해야하는-이유" class="headerlink" title="클래스 구문을 사용해야하는 이유"></a>클래스 구문을 사용해야하는 이유</h3><p>클래스와 사용자 정의 타입의 유사점에도 불구하고 유의해야 할 몇 가지 중요한 차이점이 있습니다.</p>
<ol>
<li>클래스 선언은 함수 선언과 달리 <em>Hoisting</em>되지 않습니다. 클래스 선언은 <code>let</code> 선언과 같이 행동하며, 실행이 선언에 도달할 때까지 Temporal dead zone에 존재합니다.</li>
<li>클래스 선언의 모든 코드는 <code>strict</code> 모드로 자동 실행됩니다. 클래스의 <code>strict</code> 모드를 거부할 수있는 방법이 없습니다.</li>
<li>모든 메서드는 Non-enumerable 입니다. <code>Object.defineProperty()</code>를 사용하여 메서드를 Non-enumerable하게 만드는 사용자 지정 타입과 다른 중요한 변경 사항입니다.</li>
<li>모든 메서드는 내부 <code>[[Construct]]</code> 메서드가 없으며 <code>new</code>로 호출하려고 하면 에러가 발생합니다.</li>
<li><code>new</code>를 사용하지 않고 클래스 생성자를 호출하면 오류가 발생합니다.</li>
<li>클래스 메서드 내에서 클래스 이름을 덮어 쓰려고하면 오류가 발생합니다.</li>
</ol>
<p>이 모든 것을 염두에 두고, 위 예제의 <code>PersonClass</code> 선언은 클래스 구문을 사용하지 않는 다음 코드와 동일합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// PersonClass와 동일합니다.</span></div><div class="line"><span class="keyword">let</span> PersonType2 = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line"><span class="meta"></span></div><div class="line">    "use strict";</div><div class="line"></div><div class="line">    <span class="keyword">const</span> PersonType2 = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">// new를 이용하여 호출이 되었는지 확인</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">new</span>.target === <span class="string">"undefined"</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Constructor must be called with new."</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">Object</span>.defineProperty(PersonType2.prototype, <span class="string">"sayName"</span>, &#123;</div><div class="line">        <span class="attr">value</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">            <span class="comment">// new를 이용하여 호출하지 않도록 함.</span></div><div class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">new</span>.target !== <span class="string">"undefined"</span>) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Method cannot be called with new."</span>);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">enumerable</span>: <span class="literal">false</span>,</div><div class="line">        <span class="attr">writable</span>: <span class="literal">true</span>,</div><div class="line">        <span class="attr">configurable</span>: <span class="literal">true</span></div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> PersonType2;</div><div class="line">&#125;());</div></pre></td></tr></table></figure>
<p>먼저 두 개의 <code>PersonType2</code> 선언이 있음을 주목하십시오(외부 scope에 있는 <code>let</code> 선언과 IIFE 내부에 있는 <code>const</code> 선언). 이것은 클래스 메서드가 클래스 이름을 덮어 쓰는 것을 금지하는 반면 클래스 외부의 코드는 이를 허용합니다. 생성자 함수는 <code>new.target</code>을 검사하여<br> <code>new</code>로 호출되는지 확인합니다. 그렇지 않은 경우 오류가 발생합니다. 다음으로, <code>sayName()</code>메소드는 Non-enumerable으로 정의되고 메t서드는 <code>new.target</code>을 검사하여 <code>new</code>로 호출되지 않았음을 확인합니다. 마지막 단계는 생성자 함수를 반환합니다.</p>
<p>이 예제는 새로운 구문을 사용하지 않고 클래스가 수행할 수있는 모든 작업할 수 있지만 클래스 구문은 모든 기능을 크게 단순화한다는 것을 보여줍니다.</p>
<h3 id="상수-클래스-이름"><a href="#상수-클래스-이름" class="headerlink" title="상수 클래스 이름"></a>상수 클래스 이름</h3><p>클래스의 이름은 클래스 내부에서 <code>const</code>를 사용하는 경우에만 지정됩니다. 즉, 클래스 외부의 클래스 이름은 덮어 쓸 수 있지만 클래스 메서드 내부에서는 덮어 쓸 수 없습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">   <span class="keyword">constructor</span>() &#123;</div><div class="line">       Foo = <span class="string">"bar"</span>;    <span class="comment">// 실행될때 에러가 발생합니다.</span></div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 클래스 선언 이후에는 가능합니다.</span></div><div class="line">Foo = <span class="string">"baz"</span>;</div></pre></td></tr></table></figure>
<p>이 코드에서 클래스 생성자 안에있는 <code>Foo</code>는 클래스 외부의 <code>Foo</code>와는 별도의 바인딩입니다. 내부의 <code>Foo</code>는 마치 <code>const</code>인 것처럼 정의되고 덮어 쓸 수 없습니다. 생성자가 <code>Foo</code>를 임의의 값으로 덮어 쓰려고하면 에러가 발생합니다. 그러나 외부 <code>Foo</code>는 <code>let</code> 선언처럼 정의되기 때문에 언제든지 값을 덮어 쓸 수 있습니다.</p>
<h2 id="클래스-표현식"><a href="#클래스-표현식" class="headerlink" title="클래스 표현식"></a>클래스 표현식</h2><p>클래스와 함수는 선언과 표현식이라는 두가지 형식을 가지고 있다는 점에서 비슷합니다. 함수와 클래스 선언은 적절한 키워드 (각각<code>function</code> 또는<code>class</code>)와 식별자로 시작됩니다. 함수는 <code>function</code> 다음에 식별자를 필요로하지 않는 표현식 형태를 가지고 있고, 비슷하게 클래스는 <code>class</code> 다음에 식별자를 필요로하지 않는 표현식 형태를 가지고 있습니다. 이 클래스 표현식은 변수 선언에 사용되거나 함수로 인수로 전달되도록 설계되었습니다.</p>
<h3 id="기본-클래스-표현식"><a href="#기본-클래스-표현식" class="headerlink" title="기본 클래스 표현식"></a>기본 클래스 표현식</h3><p>다음은 이전 <code>PersonClass</code> 예제에 해당하는 클래스 표현식과 그 코드를 사용하는 코드입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> PersonClass = <span class="class"><span class="keyword">class</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// PersonType constructor와 같습니다.</span></div><div class="line">    <span class="keyword">constructor</span>(name) &#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// PersonType.prototype.sayName과 같습니다.</span></div><div class="line">    sayName() &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> PersonClass(<span class="string">"Nicholas"</span>);</div><div class="line">person.sayName();   <span class="comment">// "Nicholas" 출력</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> PersonClass);     <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> <span class="built_in">Object</span>);          <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> PersonClass);                    <span class="comment">// "function"</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> PersonClass.prototype.sayName);  <span class="comment">// "function"</span></div></pre></td></tr></table></figure>
<p>이 예제에서 알 수 있듯이, 클래스 표현식은 <code>class</code> 다음에 식별자를 요구하지 않습니다. 구문 외에도 클래스 표현식은 클래스 선언과 기능적으로 동일합니다.</p>
<p>클래스 선언 또는 클래스 표현식 사용 여부는 주로 스타일의 문제입니다. 함수 선언 및 함수 표현식과 달리 클래스 선언과 클래스 표현식은 모두 <em>Hoisting</em> 되지 않기 때문에 코드의 런타임 동작에 거의 영향을 미치지 않습니다.</p>
<h3 id="이름이-부여된-클래스-표현식"><a href="#이름이-부여된-클래스-표현식" class="headerlink" title="이름이 부여된 클래스 표현식"></a>이름이 부여된 클래스 표현식</h3><p>이전 섹션 예제에서 익명 클래스 표현식을 사용했지만 함수 표현식과 마찬가지로 클래스 표현식의 이름을 지정할 수도 있습니다. 이렇게 하려면 다음과 같이 <code>class</code> 키워드 다음에 이름(식별자)를 포함 시킵니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> PersonClass = <span class="class"><span class="keyword">class</span> <span class="title">PersonClass2</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// PersonType constructor와 같습니다.</span></div><div class="line">    <span class="keyword">constructor</span>(name) &#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// PersonType.prototype.sayName와 같습니다.</span></div><div class="line">    sayName() &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> PersonClass);        <span class="comment">// "function"</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> PersonClass2);       <span class="comment">// "undefined"</span></div></pre></td></tr></table></figure>
<p>이 예제에서 클래스 표현식의 이름은 <code>PersonClass2</code>입니다. <code>PersonClass2</code> 식별자는 클래스 정의 내에서만 존재하기 때문에 (이 예제에서<code>sayName()</code> 메서드 처럼) 클래스 메서드 내부에서 사용될 수 있습니다. 하지만 클래스 밖에서 <code>typeof PersonClass2</code>는 <code>PersonClass2</code> 바인딩이 존재하지 않기 때문에 <code>&quot;undefined&quot;</code>입니다. 이러한 이유를 이해하기 위해 아래 예제처럼 클래스를 사용하지 않는 동일한 함수 선언을 살펴보겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// PersonClass에 이름이 부여된 클래스 표현식과 동일합니다.</span></div><div class="line"><span class="keyword">let</span> PersonClass = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line"><span class="meta"></span></div><div class="line">    "use strict";</div><div class="line"></div><div class="line">    <span class="keyword">const</span> PersonClass2 = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">// 함수가 new로 호출되었는지 확인합니다.</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">new</span>.target === <span class="string">"undefined"</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Constructor must be called with new."</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">Object</span>.defineProperty(PersonClass2.prototype, <span class="string">"sayName"</span>, &#123;</div><div class="line">        <span class="attr">value</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">            <span class="comment">// 함수가 new를 사용하지 않고 호출되었는지 확인합니다</span></div><div class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">new</span>.target !== <span class="string">"undefined"</span>) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Method cannot be called with new."</span>);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">enumerable</span>: <span class="literal">false</span>,</div><div class="line">        <span class="attr">writable</span>: <span class="literal">true</span>,</div><div class="line">        <span class="attr">configurable</span>: <span class="literal">true</span></div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> PersonClass2;</div><div class="line">&#125;());</div></pre></td></tr></table></figure>
<p>이름이 부여된 클래스 표현식을 작성하면 JavaScript 엔진에서 일어나는 일이 약간 바뀝니다. 클래스 선언의 경우, 외부 바인딩 (<code>let</code>으로 정의)은 내부 바인딩 (<code>const</code>로 정의)과 동일한 이름을 가집니다. 이름이 부여된 클래스 표현식은 <code>const</code> 정의에서 그 이름을 사용하므로<code>PersonClass2</code>는 클래스 내부에서만 사용하도록 정의됩니다.</p>
<p>이름이 부여된 클래스 표현식은 이름이 부여된 함수 표현식과 다르게 동작하지만, 두 표현식 사이에는 여전히 많은 유사점이 있습니다. 둘 다 값(Value)으로 사용할 수 있으며, 이는 많은 가능성을 열어줍니다. 이것은 아래에서 다루도록 하겠습니다.</p>
<h2 id="일급-시민-First-Class-Citizen-으로서의-클래스"><a href="#일급-시민-First-Class-Citizen-으로서의-클래스" class="headerlink" title="일급 시민(First-Class Citizen)으로서의 클래스"></a>일급 시민(First-Class Citizen)으로서의 클래스</h2><blockquote>
<p><a href="https://ko.wikipedia.org/wiki/%EC%9D%BC%EA%B8%89_%EA%B0%9D%EC%B2%B4" target="_blank" rel="external">일급 시민</a>: 컴퓨터 프로그래밍 언어 디자인에서, 특정 언어의 일급 객체 (first-class citizens, 일급 값, 일급 엔티티, 혹은 일급 시민)이라 함은 일반적으로 다른 객체들에 적용 가능한 연산을 모두 지원하는 객체를 가리킨다. 함수에 파라미터로 넘기기, 변수에 대입하기와 같은 연산들이 여기서 말하는 일반적인 연산의 예에 해당한다.</p>
</blockquote>
<p>프로그래밍 언어에서 어떤것은 값(Value)으로 사용될 수 있고, 이 경우에 <em>First-Class Citizen</em>이라고 말합니다. 즉, 함수로 전달되고 함수에서 반환되며 변수에 할당될 수 있습니다. JavaScript 함수는 <em>First-Class Citizen</em> (때로는 <em>First-Class Function</em>이라 부름)이며, 이는 JavaScript를 고유하게 만드는 요소의 일부입니다.</p>
<p>ECMAScript 6은 클래스를 <em>First-Class Citizen</em>으로 만들어 이러한 전통을 이어가고 있습니다. 이를 통해 클래스를 다양한 방식으로 사용할 수 있습니다. 예를 들어, 파라미터로 함수에 전달할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObject</span>(<span class="params">classDef</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> classDef();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> obj = createObject(<span class="class"><span class="keyword">class</span> </span>&#123;</div><div class="line"></div><div class="line">    sayHi() &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"Hi!"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">obj.sayHi();        <span class="comment">// "Hi!"</span></div></pre></td></tr></table></figure>
<p>이 예제에서, <code>createObject()</code> 함수는 익명의 클래스 표현식을 인수로하여 호출되고, <code>new</code>로 그 클래스의 인스턴스를 생성하여 인스턴스를 리턴합니다. 변수 <code>obj</code>는 반환된 인스턴스를 저장합니다.</p>
<p>클래스 표현식의 또 다른 흥미로운 사용법은 클래스 생성자를 즉시 호출하여 싱글톤을 생성하는 것입니다. 이렇게 하려면 클래스 표현식에<br> <code>new</code>를 사용해야 하고 마지막에 괄호를 포함해야합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="class"><span class="keyword">class</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">constructor</span>(name) &#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    sayName() &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;(<span class="string">"Nicholas"</span>);</div><div class="line"></div><div class="line">person.sayName();       <span class="comment">// "Nicholas"</span></div></pre></td></tr></table></figure>
<p>여기서 익명의 클래스 표현식이 생성되고 즉시 실행됩니다. 이 패턴을 사용하면 클래스 참조를 검사할 수 있게하지 않고도 싱글톤을 생성하기<br> 위한 클래스 구문을 사용할 수 있습니다(<code>PersonClass</code>는 바깥 쪽이 아닌 클래스 내에서만 바인딩을 생성한다는 것을 기억하십시오.). 클래스 표현식의 끝 부분에있는 괄호는 함수를 호출하는 동시에 인자를 전달할 수 있는 것을 나타냅니다.</p>
<p>지금까지 이 장의 예제는 메서드가 있는 클래스에 중점을 두었습니다. 그러나 객체 리터럴과 유사한 구문을 사용하여 클래스에 접근자(Accessor) 프로퍼티를 만들 수도 있습니다.</p>
<h2 id="접근자-Accessor-프로퍼티"><a href="#접근자-Accessor-프로퍼티" class="headerlink" title="접근자(Accessor) 프로퍼티"></a>접근자(Accessor) 프로퍼티</h2><p>클래스 생성자 내에서 자체 프로퍼티를 만들어야 하지만 클래스를 사용하면 프로토 타입에 접근자(Accessor) 프로퍼티를 정의할 수 있습니다. <em>Getter</em>를 만들려면 키워드 <code>get</code> 다음에 공백 문자와 식별자를 사용하합니다. <em>Setter</em>를 만들려면 <code>set</code> 키워드를 사용합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomHTMLElement</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">constructor</span>(element) &#123;</div><div class="line">        <span class="keyword">this</span>.element = element;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    get html() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.element.innerHTML;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    set html(value) &#123;</div><div class="line">        <span class="keyword">this</span>.element.innerHTML = value;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(CustomHTMLElement.prototype, <span class="string">"html"</span>);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"get"</span> <span class="keyword">in</span> descriptor);   <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"set"</span> <span class="keyword">in</span> descriptor);   <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(descriptor.enumerable); <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p>이 코드에서, <code>CustomHTMLElement</code> 클래스는 기존 DOM Element를 감싸는 래퍼로 만들어집니다. 그것은 Element 자체에 대한 <code>innerHTML</code> 메서드에 위임한 <code>html</code>을 위한 <em>Getter</em>와 <em>Setter</em>를 둘 다 가지고 있습니다. 이 접근자 프로퍼티는 <code>CustomHTMLElement.prototype</code>에서 생성되며, 다른 메서드와 마찬가지로 Non-enumerable로 생성됩니다. 클래스를 사용하지 않는 동일한 코드는 아래와 같습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 위 예제와 동일합니다.</span></div><div class="line"><span class="keyword">let</span> CustomHTMLElement = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line"><span class="meta"></span></div><div class="line">    "use strict";</div><div class="line"></div><div class="line">    <span class="keyword">const</span> CustomHTMLElement = <span class="function"><span class="keyword">function</span>(<span class="params">element</span>) </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">// new를 이용한 호출인지 확인 합니다.</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">new</span>.target === <span class="string">"undefined"</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Constructor must be called with new."</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.element = element;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">Object</span>.defineProperty(CustomHTMLElement.prototype, <span class="string">"html"</span>, &#123;</div><div class="line">        <span class="attr">enumerable</span>: <span class="literal">false</span>,</div><div class="line">        <span class="attr">configurable</span>: <span class="literal">true</span>,</div><div class="line">        <span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.element.innerHTML;</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">set</span>: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">            <span class="keyword">this</span>.element.innerHTML = value;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> CustomHTMLElement;</div><div class="line">&#125;());</div></pre></td></tr></table></figure>
<p>이전 예제와 마찬가지로 이 코드는 클래스를 이용하는 것이 동일한 기능을 하는 클래스를 사용하지 않는 코드에 비해 얼마나 코드를 줄일수 있는지 보여줍니다. <code>html</code> 접근자 프로퍼티 정의만이 거의 비슷한 크기입니다.</p>
<h2 id="계산된-멤버-이름"><a href="#계산된-멤버-이름" class="headerlink" title="계산된 멤버 이름"></a>계산된 멤버 이름</h2><p>객체 리터럴과 클래스 간의 유사점은 아직 끝나지 않았습니다. 클래스 메서드와 접근자 프로퍼티는 계산된 이름을 가질 수도 있습니다. 식별자를 사용하는 대신 표현식 주위에 대괄호를 사용합니다. 이 표현식은 객체 리터럴의 계산된 이름에 사용되는 구문과 동일합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> methodName = <span class="string">"sayName"</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonClass</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">constructor</span>(name) &#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    [methodName]() &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> me = <span class="keyword">new</span> PersonClass(<span class="string">"Nicholas"</span>);</div><div class="line">me.sayName();           <span class="comment">// "Nicholas"</span></div></pre></td></tr></table></figure>
<p>이 버전의 <code>PersonClass</code>는 변수를 사용하여 정의 안에 있는 메서드에 이름을 할당합니다. 문자열 <code>&quot;sayName&quot;</code>은 <code>methodName</code> 변수에 할당되고 메서드를 선언하기 위해 <code>methodName</code>이 사용됩니다. <code>sayName()</code> 메서드는 나중에 직접 액세스됩니다.</p>
<p>접근자 프로퍼티는 다음과 같은 방식으로 계산된 이름을 사용할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> propertyName = <span class="string">"html"</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomHTMLElement</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">constructor</span>(element) &#123;</div><div class="line">        <span class="keyword">this</span>.element = element;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    get [propertyName]() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.element.innerHTML;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    set [propertyName](value) &#123;</div><div class="line">        <span class="keyword">this</span>.element.innerHTML = value;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>여기서 <code>html</code>에 대한 <em>Getter</em>와 <em>Setter</em>는 <code>propertyName</code> 변수를 사용하여 설정됩니다. <code>.html</code>을 사용하여 프로퍼티에 접근하는 것은 정의에만 영향을 줍니다.</p>
<p>클래스와 객체 리터럴 간에는 메서드, 접근자 프로퍼티 및 계산된 이름등 많은 유사점이 있다는 것을 알았습니다. 그리고 <em>Generator</em>라는 유사점이 하나더 있습니다. </p>
<h2 id="Generator-메서드"><a href="#Generator-메서드" class="headerlink" title="Generator 메서드"></a><em>Generator</em> 메서드</h2><p>8 장에서 <em>Generator</em>를 소개할 때 메서드 이름에 별표 (<code>*</code>)를 추가하여 객체 리터럴에 <em>Generator</em>를 정의하는 방법을 배웠습니다. 클래스에 대해서도 동일한 구문이 적용되어 모든 메서드를 <em>Generator</em>로 사용할 수 있습니다. 다음은 그 예입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</div><div class="line"></div><div class="line">    *createIterator() &#123;</div><div class="line">        <span class="keyword">yield</span> <span class="number">1</span>;</div><div class="line">        <span class="keyword">yield</span> <span class="number">2</span>;</div><div class="line">        <span class="keyword">yield</span> <span class="number">3</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> MyClass();</div><div class="line"><span class="keyword">let</span> iterator = instance.createIterator();</div></pre></td></tr></table></figure>
<p>이 코드는 <code>createIterator()</code> <em>Generator</em> 메서드를 가지는 <code>MyClass</code>라는 클래스를 생성합니다. 이 메서드는 값이 <em>Generator</em>에 하드코딩된 <em>Iterator</em>를 반환합니다. <em>Generator</em> 메서드는 값의 컬렉션을 나타내는 객체가 있고 해당 값을 쉽게 반복할 때 유용합니다. <em>Array</em>, <em>Set</em>, <em>Map</em>은 모두 개발자들이 아이템과 상호 작용할 필요가 있는 다양한 방법을 설명하기 위해 여러 <em>Generator</em> 메서드를 가지고 있습니다.</p>
<p>클래스에 대한 기본 <em>Iterator</em>를 정의하면 클래스가 값 컬렉션을 나타내는 경우 훨씬 유용합니다. <code>Symbol.iterator</code>를 사용하여 다음과 같이 <em>Generator</em> 메서드를 정의하여 클래스의 기본 <em>Iterator</em>를 정의할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Collection</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">constructor</span>() &#123;</div><div class="line">        <span class="keyword">this</span>.items = [];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    *[<span class="built_in">Symbol</span>.iterator]() &#123;</div><div class="line">        <span class="keyword">yield</span> *<span class="keyword">this</span>.items.values();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> collection = <span class="keyword">new</span> Collection();</div><div class="line">collection.items.push(<span class="number">1</span>);</div><div class="line">collection.items.push(<span class="number">2</span>);</div><div class="line">collection.items.push(<span class="number">3</span>);</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> collection) &#123;</div><div class="line">    <span class="built_in">console</span>.log(x);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 결과:</span></div><div class="line"><span class="comment">// 1</span></div><div class="line"><span class="comment">// 2</span></div><div class="line"><span class="comment">// 3</span></div></pre></td></tr></table></figure>
<p>이 예제는 <code>this.items</code> 배열의 <code>values()</code> <em>Iterator</em>에 위임한 <em>Generator</em> 메서드에 대해 계산된 이름을 사용합니다. 컬렉션의 값을 관리하는 모든 클래스에는 기본 <em>Iterator</em>가 포함되어야 합니다. 컬렉션 관련 일부 작업에는 <em>Iterator</em>가 필요하기 때문입니다. 이제, <code>Collection</code>의 어떤 인스턴스도 <code>for-of</code> 루프나 <em>Spread</em> 연산자에 직접 사용될 수 있습니다.</p>
<p>클래스 프로토 타입에 메서드 및 접근자 프로퍼티를 추가하면 객체 인스턴스에 해당 메서드를 표시할 때 유용합니다. 반면에 클래스 자체의 메서드 또는 접근자 프로퍼티를 원하면 정적 멤버를 사용해야합니다.</p>
<h2 id="정적-멤버-Static-Member"><a href="#정적-멤버-Static-Member" class="headerlink" title="정적 멤버(Static Member)"></a>정적 멤버(Static Member)</h2><p>정적 멤버를 시뮬레이트하기 위해 생성자에 직접 메서드를 추가하는 것은 ECMAScript 5 및 이전 버전의 또 다른 공통 패턴입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">PersonType</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// static method</span></div><div class="line">PersonType.create = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PersonType(name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// instance method</span></div><div class="line">PersonType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person = PersonType.create(<span class="string">"Nicholas"</span>);</div></pre></td></tr></table></figure>
<p>다른 프로그래밍 언어에서, <code>PersonType.create()</code>라고 불리는 팩토리 메소드는 정적 메소드로 간주될 것입니다. 왜냐하면 <code>PersonType</code>의<br> 인스턴스에 의존하지 않기 때문입니다. ECMAScript 6 클래스는 메서드 또는 접근자 프로퍼티 이름 앞에 정식 <code>static</code> Annotation을 사용하여 정적 멤버 생성을 단순화합니다. 예를 들어, 다음은 이전 예제와 동일한 클래스입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonClass</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// PersonType constructor와 동일합니다.</span></div><div class="line">    <span class="keyword">constructor</span>(name) &#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// PersonType.prototype.sayName와 동일합니다.</span></div><div class="line">    sayName() &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// PersonType.create와 동일합니다.</span></div><div class="line">    <span class="keyword">static</span> create(name) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PersonClass(name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> person = PersonClass.create(<span class="string">"Nicholas"</span>);</div></pre></td></tr></table></figure>
<p><code>PersonClass</code> 정의는 <code>create()</code>라고 하는 하나의 정적 메서드를 가지고 있습니다. 메서드 구문은 <code>static</code> 키워드를 제외하고 <code>sayName()</code>과 동일합니다. <code>static</code> 키워드는 클래스 내의 임의의 메서드 또는 접근자 프로퍼티 정의에 사용할 수 있습니다. 유일한 제약은<code>static</code>을 <code>constructor</code> 메서드 정의와 함께 사용할 수 없다는 것입니다.</p>
<blockquote>
<p>정적 멤버는 인스턴스에서 액세스할 수 없습니다. 항상 클래스의 정적 멤버에 직접 액세스해야합니다.</p>
</blockquote>
<h2 id="파생-클래스를-사용한-상속"><a href="#파생-클래스를-사용한-상속" class="headerlink" title="파생 클래스를 사용한 상속"></a>파생 클래스를 사용한 상속</h2><p>ECMAScript 6 이전에는 사용자 정의 타입으로 상속을 구현할때 대규모 과정이 필요했습니다. 적절한 상속에는 여러 단계가 필요했습니다. 예를 들어 다음 예제를 살펴보겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params">length, width</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.length = length;</div><div class="line">    <span class="keyword">this</span>.width = width;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Rectangle.prototype.getArea = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.length * <span class="keyword">this</span>.width;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Square</span>(<span class="params">length</span>) </span>&#123;</div><div class="line">    Rectangle.call(<span class="keyword">this</span>, length, length);</div><div class="line">&#125;</div><div class="line"></div><div class="line">Square.prototype = <span class="built_in">Object</span>.create(Rectangle.prototype, &#123;</div><div class="line">    <span class="attr">constructor</span>: &#123;</div><div class="line">        <span class="attr">value</span>:Square,</div><div class="line">        <span class="attr">enumerable</span>: <span class="literal">true</span>,</div><div class="line">        <span class="attr">writable</span>: <span class="literal">true</span>,</div><div class="line">        <span class="attr">configurable</span>: <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">var</span> square = <span class="keyword">new</span> Square(<span class="number">3</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(square.getArea());              <span class="comment">// 9</span></div><div class="line"><span class="built_in">console</span>.log(square <span class="keyword">instanceof</span> Square);      <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(square <span class="keyword">instanceof</span> Rectangle);   <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p><code>Square</code>는 <code>Rectangle</code>을 상속받습니다. 그래서 <code>Square.prototype</code>을 <code>Rectangle.prototype</code>에서 생성한 새로운 객체로 덮어 쓰고<code>Rectangle.call()</code> 메서드를 호출해야합니다. 이 단계들은 종종 JavaScript 신참을 혼란스럽게 만들거나 경험 많은 개발자에게 오류의 원인이 되었습니다.</p>
<p>클래스는 익숙한 <code>extends</code> 키워드를 사용하여 클래스가 상속해야하는 함수를 지정함으로써 상속을 보다 쉽게 구현할 수 있도록합니다. 프로토 타입은 자동으로 조정되며 <code>super()</code> 메서드를 호출하여 기본 클래스 생성자에 액세스할 수 있습니다. 다음은 앞의 예제와 동일한 ECMAScript 6 코드입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(length, width) &#123;</div><div class="line">        <span class="keyword">this</span>.length = length;</div><div class="line">        <span class="keyword">this</span>.width = width;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    getArea() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.length * <span class="keyword">this</span>.width;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(length) &#123;</div><div class="line"></div><div class="line">        <span class="comment">// Rectangle.call(this, length, length)와 같습니다.</span></div><div class="line">        <span class="keyword">super</span>(length, length);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> square = <span class="keyword">new</span> Square(<span class="number">3</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(square.getArea());              <span class="comment">// 9</span></div><div class="line"><span class="built_in">console</span>.log(square <span class="keyword">instanceof</span> Square);      <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(square <span class="keyword">instanceof</span> Rectangle);   <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>이번에 <code>Square</code> 클래스는 <code>extends</code> 키워드를 사용하여 <code>Rectangle</code>에서 상속받습니다. <code>Square</code> 생성자는 <code>super()</code>를 사용하여 지정된 파라미터로 <code>Rectangle</code> 생성자를 호출합니다. ECMAScript 5 버전의 코드와 달리 식별자 <code>Rectangle</code>은 클래스 선언 (<code>extends</code>이후)에서만 사용됩니다.</p>
<p>다른 클래스로부터 상속받은 클래스를 파생 클래스(derived classes)라고합니다. 파생 클래스는 생성자를 지정하는 경우 <code>super()</code>를 사용해야합니다. 그렇지 않으면 오류가 발생합니다. 생성자를 사용하지 않기로 결정한 경우 클래스의 새 인스턴스를 만들 때 <code>super()</code>가 모든 파라미터와 함께 자동으로 호출됩니다. 예를 들어, 다음 두 클래스는 동일합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</div><div class="line">    <span class="comment">// 생성자가 없습니다.</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 위 클래스는 아래와 동일합니다.</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(...args) &#123;</div><div class="line">        <span class="keyword">super</span>(...args);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>이 예제의 두 번째 클래스는 모든 파생 클래스에 대한 기본 생성자와 동일합니다. 모든 파라미터는 순서대로 기본 클래스 생성자에 전달됩니다. 이전에 정의한 예제에서 <code>Square</code> 클래스의 생성자는 하나의 파라미터만 필요하기 때문에 <code>super(...args)</code>는 올바르지 않으므로 수동으로 생성자를 정의하는 것이 좋습니다.</p>
<blockquote>
<p><code>super()</code>를 사용할 때 유의해야할 몇 가지 사항이 있습니다.</p>
<ol>
<li><p>파생 클래스에서만 <code>super()</code>를 사용할 수 있습니다. 비 파생 클래스 (<code>extends</code>를 사용하지 않는 클래스) 또는 함수에서 사용하려고<br>하면 오류가 발생합니다.</p>
</li>
<li><p>생성자에서 <code>this</code>에 접근하기 전에 <code>super()</code>를 호출해야합니다. <code>super()</code>는 <code>this</code>를 초기화할 책임이 있기 때문에 <code>super()</code>를 호출하기 전에 <code>this</code>에 접근하려고 하면 에러가 발생합니다.</p>
</li>
<li><p><code>super()</code>를 호출하지 않는 유일한 방법은 클래스 생성자에서 객체를 반환하는 것입니다.</p>
</li>
</ol>
</blockquote>
<h3 id="클래스-메서드-숨기기"><a href="#클래스-메서드-숨기기" class="headerlink" title="클래스 메서드 숨기기"></a>클래스 메서드 숨기기</h3><p>파생 클래스의 메서드는 항상 기본 클래스에서 같은 이름의 메서드를 숨깁니다. 예를 들어, <code>Square</code>에 <code>getArea()</code>를 추가하면 그 기능을 재정의할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(length) &#123;</div><div class="line">        <span class="keyword">super</span>(length, length);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Rectangle.prototype.getArea()를 숨기고 재정의 합니다.</span></div><div class="line">    getArea() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.length * <span class="keyword">this</span>.length;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>getArea()</code>가 <code>Square</code>의 일부로 정의 되었기 때문에 <code>Rectangle.prototype.getArea()</code> 메서드는 <code>Square</code> 인스턴스에 의해 더이상 호출되지 않습니다. 물론, 다음과 같이 <code>super.getArea()</code> 메서드를 사용하여 메서드의 기본 클래스 버전을 호출하기로 결정할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(length) &#123;</div><div class="line">        <span class="keyword">super</span>(length, length);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Rectangle.prototype.getArea()를 숨기고 재정의 하여 호출 합니다.</span></div><div class="line">    getArea() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getArea();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>이런 방식으로 <code>super</code>를 사용하는 것은 4 장에서 논의된 <code>super</code> 참조와 똑같이 작동합니다 (“Super 참조를 사용한 쉬운 프로토 타입 액세스” 참조). <code>this</code> 값은 자동으로 올바르게 설정되어 간단하게 메소드 호출할 수 있습니다.</p>
<h3 id="정적-멤버-상속"><a href="#정적-멤버-상속" class="headerlink" title="정적 멤버 상속"></a>정적 멤버 상속</h3><p>기본 클래스에 정적 멤버가 있는 경우 해당 정적 멤버는 파생 클래스에서도 사용할 수 있습니다. 상속은 다른 언어의 경우와 마찬가지로 작동하지만 이는 JavaScript에서는 새로운 개념입니다. 다음은 그 예입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(length, width) &#123;</div><div class="line">        <span class="keyword">this</span>.length = length;</div><div class="line">        <span class="keyword">this</span>.width = width;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    getArea() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.length * <span class="keyword">this</span>.width;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> create(length, width) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Rectangle(length, width);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(length) &#123;</div><div class="line"></div><div class="line">        <span class="comment">// same as Rectangle.call(this, length, length)</span></div><div class="line">        <span class="keyword">super</span>(length, length);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> rect = Square.create(<span class="number">3</span>, <span class="number">4</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(rect <span class="keyword">instanceof</span> Rectangle);     <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(rect.getArea());                <span class="comment">// 12</span></div><div class="line"><span class="built_in">console</span>.log(rect <span class="keyword">instanceof</span> Square);        <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p>이 코드에서는 새로운 정적 <code>create()</code> 메서드가 <code>Rectangle</code> 클래스에 추가되었습니다. 이 메서드는 상속을 통해 <code>Square.create()</code>로 사용할 수 있으며 <code>Rectangle.create()</code> 메서드와 같은 방식으로 동작합니다.</p>
<h3 id="표현식에서-파생된-클래스"><a href="#표현식에서-파생된-클래스" class="headerlink" title="표현식에서 파생된 클래스"></a>표현식에서 파생된 클래스</h3><p>아마도 ECMAScript 6에서 파생 클래스의 가장 강력한 부분은 표현식에서 클래스를 파생시킬 수 있는 능력입니다. 표현식이 <code>[[Construct]]</code>와 프로토 타입을 가진 함수로 해석되는한 어떤 표현식이라도 <code>extends</code>을 사용할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params">length, width</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.length = length;</div><div class="line">    <span class="keyword">this</span>.width = width;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Rectangle.prototype.getArea = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.length * <span class="keyword">this</span>.width;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(length) &#123;</div><div class="line">        <span class="keyword">super</span>(length, length);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> Square(<span class="number">3</span>);</div><div class="line"><span class="built_in">console</span>.log(x.getArea());               <span class="comment">// 9</span></div><div class="line"><span class="built_in">console</span>.log(x <span class="keyword">instanceof</span> Rectangle);    <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p><code>Rectangle</code>은 ECMAScript 5 스타일 생성자로 정의되고 <code>Square</code>는 클래스입니다. <code>Rectangle</code>은 <code>[[Construct]]</code>와 프로토 타입을 가지고 있기 때문에 <code>Square</code> 클래스는 직접 상속받을 수 있습니다.</p>
<p><code>extends</code> 이후에 어떤 타입의 표현식이라도 받아들이면 상속받을 것을 동적으로 결정하는 것과 같은 강력한 가능성을 제공합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params">length, width</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.length = length;</div><div class="line">    <span class="keyword">this</span>.width = width;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Rectangle.prototype.getArea = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.length * <span class="keyword">this</span>.width;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getBase</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> Rectangle;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">getBase</span>() </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(length) &#123;</div><div class="line">        <span class="keyword">super</span>(length, length);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> Square(<span class="number">3</span>);</div><div class="line"><span class="built_in">console</span>.log(x.getArea());               <span class="comment">// 9</span></div><div class="line"><span class="built_in">console</span>.log(x <span class="keyword">instanceof</span> Rectangle);    <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p><code>getBase()</code> 함수는 클래스 선언의 일부로서 직접 호출되어 <code>Rectangle</code>을 반환합니다. 이 예제는 기능적으로 이전의 것과 같습니다. 그리고 기본 클래스를 동적으로 결정할 수 있으므로 서로 다른 상속 접근법을 만들 수 있습니다. 예를 들어 mixin을 효과적으로 만들 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> SerializableMixin = &#123;</div><div class="line">    serialize() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> AreaMixin = &#123;</div><div class="line">    getArea() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.length * <span class="keyword">this</span>.width;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mixin</span>(<span class="params">...mixins</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> base = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">    <span class="built_in">Object</span>.assign(base.prototype, ...mixins);</div><div class="line">    <span class="keyword">return</span> base;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">mixin</span>(<span class="title">AreaMixin</span>, <span class="title">SerializableMixin</span>) </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(length) &#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">        <span class="keyword">this</span>.length = length;</div><div class="line">        <span class="keyword">this</span>.width = length;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> Square(<span class="number">3</span>);</div><div class="line"><span class="built_in">console</span>.log(x.getArea());               <span class="comment">// 9</span></div><div class="line"><span class="built_in">console</span>.log(x.serialize());             <span class="comment">// "&#123;"length":3,"width":3&#125;"</span></div></pre></td></tr></table></figure>
<p>이 예에서는 클래식 상속 대신 mixin이 사용됩니다. <code>mixin()</code> 함수는 mixin 객체를 나타내는 파라미터를 취합니다. <code>base</code>라는 함수를 생성하고 각 mixin 객체의 프로퍼티를 프로토 타입에 할당합니다. <code>mixin()</code> 함수는 <code>Square</code>가 <code>extends</code>를 사용할 수 있도록 함수를 반환합니다. <code>extends</code>가 여전히 사용되기 때문에 생성자에서 <code>super()</code>를 호출해야 한다는 것을 명심하십시오.</p>
<p><code>Square</code>의 인스턴스는 <code>AreaMixin</code>의 <code>getArea()</code>와 <code>SerializableMixin</code>의 <code>serialize()</code>를 가지고 있습니다. 이는 프로토 타입 상속을 통해 수행됩니다. <code>mixin()</code> 함수는 새로운 함수의 프로토 타입을 각 <code>mixin</code>의 모든 프로퍼티로 동적으로 채웁니다. (여러 mixin이 동일한 속성을 갖는 경우 마지막 프로퍼티만 추가됩니다.)</p>
<blockquote>
<p>모든 표현식은<code>extends</code> 다음에 사용될 수 있지만, 모든 표현식이 유효한 클래스가되는 것은 아닙니다. 특히 다음 표현식 유형은 오류를 유발합니다.</p>
<ul>
<li><code>null</code></li>
<li>Generator 함수 (Chapter 8에서 설명함)</li>
</ul>
<p>이러한 경우, 호출할 <code>[[Construct]]</code>가 없으므로 클래스의 새 인스턴스를 만들려고하면 오류가 발생합니다.</p>
</blockquote>
<h3 id="내장-Built-in-상속"><a href="#내장-Built-in-상속" class="headerlink" title="내장(Built-in) 상속"></a>내장(Built-in) 상속</h3><p>JavaScript <em>Array</em>가 추가될때부터 개발자는 상속을 통해 자신만의 특별한 <em>Array</em> 타입을 만들고 싶어했습니다. ECMAScript 5 및 이전 버전에서는 이것이 가능하지 않았습니다. 고전적인 상속을 사용하려고 시도해도 코드가 작동하지 않았습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// built-in array 작동방법</span></div><div class="line"><span class="keyword">var</span> colors = [];</div><div class="line">colors[<span class="number">0</span>] = <span class="string">"red"</span>;</div><div class="line"><span class="built_in">console</span>.log(colors.length);         <span class="comment">// 1</span></div><div class="line"></div><div class="line">colors.length = <span class="number">0</span>;</div><div class="line"><span class="built_in">console</span>.log(colors[<span class="number">0</span>]);             <span class="comment">// undefined</span></div><div class="line"></div><div class="line"><span class="comment">// ES5에서 array를 상속하도록 시도함</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyArray</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">Array</span>.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">MyArray.prototype = <span class="built_in">Object</span>.create(<span class="built_in">Array</span>.prototype, &#123;</div><div class="line">    <span class="attr">constructor</span>: &#123;</div><div class="line">        <span class="attr">value</span>: MyArray,</div><div class="line">        <span class="attr">writable</span>: <span class="literal">true</span>,</div><div class="line">        <span class="attr">configurable</span>: <span class="literal">true</span>,</div><div class="line">        <span class="attr">enumerable</span>: <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> MyArray();</div><div class="line">colors[<span class="number">0</span>] = <span class="string">"red"</span>;</div><div class="line"><span class="built_in">console</span>.log(colors.length);         <span class="comment">// 0</span></div><div class="line"></div><div class="line">colors.length = <span class="number">0</span>;</div><div class="line"><span class="built_in">console</span>.log(colors[<span class="number">0</span>]);             <span class="comment">// "red"</span></div></pre></td></tr></table></figure>
<p>이 코드의 끝 부분에 있는 <code>console.log()</code> 출력은 <em>Array</em>에 JavaScript의 고전적인 상속 형태를 사용하여, 어떤 예기치 않은 동작을 일으키는 방법을 보여줍니다. <code>MyArray</code>의 인스턴스에서 <code>length</code>와 숫자 프로퍼티는 <code>Array.apply()</code> 또는 prototype을 할당해도 Built-in <em>Array</em>에서 처럼 동작하지 않습니다.</p>
<p>ECMAScript 6 클래스의 목표 중 하나는 모든 Built-in 함수에서 상속을 허용하는 것입니다. 이를 달성하기 위해 클래스의 상속 모델은 ECMAScript 5 및 이전 버전에서 보여준 고전적인 상속 모델과 약간 다릅니다.</p>
<p>ECMAScript 5 전통적인 상속에서 <code>this</code>의 값은 파생된 타입 (예를 들면, <code>MyArray</code>)에 의해 먼저 생성되고, <code>Array.apply()</code> 메서드와 같은 기본 타입 생성자가 호출됩니다. 즉, 이것은 <code>MyArray</code> 인스턴스로 시작하여 <em>Array</em>의 추가 프로퍼티로 꾸며져 있음을 의미합니다.</p>
<p>ECMAScript 6 클래스 기반 상속에서, <code>this</code>의 값은 먼저 기본타입(<code>Array</code>)에 의해 생성된 다음 파생 클래스 생성자 (<code>MyArray</code>)에 의해 수정됩니다. 결과적으로 <code>this</code>는 기본타입의 모든 Built-in 기능으로 시작하여 그에 관련된 모든 기능을 올바르게 상속합니다.</p>
<p>다음 예제는 클래스 기반 특수 Array의 실행을 보여줍니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</div><div class="line">    <span class="comment">// empty</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> MyArray();</div><div class="line">colors[<span class="number">0</span>] = <span class="string">"red"</span>;</div><div class="line"><span class="built_in">console</span>.log(colors.length);         <span class="comment">// 1</span></div><div class="line"></div><div class="line">colors.length = <span class="number">0</span>;</div><div class="line"><span class="built_in">console</span>.log(colors[<span class="number">0</span>]);             <span class="comment">// undefined</span></div></pre></td></tr></table></figure>
<p><code>MyArray</code>는 <code>Array</code>에서 직접 상속되므로 <code>Array</code>와 같이 작동합니다. 숫자 프로퍼티와 상호 작용하면 <code>length</code> 프로퍼티를 업데이트하고, <code>length</code> 프로퍼티를 조작하면 숫자 프로퍼티를 업데이트합니다. 즉, <code>Array</code>를 상속 받아서 자신만의 파생 <em>Array</em> 클래스를 만들고 다른 Built-in 함수를 상속받을 수 있다는 것을 의미합니다.</p>
<h3 id="Symbol-species-프로퍼티"><a href="#Symbol-species-프로퍼티" class="headerlink" title="Symbol.species 프로퍼티"></a>Symbol.species 프로퍼티</h3><p>Built-in 함수의 상속이 흥미로운 점은 Built-in 함수의 인스턴스를 반환하는 모든 메서드가 파생 클래스 인스턴스를 자동으로 반환한다는 것입니다. 그래서 <code>Array</code>를 상속받은 <code>MyArray</code>라는 파생 클래스가 있다면 <code>slice()</code>와 같은 메서드는 <code>MyArray</code>의 인스턴스를 리턴합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</div><div class="line">    <span class="comment">// empty</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> items = <span class="keyword">new</span> MyArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>),</div><div class="line">    subitems = items.slice(<span class="number">1</span>, <span class="number">3</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(items <span class="keyword">instanceof</span> MyArray);      <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(subitems <span class="keyword">instanceof</span> MyArray);   <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>이 코드에서 <code>slice()</code> 메서드는 <code>MyArray</code> 인스턴스를 반환합니다. <code>slice()</code> 메서드는 <code>Array</code>로부터 상속 받고 <code>Array</code>의 인스턴스를 정상적으로 리턴합니다. 하지만 뒤에서 이 변화를 일으키는 것은 <code>Symbol.species</code> 프로퍼티입니다.</p>
<p><code>Symbol.species</code> <em>Symbol</em>은 함수를 반환하는 정적(Static) 접근자(Accessor) 프로퍼티를 정의하는데 사용됩니다. 이 함수는 클래스의 인스턴스가 인스턴스 메서드 내부에서 만들어져야 할 때마다 생성자 대신 사용하는 생성자입니다. 아래의 Built-in 타입은 <code>Symbol.species</code>가 정의되어 있습니다.</p>
<ul>
<li>Array</li>
<li>ArrayBuffer (Chapter 10에서 논의 합니다.)</li>
<li>Map</li>
<li>Promise</li>
<li>RegExp</li>
<li>Set</li>
<li>Typed Array (Chapter 10에서 논의 합니다.)</li>
</ul>
<p>이 각각의 타입은 <code>this</code>를 반환하는 디폴트 <code>Symbol.species</code> 프로퍼티를 가지고 있습니다. 이것은 프로퍼티가 항상 생성자 함수를 반환한다는 것을 의미합니다. 커스텀 클래스에서 이 기능을 구현한다면 코드는 다음과 같이 보일 것입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 몇몇 builtin 타입은 이와 유사한 방법을 사용합니다.</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> get [<span class="built_in">Symbol</span>.species]() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">constructor</span>(value) &#123;</div><div class="line">        <span class="keyword">this</span>.value = value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    clone() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">this</span>.constructor[<span class="built_in">Symbol</span>.species](<span class="keyword">this</span>.value);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>이 예제에서 잘 알려진 <code>Symbol.species</code> <em>Symbol</em>은 <code>MyClass</code>에 정적 접근자 프로퍼티를 할당하는데 사용됩니다. 클래스의 타입 변경은 불가능하므로 setter가 없는 getter만 있습니다. <code>this.constructor [Symbol.species]</code>를 호출하면 <code>MyClass</code>가 리턴됩니다. <code>clone()</code> 메서드는 직접 <code>MyClass</code>를 사용하지 않고 클래스 정의(Class Definition)를 사용하여 새로운 인스턴스를 반환합니다. 그리고 파생 클래스가 그 값을 오버라이드(override) 할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> get [<span class="built_in">Symbol</span>.species]() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">constructor</span>(value) &#123;</div><div class="line">        <span class="keyword">this</span>.value = value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    clone() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">this</span>.constructor[<span class="built_in">Symbol</span>.species](<span class="keyword">this</span>.value);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDerivedClass1</span> <span class="keyword">extends</span> <span class="title">MyClass</span> </span>&#123;</div><div class="line">    <span class="comment">// empty</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDerivedClass2</span> <span class="keyword">extends</span> <span class="title">MyClass</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> get [<span class="built_in">Symbol</span>.species]() &#123;</div><div class="line">        <span class="keyword">return</span> MyClass;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> instance1 = <span class="keyword">new</span> MyDerivedClass1(<span class="string">"foo"</span>),</div><div class="line">    clone1 = instance1.clone(),</div><div class="line">    instance2 = <span class="keyword">new</span> MyDerivedClass2(<span class="string">"bar"</span>),</div><div class="line">    clone2 = instance2.clone();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(clone1 <span class="keyword">instanceof</span> MyClass);             <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(clone1 <span class="keyword">instanceof</span> MyDerivedClass1);     <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(clone2 <span class="keyword">instanceof</span> MyClass);             <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(clone2 <span class="keyword">instanceof</span> MyDerivedClass2);     <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p>여기에서 <code>MyDerivedClass1</code>은 <code>MyClass</code>를 상속 받고 <code>Symbol.species</code> 프로퍼티는 변경하지 않습니다. <code>clone()</code>이 호출되면, <code>this.constructor [Symbol.species]</code>가 <code>MyDerivedClass1</code>을 리턴하기 때문에 <code>MyDerivedClass1</code>의 인스턴스를 리턴합니다. <code>MyDerivedClass2</code> 클래스는 <code>MyClass</code>를 상속 받아 <code>Symbol.species</code>를 오버라이드하여 <code>MyClass</code>를 반환합니다. <code>MyDerivedClass2</code>의 인스턴스에서 <code>clone()</code>이 호출될 때, 반환 값은 <code>MyClass</code>의 인스턴스입니다. <code>Symbol.species</code>를 사용하여 파생 클래스는 메서드가 인스턴스를 리턴할 때 리턴되어야 하는 값의 타입을 판별할 수 있습니다.</p>
<p>예를 들어 <code>Array</code>는 <code>Symbol.species</code>를 사용하여 배열을 반환하는 메서드에 사용할 클래스를 지정합니다. <code>Array</code>에서 파생된 클래스에서 다음과 같이 상속된 메서드에서 반환된 객체의 타입을 결정할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> get [<span class="built_in">Symbol</span>.species]() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">Array</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> items = <span class="keyword">new</span> MyArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>),</div><div class="line">    subitems = items.slice(<span class="number">1</span>, <span class="number">3</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(items <span class="keyword">instanceof</span> MyArray);      <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(subitems <span class="keyword">instanceof</span> <span class="built_in">Array</span>);     <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(subitems <span class="keyword">instanceof</span> MyArray);   <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p>이 코드는 <code>Array</code>를 상속받은 <code>MyArray</code>의 <code>Symbol.species</code>를 오버라이드합니다. <em>Array</em>를 반환하는 모든 상속된 메서드는 이제<code>MyArray</code> 대신 <code>Array</code> 인스턴스를 사용합니다.</p>
<p>일반적으로 클래스 메서드에서 <code>this.constructor</code>를 사용하려고 할 때마다 <code>Symbol.species</code> 프로퍼티를 사용해야합니다. 이렇게하면 파생 클래스가 반환 형식을 쉽게 재정의할 수 있습니다. 또한 <code>Symbol.species</code>가 정의된 클래스에서 파생 클래스를 만드는 경우에도 생성자 대신 사용해야 합니다.</p>
<h2 id="클래스-생성자에서-new-target-사용"><a href="#클래스-생성자에서-new-target-사용" class="headerlink" title="클래스 생성자에서 new.target 사용"></a>클래스 생성자에서 new.target 사용</h2><p>3 장에서는 <code>new.target</code>과 함수가 호출되는 방식에 따라 값이 변경되는 방법에 대해 알게되었습니다. 클래스 생성자에서 <code>new.target</code>을 사용하여 클래스가 호출되는 방법을 결정할 수도 있습니다. <code>new.target</code>은 다음 예제와 같이 클래스 생성자 함수와 같습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(length, width) &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">new</span>.target === Rectangle);</div><div class="line">        <span class="keyword">this</span>.length = length;</div><div class="line">        <span class="keyword">this</span>.width = width;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// new.target은 Rectangle입니다.</span></div><div class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Rectangle(<span class="number">3</span>, <span class="number">4</span>);      <span class="comment">// true 출력</span></div></pre></td></tr></table></figure>
<p>이 코드의 <code>new.target</code>은 <code>new Rectangle(3, 4)</code>이 호출될 때 <code>Rectangle</code>과 동일하다는 것을 보여줍니다. 클래스 생성자는 <code>new</code>가 없으면 호출될 수 없으므로 <code>new.target</code> 프로퍼티는 항상 클래스 생성자 내부에서 정의됩니다. 그러나 그 값이 항상 같지는 않을 수도 있습니다. 다음 코드를 살펴보겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(length, width) &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">new</span>.target === Rectangle);</div><div class="line">        <span class="keyword">this</span>.length = length;</div><div class="line">        <span class="keyword">this</span>.width = width;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(length) &#123;</div><div class="line">        <span class="keyword">super</span>(length, length)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// new.target is Square</span></div><div class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Square(<span class="number">3</span>);      <span class="comment">// 결과는 false</span></div></pre></td></tr></table></figure>
<p><code>Square</code>는 <code>Rectangle</code> 생성자를 호출하고 <code>Rectangle</code> 생성자가 호출될 때 <code>new.target</code>은 <code>Square</code>와 같습니다. 이는 각 생성자에게 호출되는 방식에 따라 동작을 변경할 수있는 기능을 제공하므로 중요합니다. 예를 들어, 다음과 같이 <code>new.target</code>을 사용하여 추상적인 기본 클래스 (직접적으로 인스턴스화할 수없는 클래스)를 생성할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// abstract base class</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>() &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">new</span>.target === Shape) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"This class cannot be instantiated directly."</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(length, width) &#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">        <span class="keyword">this</span>.length = length;</div><div class="line">        <span class="keyword">this</span>.width = width;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> Shape();                <span class="comment">// throws error</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> y = <span class="keyword">new</span> Rectangle(<span class="number">3</span>, <span class="number">4</span>);        <span class="comment">// no error</span></div><div class="line"><span class="built_in">console</span>.log(y <span class="keyword">instanceof</span> Shape);    <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>이 예제에서 <code>Shape</code> 클래스 생성자는 <code>new.target</code>이 <code>Shape</code> 일 때마다 에러를 던집니다. 즉, <code>new Shape ()</code>는 항상 에러를 던집니다. 그러나 여전히 <code>Rectangle</code>에서 사용하는 것처럼 <code>Shape</code>을 기본 클래스로 사용할 수 있습니다.  <code>super()</code> 호출은 <code>Shape</code> 생성자를 실행하고 <code>new.target</code>은 <code>Rectangle</code>과 같습니다. 그래서 생성자는 오류없이 계속됩니다.</p>
<blockquote>
<p><code>new</code>가 없으면 클래스를 호출할 수 없으므로 <code>new.target</code> 프로퍼티는 결코 클래스 생성자 내부에서 정의되지 않습니다.</p>
</blockquote>
<h2 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h2><p>ECMAScript 6 클래스는 JavaScript에서 상속을 사용하기 쉽게하기 때문에 다른 언어에서 상속에 대한 기존의 이해를 버릴 필요가 없습니다. ECMAScript 6 클래스는 ECMAScript 5의 클래식 상속 모델에 대한 Syntactic sugar로 시작하지만 실수를 줄이기위한 많은 기능을 추가합니다.</p>
<p>ECMAScript 6 클래스는 클래스 프로토 타입에 비 정적 메서드를 정의하여 프로토 타입 상속과 함께 작동하고, 정적 메서드는 생성자 자체에서 끝납니다. 클래스의 모든 메소드는 Non-enumerable이며, 기본적으로 Non-enumerable인 Built-in 객체의 동작과 더 잘 일치하는 기능입니다. 또한 클래스 생성자는 <code>new</code>가 없으면 호출할 수 없으므로 실수로 클래스를 함수로 호출할 수 없습니다.</p>
<p>클래스 기반 상속을 사용하면 다른 클래스, 함수 또는 표현식에서 클래스를 파생시킬 수 있습니다. 이 기능을 사용하여 상속할 올바른 기준을 결정하는 함수를 호출할 수 있으므로 mixin 및 다른 여러 구성 패턴을 사용하여 새 클래스를 만들 수 있습니다. 상속은 <code>Array</code>와 같은 Built-in 객체를 상속하는 것이 가능합니다.</p>
<p>클래스 생성자에서 <code>new.target</code>을 사용하여 클래스가 어떻게 호출되는지에 따라 다르게 행동할 수 있습니다. 가장 보편적인 사용은 직접적으로 인스턴스화 될 때 오류를 던지지만 다른 클래스를 통해 상속을 허용하는 추상 기본 클래스를 만드는 것입니다.</p>
<p>전반적으로 클래스는 JavaScript에 중요한 추가 요소입니다. 보다 간결한 구문과 사용자 정의 객체 타입을 안전하고 일관된 방식으로 정의하기 위한 더 나은 기능을 제공합니다.</p>
<hr>
<blockquote>
<p>이 내용은 나중에 참고하기 위해 제가 공부하며 정리한 내용입니다.<br>의역, 오역, 직역이 있을 수 있음을 알려드립니다.<br>This post is a translation of this original article [<a href="https://leanpub.com/understandinges6/read#leanpub-auto-introducing-javascript-classes" target="_blank" rel="external">https://leanpub.com/understandinges6/read#leanpub-auto-introducing-javascript-classes</a>]</p>
</blockquote>
<h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul>
<li><a href="https://infoscis.github.io/2018/01/24/ecmascript-6-block-binding/">ECMAScript 6 Block Binding</a></li>
<li><a href="https://infoscis.github.io/2018/01/24/ecmascript-6-strings-and-regular-expressions/">ECMAScript 6 문자열과 정규 표현식</a></li>
<li><a href="https://infoscis.github.io/2018/01/24/ecmascript-6-functions/">ECMAScript 6 함수</a></li>
<li><a href="https://infoscis.github.io/2018/01/25/ecmascript-6-expanded-object-functionality/">ECMAScript 6 객체의 확장된 기능</a></li>
<li><a href="https://infoscis.github.io/2018/01/26/ecmascript-6-destructuring-for-easier-data-access/">ECMAScript 6 쉬운 데이터 액세스를 위한 Destructuring</a></li>
<li><a href="https://infoscis.github.io/2018/01/27/ecmascript-6-symbols-and-symbol-properties/">ECMAScript 6 Symbol과 Symbol 프로퍼티</a></li>
<li><a href="https://infoscis.github.io/2018/01/27/ecmascript-6-sets-and-maps/">ECMAScript 6 Set과 Map</a></li>
<li><a href="https://infoscis.github.io/2018/01/31/ecmascript-6-iterators-and-generators/">ECMAScript 6 Iterator와 Generator</a></li>
<li><a href="https://infoscis.github.io/2018/02/13/ecmascript-6-introducing-javascript-classes/">ECMAScript 6 JavaScript 클래스 소개</a></li>
<li><a href="https://infoscis.github.io/2018/02/13/ecmascript-6-improved-array-capabilities/">ECMAScript 6 Array 기능 향상</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-promises-and-asynchronous-programming/">ECMAScript 6 Promise와 비동기 프로그램밍</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-proxies-and-the-reflection-api/">ECMAScript 6 프록시와 리플렉션 API</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-encapsulating-code-with-modules/">ECMAScript 6 Module로 코드 캡슐화하기</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-appendix-a-smaller-changes/">ECMAScript 6 부록 A. 작은 변경 사항</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-appendix-b-understanding-ecmascript-7/">ECMAScript 6 부록 B. ECMAScript 7(2016) 이해하기</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JavaScript-클래스-소개&quot;&gt;&lt;a href=&quot;#JavaScript-클래스-소개&quot; class=&quot;headerlink&quot; title=&quot;JavaScript 클래스 소개&quot;&gt;&lt;/a&gt;JavaScript 클래스 소개&lt;/h1&gt;&lt;p&gt;대부분의 공식적인 
    
    </summary>
    
      <category term="JavaScript" scheme="http://infoscis.github.io/categories/JavaScript/"/>
    
      <category term="ECMAScript 2015" scheme="http://infoscis.github.io/categories/JavaScript/ECMAScript-2015/"/>
    
    
      <category term="JavaScript" scheme="http://infoscis.github.io/tags/JavaScript/"/>
    
      <category term="ECMAScript 2015" scheme="http://infoscis.github.io/tags/ECMAScript-2015/"/>
    
  </entry>
  
  <entry>
    <title>Angular에서 ViewChildren, ContentChildren, 그리고 QueryList 이해하기</title>
    <link href="http://infoscis.github.io/2018/02/13/understanding-viewchildren-contentchildren-and-querylist-in-angular/"/>
    <id>http://infoscis.github.io/2018/02/13/understanding-viewchildren-contentchildren-and-querylist-in-angular/</id>
    <published>2018-02-13T14:43:23.000Z</published>
    <updated>2018-02-13T15:10:21.970Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Angular에서-ViewChildren-ContentChildren-그리고-QueryList-이해하기"><a href="#Angular에서-ViewChildren-ContentChildren-그리고-QueryList-이해하기" class="headerlink" title="Angular에서 ViewChildren, ContentChildren, 그리고 QueryList 이해하기"></a>Angular에서 ViewChildren, ContentChildren, 그리고 QueryList 이해하기</h1><p>부모 <em>Component</em>에서 자녀에게 액세스 해야하는 경우가 있습니다. Angular로 어떻게 처리 할 수 있는지 보도록 하겠습니다.</p>
<h3 id="ViewChildren"><a href="#ViewChildren" class="headerlink" title="ViewChildren"></a>ViewChildren</h3><blockquote>
<p>View DOM에서 지정된 <em>Component</em> 또는 <em>Directive</em>를 QueryList로 반환합니다.</p>
</blockquote>
<p>예를 들어 간단한 <code>alert</code> <em>Component</em>를 작성해 보겠습니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span>(&#123;</div><div class="line">  selector: <span class="string">'alert'</span>,</div><div class="line">  template: <span class="string">`</span></div><div class="line">    &lt;h1 (click)="alert()"&gt;&#123;&#123;type&#125;&#125;&lt;/h1&gt;</div><div class="line">  `,</div><div class="line">&#125;)</div><div class="line"><span class="keyword">export</span> <span class="keyword">class</span> AlertComponent &#123;</div><div class="line">  <span class="meta">@Input</span>() <span class="keyword">type</span>: <span class="built_in">string</span> = <span class="string">"success"</span>;</div><div class="line">  </div><div class="line">  alert() &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"alert"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>이제 우리의 <code>app</code> <em>Component</em>에서 이 <em>Component</em>를 여러번 사용하고 <code>@ViewChildren</code> 데코레이터를 사용합시다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span>(&#123;</div><div class="line">  selector: <span class="string">'my-app'</span>,</div><div class="line">  template: <span class="string">`</span></div><div class="line">    &lt;alert&gt;&lt;/alert&gt;</div><div class="line">    &lt;alert type="danger"&gt;&lt;/alert&gt;</div><div class="line">    &lt;alert type="info"&gt;&lt;/alert&gt;</div><div class="line">  `,</div><div class="line">&#125;)</div><div class="line"><span class="keyword">export</span> <span class="keyword">class</span> App &#123;</div><div class="line">  <span class="meta">@ViewChildren</span>(AlertComponent) alerts: QueryList&lt;AlertComponent&gt;</div><div class="line">  </div><div class="line">  ngAfterViewInit() &#123;</div><div class="line">    <span class="keyword">this</span>.alerts.forEach(<span class="function"><span class="params">alertInstance</span> =&gt;</span> <span class="built_in">console</span>.log(alertInstance));</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>우리는 <code>@ViewChildren</code> 데코레이터를 사용하여 호스트 뷰에서 요소를 가져올 수 있습니다.</p>
<p><code>@ViewChildren</code> 데코레이터는 파라미터 타입으로 <em>Component</em> / <em>Directive</em> 타입 또는 템플릿 변수 이름을 지원합니다.</p>
<p>파라미터가 <em>Component</em> / <em>Directive</em> 일 경우 반환 값은 <em>Component</em> / <em>Directive</em>의 인스턴스가 됩니다.</p>
<p><img src="https://cdn-images-1.medium.com/max/1600/1*MTk58yTB865Bc8cOgaiGYw.png" alt=""></p>
<p>파라미터가 템플릿 변수 이름인 경우 반환 값은 Native Element에 대한 참조가 됩니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span>(&#123;</div><div class="line">  selector: <span class="string">'my-app'</span>,</div><div class="line">  template: <span class="string">`</span></div><div class="line">    &lt;div #div&gt;#div is a template variable&lt;/div&gt;</div><div class="line">  `,</div><div class="line">&#125;)</div><div class="line"><span class="keyword">export</span> <span class="keyword">class</span> App &#123;</div><div class="line">  <span class="meta">@ViewChildren</span>(<span class="string">"div"</span>) divs: QueryList&lt;<span class="built_in">any</span>&gt;</div><div class="line">  </div><div class="line">  ngAfterViewInit() &#123;</div><div class="line">    <span class="keyword">this</span>.divs.forEach(<span class="function"><span class="params">div</span> =&gt;</span> <span class="built_in">console</span>.log(div));</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://cdn-images-1.medium.com/max/1600/1*LzNNo2S77gcZTH53q4Yk_Q.png" alt=""></p>
<blockquote>
<p>참고: 이 경우 하나의 요소이므로 <code>@ViewChild</code> 데코레이터를 사용하는 것이 더 좋습니다.</p>
</blockquote>
<h3 id="read-파라미터"><a href="#read-파라미터" class="headerlink" title="read 파라미터"></a>read 파라미터</h3><p>기본적으로 <code>@ViewChildren</code> 데코레이터는 <em>Component</em> 인스턴스를 반환하지만 다른 토큰을 요청할 수 있습니다.</p>
<ul>
<li><p>native DOM Element</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@ViewChildren</span>(AlertComponent, &#123; read: ElementRef &#125;) alerts: QueryList&lt;AlertComponent&gt;</div></pre></td></tr></table></figure>
<p><img src="https://cdn-images-1.medium.com/max/1600/1*ErdMIcdmuLCl1GPLlPE4XQ.png" alt=""></p>
</li>
<li><p>ViewContainerRef  - 템플릿이나 <em>Component</em>를 동적으로 만들어야 할 때 이 토큰이 필요합니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@ViewChildren</span>(AlertComponent, &#123; read: ViewContainerRef &#125;) alerts: QueryList&lt;AlertComponent&gt;</div></pre></td></tr></table></figure>
<p><img src="https://cdn-images-1.medium.com/max/1600/1*P6uwx4bMpriVFoL5E6dHcg.png" alt=""></p>
</li>
</ul>
<h3 id="QueryList"><a href="#QueryList" class="headerlink" title="QueryList"></a>QueryList</h3><p><code>@ViewChildren</code>의 반환 타입은 <code>QueryList</code>입니다. <code>QueryList</code>는 항목 목록을 저장하는 객체의 이름입니다. 이 객체의 특별한 점은 응용 프로그램의 상태가 변경되면 Angular가 자동으로 객체 항목을 업데이트한다는 것입니다.</p>
<p><code>QueryList</code>는 <em>Iterable</em> 인터페이스를 구현하므로 <code>ngFor</code> <em>Directive</em>를 사용하여 Angular 템플릿에서 사용할 수 있습니다.</p>
<h4 id="QueryList-API"><a href="#QueryList-API" class="headerlink" title="QueryList API"></a>QueryList API</h4><h5 id="Getter"><a href="#Getter" class="headerlink" title="Getter"></a>Getter</h5><ul>
<li>first - 첫 번째 항목 가져 오기</li>
<li>last - 마지막 항목 가져 오기</li>
<li>length - 아이템 길이를 얻는다.</li>
</ul>
<h5 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h5><p><code>map()</code>, <code>filter()</code> , <code>find()</code>, <code>reduce()</code>, <code>forEach()</code>, <code>some()</code></p>
<ul>
<li><code>toArray()</code> - JavaScript 배열로 항목을 반환합니다.</li>
<li>changes () - 값의 변경을 changes Observable을 구독 (subscribe)하여 인지할 수 있습니다. 하위 요소가 추가, 제거 또는 이동될 때마다 쿼리 목록이 업데이트되고 쿼리 목록의 changes Observable이 새로운 값을 emit 합니다.</li>
</ul>
<h4 id="기억하세요"><a href="#기억하세요" class="headerlink" title="기억하세요"></a>기억하세요</h4><p><code>QueryList</code>는 <code>ngAfterViewInit</code> 라이프 사이클 훅 전에만 초기화되며, 따라서 이 시점에만 사용할 수 있습니다.</p>
<h3 id="ViewChildren-vs-ContentChildren"><a href="#ViewChildren-vs-ContentChildren" class="headerlink" title="@ViewChildren vs @ContentChildren"></a>@ViewChildren vs @ContentChildren</h3><p><code>@ViewChildren</code>은 <code>ng-content</code> 태그 내에 존재하는 요소를 포함하지 않습니다.</p>
<p><code>@ContentChildren</code>은 <code>ng-content</code> 태그 내에 존재하는 요소만 포함됩니다.</p>
<p><img src="https://cdn-images-1.medium.com/max/1600/1*PpBxoE8q6s6PQeqY-8j96w.png" alt=""></p>
<h3 id="ContentChildren"><a href="#ContentChildren" class="headerlink" title="@ContentChildren"></a>@ContentChildren</h3><blockquote>
<p>Content DOM에서 지정된 요소 또는 <em>Directive</em>를 QueryList로 반환합니다.</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span>(&#123;</div><div class="line">  selector: <span class="string">'tab'</span>,</div><div class="line">  template: <span class="string">`</span></div><div class="line">    &lt;p&gt;&#123;&#123;title&#125;&#125;&lt;/p&gt;</div><div class="line">  `,</div><div class="line">&#125;)</div><div class="line"><span class="keyword">export</span> <span class="keyword">class</span> TabComponent &#123;</div><div class="line">  <span class="meta">@Input</span>() title;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Component</span>(&#123;</div><div class="line">  selector: <span class="string">'tabs'</span>,</div><div class="line">  template: <span class="string">`</span></div><div class="line">    &lt;ng-content&gt;&lt;/ng-content&gt;</div><div class="line">  `,</div><div class="line">&#125;)</div><div class="line"><span class="keyword">export</span> <span class="keyword">class</span> TabsComponent &#123;</div><div class="line"> <span class="meta">@ContentChildren</span>(TabComponent) tabs: QueryList&lt;TabComponent&gt;</div><div class="line"> </div><div class="line"> ngAfterContentInit() &#123;</div><div class="line">   <span class="keyword">this</span>.tabs.forEach(<span class="function"><span class="params">tabInstance</span> =&gt;</span> <span class="built_in">console</span>.log(tabInstance))</div><div class="line"> &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Component</span>(&#123;</div><div class="line">  selector: <span class="string">'my-app'</span>,</div><div class="line">  template: <span class="string">`</span></div><div class="line">    &lt;tabs&gt;</div><div class="line">     &lt;tab title="One"&gt;&lt;/tab&gt;</div><div class="line">     &lt;tab title="Two"&gt;&lt;/tab&gt;</div><div class="line">    &lt;/tabs&gt;</div><div class="line">  `,</div><div class="line">&#125;)</div><div class="line"><span class="keyword">export</span> <span class="keyword">class</span> App &#123;&#125;</div></pre></td></tr></table></figure>
<h4 id="기억하세요-1"><a href="#기억하세요-1" class="headerlink" title="기억하세요"></a>기억하세요</h4><p><code>QueryList</code>는 <code>ngAfterContentInit</code> 라이프 사이클 훅 전에만 초기화되며, 따라서 이 시점에서만 사용할 수 있습니다.</p>
<hr>
<blockquote>
<p>이 내용은 나중에 참고하기 위해 제가 공부하며 정리한 내용입니다.<br>의역, 오역, 직역이 있을 수 있음을 알려드립니다.<br>This post is a translation of this original article [<a href="https://netbasal.com/understanding-viewchildren-contentchildren-and-querylist-in-angular-896b0c689f6e" target="_blank" rel="external">https://netbasal.com/understanding-viewchildren-contentchildren-and-querylist-in-angular-896b0c689f6e</a>]</p>
</blockquote>
<h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul>
<li><a href="https://infoscis.github.io/2017/07/21/angular-tutorial-introduction/">Angular 튜토리얼 - 소개</a></li>
<li><a href="https://infoscis.github.io/2017/07/21/angular-tutorial-the-hero-editor/">Angular 튜터리얼 - Hero 에디터</a></li>
<li><a href="https://infoscis.github.io/2017/07/21/angular-tutorial-master-detail/">Angular 튜터리얼 - Master/Detail</a></li>
<li><a href="https://infoscis.github.io/2017/07/21/angular-tutorial-multiple-components/">Angular 튜터리얼 - 다중 콤포넌트</a></li>
<li><a href="https://infoscis.github.io/2017/07/21/angular-tutorial-services/">Angular 튜터리얼 - 서비스</a></li>
<li><a href="https://infoscis.github.io/2017/07/21/angular-tutorial-routing/">Angular 튜터리얼 - 라우팅</a></li>
<li><a href="https://infoscis.github.io/2017/07/21/angular-tutorial-http/">Angular 튜터리얼 - HTTP</a></li>
<li><a href="https://infoscis.github.io/2017/07/21/angular-http-client/">Angular HttpClient</a></li>
<li><a href="https://infoscis.github.io/2017/06/15/angular-webpack-configuration/">Angular Webpack 설정</a></li>
<li><a href="https://infoscis.github.io/2018/01/24/angular-translation-service/">Angular에서 간단하게 번역기능 구현하기</a></li>
<li><a href="https://infoscis.github.io/2018/01/24/angular-dynamic-component/">Angular 동적 컴포넌트 로딩</a></li>
<li><a href="https://infoscis.github.io/2018/02/13/dynamic-content-in-angular/">Angular에서 동적 컨텐츠 생성</a></li>
<li><a href="https://infoscis.github.io/2018/02/13/understanding-viewchildren-contentchildren-and-querylist-in-angular/">Angular에서 ViewChildren, ContentChildren, 그리고 QueryList 이해하기</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Angular에서-ViewChildren-ContentChildren-그리고-QueryList-이해하기&quot;&gt;&lt;a href=&quot;#Angular에서-ViewChildren-ContentChildren-그리고-QueryList-이해하기&quot; clas
    
    </summary>
    
      <category term="Angular" scheme="http://infoscis.github.io/categories/Angular/"/>
    
    
      <category term="Angular" scheme="http://infoscis.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>Angular에서 동적 컨텐츠 생성</title>
    <link href="http://infoscis.github.io/2018/02/13/dynamic-content-in-angular/"/>
    <id>http://infoscis.github.io/2018/02/13/dynamic-content-in-angular/</id>
    <published>2018-02-13T14:42:55.000Z</published>
    <updated>2018-02-13T15:10:29.661Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Angular에서-동적-컨텐츠-생성"><a href="#Angular에서-동적-컨텐츠-생성" class="headerlink" title="Angular에서 동적 컨텐츠 생성"></a>Angular에서 동적 컨텐츠 생성</h1><p>이 글에서 Angular로 동적 컨텐츠를 만드는 몇가지 방법을 보여 드리겠습니다. 사용자 지정 리스트 템플릿, 동적 <em>Component</em> 생성, 런타임 <em>Component</em> 및 모듈 컴파일의 예제를 보여줍니다. 전체 소스 코드는 이 글의 끝부분에서 보실수 있습니다.</p>
<p>제가 작업하고 있는 <a href="https://leanpub.com/developing-with-angular" target="_blank" rel="external">Developing with Angular</a>에서 Angular 개발에 대한 더 많은 정보를 얻을 수 있습니다.</p>
<h2 id="List-item-templates"><a href="#List-item-templates" class="headerlink" title="List item templates"></a>List item templates</h2><p>사용자 정의 템플릿을 제공하여 Angular <em>Component</em>를 풍성하게 만드는 방법을 살펴 보겠습니다. 개발자가 선언한 외부 Row(행) 템플릿을 지원하는 간단한 리스트 <em>Component</em>를 작성하며 시작하겠습니다.</p>
<h3 id="List-component"><a href="#List-component" class="headerlink" title="List component"></a>List component</h3><p>먼저 바인딩된 항목 컬렉션을 표시하는 간단한 리스트 <em>Component</em>를 만듭니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span>(&#123;</div><div class="line">    selector: <span class="string">'tlist'</span>,</div><div class="line">    template: <span class="string">`</span></div><div class="line">    &lt;ul&gt;</div><div class="line">        &lt;li *ngFor="let item of items"&gt;</div><div class="line">            &#123;&#123; item.title &#125;&#125;</div><div class="line">        &lt;/li&gt;</div><div class="line">    &lt;/ul&gt;</div><div class="line">  `</div><div class="line">&#125;)</div><div class="line"><span class="keyword">export</span> <span class="keyword">class</span> TListComponent &#123;</div><div class="line"></div><div class="line">    <span class="meta">@Input</span>()</div><div class="line">    items: <span class="built_in">any</span>[] = [];</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>이제 메인 응용 프로그램 <em>Component</em>를 업데이트 하거나 다음 예제와 같이 별도의 데모 <em>Component</em>를 만듭니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span>(&#123;</div><div class="line">    selector: <span class="string">'tlist-demo'</span>,</div><div class="line">    template: <span class="string">`</span></div><div class="line">        &lt;h1&gt;Templated list&lt;/h1&gt;</div><div class="line">        &lt;tlist [items]="items"&gt;&lt;/tlist&gt;</div><div class="line">    `</div><div class="line">&#125;)</div><div class="line"><span class="keyword">export</span> <span class="keyword">class</span> AppComponent &#123;</div><div class="line"></div><div class="line">    items: <span class="built_in">any</span>[] = [</div><div class="line">        &#123; title: <span class="string">'Item 1'</span> &#125;,</div><div class="line">        &#123; title: <span class="string">'Item 2'</span> &#125;,</div><div class="line">        &#123; title: <span class="string">'Item 3'</span> &#125;</div><div class="line">    ];</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>그러면 다음과 같이 정렬되지 않은 HTML 목록이 렌더링됩니다.</p>
<p><img src="https://denysvuika.files.wordpress.com/2017/10/angular-dynamic-content-01.png" alt=""></p>
<h3 id="Row-templates"><a href="#Row-templates" class="headerlink" title="Row templates"></a>Row templates</h3><p>우리는 객체의 배열에 바인딩하고 정렬되지 않은 표준 HTML리스트를 렌더링하는 간단한 리스트 컴포넌트를 만들었습니다. 그리고 모든 리스트 항목은 <code>title</code> 프로퍼티 값에 바인딩됩니다. 이제 외부 템플릿을 지원하도록 코드를 변경해 보겠습니다. 아래 그림과 같이 코드를 업데이트 합니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; Component, Input, ContentChild, TemplateRef &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</div><div class="line"></div><div class="line"><span class="meta">@Component</span>(&#123;</div><div class="line">    selector: <span class="string">'tlist'</span>,</div><div class="line">    template: <span class="string">`</span></div><div class="line">        &lt;ul&gt;</div><div class="line">            &lt;template ngFor [ngForOf]="items" [ngForTemplate]="template"&gt;</div><div class="line">            &lt;/template&gt;</div><div class="line">        &lt;/ul&gt;</div><div class="line">    `</div><div class="line">&#125;)</div><div class="line"><span class="keyword">export</span> <span class="keyword">class</span> TListComponent &#123;</div><div class="line"></div><div class="line">    <span class="meta">@ContentChild</span>(TemplateRef)</div><div class="line">    template: TemplateRef&lt;<span class="built_in">any</span>&gt;;</div><div class="line"></div><div class="line">    <span class="meta">@Input</span>()</div><div class="line">    items: <span class="built_in">any</span>[] = [];</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>이제 <code>TListComponent</code>는 자식 컨텐츠에서 정의될 템플릿을 참조합니다. 그리고 템플릿 내용을 받아 각 <code>*ngFor</code> 항목에 적용합니다. 따라서 이 <em>Component</em>를 사용하는 응용 프로그램 개발자는 다음과 같이 전체 Row 템플릿을 정의할 수 있습니다.</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">tlist</span> [<span class="attr">items</span>]=<span class="string">"items"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">template</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span></div><div class="line">            Row template content</div><div class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">tlist</span>&gt;</span></div></pre></td></tr></table></figure>
<p>이제 아래 예제와 같이 업데이트합니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</div><div class="line"></div><div class="line"><span class="meta">@Component</span>(&#123;</div><div class="line">    selector: <span class="string">'tlist-demo'</span>,</div><div class="line">    template: <span class="string">`</span></div><div class="line">        &lt;div&gt;</div><div class="line">            &lt;h2&gt;Templated list&lt;/h2&gt;</div><div class="line">            &lt;tlist [items]="items"&gt;</div><div class="line">                &lt;template let-item="$implicit" let-i="index"&gt;</div><div class="line">                    &lt;li&gt;[&#123;&#123;i&#125;&#125;] Hello: &#123;&#123;item.title&#125;&#125;&lt;/li&gt;</div><div class="line">                &lt;/template&gt;</div><div class="line">            &lt;/tlist&gt;</div><div class="line">        &lt;/div&gt;</div><div class="line">    `</div><div class="line">&#125;)</div><div class="line"><span class="keyword">export</span> <span class="keyword">class</span> TListComponentDemo &#123;</div><div class="line">    items: <span class="built_in">any</span>[] = [</div><div class="line">        &#123; title: <span class="string">'Item 1'</span> &#125;,</div><div class="line">        &#123; title: <span class="string">'Item 2'</span> &#125;,</div><div class="line">        &#123; title: <span class="string">'Item 3'</span> &#125;</div><div class="line">    ];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>각 Row에 대한 기본 데이터 바인딩 컨텍스트에 액세스하기 위해 <code>let-item = &quot;$implicit&quot;</code> 프로퍼티를 사용하여 <code>item</code> 변수에 매핑합니다. 따라서 <code>item</code>은 <code>TListComponentDemo</code>의 <code>items</code> 컬렉션에 있는 항목을 가리키며 <code>title</code> 프로퍼티에 바인딩할 수 있습니다. 또한 <code>let-i = &quot;index&quot;</code>를 통해 <code>i</code> 변수에 Row 인덱스 프로퍼티 값을 할당합니다.</p>
<p>또 다른 개선점은 <code>TListComponent</code>가 더 이상 모든 바인딩된 객체가 <code>title</code> 프로퍼티를 갖도록 강요하지 않는다는 것입니다. 이제 템플릿과 기본 컨텍스트가 모두 응용 프로그램 수준에서 정의됩니다.</p>
<p>변경 사항이 렌더링된 결과는 다음과 같습니다.</p>
<p><img src="https://denysvuika.files.wordpress.com/2017/10/angular-dynamic-content-02.png" alt=""></p>
<h2 id="동적-Component"><a href="#동적-Component" class="headerlink" title="동적 Component"></a>동적 Component</h2><p>또 다른 일반적인 시나리오는 일부 조건에 따라 <em>Component</em>의 내용을 변경하는 것입니다. 예를 들어 아래와 같이 <code>type</code> 프로퍼티 값을 기반으로 다른 하위 <em>Component</em>를 렌더링하는 경우입니다.</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">component</span> <span class="attr">type</span>=<span class="string">"my-type-1"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">component</span> <span class="attr">type</span>=<span class="string">"my-type-2"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></div></pre></td></tr></table></figure>
<p>기본 <em>Component</em> 구조부터 살펴 보겠습니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span>(&#123;</div><div class="line">    selector: <span class="string">'dynamic-content'</span>,</div><div class="line">    template: <span class="string">`</span></div><div class="line">        &lt;div&gt;</div><div class="line">            &lt;div #container&gt;&lt;/div&gt;</div><div class="line">        &lt;/div&gt;</div><div class="line">    `</div><div class="line">&#125;)</div><div class="line"><span class="keyword">export</span> <span class="keyword">class</span> DynamicContentComponent &#123;</div><div class="line">  </div><div class="line">  <span class="meta">@ViewChild</span>(<span class="string">'container'</span>, &#123; read: ViewContainerRef &#125;)</div><div class="line">  container: ViewContainerRef;</div><div class="line"></div><div class="line">  <span class="meta">@Input</span>()</div><div class="line">  <span class="keyword">type</span>: <span class="built_in">string</span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>container</code> 사용법에 유의하십시오. 주입 지점으로 사용되며, 모든 동적 컨텐츠가 이 요소 아래의 DOM에 삽입됩니다. 또한 <code>ViewContainerRef</code> 유형의 프로퍼티를 사용하면 코드에서 <code>container</code>에 액세스할 수 있습니다.</p>
<p>이 <em>Component</em>는 나중에 다음과 같이 사용할 수 있습니다.</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dynamic-content</span> <span class="attr">type</span>=<span class="string">"some-value"</span>&gt;</span><span class="tag">&lt;/<span class="name">dynamic-type</span>&gt;</span></div></pre></td></tr></table></figure>
<p>이제 “type” 값을 기반으로 표시할 두 가지 간단한 <em>Component</em>와 추가적으로 “unknown” 타입에 대한 하나의 대체 <em>Component</em>를 소개합니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span>(&#123;</div><div class="line">    selector: <span class="string">'dynamic-sample-1'</span>,</div><div class="line">    template: <span class="string">`&lt;div&gt;Dynamic sample 1&lt;/div&gt;`</span></div><div class="line">&#125;)</div><div class="line"><span class="keyword">export</span> <span class="keyword">class</span> DynamicSample1Component &#123;&#125;</div><div class="line"></div><div class="line"><span class="meta">@Component</span>(&#123;</div><div class="line">    selector: <span class="string">'dynamic-sample-2'</span>,</div><div class="line">    template: <span class="string">`&lt;div&gt;Dynamic sample 2&lt;/div&gt;`</span></div><div class="line">&#125;)</div><div class="line"><span class="keyword">export</span> <span class="keyword">class</span> DynamicSample2Component &#123;&#125;</div><div class="line"></div><div class="line"><span class="meta">@Component</span>(&#123;</div><div class="line">    selector: <span class="string">'unknown-component'</span>,</div><div class="line">    template: <span class="string">`&lt;div&gt;Unknown component&lt;/div&gt;`</span></div><div class="line">&#125;)</div><div class="line"><span class="keyword">export</span> <span class="keyword">class</span> UnknownDynamicComponent &#123;&#125;</div></pre></td></tr></table></figure>
<p>또한 해당 문자열을 <em>Component</em>로 변환할 수 있도록 “string” - “type” 매핑이 필요합니다. 별도의 <em>Injectable</em> 서비스 (권장) 또는 <em>Component</em> 구현의 일부일 수 있습니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> mappings = &#123;</div><div class="line">   <span class="string">'sample1'</span>: DynamicSample1Component,</div><div class="line">   <span class="string">'sample2'</span>: DynamicSample2Component</div><div class="line">&#125;;</div><div class="line">getComponentType(typeName: <span class="built_in">string</span>) &#123;</div><div class="line">    <span class="keyword">let</span> <span class="keyword">type</span> = <span class="keyword">this</span>.mappings[typeName];</div><div class="line">    <span class="keyword">return</span> <span class="keyword">type</span> || UnknownDynamicComponent;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>그리고 <code>type</code> 이름이 없을 경우 <code>UnknownDynamicComponent</code>가 자동으로 반환됩니다.</p>
<p>이제 <em>Component</em>를 동적으로 만들 준비가 되었습니다. 다음은 동적 <em>Component</em> 생성에 관심이 있는 주요 블록이 있는 <em>Component</em>의 단순 버전입니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">class</span> DynamicContentComponent <span class="keyword">implements</span> OnInit, OnDestroy &#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> componentRef: ComponentRef&lt;&#123;&#125;&gt;;</div><div class="line"></div><div class="line">    <span class="keyword">constructor</span>(<span class="params"></span></div><div class="line">        <span class="keyword">private</span> componentFactoryResolver: ComponentFactoryResolver) &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ngOnInit() &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.type) &#123;</div><div class="line">            <span class="keyword">let</span> componentType = <span class="keyword">this</span>.getComponentType(<span class="keyword">this</span>.type);</div><div class="line">            <span class="keyword">let</span> factory = <span class="keyword">this</span>.componentFactoryResolver.resolveComponentFactory(componentType);</div><div class="line">            <span class="keyword">this</span>.componentRef = <span class="keyword">this</span>.container.createComponent(factory);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ngOnDestroy() &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.componentRef) &#123;</div><div class="line">            <span class="keyword">this</span>.componentRef.destroy();</div><div class="line">            <span class="keyword">this</span>.componentRef = <span class="literal">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>동적으로 생성하려는 모든 <em>Component</em>는 모듈의 <code>entryComponents</code> 섹션에 등록해야합니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@NgModule</span>(&#123;</div><div class="line">  imports: [...],</div><div class="line">  declarations: [...],</div><div class="line">  entryComponents: [</div><div class="line">    DynamicSample1Component,</div><div class="line">    DynamicSample2Component,</div><div class="line">    UnknownDynamicComponent</div><div class="line">  ],</div><div class="line">  bootstrap: [ AppComponent ]</div><div class="line">&#125;)</div><div class="line"><span class="keyword">export</span> <span class="keyword">class</span> AppModule &#123; &#125;</div></pre></td></tr></table></figure>
<p>이제 세 가지 모든 경우를 테스트 할 수 있습니다.</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dynamic-content</span> <span class="attr">type</span>=<span class="string">"sample1"</span>&gt;</span><span class="tag">&lt;/<span class="name">dynamic-content</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dynamic-content</span> <span class="attr">type</span>=<span class="string">"sample2"</span>&gt;</span><span class="tag">&lt;/<span class="name">dynamic-content</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dynamic-content</span> <span class="attr">type</span>=<span class="string">"some-other-type"</span>&gt;</span><span class="tag">&lt;/<span class="name">dynamic-content</span>&gt;</span></div></pre></td></tr></table></figure>
<p>아마도 대부분의 경우 새로 작성된 하위 <em>Component</em>에 런타임 컨텍스트를 전달하려고 할 것입니다.</p>
<p>서로 다른 타입의 동적 <em>Component</em>를 유지하는 가장 쉬운 방법은 공통 인터페이스 또는 추상 클래스를 작성하는 것입니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> DynamicComponent &#123;</div><div class="line">   context: <span class="built_in">any</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>간단히 하기 위해, <code>context</code>에 <code>any</code> 타입을 사용했습니다. 실제 시나리오에서는 정적 검사의 이점을 얻기위해 타입을 선언할 수 있습니다.</p>
<p><code>context</code>를 고려하여 이전에 생성된 모든 <em>Component</em>를 업데이트 할 수 있습니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">abstract</span> <span class="keyword">class</span> DynamicComponent &#123;</div><div class="line">    context: <span class="built_in">any</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Component</span>(&#123;</div><div class="line">    selector: <span class="string">'dynamic-sample-1'</span>,</div><div class="line">    template: <span class="string">`&lt;div&gt;Dynamic sample 1 (&#123;&#123;context?.text&#125;&#125;)&lt;/div&gt;`</span></div><div class="line">&#125;)</div><div class="line"><span class="keyword">export</span> <span class="keyword">class</span> DynamicSample1Component <span class="keyword">extends</span> DynamicComponent &#123;&#125;</div><div class="line"></div><div class="line"><span class="meta">@Component</span>(&#123;</div><div class="line">    selector: <span class="string">'dynamic-sample-2'</span>,</div><div class="line">    template: <span class="string">`&lt;div&gt;Dynamic sample 2 (&#123;&#123;context?.text&#125;&#125;)&lt;/div&gt;`</span></div><div class="line">&#125;)</div><div class="line"><span class="keyword">export</span> <span class="keyword">class</span> DynamicSample2Component <span class="keyword">extends</span> DynamicComponent &#123;&#125;</div><div class="line"></div><div class="line"><span class="meta">@Component</span>(&#123;</div><div class="line">    selector: <span class="string">'unknown-component'</span>,</div><div class="line">    template: <span class="string">`&lt;div&gt;Unknown component (&#123;&#123;context?.text&#125;&#125;)&lt;/div&gt;`</span></div><div class="line">&#125;)</div><div class="line"><span class="keyword">export</span> <span class="keyword">class</span> UnknownDynamicComponent <span class="keyword">extends</span> DynamicComponent &#123;&#125;</div></pre></td></tr></table></figure>
<p>그리고 동적 <em>Component</em>도 업데이트 해야합니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">class</span> DynamicContentComponent <span class="keyword">implements</span> OnInit, OnDestroy &#123;</div><div class="line">  ...</div><div class="line"> </div><div class="line">  <span class="meta">@Input</span>()</div><div class="line">  context: <span class="built_in">any</span>;</div><div class="line"> </div><div class="line">  ...</div><div class="line">  ngOnInit() &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.type) &#123;</div><div class="line">      ...</div><div class="line">      <span class="keyword">let</span> instance = &lt;DynamicComponent&gt; <span class="keyword">this</span>.componentRef.instance;</div><div class="line">      instance.context = <span class="keyword">this</span>.context;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>위의 변경 사항으로 이제 부모 <em>Component</em> 내에서 <code>context</code> 객체를 바인딩 할 수 있습니다. 다음은 간단한 데모입니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span>(&#123;</div><div class="line">    selector: <span class="string">'dynamic-component-demo'</span>,</div><div class="line">    template: <span class="string">`</span></div><div class="line">        &lt;div&gt;</div><div class="line">            &lt;h2&gt;Dynamic content&lt;/h2&gt;</div><div class="line">            &lt;h3&gt;Context: &lt;input type="text" [(ngModel)]="context.text"&gt;&lt;/h3&gt;</div><div class="line">            &lt;dynamic-content type="sample1" [context]="context"&gt;&lt;/dynamic-content&gt;</div><div class="line">            &lt;dynamic-content type="sample2" [context]="context"&gt;&lt;/dynamic-content&gt;</div><div class="line">            &lt;dynamic-content type="some-other-type" [context]="context"&gt;&lt;/dynamic-content&gt;</div><div class="line">        &lt;/div&gt;</div><div class="line">    `</div><div class="line">&#125;)</div><div class="line"><span class="keyword">export</span> <span class="keyword">class</span> DynamicContentComponentDemo &#123;</div><div class="line"></div><div class="line">    context: <span class="built_in">any</span> = &#123;</div><div class="line">        text: <span class="string">'test'</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>런타임에는 세 가지 <em>Component</em>(Fallback된 <code>UnknownDynamicComponent</code> 포함)를 볼 수 있어야합니다. <code>Context</code> 입력란의 텍스트를 변경하면 모든 위젯이 자동으로 업데이트됩니다.</p>
<p><img src="https://denysvuika.files.wordpress.com/2017/10/angular-dynamic-content-03.png" alt=""></p>
<h3 id="일반적인-사용-사례"><a href="#일반적인-사용-사례" class="headerlink" title="일반적인 사용 사례"></a>일반적인 사용 사례</h3><p>정의 파일 (JSON, XML 등)을 기반으로 Form(또는 복합 <em>Component</em>)을 표시해야하는 경우 스키마 또는 상태를 기반으로 최종 컨텐츠를 빌드하는 동적 <em>Component</em>와 여러 동적 컨텐츠 컨테이너에서 빌드된 <em>Form Component</em>를 갖게 될 수 있습니다.</p>
<h2 id="런타임-컴파일"><a href="#런타임-컴파일" class="headerlink" title="런타임 컴파일"></a>런타임 컴파일</h2><p>일부 고급 시나리오의 경우 Angular <em>Component</em> 또는 템플릿 편집을 완전히 제어 할 필요가 있을 수 있습니다.</p>
<p>이 장에서는 다음 기능을 구현합니다.</p>
<ul>
<li>사용자에게 <em>Component</em> 템플릿을 정의하도록 합니다.</li>
<li><em>Component</em>를 즉석에서 컴파일(사용자 정의 템플릿 + 클래스)합니다.</li>
<li>컴포넌트를 생성하면서 NgModule을 즉시 컴파일합니다.</li>
<li>새로 생성된 <em>Component</em> 표시합니다.</li>
</ul>
<p>구현은 이전 장의 동적 <em>Component</em>를 기반으로 합니다. 그리고 콘텐츠를 삽입하기위한 전용 자리 표시자가있는 기본 <em>Component</em>가 필요합니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span>(&#123;</div><div class="line">    selector: <span class="string">'runtime-content'</span>,</div><div class="line">    template: <span class="string">`</span></div><div class="line">        &lt;div&gt;</div><div class="line">            &lt;div #container&gt;&lt;/div&gt;</div><div class="line">        &lt;/div&gt;</div><div class="line">    `</div><div class="line">&#125;)</div><div class="line"><span class="keyword">export</span> <span class="keyword">class</span> RuntimeContentComponent &#123;</div><div class="line"></div><div class="line">    <span class="meta">@ViewChild</span>(<span class="string">'container'</span>, &#123; read: ViewContainerRef &#125;)</div><div class="line">    container: ViewContainerRef;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>사용자가 <em>Component</em> 템플릿을 편집 할 수 있도록 기본 UI를 수정합니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span>(&#123;</div><div class="line">    selector: <span class="string">'runtime-content'</span>,</div><div class="line">    template: <span class="string">`</span></div><div class="line">        &lt;div&gt;</div><div class="line">            &lt;h3&gt;Template&lt;/h3&gt;</div><div class="line">            &lt;div&gt;</div><div class="line">                &lt;textarea rows="5" [(ngModel)]="template"&gt;&lt;/textarea&gt;</div><div class="line">            &lt;/div&gt;</div><div class="line">            &lt;button (click)="compileTemplate()"&gt;Compile&lt;/button&gt;</div><div class="line">            &lt;h3&gt;Output&lt;/h3&gt;</div><div class="line">            &lt;div #container&gt;&lt;/div&gt;</div><div class="line">        &lt;/div&gt;</div><div class="line">    `</div><div class="line">&#125;)</div><div class="line"><span class="keyword">export</span> <span class="keyword">class</span> RuntimeContentComponent &#123;</div><div class="line"></div><div class="line">  template: <span class="built_in">string</span> = <span class="string">'&lt;div&gt;\nHello, &#123;&#123;name&#125;&#125;\n&lt;/div&gt;'</span>;</div><div class="line">  </div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>ngModel</code>을 사용하려면 <code>AppModule</code> 내에서 <code>FormsModule</code>을 가져 와서 참조해야합니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; NgModule &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</div><div class="line"><span class="keyword">import</span> &#123; BrowserModule &#125; <span class="keyword">from</span> <span class="string">'@angular/platform-browser'</span>;</div><div class="line"><span class="keyword">import</span> &#123; FormsModule &#125; <span class="keyword">from</span> <span class="string">'@angular/forms'</span>;</div><div class="line"><span class="meta">@NgModule</span>(&#123;</div><div class="line">  imports: [BrowserModule, FormsModule],</div><div class="line">  declarations: [...],</div><div class="line">  bootstrap: [ AppComponent ]</div><div class="line">&#125;)</div><div class="line"><span class="keyword">export</span> <span class="keyword">class</span> AppModule &#123; &#125;</div></pre></td></tr></table></figure>
<p>렌더링될 때 다음과 같이 보일 것입니다.</p>
<p><img src="https://denysvuika.files.wordpress.com/2017/10/angular-dynamic-content-04.png" alt=""></p>
<p>이제 <em>Component</em> 구현의 가장 중요한 부분인 런타임 컴파일입니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">class</span> RuntimeContentComponent &#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> createComponentFactorySync(compiler: Compiler, metadata: Component, componentClass: <span class="built_in">any</span>): ComponentFactory&lt;<span class="built_in">any</span>&gt; &#123;</div><div class="line">        <span class="keyword">const</span> cmpClass = componentClass || <span class="keyword">class</span> RuntimeComponent &#123; name: <span class="built_in">string</span> = <span class="string">'Denys'</span> &#125;;</div><div class="line">        <span class="keyword">const</span> decoratedCmp = Component(metadata)(cmpClass);</div><div class="line"></div><div class="line">        <span class="meta">@NgModule</span>(&#123; imports: [CommonModule], declarations: [decoratedCmp] &#125;)</div><div class="line">        <span class="keyword">class</span> RuntimeComponentModule &#123; &#125;</div><div class="line"></div><div class="line">        <span class="keyword">let</span> <span class="keyword">module</span>: ModuleWithComponentFactories&lt;any&gt; = compiler.compileModuleAndAllComponentsSync(RuntimeComponentModule);</div><div class="line">        return <span class="keyword">module</span>.componentFactories.find(f =&gt; f.componentType === decoratedCmp);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>위 코드는 사용자 지정 메타 데이터와 선택적으로 <em>Component</em> 클래스를 받습니다. 클래스가 제공되어 있지 않은 경우, 대신 <code>RuntimeComponent</code>를 미리 정의된 <code>name</code> 프로퍼티와 함께 사용됩니다. 이것은 우리가 테스트를 위해 사용할 것입니다. 그런 다음 결과 <em>Component</em>는 제공된 메타 데이터로 장식(Decorate)됩니다.</p>
<p>다음으로, <code>RuntimeComponentModule</code> 모듈은 미리 정의된 <code>CommonModule</code>을 import(필요한 경우 목록을 확장 할 수 있음)하고, <code>declarations</code> 섹션의 일부로 이전에 생성되어 장식(Decorate)된 <em>Component</em>로 만들어집니다.</p>
<p>마지막으로 이 함수는 Angular의 <code>Compiler</code> 서비스를 사용하여 모듈과 포함된 <em>Component</em>를 컴파일합니다. 컴파일된 모듈은 기본 <em>Component</em> 팩토리에 대한 액세스를 제공하며 이는 정확히 우리가 필요로하는 것입니다.</p>
<p>마지막 단계에서는 다음 코드로 <code>Compile</code> 버튼을 연결합니다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">class</span> RuntimeContentComponent &#123;</div><div class="line"></div><div class="line">    compileTemplate() &#123;</div><div class="line"></div><div class="line">        <span class="keyword">let</span> metadata = &#123;</div><div class="line">            selector: <span class="string">`runtime-component-sample`</span>,</div><div class="line">            template: <span class="keyword">this</span>.template</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        <span class="keyword">let</span> factory = <span class="keyword">this</span>.createComponentFactorySync(<span class="keyword">this</span>.compiler, metadata, <span class="literal">null</span>);</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.componentRef) &#123;</div><div class="line">            <span class="keyword">this</span>.componentRef.destroy();</div><div class="line">            <span class="keyword">this</span>.componentRef = <span class="literal">null</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">this</span>.componentRef = <span class="keyword">this</span>.container.createComponent(factory);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>사용자가 <code>Compile</code> 버튼을 클릭할 때 마다 템플릿을 가져 와서 (<code>RuntimeComponent</code> 클래스가 미리 정의된 <code>name</code> 프로퍼티를 사용하여) 새 <em>Component</em>를 컴파일하고 렌더링합니다.</p>
<p><img src="https://denysvuika.files.wordpress.com/2017/10/angular-dynamic-content-05.png" alt=""></p>
<p>어디에서든 <em>Component</em> 템플릿을 저장하고 즉시 <em>Component</em>를 생성하려는 경우 가장 좋은 옵션입니다.</p>
<h2 id="소스코드"><a href="#소스코드" class="headerlink" title="소스코드"></a>소스코드</h2><p>이 <a href="https://github.com/DenisVuyka/ng2-dynamic-content" target="_blank" rel="external">GitHub 저장소</a>에서 모든 소스 코드와 실제 예제 프로젝트를 얻을 수 있습니다.</p>
<hr>
<blockquote>
<p>이 내용은 나중에 참고하기 위해 제가 공부하며 정리한 내용입니다.<br>의역, 오역, 직역이 있을 수 있음을 알려드립니다.<br>This post is a translation of this original article [<a href="https://denysvuika.blog/2017/10/07/dynamic-content-in-angular/" target="_blank" rel="external">https://denysvuika.blog/2017/10/07/dynamic-content-in-angular/</a>]</p>
</blockquote>
<h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul>
<li><a href="https://infoscis.github.io/2017/07/21/angular-tutorial-introduction/">Angular 튜토리얼 - 소개</a></li>
<li><a href="https://infoscis.github.io/2017/07/21/angular-tutorial-the-hero-editor/">Angular 튜터리얼 - Hero 에디터</a></li>
<li><a href="https://infoscis.github.io/2017/07/21/angular-tutorial-master-detail/">Angular 튜터리얼 - Master/Detail</a></li>
<li><a href="https://infoscis.github.io/2017/07/21/angular-tutorial-multiple-components/">Angular 튜터리얼 - 다중 콤포넌트</a></li>
<li><a href="https://infoscis.github.io/2017/07/21/angular-tutorial-services/">Angular 튜터리얼 - 서비스</a></li>
<li><a href="https://infoscis.github.io/2017/07/21/angular-tutorial-routing/">Angular 튜터리얼 - 라우팅</a></li>
<li><a href="https://infoscis.github.io/2017/07/21/angular-tutorial-http/">Angular 튜터리얼 - HTTP</a></li>
<li><a href="https://infoscis.github.io/2017/07/21/angular-http-client/">Angular HttpClient</a></li>
<li><a href="https://infoscis.github.io/2017/06/15/angular-webpack-configuration/">Angular Webpack 설정</a></li>
<li><a href="https://infoscis.github.io/2018/01/24/angular-translation-service/">Angular에서 간단하게 번역기능 구현하기</a></li>
<li><a href="https://infoscis.github.io/2018/01/24/angular-dynamic-component/">Angular 동적 컴포넌트 로딩</a></li>
<li><a href="https://infoscis.github.io/2018/02/13/dynamic-content-in-angular/">Angular에서 동적 컨텐츠 생성</a></li>
<li><a href="https://infoscis.github.io/2018/02/13/understanding-viewchildren-contentchildren-and-querylist-in-angular/">Angular에서 ViewChildren, ContentChildren, 그리고 QueryList 이해하기</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Angular에서-동적-컨텐츠-생성&quot;&gt;&lt;a href=&quot;#Angular에서-동적-컨텐츠-생성&quot; class=&quot;headerlink&quot; title=&quot;Angular에서 동적 컨텐츠 생성&quot;&gt;&lt;/a&gt;Angular에서 동적 컨텐츠 생성&lt;/h1&gt;&lt;p&gt;이 
    
    </summary>
    
      <category term="Angular" scheme="http://infoscis.github.io/categories/Angular/"/>
    
    
      <category term="Angular" scheme="http://infoscis.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>ECMAScript 6 Iterator와 Generator</title>
    <link href="http://infoscis.github.io/2018/01/31/ecmascript-6-iterators-and-generators/"/>
    <id>http://infoscis.github.io/2018/01/31/ecmascript-6-iterators-and-generators/</id>
    <published>2018-01-31T14:24:43.000Z</published>
    <updated>2018-02-27T14:12:31.782Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Iterator와-Generator"><a href="#Iterator와-Generator" class="headerlink" title="Iterator와 Generator"></a>Iterator와 Generator</h1><p>많은 프로그래밍 언어는 컬렉션에서 위치를 추적하기 위해 변수가 필요한 <code>for</code> 루프를 사용하여 데이터를 반복하는 것에서 컬렉션의 다음 항목을 반환하는 <em>Interator</em> 객체를 사용하는 방식으로 전환했습니다. <em>Iterator</em>를 사용하면 데이터 컬렉션을 쉽게 처리할 수 있어 ECMAScript 6에서는 <em>Iterator</em>를 JavaScript에 추가했습니다. <em>Iterator</em>는 새로운 <em>Array</em> 메서드 및 새로운 타입의 컬렉션 (<em>Set</em> 및 <em>Map</em>)과 결합하여 데이터를 효율적으로 처리할수 있는 핵심 요소이며, 이러한 부분은 JavaScript의 여러곳에서 찾아볼 수 있습니다. 또한 <em>Iterator</em>와 함께 작동하는 새로운 <code>for-of</code> 루프가 있으며, <em>Spread</em> (<code>...</code>) 연산자에서도 <em>Iterator</em>를 사용할 수 있습니다. 그리고<br> <em>Iterator</em>는 비동기 프로그래밍을 더 쉽게 만들수 있게 합니다.</p>
<p>이 장에서는 <em>Iterator</em>의 많은 용도에 대해 다루지만, 먼저 <em>Iterator</em>가 JavaScript에 추가된 이유에 대한 역사를 이해하는 것이 중요합니다.</p>
<h2 id="루프-Loop-문제점"><a href="#루프-Loop-문제점" class="headerlink" title="루프(Loop) 문제점"></a>루프(Loop) 문제점</h2><p>JavaScript로 프로그래밍한 적이 있다면 아마도 다음 코드가 익숙할 것입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>];</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = colors.length; i &lt; len; i++) &#123;</div><div class="line">    <span class="built_in">console</span>.log(colors[i]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>이 표준 <code>for</code> 루프는 인덱스를 <code>colors</code> <em>Array</em>에 대해 <code>i</code> 변수로 추적합니다. <code>i</code>의 값은 <code>i</code>가 (<code>len</code>에 저장된) <em>Array</em>의 길이보다 크지 않다면 루프가 실행될 때마다 증가합니다.</p>
<p>이 예제의 루프는 매우 간단하지만 루프를 중첩하여 여러 변수를 추적해야 할 때 매우 복잡해집니다. 추가적인 복잡성으로 인해 오류가 발생할 수 있으며, <code>for</code> 루프의 상용구는 유사한 코드가 여러 위치에 작성되어 더 많은 오류를 발생시킬 수 있습니다. <em>Iterator</em>는 이 문제를 해결하기 위한 것입니다.</p>
<h2 id="Iterator는-무엇일까요"><a href="#Iterator는-무엇일까요" class="headerlink" title="Iterator는 무엇일까요?"></a><em>Iterator</em>는 무엇일까요?</h2><p><em>Iterator</em>는 반복을 위해 설계된 특정 인터페이스가 있는 객체입니다. 모든 <em>Iterator</em> 객체는 결과 객체를 반환하는 <code>next()</code> 메서드를 가지고 있습니다. 결과 객체에는 두 가지 프로퍼티, 즉 다음 값인 <code>value</code>와 반환할 값이 더 이상 없을 때 <code>true</code> 인 부울 값인 <code>done</code> 프로퍼티입니다. <em>Iterator</em>는 값 컬렉션 내의 위치에 대한 내부 포인터를 유지하고 <code>next()</code> 메서드를 호출할 때마다 다음 적절한 값을 반환합니다.</p>
<p>마지막 값이 반환된 후에 <code>next()</code>를 호출하면 메서드는 <code>done</code>을 <code>true</code>로 리턴하고 <code>value</code>는 <em>Iterator</em>의 <em>리턴 값</em>을 포함합니다. 이 리턴 값은 데이터의 일부가 아니며 관련 데이터의 마지막 부분이거나 그러한 데이터가 없으면 <code>undefined</code>입니다. <em>Iterator</em>의 리턴 값은 정보를 호출자에게 전달하는 마지막 방법이라는 점에서 함수의 리턴 값과 유사합니다.</p>
<p>이를 염두에 두고 ECMAScript 5에서 <em>Iterator</em>를 만드는 것은 아래와 같이 간단합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createIterator</span>(<span class="params">items</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> i = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">next</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">            <span class="keyword">var</span> done = (i &gt;= items.length);</div><div class="line">            <span class="keyword">var</span> value = !done ? items[i++] : <span class="literal">undefined</span>;</div><div class="line"></div><div class="line">            <span class="keyword">return</span> &#123;</div><div class="line">                <span class="attr">done</span>: done,</div><div class="line">                <span class="attr">value</span>: value</div><div class="line">            &#125;;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> iterator = createIterator([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(iterator.next());         <span class="comment">// "&#123; value: 1, done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());         <span class="comment">// "&#123; value: 2, done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());         <span class="comment">// "&#123; value: 3, done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());         <span class="comment">// "&#123; value: undefined, done: true &#125;"</span></div><div class="line"></div><div class="line"><span class="comment">// for all further calls</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());         <span class="comment">// "&#123; value: undefined, done: true &#125;"</span></div></pre></td></tr></table></figure>
<p><code>createIterator()</code> 함수는 <code>next()</code> 메서드를 가진 객체를 반환합니다. 메서드가 호출될 때마다 <code>items</code> <em>Array</em>의 다음 값은 <code>value</code>로 리턴됩니다. <code>i</code>가 3 일 때 <code>done</code>은 <code>true</code>가 되고 <code>value</code>를 설정하는 삼항 조건 연산자는 <code>undefined</code>로 평가됩니다. 이 결과는  ECMAScript 6에서는 마지막 데이터가 사용된 후 <code>next()</code>가 호출될 때와 같은 특수한 역할을 합니다.</p>
<p>이 예제에서 보듯이, ECMAScript 6에 규정된 규칙에 따라 동작하는 <em>Iterator</em> 작성은 약간 복잡합니다.</p>
<p>다행히도 ECMAScript 6은 <em>Iterator</em> 생성자를 제공하여 <em>Iterator</em> 객체를 훨씬 쉽게 만들 수 있습니다.</p>
<h2 id="Generator는-무엇일까요"><a href="#Generator는-무엇일까요" class="headerlink" title="Generator는 무엇일까요?"></a><em>Generator</em>는 무엇일까요?</h2><p><em>Generator</em>는 <em>Iterator</em>를 반환하는 함수입니다. <em>Generator</em> 함수는 <code>function</code> 키워드 다음에 별표 (<code>*</code>)가 추가되고 새로운 <code>yield</code> 키워드를 사용합니다. 별표가 <code>function</code> 바로 앞에 있는지 또는 <code>*</code>와 <code>function</code> 사이에 공백이 있는지는 중요하지 않습니다. 아래 예제를 보겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// generator</span></div><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createIterator</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</div><div class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// generator는 일반 함수처럼 호출되지만 iterator를 반환합니다.</span></div><div class="line"><span class="keyword">let</span> iterator = createIterator();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(iterator.next().value);     <span class="comment">// 1</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next().value);     <span class="comment">// 2</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next().value);     <span class="comment">// 3</span></div></pre></td></tr></table></figure>
<p><code>createIterator()</code> 이전의 <code>*</code>는 함수를 <em>Generator</em>로 만듭니다. ECMAScript 6에 새로 도입된 <code>yield</code> 키워드는 <code>next()</code>가 호출될 때 결과 <em>Iterator</em>가 리턴 해야하는 값을 리턴될 순서대로 지정합니다. 이 예제에서 생성된 <em>Iterator</em>는 <code>next()</code> 메서드를 연속적으로 호출할 때 세가지 다른 값을 리턴합니다. : <code>1</code>, <code>2</code> 그리고 마지막으로 <code>3</code>. <em>Generator</em>는 <code>iterator</code>를 생성할 때 본 것처럼 다른 함수와 똑같이 호출할 수 있습니다.</p>
<p>아마도 <em>Generator</em> 함수 중 가장 흥미로운 부분은 각 <code>yield</code> 문 다음에 실행을 멈추는 것입니다. 예를 들어, 이 코드에서 <code>yield 1</code>을 실행 한 후에, 함수는 <em>Iterator</em>의 <code>next()</code> 메서드가 호출될 때까지 다른 것을 실행하지 않고, <code>next()</code>가 호출 되는 시점에 <code>yield 2</code>가 실행됩니다. 함수 중간에 실행을 중지하는 이 기능은 매우 강력하며 <em>Generator</em> 함수의 사용을 흥미롭게 합니다. (“Iterator의 고급기능”섹션에서 논의 함).</p>
<p><code>yield</code> 키워드는 모든 값이나 표현식과 함께 사용할 수 있으므로 항목을 하나씩 나열하지 않고 <em>Iterator</em>에 항목을 추가하는 <em>Generator</em> 함수를 작성할 수 있습니다. 예를 들어, <code>for</code> 루프에서 <code>yield</code>를 사용할 수있는 방법은 다음과 같습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createIterator</span>(<span class="params">items</span>) </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; items.length; i++) &#123;</div><div class="line">        <span class="keyword">yield</span> items[i];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> iterator = createIterator([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: 1, done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: 2, done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: 3, done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: undefined, done: true &#125;"</span></div><div class="line"></div><div class="line"><span class="comment">// for all further calls</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: undefined, done: true &#125;"</span></div></pre></td></tr></table></figure>
<p>이 예제는 <code>items</code>라는 <em>Array</em>를 <code>createIterator()</code> <em>Generator</em> 함수에 전달합니다. 함수 내에서 <code>for</code> 루프가 진행됨에 따라 <em>Array</em>에서 <em>Iterator</em> 요소를 생성합니다. <code>yield</code>가 발생할 때마다 루프가 멈추고 <code>iterator</code>의 <code>next()</code>가 호출될 때마다 루프의 다음 <code>yield</code> 문이 실행 됩니다.</p>
<p><em>Generator</em>는 ECMAScript 6의 중요한 기능이며, 함수이기 때문에 모든 곳에서 사용할 수 있습니다. 이 섹션의 나머지 부분에서는 <em>Generator</em>를 작성하는 다른 유용한 방법에 중점을 둡니다.</p>
<blockquote>
<p><code>yield</code> 키워드는 <em>Generator</em> 내부에서만 사용할 수 있습니다. 예를 들면 다음과 같이 <em>Generator</em> 내부 함수에서 사용하는 것을 포함하여 다른 곳에서 <code>yield</code>를 사용하는 것은 구문 오류입니다.</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createIterator</span>(<span class="params">items</span>) </span>&#123;</div><div class="line"></div><div class="line">    items.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">// syntax error</span></div><div class="line">        <span class="keyword">yield</span> item + <span class="number">1</span>;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><code>yield</code>는 기술적으로 <code>createIterator()</code> 내부에 있지만, <code>yield</code>는 함수의 경계를 넘을 수 없으므로 이 코드는 구문 오류입니다. <code>yield</code>가 <code>return</code>과 비슷한 방식으로 사용되었지만 중첩된 함수는 그 함수를 포함하는 값을 리턴할 수 없습니다.</p>
</blockquote>
<h3 id="Generator-함수-표현식"><a href="#Generator-함수-표현식" class="headerlink" title="Generator 함수 표현식"></a><em>Generator</em> 함수 표현식</h3><p>함수 표현식을 사용하여 <code>function</code> 키워드와 여는 괄호 사이에 별표 (<code>*</code>) 문자를 포함시킴으로써 <em>Generator</em>를 생성할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> createIterator = <span class="function"><span class="keyword">function</span> *(<span class="params">items</span>) </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; items.length; i++) &#123;</div><div class="line">        <span class="keyword">yield</span> items[i];</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> iterator = createIterator([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(iterator.next());         <span class="comment">// "&#123; value: 1, done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());         <span class="comment">// "&#123; value: 2, done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());         <span class="comment">// "&#123; value: 3, done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());         <span class="comment">// "&#123; value: undefined, done: true &#125;"</span></div><div class="line"></div><div class="line"><span class="comment">// for all further calls</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());         <span class="comment">// "&#123; value: undefined, done: true &#125;"</span></div></pre></td></tr></table></figure>
<p>이 코드에서, <code>createIterator()</code>는 함수 선언 대신에 <em>Generator</em> 함수 표현식입니다. 함수 표현식이 익명이므로 별표는 <code>function</code> 키워드와 여는 괄호 사이에 옵니다. 그 외에 이 예제는 <code>for</code> 루프를 사용했던 <code>createIterator()</code> 함수의 이전 버전과 동일합니다.</p>
<blockquote>
<p><em>Arrow</em> 함수를 이용해 <em>Generator</em>를 만들수 없습니다.</p>
</blockquote>
<h3 id="Generator-객체-메서드"><a href="#Generator-객체-메서드" class="headerlink" title="Generator 객체 메서드"></a><em>Generator</em> 객체 메서드</h3><p><em>Generator</em>는 함수이기 때문에 객체에도 추가할 수 있습니다. 예를 들어, 함수 표현식을 사용하여 ECMAScript 5 스타일 객체 리터럴에서 <em>Generator</em>를 만들 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = &#123;</div><div class="line"></div><div class="line">    <span class="attr">createIterator</span>: <span class="function"><span class="keyword">function</span> *(<span class="params">items</span>) </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; items.length; i++) &#123;</div><div class="line">            <span class="keyword">yield</span> items[i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> iterator = o.createIterator([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</div></pre></td></tr></table></figure>
<p>메서드 이름 앞에 별표(<code>*</code>)를 붙임으로써 ECMAScript 6 단축 메서드를 바로 사용할 수도 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = &#123;</div><div class="line"></div><div class="line">    *createIterator(items) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; items.length; i++) &#123;</div><div class="line">            <span class="keyword">yield</span> items[i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> iterator = o.createIterator([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</div></pre></td></tr></table></figure>
<p>이 예제는 “<em>Generator</em> 함수 표현식” 섹션의 예제와 기능적으로 동일합니다. 단지 다른 구문을 사용했을 뿐입니다. 단축 버전에서는<br> <code>createIterator()</code> 메서드가 <code>function</code> 키워드 없이 정의되었고 별표와 메서드 이름 사이에 공백을 둘 수 있지만 별표는 메서드 이름 바로 앞에 위치해야 합니다.</p>
<h2 id="Iterables-과-for-of"><a href="#Iterables-과-for-of" class="headerlink" title="Iterables 과 for-of"></a>Iterables 과 for-of</h2><p><em>Iterator</em>와 밀접하게 관련된 <em>Iterable</em> 은 <code>Symbol.iterator</code> 프로퍼티를 가진 객체입니다. 잘 알려진 <code>Symbol.iterator</code> <em>Symbol</em>은 주어진 객체에 대한 <em>Iterator</em>를 반환하는 함수를 지정합니다. ECMAScript 6에서는 모든 컬렉션 객체 (<em>Array</em>, <em>Set</em> 및 <em>Map</em>) 및 문자열이 <em>Iterable</em>이므로 기본 <em>Iterator</em>가 지정되어 있습니다. <em>Iterable</em>은 ECMAScript에 새로 추가된 <code>for-of</code> 루프와 함께 사용하도록 설계되었습니다.</p>
<blockquote>
<p><em>Generator</em>가 기본적으로 <code>Symbol.iterator</code> 프로퍼티를 할당하므로 <em>Generator</em>가 만든 모든 <em>Iterator</em>도 <em>Iterable</em>입니다.</p>
</blockquote>
<p>이 장의 시작 부분에서, <code>for</code> 루프 내에서 인덱스를 추적하는 문제에 대해 언급했습니다. 이 문제를 해결하는 첫 번째는 <em>Iterator</em>입니다. 그리고 두 번째는 <code>for-of</code> 루프입니다. 컬렉션에 대한 인덱스를 추적할 필요가 없기 때문에 컬렉션의 내용에 대한 작업에 집중할 수 있습니다.</p>
<p><code>for-of</code> 루프는 루프가 실행될 때마다 <em>Iterable</em>에서 <code>next()</code>를 호출하고 결과 객체의 <code>value</code>를 변수에 저장합니다. 루프는 반환된 객체의 <code>done</code> 프로퍼티 값이 <code>true</code>가 될 때까지 이 과정을 계속합니다. 다음은 그 예제를 살펴 보겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> values) &#123;</div><div class="line">    <span class="built_in">console</span>.log(num);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>이 코드는 다음을 출력합니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td></tr></table></figure>
<p>이 <code>for-of</code> 루프는 <code>values</code> <em>Array</em>에 <code>Symbol.iterator</code> 메서드를 먼저 호출하여 <em>Iterator</em>를 검색합니다. (<code>Symbol.iterator</code>에 대한 호출은 JavaScript 엔진 자체에서 발생합니다.) 그러면 <code>iterator.next()</code>가 호출되고 <em>Iterator</em>의 결과 객체에있는 <code>value</code> 프로퍼티가<br> <code>num</code>으로 읽혀집니다. <code>num</code> 변수는 <code>1</code>, <code>2</code>, 그리고 마지막으로 <code>3</code>입니다. 결과 객체에서 <code>done</code>이 <code>true</code> 일 때, 루프는 끝나기 때문에 <code>num</code>은 결코 <code>undefined</code>의 값으로 지정되지 않습니다.</p>
<p>단순히 <em>Array</em>이나 컬렉션의 값을 반복한다면 <code>for</code> 루프 대신에 <code>for-of</code> 루프를 사용하는 것이 좋습니다. <code>for-of</code> 루프는 일반적으로 추적하기 위한 조건이 적기 때문에 에러 발생이 전통적인 <code>for</code> 루프보다 적습니다. 보다 복잡한 제어 조건이 필요한 경우 전통적인<code>for</code> 루프를 사용 하십시오.</p>
<blockquote>
<p><code>for-of</code> 문은 <em>Non-iterable</em> 객체, <code>null</code> 또는 <code>undefined</code>에서 사용될 때 에러를 던집니다.</p>
</blockquote>
<h3 id="Default-Iterator-액세스-하기"><a href="#Default-Iterator-액세스-하기" class="headerlink" title="Default Iterator 액세스 하기"></a>Default Iterator 액세스 하기</h3><p>Symbol.iterator를 사용하여 다음과 같이 객체의 <em>Default Iterator</em>를 액세스할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line"><span class="keyword">let</span> iterator = values[<span class="built_in">Symbol</span>.iterator]();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(iterator.next());         <span class="comment">// "&#123; value: 1, done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());         <span class="comment">// "&#123; value: 2, done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());         <span class="comment">// "&#123; value: 3, done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());         <span class="comment">// "&#123; value: undefined, done: true &#125;"</span></div></pre></td></tr></table></figure>
<p>이 코드는 <code>values</code>에 대한 <em>Default Iterator</em>를 가져오고 이를 사용하여 <em>Array</em>의 각항목을 반복합니다. 이것은 <code>for-of</code> 루프를 사용할 때 배후에서 일어나는 것과 같은 방식입니다.</p>
<p>Symbol.iterator는 <em>Default Iterator</em>를 지정하므로 이를 사용하여 객체가 다음과 같이 반복 가능한지 여부를 확인할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isIterable</span>(<span class="params">object</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> object[<span class="built_in">Symbol</span>.iterator] === <span class="string">"function"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(isIterable([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]));     <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(isIterable(<span class="string">"Hello"</span>));       <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(isIterable(<span class="keyword">new</span> <span class="built_in">Map</span>()));     <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(isIterable(<span class="keyword">new</span> <span class="built_in">Set</span>()));     <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(isIterable(<span class="keyword">new</span> <span class="built_in">WeakMap</span>())); <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log(isIterable(<span class="keyword">new</span> <span class="built_in">WeakSet</span>())); <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p><code>isIterable()</code> 함수는 객체에 <em>Default Iterator</em>가 존재 하는지를 확인하는 함수입니다. <code>for-of</code> 루프는 실행 전에 비슷한 검사를 수행합니다.</p>
<p>지금까지 이 섹션의 예제에서는 내장 <em>Iterable</em>이 있는 <code>Symbol.iterator</code>를 사용하는 방법을 알아 봤지만 <code>Symbol.iterator</code> 프로퍼티를 사용하여 고유한 <em>Iterable</em>을 만들수도 있습니다.</p>
<h3 id="Iterable-만들기"><a href="#Iterable-만들기" class="headerlink" title="Iterable 만들기"></a><em>Iterable</em> 만들기</h3><p>개발자가 정의한 객체는 기본적으로 반복 가능하지 않지만 <em>Generator</em>가 포함된 <code>Symbol.iterator</code> 프로퍼티를 만들어 반복 가능하게 만들 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> collection = &#123;</div><div class="line">    <span class="attr">items</span>: [],</div><div class="line">    *[<span class="built_in">Symbol</span>.iterator]() &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> <span class="keyword">this</span>.items) &#123;</div><div class="line">            <span class="keyword">yield</span> item;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div><div class="line">collection.items.push(<span class="number">1</span>);</div><div class="line">collection.items.push(<span class="number">2</span>);</div><div class="line">collection.items.push(<span class="number">3</span>);</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> collection) &#123;</div><div class="line">    <span class="built_in">console</span>.log(x);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>위 코드는 다음을 출력합니다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td></tr></table></figure></p>
<p>먼저, 이 예제는 <code>collection</code>이라는 객체의 <em>Default Iterator</em>를 정의합니다. <em>Default Iterator</em>는 <em>Generator</em>인 <code>Symbol.iterator</code> 메서드에 의해 생성됩니다 (별표시는 여전히 이름 앞에 옵니다). <em>Generator</em>는 <code>for-of</code> 루프를 사용하여 <code>this.items</code>의 값을 반복하고 <code>yield</code>를 사용하여 각각을 리턴합니다. <code>collection</code> 객체는 수동으로 반복하여 <code>collection</code>의 <em>Default Iterator</em>에 대한 값을 정의하는 대신, <code>this.items</code>의 <em>Default Iterator</em>를 사용하여 작업을 수행합니다.</p>
<blockquote>
<p>이 장의 뒷부분에 나오는 “Generator 위임”에서는 다른 객체의 <em>Iterator</em>를 사용하는 방법에 대해 설명합니다.</p>
</blockquote>
<p>이제까지  <em>Array</em>의 <em>Default Iterator</em>에 대한 사용법을 살펴 보았지만 ECMAScript 6에는 더 많은 <em>Iterator</em>가 내장되어 있어 데이터 수집 작업을 쉽게 수행할 수 있습니다.</p>
<h2 id="내장-Iterator들"><a href="#내장-Iterator들" class="headerlink" title="내장 Iterator들"></a>내장 <em>Iterator</em>들</h2><p><em>Iterator</em>는 ECMAScript 6의 중요한 부분이므로 많은 빌트인 타입에 대해 자체적으로 <em>Iterator</em>를 만들 필요가 없습니다. 언어 레벨에서 기본적으로 포함하고 있습니다. 기본 제공되는 <em>Iterator</em>가 목적에 부합하지 않을 때만 <em>Iterator</em>를 만들어야 하며, 이는 자신만의 객체 나 클래스를 정의할 때 자주 발생합니다. 그 외에는 내장된 <em>Iterator</em>를 사용하여 작업을 수행할 수 있습니다. 아마도 가장 일반적인 <em>Iterator</em>는 컬렉션에서 작동하는 <em>Iterator</em>일 것입니다.</p>
<h3 id="컬렉션-Iterator들"><a href="#컬렉션-Iterator들" class="headerlink" title="컬렉션 Iterator들"></a>컬렉션 <em>Iterator</em>들</h3><p>ECMAScript 6에는 <em>Array</em>, <em>Map</em> 및 <em>Set</em> 세가지 타입의 컬렉션 객체가 있습니다. 세가지 모두에는 내용을 탐색하는데 도움이되는 다음과 같은 기본 제공 <em>Iterator</em>가 있습니다.</p>
<ul>
<li>entries() - 값이 키 - 값 쌍인 <em>Iterator</em>를 반환합니다.</li>
<li>values() - 값이 컬렉션의 value인 <em>Iterator</em>를 반환합니다.</li>
<li>keys() - 값이 컬렉션에 포함된 key인 <em>Iterator</em>를 반환합니다.</li>
</ul>
<p>이 메서드 중 하나를 호출하여 컬렉션을 검색할 수 있습니다.</p>
<h4 id="entries-Iterator"><a href="#entries-Iterator" class="headerlink" title="entries() Iterator"></a>entries() <em>Iterator</em></h4><p><code>entries()</code> <em>Iterator</em>는 <code>next()</code>가 호출될 때마다 두개의 아이템 <em>Array</em>을 반환합니다. 두개의 아이템 <em>Array</em>는 컬렉션의 각 항목에 대한 키와 값을 나타냅니다. <em>Array</em>의 경우 첫 번째 항목은 숫자 인덱스입니다. <em>Set</em>의 경우 첫 번째 항목은 값이기도합니다 (값은 <em>Set</em>의 키와 동일하므로). <em>Map</em>의 경우 첫 번째 항목은 키입니다.</p>
<p>다음은이 <em>Iterator</em>를 사용하는 몇 가지 예제입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> colors = [ <span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span> ];</div><div class="line"><span class="keyword">let</span> tracking = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1234</span>, <span class="number">5678</span>, <span class="number">9012</span>]);</div><div class="line"><span class="keyword">let</span> data = <span class="keyword">new</span> <span class="built_in">Map</span>();</div><div class="line"></div><div class="line">data.set(<span class="string">"title"</span>, <span class="string">"Understanding ECMAScript 6"</span>);</div><div class="line">data.set(<span class="string">"format"</span>, <span class="string">"ebook"</span>);</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> entry <span class="keyword">of</span> colors.entries()) &#123;</div><div class="line">    <span class="built_in">console</span>.log(entry);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> entry <span class="keyword">of</span> tracking.entries()) &#123;</div><div class="line">    <span class="built_in">console</span>.log(entry);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> entry <span class="keyword">of</span> data.entries()) &#123;</div><div class="line">    <span class="built_in">console</span>.log(entry);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>console.log()</code> 호출은 다음과 같은 결과를냅니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[0, &quot;red&quot;]</div><div class="line">[1, &quot;green&quot;]</div><div class="line">[2, &quot;blue&quot;]</div><div class="line">[1234, 1234]</div><div class="line">[5678, 5678]</div><div class="line">[9012, 9012]</div><div class="line">[&quot;title&quot;, &quot;Understanding ECMAScript 6&quot;]</div><div class="line">[&quot;format&quot;, &quot;ebook&quot;]</div></pre></td></tr></table></figure>
<p>위 예제는 각 컬렉션 타입에 대해 <code>entries()</code> 메서드를 사용하여 <em>Iterator</em>를 검색하고 <code>for-of</code> 루프를 사용하여 반복합니다. console 출력은 각 객체에 대해 어떻게 키와 값이 쌍으로 리턴되는지 보여줍니다.</p>
<h4 id="values-Iterator"><a href="#values-Iterator" class="headerlink" title="values() Iterator"></a>values() <em>Iterator</em></h4><p><code>values()</code> <em>Iterator</em>는 컬렉션에 저장된 값을 반환합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> colors = [ <span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span> ];</div><div class="line"><span class="keyword">let</span> tracking = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1234</span>, <span class="number">5678</span>, <span class="number">9012</span>]);</div><div class="line"><span class="keyword">let</span> data = <span class="keyword">new</span> <span class="built_in">Map</span>();</div><div class="line"></div><div class="line">data.set(<span class="string">"title"</span>, <span class="string">"Understanding ECMAScript 6"</span>);</div><div class="line">data.set(<span class="string">"format"</span>, <span class="string">"ebook"</span>);</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> colors.values()) &#123;</div><div class="line">    <span class="built_in">console</span>.log(value);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> tracking.values()) &#123;</div><div class="line">    <span class="built_in">console</span>.log(value);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> data.values()) &#123;</div><div class="line">    <span class="built_in">console</span>.log(value);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>이 코드는 다음을 출력합니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&quot;red&quot;</div><div class="line">&quot;green&quot;</div><div class="line">&quot;blue&quot;</div><div class="line">1234</div><div class="line">5678</div><div class="line">9012</div><div class="line">&quot;Understanding ECMAScript 6&quot;</div><div class="line">&quot;ebook&quot;</div></pre></td></tr></table></figure>
<p>이 예제에서와 같이 <code>values()</code> <em>Iterator</em>를 호출하면 컬렉션의 해당 데이터 위치에 대한 정보없이 각 컬렉션에 포함된 정확한 데이터가 반환됩니다.</p>
<h4 id="keys-Iterator"><a href="#keys-Iterator" class="headerlink" title="keys() Iterator"></a>keys() <em>Iterator</em></h4><p><code>keys()</code> <em>Iterator</em>는 컬렉션에 있는 각 키를 반환합니다. <em>Array</em>의 경우 숫자 키만 반환하며 <em>Array</em>의 다른 프로퍼티는 반환하지 않습니다. <em>Set</em>의 경우 키는 값과 동일하므로 <code>keys()</code> 및 <code>values()</code>는 동일한 <em>Iterator</em>를 반환합니다. <em>Map</em>의 경우, <code>keys()</code> <em>Iterator</em>는 각 고유 키를 리턴합니다. 다음은 이 세가지를 모두 보여주는 예제입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> colors = [ <span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span> ];</div><div class="line"><span class="keyword">let</span> tracking = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1234</span>, <span class="number">5678</span>, <span class="number">9012</span>]);</div><div class="line"><span class="keyword">let</span> data = <span class="keyword">new</span> <span class="built_in">Map</span>();</div><div class="line"></div><div class="line">data.set(<span class="string">"title"</span>, <span class="string">"Understanding ECMAScript 6"</span>);</div><div class="line">data.set(<span class="string">"format"</span>, <span class="string">"ebook"</span>);</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> colors.keys()) &#123;</div><div class="line">    <span class="built_in">console</span>.log(key);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> tracking.keys()) &#123;</div><div class="line">    <span class="built_in">console</span>.log(key);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> data.keys()) &#123;</div><div class="line">    <span class="built_in">console</span>.log(key);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>이 예제는 다음을 출력합니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">0</div><div class="line">1</div><div class="line">2</div><div class="line">1234</div><div class="line">5678</div><div class="line">9012</div><div class="line">&quot;title&quot;</div><div class="line">&quot;format&quot;</div></pre></td></tr></table></figure>
<p><code>keys()</code> <em>Iterator</em>는 <code>colors</code>, <code>tracking</code> 및 <code>data</code>에서 각 키를 가져 오며, 이 키들은 세개의 <code>for-of</code> 루프 내부에서 출력됩니다. <em>Array</em>의 경우 숫자 색인만 출력되며 <em>Array</em>에 명명된(named) 프로퍼티를 추가 한 경우에도 숫자 색인만 출력합니다. 이것은 <code>for-in</code> 루프는 숫자 인덱스가 아닌 프로퍼티를 반복하기 때문에 <code>for-in</code>에서 <em>Array</em>를 이용하는 방식과 다릅니다.</p>
<h4 id="컬렉션-타입에-대한-Default-Iterator"><a href="#컬렉션-타입에-대한-Default-Iterator" class="headerlink" title="컬렉션 타입에 대한 Default Iterator"></a>컬렉션 타입에 대한 <em>Default Iterator</em></h4><p>각 컬렉션 타입에는 <em>Iterator</em>가 명시적으로 지정되지 않은 경우 <code>for-of</code>에 의해 사용되는 <em>Default Iterator</em>가 있습니다. <code>values()</code> 메서드는 <em>Array</em>와 <em>Set</em>의 <em>Default Iterator</em>이며, <code>entries()</code> 메서드는 <em>Map</em>의 <em>Default Iterator</em>입니다. 이러한 기본값은 <code>for-of</code> 루프에서 컬렉션 객체를 사용하는 것을 좀더 쉽게 만듭니다. 다음 예제를 살펴보겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> colors = [ <span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span> ];</div><div class="line"><span class="keyword">let</span> tracking = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1234</span>, <span class="number">5678</span>, <span class="number">9012</span>]);</div><div class="line"><span class="keyword">let</span> data = <span class="keyword">new</span> <span class="built_in">Map</span>();</div><div class="line"></div><div class="line">data.set(<span class="string">"title"</span>, <span class="string">"Understanding ECMAScript 6"</span>);</div><div class="line">data.set(<span class="string">"format"</span>, <span class="string">"print"</span>);</div><div class="line"></div><div class="line"><span class="comment">// colors.values()를 사용하는 것과 같습니다.</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> colors) &#123;</div><div class="line">    <span class="built_in">console</span>.log(value);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// tracking.values()를 사용하는 것과 같습니다.</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> tracking) &#123;</div><div class="line">    <span class="built_in">console</span>.log(num);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// data.entries()를 사용하는 것과 같습니다.</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> entry <span class="keyword">of</span> data) &#123;</div><div class="line">    <span class="built_in">console</span>.log(entry);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><em>Iterator</em>가 지정되지 않았기 때문에 <em>Default Iterator</em>가 사용됩니다. <em>Array</em>, <em>Set</em> 및 <em>Map</em>의 <em>Default Iterator</em>는 이러한 객체가 초기화되는 방식을 반영하도록 설계되었으므로 이 코드는 다음을 출력합니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&quot;red&quot;</div><div class="line">&quot;green&quot;</div><div class="line">&quot;blue&quot;</div><div class="line">1234</div><div class="line">5678</div><div class="line">9012</div><div class="line">[&quot;title&quot;, &quot;Understanding ECMAScript 6&quot;]</div><div class="line">[&quot;format&quot;, &quot;print&quot;]</div></pre></td></tr></table></figure>
<p><em>Array</em>와 <em>Set</em>은 기본적으로 값을 반환하고, <em>Map</em>은 <code>Map</code> 생성자에 전달할 수 있는 것과 동일한 <em>Array</em> 형태를 반환합니다. 반대로 <em>Weak Set</em>과 <em>Weak Map</em>에는 Built-in <em>Iterator</em>가 없습니다. 약한 참조를 관리한다는 것은 이러한 컬렉션에 정확히 얼마나 많은 값이 있는지를 알 수있는 방법이 없다는 것을 의미합니다. 또한 이들을 반복할 방법이 없다는 것을 의미합니다.</p>
<h3 id="Destructuring과-for-of-루프"><a href="#Destructuring과-for-of-루프" class="headerlink" title="Destructuring과 for-of 루프"></a>Destructuring과 for-of 루프</h3><p><em>Map</em>에 대한 <em>Default Iterator</em>의 동작은 다음 예와 같이 <em>Destructuring</em>이 있는 <code>for-of</code> 루프에서 사용될 때도 유용합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> data = <span class="keyword">new</span> <span class="built_in">Map</span>();</div><div class="line"></div><div class="line">data.set(<span class="string">"title"</span>, <span class="string">"Understanding ECMAScript 6"</span>);</div><div class="line">data.set(<span class="string">"format"</span>, <span class="string">"ebook"</span>);</div><div class="line"></div><div class="line"><span class="comment">// data.entries()을 사용하는 것과 같습니다.</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> data) &#123;</div><div class="line">    <span class="built_in">console</span>.log(key + <span class="string">"="</span> + value);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>이 코드의 <code>for-of</code> 루프는 <em>Destructured</em> <em>Array</em>을 사용하여 <em>Map</em>의 각 항목에 대해 <code>key</code>와 <code>value</code>를 지정합니다. 이 방법으로 두 항목 <em>Array</em>에 액세스하거나 <em>Map</em>에서 키 또는 값을 가져 오지 않고도 키와 값을 사용하여 쉽게 작업할 수 있습니다. <em>Map</em>에 대해 <em>Destructured</em> <em>Array</em>를 사용하여 <code>for-of</code> 루프가 <em>Set</em>과 <em>Array</em>의 경우와 마찬가지로 <em>Map</em>에 똑같이 유용할 수 있습니다.</p>
<h3 id="문자열-Iterator"><a href="#문자열-Iterator" class="headerlink" title="문자열 Iterator"></a>문자열 Iterator</h3><p>JavaScript 문자열은 ECMAScript 5가 출시된 이후 천천히 배열과 비슷해졌습니다. 예를 들어, ECMAScript 5는 문자열의 문자에 액세스하기위한 대괄호 표기법을 사용합니다 (즉, 첫 번째 문자를 가져 오기 위해 <code>text[0]</code> 사용). 그러나 대괄호 표기법은 문자가 아닌 <em>Code Unit</em>에서 작동하므로 아래 예제에서 보여주는 것처럼 2 바이트 문자를 올바르게 액세스하는데 사용할 수 없습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> message = <span class="string">"A ð ®· B"</span>;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i &lt; message.length; i++) &#123;</div><div class="line">    <span class="built_in">console</span>.log(message[i]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>이 코드는 괄호 표기법과 <code>length</code> 프로퍼티를 사용하여 반복하고 유니 코드 문자가 포함된 문자열을 출력합니다. 결과는 예상과 다릅니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">A</div><div class="line">(blank)</div><div class="line">(blank)</div><div class="line">(blank)</div><div class="line">(blank)</div><div class="line">B</div></pre></td></tr></table></figure>
<p>두개의 바이는 두 개의 개별 <em>Code Unit</em>으로 취급되기 때문에 A와 B 사이에 4 개의 비어있는 행이 출력됩니다.</p>
<p>다행스럽게도 ECMAScript 6은 유니 코드를 완벽하게 지원하고 (2 장 참조) 기본 문자열 <em>Iterator</em>는 문자열 반복 문제를 해결하기 위한 시도입니다. 따라서 문자열의 기본 <em>Iterator</em>는 <em>Code Unit</em>이 아닌 문자단위로 작동합니다. 이 예제를 <code>for-of</code> 루프와 함께 기본 문자열 <em>Iterator</em>를 사용하도록 변경하면 보다 적절한 결과가 출력됩니다. 다음은 수정된 코드입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> message = <span class="string">"A ð ®· B"</span>;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> c <span class="keyword">of</span> message) &#123;</div><div class="line">    <span class="built_in">console</span>.log(c);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>출력 결과는 다음과 같습니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">A</div><div class="line">(blank)</div><div class="line">ð ®·</div><div class="line">(blank)</div><div class="line">B</div></pre></td></tr></table></figure>
<p>이 결과는 문자로 작업할 때 기대했던 것과 더 비슷합니다. 루프는 유니 코드 문자뿐 아니라 나머지 문자도 모두 성공적으로 출력합니다.</p>
<h3 id="NodeList-Iterator"><a href="#NodeList-Iterator" class="headerlink" title="NodeList Iterator"></a>NodeList Iterator</h3><p>DOM (Document Object Model)에는 문서의 요소 컬렉션을 나타내는 <code>NodeList</code> 타입이 있습니다. JavaScript를 웹 브라우저에서 실행하는 사람들에게는 <code>NodeList</code> 객체와 <em>Array</em>의 차이점을 이해하는 것이 항상 약간 어려웠습니다. <code>NodeList</code> 객체와 <em>Array</em>는 항목의 수를 나타 내기 위해 <code>length</code> 프로퍼티를 사용하며, 둘 다 괄호 표기법을 사용하여 개별 항목에 액세스합니다. 그러나 내부적으로 <code>NodeList</code>와 <em>Array</em>는 완전히 다르게 작동하므로 많은 혼란을 겪습니다.</p>
<p>ECMAScript 6에 <em>Default Iterator</em>가 추가된 <code>NodeList</code> (ECMAScript 6 자체가 아닌 HTML 사양에 포함됨)의 DOM 정의에는 <em>Array</em> <em>Default Iterator</em>와 같은 방식으로 작동하는 <em>Default Iterator</em>가 포함되어 있습니다. 즉, <code>for-of</code> 루프 또는 객체의 <em>Default Iterator</em>를 사용하는 다른 부분에서 아래와같이 <code>NodeList</code>를 사용할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> divs = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"div"</span>);</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> div <span class="keyword">of</span> divs) &#123;</div><div class="line">    <span class="built_in">console</span>.log(div.id);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>이 코드는 <code>getElementsByTagName()</code>을 호출하여 <code>document</code> 객체의 모든 <code>&lt;div&gt;</code> 요소를 나타내는 <code>NodeList</code>를 검색합니다. <code>for-of</code> 루프는 각 요소를 반복하고 엘리먼트 ID를 출력하므로 표준 <em>Array</em>의 코드와 동일합니다.</p>
<h2 id="Spread-연산자와-Non-Array-Iterables"><a href="#Spread-연산자와-Non-Array-Iterables" class="headerlink" title="Spread 연산자와 Non-Array Iterables"></a>Spread 연산자와 Non-Array Iterables</h2><p>7 장에서 아래와 같이 <em>Set</em>을 <em>Array</em>로 변환하는 데 <em>Spread</em> 연산자 (<code>...</code>)를 사용할 수 있다는 점을 설명했습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]),</div><div class="line">    array = [...set];</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(array);             <span class="comment">// [1,2,3,4,5]</span></div></pre></td></tr></table></figure>
<p>이 코드는 <em>Array</em> 리터럴의 <em>Spread</em> 연산자를 사용하여 해당 <em>Array</em>을 <code>set</code>의 값으로 채웁니다. <em>Spread</em> 연산자는 모든 <em>Iterable</em>에서 작동하고 <em>Default Iterator</em>를 사용하여 포함할 값을 결정합니다. 모든 값은 <em>Iterator</em>에서 읽혀지고 <em>Iterator</em>에서 값이 리턴된 순서대로 <em>Array</em>에 삽입됩니다. 이 예제는 <em>Set</em>이 <em>Iterable</em>이기 때문에 작동했습니다. 그리고 모든 <em>Iterable</em>에서 똑같이 작동 합니다. 다른 예를 살펴 보겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([ [<span class="string">"name"</span>, <span class="string">"Nicholas"</span>], [<span class="string">"age"</span>, <span class="number">25</span>]]),</div><div class="line">    array = [...map];</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(array);         <span class="comment">// [ ["name", "Nicholas"], ["age", 25]]</span></div></pre></td></tr></table></figure>
<p>여기에서 <em>Spread</em> 연산자는 <code>map</code>을 <em>Array</em>의 <em>Array</em>로 변환합니다. <em>Map</em>에 대한 <em>Default Iterator</em>는 키-값 쌍을 반환하기 때문에 결과 <em>Array</em>는 <code>new Map()</code>호출 중에 전달된 <em>Array</em>처럼 보입니다.</p>
<p><em>Array</em> 리터럴에서 원하는 만큼 여러번 <em>Spread</em> 연산자를 사용할 수 있으며 <em>Iterable</em>에서 여러 항목을 삽입하려는 곳이면 어디에서나 사용할 수 있습니다. 이러한 항목은 <em>Spread</em> 연산자의 위치에 있는 새로운 <em>Array</em>에 순서대로 나타납니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> smallNumbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</div><div class="line">    bigNumbers = [<span class="number">100</span>, <span class="number">101</span>, <span class="number">102</span>],</div><div class="line">    allNumbers = [<span class="number">0</span>, ...smallNumbers, ...bigNumbers];</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(allNumbers.length);     <span class="comment">// 7</span></div><div class="line"><span class="built_in">console</span>.log(allNumbers);    <span class="comment">// [0, 1, 2, 3, 100, 101, 102]</span></div></pre></td></tr></table></figure>
<p><em>Spread</em> 연산자는 <code>smallNumbers</code> 및 <code>bigNumbers</code>의 값에서 <code>allNumbers</code>를 만드는 데 사용됩니다. 값은 <code>allNumbers</code>가 만들어질 때 <em>Array</em>가 추가되는 순서와 동일한 순서로 <code>allNumbers</code>에 배치됩니다. 먼저 <code>0</code>이오고 <code>smallNumbers</code>의 값이 뒤 따르고 <code>bigNumbers</code>의 값이옵니다. 그러나 원래 배열은 값이 <code>allNumbers</code>로 복사되었으므로 변경되지 않습니다.</p>
<p><em>Spread</em> 연산자는 어떤 <em>Iterable</em>에서도 사용할 수 있기 때문에, <em>Iterable</em>을 <em>Array</em>로 변환하는 가장 쉬운 방법입니다. 문자열을 문자 <em>Array</em>(<em>Code Unit</em> 아님) 및 브라우저의 <code>NodeList</code> 객체를 Node <em>Array</em>로 변환할 수 있습니다.</p>
<p><code>for-of</code> 연산자와 <em>Spread</em> 연산자를 포함하여 <em>Iterator</em>가 작동하는 기본 사항을 이해 했으므로 이제는 <em>Iterator</em>를 좀 더 복잡한 용도로 살펴볼 차례입니다.</p>
<h2 id="Iterator-고급-기능"><a href="#Iterator-고급-기능" class="headerlink" title="Iterator 고급 기능"></a><em>Iterator</em> 고급 기능</h2><p><em>Iterator</em>는 <em>Genertor</em>를 이용하여 쉽게 만들고 기본 기능을 이용하여 <em>Iterator</em>를 쉽게 사용할수 있습니다. 그러나 <em>Iterator</em>는 단순히 값의 모음을 반복하는것 이외의 작업에 사용될 때 훨씬 강력합니다. ECMAScript 6을 개발하는 동안 제작자가 더 많은 기능을 추가하도록 독창적인 아이디어와 패턴이 많이 나타났습니다. 이러한 추가 기능중 일부는 함께 사용하면 흥미로운 상호 작용을 수행할 수 있습니다.</p>
<h3 id="Iterator에-파라미터-넘기기"><a href="#Iterator에-파라미터-넘기기" class="headerlink" title="Iterator에 파라미터 넘기기"></a><em>Iterator</em>에 파라미터 넘기기</h3><p>이 장 전반의 예제에서는 <em>Iterator</em>의 <code>next()</code> 메서드를 통해 값을 전달받거나 <em>Generator</em>의 <code>yield</code>를 사용하는 모습을 보여줬습습니다. 그러나 <code>next()</code> 메서드를 통해 <em>Iterator</em>에 파라미터를 전달할 수도 있습니다. 파라미터가 <code>next()</code> 메서드에 전달되면, 그 파라미터는 <em>Generator</em> 내부의 <code>yield</code> 문의 값이 됩니다. 이 기능은 비동기 프로그래밍과 같은 고급 기능에 중요합니다. 다음은 기본적인 예입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createIterator</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> first = <span class="keyword">yield</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">let</span> second = <span class="keyword">yield</span> first + <span class="number">2</span>;       <span class="comment">// 4 + 2</span></div><div class="line">    <span class="keyword">yield</span> second + <span class="number">3</span>;                   <span class="comment">// 5 + 3</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> iterator = createIterator();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: 1, done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next(<span class="number">4</span>));          <span class="comment">// "&#123; value: 6, done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next(<span class="number">5</span>));          <span class="comment">// "&#123; value: 8, done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: undefined, done: true &#125;"</span></div></pre></td></tr></table></figure>
<p><code>next()</code>의 첫 번째 호출은 전달된 파라미터가 사라지는 특별한 경우입니다. <code>yield</code> 문 앞에 접근할 수 있다면 <code>next()</code>에 전달된 파라미터가 <code>yield</code>에 의해 리턴된 값이되기 때문에, <code>next()</code>에 대한 첫 번째 호출의 파라미터는 <em>Generator</em> 함수의 첫 번째 <code>yield</code> 문장을 대체할 수 있습니다. 하지만 그건 불가능합니다. 그래서 <code>next()</code>가 처음 호출되었을 때 파라미터를 넘길 이유가 없습니다.</p>
<p><code>next()</code>의 두 번째 호출에서 <code>4</code>값이 파라미터로 전달됩니다. <code>4</code>는 <em>Generator</em> 함수 내에서 <code>first</code> 변수에 할당됩니다. 할당을 포함하는 <code>yield</code> 문에서 표현식의 오른쪽은 <code>next()</code>의 첫 번째 호출에서 평가되고 왼쪽은 함수가 계속 실행되기 전에 <code>next()</code>의 두 번째 호출에서 평가됩니다. <code>next()</code>의 두 번째 호출이 <code>4</code>로 전달되기 때문에, 그 값은 <code>first</code>에 할당되고 실행이 계속됩니다.</p>
<p>두 번째 <code>yield</code>는 첫 번째 <code>yield</code>의 결과를 사용하고 두개를 더합니다. 즉, <code>6</code>의 값을 반환합니다. <code>next()</code>가 세번째로 호출될 때, 값 <code>5</code>가 파라미터로 전달됩니다. 이 값은 변수 <code>second</code>에 할당된 다음 <code>yield</code> 문에서 <code>8</code>을 반환하는데 사용됩니다.</p>
<p>실행이 <em>Generator</em> 함수 내에서 계속될 때마다 어떤 코드가 실행되고 있는지 고려하여 어떤 일이 일어나고 있는지 생각하는 것이 쉽습니다. 그림 8-1은 색상을 사용하여 실행중인 코드를 보여줍니다.</p>
<p><img src="https://leanpub.com/site_images/understandinges6/fg0601.png" alt=""><br><strong>[그림 8-1]Generator 내부에서 코드 실행</strong></p>
<p>노란색은 <code>next()</code>에 대한 첫 번째 호출과 <em>Generator</em> 내부에서 실행된 코드를 나타냅니다. 아쿠아색은 <code>next(4)</code>의 호출과 그 호출로 실행된 코드를 나타냅니다. 그리고 자주색은 <code>next(5)</code> 호출과 그 결과로 실행되는 코드를 나타냅니다. 까다로운 부분은 왼쪽면이 실행되기 전에 각 표현식의 오른쪽에있는 코드가 어떻게 실행되고 중지되는지 입니다. 이것은 일반 함수를 디버깅하는 것보다 <em>Generator</em>를 디버깅하는 것을 더 복잡하게 만드는 원인입니다.</p>
<p>지금까지 <code>next()</code> 메서드에 값이 전달될 때 <code>yield</code>가 <code>return</code>처럼 작동할 수 있다는 것을 보았습니다. 그러나 이것만이 <em>Generator</em> 내부에서 수행할 수있는 유일한 실행이 아닙니다. <em>Iterator</em>로 인해 오류가 발생할 수도 있습니다.</p>
<h3 id="Iterator에서-에러-던지기"><a href="#Iterator에서-에러-던지기" class="headerlink" title="Iterator에서 에러 던지기"></a>Iterator에서 에러 던지기</h3><p><em>Iterator</em>에 데이터뿐만 아니라 오류 조건도 전달할 수 있습니다. <em>Iterator</em>는 <em>Iterator</em>가 다시 시작할 때 오류를 발생 시키도록 지시하는 <code>throw()</code> 메서드를 구현하도록 선택할 수 있습니다. 이것은 비동기 프로그래밍을 위한 중요한 기능이고, 함수를 종료하는 두가지 방법인 리턴과 오류를 던지는 기능을 모방할 수 있어 <em>Generator</em> 내부의 유연성에도 중요합니다. <em>Iterator</em>가 처리를 계속할 때 던져 져야하는 <code>throw()</code>에 에러 객체를 전달할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createIterator</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> first = <span class="keyword">yield</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">let</span> second = <span class="keyword">yield</span> first + <span class="number">2</span>;       <span class="comment">// yield 4 + 2, then throw</span></div><div class="line">    <span class="keyword">yield</span> second + <span class="number">3</span>;                   <span class="comment">// never is executed</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> iterator = createIterator();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(iterator.next());                   <span class="comment">// "&#123; value: 1, done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next(<span class="number">4</span>));                  <span class="comment">// "&#123; value: 6, done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.throw(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Boom"</span>))); <span class="comment">// generator에서 에러를 던집니다.</span></div></pre></td></tr></table></figure>
<p>이 예제에서 처음 두개의 <code>yield</code> 표현식은 평범한 것으로 평가되지만 <code>throw()</code>가 호출되면 <code>let second</code>가 평가되기 전에 에러가 발생합니다. 이로 인해 코드 실행이 오류를 직접 throw 하는 것과 비슷한 효과로 중지됩니다. 유일한 차이점은 오류가 발생하는 위치입니다. [그림 8-2]는 각 단계에서 어떤 코드가 실행되는지 보여줍니다.</p>
<p><img src="https://leanpub.com/site_images/understandinges6/fg0602.png" alt=""><br><strong>[그림 8-2] Generator 내부에서 에러를 던집니다</strong></p>
<p>이 그림에서 붉은색은 <code>throw()</code>가 호출될 때 실행되는 코드를 나타내며 빨간색 별은 오류가 <em>Generator</em> 내부로 던져지는 부분을 대략 나타냅니다. 처음 두개의 <code>yield</code> 문이 실행되고 <code>throw()</code>가 호출되면 다른 코드가 실행되기 전에 오류가 발생합니다.</p>
<p>이것을 알고있다면, <code>try-catch</code> 블록을 사용하여 <em>Generator</em> 내에서 에러를 잡을 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createIterator</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> first = <span class="keyword">yield</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">let</span> second;</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        second = <span class="keyword">yield</span> first + <span class="number">2</span>;       <span class="comment">// yield 4 + 2, then throw</span></div><div class="line">    &#125; <span class="keyword">catch</span> (ex) &#123;</div><div class="line">        second = <span class="number">6</span>;                     <span class="comment">// 에러시 다른 값을 할당함.</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">yield</span> second + <span class="number">3</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> iterator = createIterator();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(iterator.next());                   <span class="comment">// "&#123; value: 1, done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next(<span class="number">4</span>));                  <span class="comment">// "&#123; value: 6, done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.throw(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Boom"</span>))); <span class="comment">// "&#123; value: 9, done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());                   <span class="comment">// "&#123; value: undefined, done: true &#125;"</span></div></pre></td></tr></table></figure>
<p>이 예제에서, 두 번째 <code>yield</code> 문은 <code>try-catch</code> 블록이 감싸고 있습니다. 이 <code>yield</code>는 에러 없이 실행되고, 다음 실행에서 어떤한 값이 <code>second</code>에 할당되기 전에 에러가 던져 지므로 <code>catch</code> 블록은 6의 값을 할당합니다. 그리고 실행은 다음 <code>yield</code>로 이동하여 9를 반환합니다.</p>
<p>흥미로운 일이 발생합니다. <code>throw()</code> 메서드는 <code>next()</code> 메서드와 마찬가지로 결과 객체를 리턴합니다. 오류가 <em>Generator</em> 내부에서 발견 되었기 때문에 코드 실행은 다음 <code>yield</code>로 이어지고 다음 값인 <code>9</code>가 반환됩니다.</p>
<p><em>Iterator</em>에 대한 지시사항인 <code>next()</code>와 <code>throw()</code>를 생각하는 것이 도움이됩니다. <code>next()</code> 메서드는 <em>Iterator</em>에게 (주어진 값으로) 실행을 계속하도록 지시하고 <code>throw()</code>는 <em>Iterator</em>에게 오류를 던져 실행을 계속하도록 지시합니다. 그 시점 이후에 일어나는 일은 <em>Generator</em> 내부의 코드에 달려 있습니다.</p>
<p><code>next()</code>와 <code>throw()</code> 메서드는 <code>yield</code>를 사용할 때 <em>Iterator</em> 안에서 실행을 제어하지만 <code>return</code> 문도 사용할 수 있습니다. 그러나<code>return</code>은 다음 절에서 보듯이 정규 함수와 약간 다르게 작동합니다.</p>
<h3 id="Generator의-Return-문"><a href="#Generator의-Return-문" class="headerlink" title="Generator의 Return 문"></a>Generator의 Return 문</h3><p><em>Generator</em>는 함수이기 때문에 <code>return</code> 문을 사용하여 일찍 종료하고 <code>next()</code> 메서드에 대한 마지막 호출의 반환 값을 지정할 수 있습니다. 이 장의 대부분의 예제에서, <em>Iterator</em>에서 <code>next()</code>를 마지막으로 호출하면 <code>undefined</code>가 반환되지만 다른 함수에서와 같이 <code>return</code>을 사용하여 값을 지정할 수 있습니다. <em>Generator</em>에서 <code>return</code>은 모든 처리가 완료되었음을 나타내므로 <code>done</code> 프로퍼티는<code>true</code>로 설정되고 값이 제공되면 <code>value</code>가 됩니다. 다음은 <code>return</code>을 사용하여 일찍 종료하는 예제입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createIterator</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</div><div class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> iterator = createIterator();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: 1, done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: undefined, done: true &#125;"</span></div></pre></td></tr></table></figure>
<p>이 코드의 <em>Generator</em>에는 <code>yield</code>문 다음에 <code>return</code> 문장이 옵니다. <code>return</code>은 더 이상의 값이 없다는 것을 나타내므로 나머지 <code>yield</code> 문은 실행되지 않습니다 (도달할 수 없습니다).</p>
<p>리턴된 오브젝트의 <code>value</code> 필드에 값을 지정할 수도 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createIterator</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">42</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> iterator = createIterator();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: 1, done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: 42, done: true &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: undefined, done: true &#125;"</span></div></pre></td></tr></table></figure>
<p>두 번째 <code>next()</code> 메서드 호출에서 <code>value</code> 프로퍼티에 값 <code>42</code>가 리턴됩니다.(<code>done</code>이 처음으로 <code>true</code>인 지점입니다.)<br><code>next()</code>의 세번째 호출에 <code>value</code> 프로퍼티가 다시 <code>undefined</code>인 객체를 반환합니다. <code>return</code>으로 지정한 값은 <code>value</code> 프로퍼티가<code>undefined</code>로 재설정되기 전에 반환된 객체에서만 한번 사용할 수 있습니다.</p>
<blockquote>
<p><em>Spread</em> 연산자와 <code>for-of</code>는 <code>return</code> 문에 의해 지정된 값을 무시합니다. <code>done</code>이 <code>true</code>이면  바로<code>value</code>를 읽지 않고 멈춥니다. 그러나 <em>Generator</em>를 위임할 때는 <em>Iterator</em> 리턴 값이 유용합니다.</p>
</blockquote>
<h3 id="Generator-위임"><a href="#Generator-위임" class="headerlink" title="Generator 위임"></a>Generator 위임</h3><p>경우에 따라 두 개의 <em>Iterator</em> 값을 하나로 결합하는 것이 유용할 수 있습니다. <em>Generator</em>는 별표 (<code>*</code>) 문자로 <code>yield</code>라는 특수 형식을 사용하여 다른 <em>Iterator</em>에 위임할 수 있습니다. <em>Generator</em> 정의에서와 같이 <code>*</code>가 나타나는 위치는 <code>*</code>이 <code>yield</code> 키워드와 <em>Generator</em> 함수 이름 사이에있는 한 중요하지 않습니다. 다음은 그 예입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createNumberIterator</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createColorIterator</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">yield</span> <span class="string">"red"</span>;</div><div class="line">    <span class="keyword">yield</span> <span class="string">"green"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createCombinedIterator</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">yield</span> *createNumberIterator();</div><div class="line">    <span class="keyword">yield</span> *createColorIterator();</div><div class="line">    <span class="keyword">yield</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> iterator = createCombinedIterator();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: 1, done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: 2, done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: "red", done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: "green", done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: true, done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: undefined, done: true &#125;"</span></div></pre></td></tr></table></figure>
<p>위 예제에서, <code>createCombinedIterator()</code> <em>Generator</em>는 <code>createNumberIterator()</code>에서 리턴된 <em>Iterator</em>에 먼저 위임한 다음<code>createColorIterator()</code>에서 리턴된 <em>Iterator</em>에 위임합니다. <code>createCombinedIterator()</code>에서 반환된 <em>Iterator</em>는 바깥쪽에서 보기에 일관된 <em>Iterator</em>로 보여집니다. <code>next()</code>에 대한 각각의 호출은 <code>createNumberIterator()</code>와 <code>createColorIterator()</code>에 의해 생성된 <em>Iterator</em>가 비게 될 때까지 적절한 <em>Iterator</em>에 위임됩니다. 그런 다음 최종 <code>yield</code>가 실행되어 <code>true</code>를 반환합니다.</p>
<p><em>Generator</em> 위임을 통해 <em>Generator</em> 리턴값을 더 많이 사용할 수도 있습니다. 이것은 반환된 값을 액세스하는 가장 쉬운 방법이며 복잡한 작업을 수행하는데 매우 유용할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createNumberIterator</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">3</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createRepeatingIterator</span>(<span class="params">count</span>) </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">        <span class="keyword">yield</span> <span class="string">"repeat"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createCombinedIterator</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> result = <span class="keyword">yield</span> *createNumberIterator();</div><div class="line">    <span class="keyword">yield</span> *createRepeatingIterator(result);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> iterator = createCombinedIterator();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: 1, done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: 2, done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: "repeat", done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: "repeat", done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: "repeat", done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: undefined, done: true &#125;"</span></div></pre></td></tr></table></figure>
<p>여기서 <code>createCombinedIterator()</code> <em>Generator</em> <code>createNumberIterator()</code>에 위임하고 <code>result</code>에 리턴값을 할당합니다. <code>createNumberIterator()</code>는 <code>return 3</code>을 포함하기 때문에 리턴값은 <code>3</code>입니다. <code>result</code> 변수는 <code>createRepeatingIterator()</code>에 같은 문자열을 <code>yield</code> 하는 횟수(이 경우에는 3 번)를 나타내는 인자로 전달됩니다.</p>
<p><code>next()</code> 메서드에 대한 호출에서 <code>3</code> 값은 절대로 출력되지 않았습니다. 지금은 <code>createCombinedIterator()</code> <em>Generator</em> 안에만 존재합니다. 그러나 다음과 같이 또 다른 <code>yield</code> 문을 추가하여 그 값을 출력할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createNumberIterator</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">3</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createRepeatingIterator</span>(<span class="params">count</span>) </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">        <span class="keyword">yield</span> <span class="string">"repeat"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createCombinedIterator</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> result = <span class="keyword">yield</span> *createNumberIterator();</div><div class="line">    <span class="keyword">yield</span> result;</div><div class="line">    <span class="keyword">yield</span> *createRepeatingIterator(result);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> iterator = createCombinedIterator();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: 1, done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: 2, done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: 3, done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: "repeat", done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: "repeat", done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: "repeat", done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: undefined, done: true &#125;"</span></div></pre></td></tr></table></figure>
<p>이 코드에서 여분의 <code>yield</code> 문은 리턴된 값을 <code>createNumberIterator()</code> <em>Generator</em>에서 명시적으로 출력합니다.</p>
<p>리턴값을 사용하는 <em>Generator</em> 위임은 특히 비동기 작업과 함께 사용할 때 매우 흥미로운 가능성을 가지는 매우 강력한 패러다임입니다.</p>
<blockquote>
<p>문자열에 <code>yield *</code>를 직접 사용할 수 있습니다 (예 :<code>yield * &quot;hello&quot;</code>). 이 경우 문자열의 기본 <em>Iterator</em>가 사용됩니다.</p>
</blockquote>
<h2 id="비동기-Asynchronous-작업-실행"><a href="#비동기-Asynchronous-작업-실행" class="headerlink" title="비동기(Asynchronous) 작업 실행"></a>비동기(Asynchronous) 작업 실행</h2><p><em>Generator</em>의 흥미로운 점은 비동기 프로그래밍과 직접 관련이 있습니다. JavaScript의 비동기 프로그래밍은 양날의 칼입니다. 간단한 작업은 비동기식으로 수행하기 쉽고 복잡한 작업은 코드에서 내용 역할을 하게됩니다. <em>Generator</em>는 실행 중간에 코드를 효과적으로 일시 중지할 수 있으므로 비동기 처리와 관련된 많은 가능성을 가지고 있습니다.</p>
<p>비동기 작업을 수행하는 전통적인 방법은 콜백이 있는 함수를 호출하는 것입니다. 예를 들어, Node.js의 디스크에서 파일을 읽는 것을 생각해<br> 보겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</div><div class="line"></div><div class="line">fs.readFile(<span class="string">"config.json"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, contents</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (err) &#123;</div><div class="line">        <span class="keyword">throw</span> err;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    doSomethingWith(contents);</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Done"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><code>fs.readFile()</code> 메서드는 읽을 파일 이름과 콜백 함수를 가지고 호출됩니다. 작업이 끝나면 콜백 함수가 호출됩니다. 콜백은 오류가 있는지 검사하고 그렇지 않은 경우 반환된 <code>contents</code>을 처리합니다. 이 작업은 작거나, 유한한 수의 비동기 작업을 완료하는데는 괜찮지만 콜백을 중첩하거나 일련의 비동기 작업을 순서대로 수행해야하는 경우에는 복잡해집니다. 이부분이 <em>Generator</em>와 <code>yield</code>가 도움이되는 곳입니다.</p>
<h3 id="간단한-작업-실행"><a href="#간단한-작업-실행" class="headerlink" title="간단한 작업 실행"></a>간단한 작업 실행</h3><p><code>yield</code>는 실행을 멈추고 다시 시작하기 전에 <code>next()</code> 메서드가 호출되기를 기다리기 때문에 콜백을 관리하지 않고 비동기 호출을 구현할 수 있습니다. 시작하려면 <em>Generator</em>를 호출하고 다음과 같이 <em>Iterator</em>를 시작할 수있는 함수가 필요합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">taskDef</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// iterator를 만들고 다른곳에서 사용할 수 있게 합니다.</span></div><div class="line">    <span class="keyword">let</span> task = taskDef();</div><div class="line"></div><div class="line">    <span class="comment">// 태스크 시작</span></div><div class="line">    <span class="keyword">let</span> result = task.next();</div><div class="line"></div><div class="line">    <span class="comment">// next() 호출을 계속하는 재귀 함수</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">// 더해야 할 일이 있다면</span></div><div class="line">        <span class="keyword">if</span> (!result.done) &#123;</div><div class="line">            result = task.next();</div><div class="line">            step();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// process를 시작</span></div><div class="line">    step();</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>run()</code> 함수는 태스크의 정의 (<em>Generator</em> 함수)를 파라미터로 받아들입니다. <em>Generator</em>를 호출하여 <em>Iterator</em>를 만들고 <em>Iterator</em>를<code>task</code>에 저장합니다. <code>task</code> 변수는 함수 외부에 있으므로 다른 함수가 접근할 수 있습니다(뒷부분에서 설명 합니다.). <code>next()</code>에 대한 첫 번째 호출은 <em>Iterator</em>를 시작하고 결과는 나중에 사용하기 위해 저장됩니다. <code>step()</code> 함수는 <code>result.done</code>이 false인지 검사하고, 만약 그렇다면 재귀적으로 자신을 호출하기 전에 <code>next()</code>를 호출합니다. <code>next()</code>를 호출할 때마다 결과 값이 <code>result</code>에 저장됩니다.이 값은 항상 최신 정보를 포함하도록 덮어 쓰여집니다. 처음 <code>step()</code>의 호출은 더 수행할 태스크가 있는지를 알기 위해 <code>result.done</code> 변수를 확인 합니다.</p>
<p>위에 구현한 <code>run()</code>을 다음과 같이 여러 <code>yield</code> 문이 포함된 <em>Generator</em>로 실행할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">run(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</div><div class="line">    <span class="keyword">yield</span>;</div><div class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</div><div class="line">    <span class="keyword">yield</span>;</div><div class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>이 예제는 단순히 콘솔에 세 개의 숫자를 출력하는데, 간단히 <code>next()</code>에 대한 모든 호출이 이루어지는 것을 보여줍니다. 그러나 단지 두 번 <code>yield</code>하는 것은 별로 유용하지 않습니다. 다음 단계는 <em>Iterator</em> 안팎으로 값을 전달하는 것입니다.</p>
<h3 id="데이터를-가진-태스크-실행하기"><a href="#데이터를-가진-태스크-실행하기" class="headerlink" title="데이터를 가진 태스크 실행하기"></a>데이터를 가진 태스크 실행하기</h3><p>태스크 실행에 데이터를 전달하는 가장 쉬운 방법은 <code>yield</code>에 의해 지정된 값을 <code>next()</code> 메서드에 대한 호출에 전달하는 것입니다. 이렇게하려면 이 코드에서와 같이 <code>result.value</code> 만 전달하면됩니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">taskDef</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// iterator를 만들고 다른곳에서 사용할 수 있게 합니다.</span></div><div class="line">    <span class="keyword">let</span> task = taskDef();</div><div class="line"></div><div class="line">    <span class="comment">// 태스크 시작</span></div><div class="line">    <span class="keyword">let</span> result = task.next();</div><div class="line"></div><div class="line">    <span class="comment">// next() 호출을 계속하는 재귀 함수</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">// 더해야 할 일이 있다면</span></div><div class="line">        <span class="keyword">if</span> (!result.done) &#123;</div><div class="line">            result = task.next(result.value);</div><div class="line">            step();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// process 시작</span></div><div class="line">    step();</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>이제 <code>result.value</code>가 파라미터로 <code>next()</code>에 전달되었으므로 다음과 같이 <code>yield</code> 호출간에 데이터를 전달할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">run(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> value = <span class="keyword">yield</span> <span class="number">1</span>;</div><div class="line">    <span class="built_in">console</span>.log(value);         <span class="comment">// 1</span></div><div class="line"></div><div class="line">    value = <span class="keyword">yield</span> value + <span class="number">3</span>;</div><div class="line">    <span class="built_in">console</span>.log(value);         <span class="comment">// 4</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>이 예제는 콘솔에 두 개의 값을 출력합니다(1과 4). 값 1은 <code>yield 1</code>에서 나오는데, 1은 <code>value</code> 변수로 바로 전달됩니다. 4는 <code>value</code>에 3을 더하고 그 결과를 <code>value</code>에 전달함으로써 계산됩니다. 데이터가 <code>yield</code>호출 사이에서 흐르고 있으므로 비동기 호출을 허용하려면 작은 변경만 하면됩니다.</p>
<h3 id="비동기-태스크-실행"><a href="#비동기-태스크-실행" class="headerlink" title="비동기 태스크 실행"></a>비동기 태스크 실행</h3><p>앞의 예제는 정적 데이터가 <code>yield</code> 호출 사이에서 왔다 갔다했지만 비동기 프로세스를 기다리는 것은 약간 다릅니다. 태스크 러너는 콜백 및 그 사용 방법을 알아야합니다. 그리고 <code>yield</code> 표현식은 값을 태스크 러너로 전달하기 때문에 어떤 함수 호출이라도 호출이 태스크 러너가 기다려야하는 비동기 연산임을 나타내는 값을 리턴해야 함을 의미합니다.</p>
<p>다음은 값이 비동기 작업임을 알리는 한 가지 방법입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchData</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</div><div class="line">        callback(<span class="literal">null</span>, <span class="string">"Hi!"</span>);</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>이 예제의 목적을 위해, 태스크 러너에 의해 호출되는 모든 함수는 callback을 실행하는 함수를 리턴할 것이다. <code>fetchData()</code> 함수는 콜백 함수를 파라미터로 받아들이는 함수를 리턴한다. 반환된 함수가 호출되면, 단일 데이터 ( <code>&quot;Hi!&quot;</code>문자열)로 콜백 함수를 실행합니다. <code>callback</code> 파라미터는 콜백을 실행하는 것이 기본 <em>Iterator</em>와 정확하게 상호 작용 하는지를 확인하기 위해 태스크 러너로부터 올 필요가있습니다. <code>fetchData()</code> 함수는 동기식이지만, 다음과 같이 약간의 지연만으로 콜백을 호출하여 쉽게 비동기식으로 확장할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchData</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</div><div class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            callback(<span class="literal">null</span>, <span class="string">"Hi!"</span>);</div><div class="line">        &#125;, <span class="number">50</span>);</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>이 버전의 <code>fetchData()</code>는 콜백을 호출하기 전에 50ms의 지연을 가져와 이 패턴이 동기 및 비동기 코드에서 똑같이 잘 작동 함을 보여줍니다. <code>yield</code>를 사용하여 호출하려는 각 함수가 동일한 패턴을 따르는지 확인해야 합니다.</p>
<p>함수가 비동기 프로세스라는 신호를 보내는 방법을 잘 이해하면 태스크 러너를 수정하여 해당 사실을 고려할 수 있습니다. <code>result.value</code>가 함수 일 때마다, 태스크 러너는 그 값을 <code>next()</code> 메서드로 전달하는 대신에 실행할 것입니다. 다음은 업데이트된 코드입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">taskDef</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// iterator를 만들고 다른곳에서 사용할 수 있게 합니다.</span></div><div class="line">    <span class="keyword">let</span> task = taskDef();</div><div class="line"></div><div class="line">    <span class="comment">// 태스크 시작</span></div><div class="line">    <span class="keyword">let</span> result = task.next();</div><div class="line"></div><div class="line">    <span class="comment">// next() 호출을 계속하는 재귀 함수</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">// 더해야 할 일이 있다면</span></div><div class="line">        <span class="keyword">if</span> (!result.done) &#123;</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> result.value === <span class="string">"function"</span>) &#123;</div><div class="line">                result.value(<span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</div><div class="line">                    <span class="keyword">if</span> (err) &#123;</div><div class="line">                        result = task.throw(err);</div><div class="line">                        <span class="keyword">return</span>;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    result = task.next(data);</div><div class="line">                    step();</div><div class="line">                &#125;);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                result = task.next(result.value);</div><div class="line">                step();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 프로세스 시작</span></div><div class="line">    step();</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>result.value</code>가 (<code>===</code>연산자로 검사된) 함수이면 콜백 함수가 호출됩니다. 이 콜백 함수는 가능한 오류를 첫 번째 인수 (<code>err</code>)로 전달하고 결과를 두 번째 인수로 전달하는 Node.js 규칙을 따릅니다. <code>err</code>가 있어 오류가 발생하면 <code>task.throw()</code>가 <code>task.next()</code>대신에 오류 객체와 함께 호출되므로 정확한 위치에 오류가 발생합니다. 오류가 없으면 <code>data</code>가 <code>task.next()</code>에 전달되고 그 결과가 저장됩니다. 그런 다음 <code>step()</code>이 호출되어 프로세스가 계속 진행됩니다. <code>result.value</code>가 함수가 아니라면 <code>next()</code> 메서드에 직접 전달됩니다.</p>
<p>이 새로운 버전의 태스크 러너는 모든 비동기 태스크에 대한 준비가 되어 있습니다. Node.js에서 파일로부터 데이터를 읽으려면, 이 섹션의 시작 부분에서 <code>fetchData()</code> 함수와 유사한 함수를 반환하는 <code>fs.readFile()</code>을 감싸는 래퍼를 생성해야합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">filename</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</div><div class="line">        fs.readFile(filename, callback);</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>readFile()</code> 메서드는 파라미터인 파일명을 받아들이고 콜백을 호출하는 함수를 반환합니다. 콜백은 <code>fs.readFile()</code> 메서드에 직접 전달되며, 메서드는 완료시 콜백을 실행합니다. 다음과 같이 <code>yield</code>를 사용하여 이 작업을 실행할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">run(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> contents = <span class="keyword">yield</span> readFile(<span class="string">"config.json"</span>);</div><div class="line">    doSomethingWith(contents);</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Done"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>이 예제는 주 코드에 콜백을 표시하지 않고 비동기 <code>readFile()</code> 연산을 수행합니다. <code>yield</code>와는 별도로, 코드는 동기 코드와 동일하게 보입니다. 비동기 작업을 수행하는 함수가 모두 동일한 인터페이스를 준수하는 한 동기 코드와 같은 로직을 작성할 수 있습니다.</p>
<p>물론,이 예제에서 사용된 패턴에는 단점이 있습니다. 즉, 함수를 반환하는 함수가 비동기인지 항상 확신할 수는 없습니다. 지금 당장은 실행중인 태스크 뒤에있는 이론을 이해하는 것이 중요합니다. <em>Promise</em>를 사용하면 비동기 작업을 예약하는 보다 강력한 방법이 제공되며 11 장에서는 이 주제에 대해 자세히 설명합니다.</p>
<h2 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h2><p><em>Iterator</em>는 ECMAScript 6의 중요한 부분이며 언어의 몇 가지 핵심 요소에 존재합니다. 표면적으로 <em>Iterator</em>는 간단한 API를 사용하여 일련의 값을 반환하는 방법을 제공합니다. 그러나 ECMAScript 6에서 <em>Iterator</em>를 사용하는 훨씬 더 복잡한 방법이 있습니다.</p>
<p><code>Symbol.iterator</code> <em>Symbol</em>은 객체의 기본 <em>Iterator</em>를 정의하는데 사용됩니다. <em>Built-in</em> 객체와 개발자 정의 객체는 모두 이 <em>Symbol</em>을 사용하여 <em>Iterator</em>를 반환하는 메서드를 제공할 수 있습니다. <code>Symbol.iterator</code>가 객체에 제공되면 객체는 <em>Iterable</em>한 것으로 간주됩니다.</p>
<p><code>for-of</code> 루프는 <em>Iterable</em>를 사용하여 루프에서 일련의 값을 반환합니다. <code>for-of</code>를 사용하면 더 이상 값을 추적할 필요가 없고 루프가 끝나는 시점을 제어할 필요가 없으므로 전통적인 <code>for</code> 루프를 반복하는 것보다 쉽습니다. <code>for-of</code> 루프는 <em>Iterator</em>에서 더 이상 값이 없을 때까지 모든 값을 자동으로 읽은 다음 종료합니다.</p>
<p><code>for-of</code>를 더 쉽게 사용하기 위해 ECMAScript 6의 많은 타입에는 기본 <em>Iterator</em>가 있습니다. 컬렉션, 즉 <em>Array</em>, <em>Map</em> 및 <em>Set</em>과 같은 모든 컬렉션 유형에는 내용에 쉽게 액세스할 수 있도록 설계된 <em>Iterator</em>가 있습니다. 문자열에는 기본 <em>Iterator</em>가 있어 <em>Code unit</em>이 아닌 문자열의 문자를 쉽게 반복할 수 있습니다.</p>
<p><em>Spread</em> 연산자는 모든 <em>Iterable</em> 함수에서 작동하며 <em>Iterable</em>를 <em>Array</em>로 쉽게 변환합니다. 변환은 <em>Iterator</em>에서 값을 읽어 <em>Array</em>에 개별적으로 삽입하여 작동합니다.</p>
<p><em>Generator</em>는 호출될 때 <em>Iterator</em>를 자동으로 생성하는 특수 함수입니다. <em>Generator</em> 정의는 별표(<code>*</code>) 문자로 표시되고 <code>yield</code> 키워드를 사용하여 <code>next()</code> 메서드를 연속적으로 호출할 때 반환할 값을 나타냅니다.</p>
<p><em>Generator</em> 위임은 새로운 <em>Generator</em>에서 기존 <em>Generator</em>를 재사용 하도록 함으로써 <em>Iterator</em> 동작을 잘 캡슐화하도록 합니다. <code>yield</code> 대신 <code>yield *</code>를 호출하여 다른 <em>Generator</em>의 기존 <em>Generator</em>를 사용할 수 있습니다. 이 프로세스를 통해 여러 <em>Iterator</em>의 값을 반환하는 <em>Iterator</em>를 만들 수 있습니다.</p>
<p>아마도 <em>Generator</em>와 <em>Iterator</em> 중 가장 흥미로운 부분은 보다 깨끗한 비동기 코드를 생성할 수 있다는 것입니다. 콜백을 사용하는 대신 동기식으로 보이는 코드가 실제로 <code>yield</code>를 사용하면 비동기 작업으로 완료될 때까지 대기합니다.</p>
<hr>
<blockquote>
<p>이 내용은 나중에 참고하기 위해 제가 공부하며 정리한 내용입니다.<br>의역, 오역, 직역이 있을 수 있음을 알려드립니다.<br>This post is a translation of this original article [<a href="https://leanpub.com/understandinges6/read#leanpub-auto-iterators-and-generators" target="_blank" rel="external">https://leanpub.com/understandinges6/read#leanpub-auto-iterators-and-generators</a>]</p>
</blockquote>
<h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul>
<li><a href="https://infoscis.github.io/2018/01/24/ecmascript-6-block-binding/">ECMAScript 6 Block Binding</a></li>
<li><a href="https://infoscis.github.io/2018/01/24/ecmascript-6-strings-and-regular-expressions/">ECMAScript 6 문자열과 정규 표현식</a></li>
<li><a href="https://infoscis.github.io/2018/01/24/ecmascript-6-functions/">ECMAScript 6 함수</a></li>
<li><a href="https://infoscis.github.io/2018/01/25/ecmascript-6-expanded-object-functionality/">ECMAScript 6 객체의 확장된 기능</a></li>
<li><a href="https://infoscis.github.io/2018/01/26/ecmascript-6-destructuring-for-easier-data-access/">ECMAScript 6 쉬운 데이터 액세스를 위한 Destructuring</a></li>
<li><a href="https://infoscis.github.io/2018/01/27/ecmascript-6-symbols-and-symbol-properties/">ECMAScript 6 Symbol과 Symbol 프로퍼티</a></li>
<li><a href="https://infoscis.github.io/2018/01/27/ecmascript-6-sets-and-maps/">ECMAScript 6 Set과 Map</a></li>
<li><a href="https://infoscis.github.io/2018/01/31/ecmascript-6-iterators-and-generators/">ECMAScript 6 Iterator와 Generator</a></li>
<li><a href="https://infoscis.github.io/2018/02/13/ecmascript-6-introducing-javascript-classes/">ECMAScript 6 JavaScript 클래스 소개</a></li>
<li><a href="https://infoscis.github.io/2018/02/13/ecmascript-6-improved-array-capabilities/">ECMAScript 6 Array 기능 향상</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-promises-and-asynchronous-programming/">ECMAScript 6 Promise와 비동기 프로그램밍</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-proxies-and-the-reflection-api/">ECMAScript 6 프록시와 리플렉션 API</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-encapsulating-code-with-modules/">ECMAScript 6 Module로 코드 캡슐화하기</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-appendix-a-smaller-changes/">ECMAScript 6 부록 A. 작은 변경 사항</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-appendix-b-understanding-ecmascript-7/">ECMAScript 6 부록 B. ECMAScript 7(2016) 이해하기</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Iterator와-Generator&quot;&gt;&lt;a href=&quot;#Iterator와-Generator&quot; class=&quot;headerlink&quot; title=&quot;Iterator와 Generator&quot;&gt;&lt;/a&gt;Iterator와 Generator&lt;/h1&gt;&lt;p&gt;많은
    
    </summary>
    
      <category term="JavaScript" scheme="http://infoscis.github.io/categories/JavaScript/"/>
    
      <category term="ECMAScript 2015" scheme="http://infoscis.github.io/categories/JavaScript/ECMAScript-2015/"/>
    
    
      <category term="JavaScript" scheme="http://infoscis.github.io/tags/JavaScript/"/>
    
      <category term="ECMAScript 2015" scheme="http://infoscis.github.io/tags/ECMAScript-2015/"/>
    
  </entry>
  
  <entry>
    <title>ECMAScript 6 Set과 Map</title>
    <link href="http://infoscis.github.io/2018/01/27/ecmascript-6-sets-and-maps/"/>
    <id>http://infoscis.github.io/2018/01/27/ecmascript-6-sets-and-maps/</id>
    <published>2018-01-27T14:19:03.000Z</published>
    <updated>2018-02-27T14:12:22.502Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Set과-Map"><a href="#Set과-Map" class="headerlink" title="Set과 Map"></a>Set과 Map</h1><p>JavaScript의 역사에서 컬렉션 타입은 <em>Array</em> 타입 하나만 가지고 있었습니다. (<em>Array</em>가 아닌 모든 객체는 키 - 값 쌍의 집합이므로 <em>Array</em>와 원래 의도된 용도는 다릅니다). <em>Array</em>는 다른 언어와 마찬가지로 JavaScript에서도 사용되지만 다른 컬렉션이 없기 때문에 대개 Queue 및 Stack으로 <em>Array</em>를 사용합니다. <em>Array</em>는 숫자 인덱스만 사용하기 때문에 개발자는 숫자가 아닌 인덱스가 필요할 때마다 <em>Array</em>가 아닌 객체를 사용했습니다. 아래에서 설명한 기술을 사용하면 <em>Array</em>가 아닌 객체를 사용하여 Set 및 Map을 사용자 정의로 구현할 수 있습니다.</p>
<p><em>Set</em>은 중복을 포함할 수 없는 값의 목록입니다. 일반적인 <em>Array</em>의 항목처럼 <em>Set</em>은 개별 항목에 액세스하지 않습니다. 대신 값이 있는지 확인하기 위해 <em>Set</em>를 확인하는 것이 훨씬 더 일반적입니다. <em>Map</em>은 특정 값에 해당하는 키의 모음입니다. 따라서 <em>Map</em>의 각 항목에는 두 개의 데이터가 저장되고 값은 읽을 키를 지정하여 검색됩니다. <em>Map</em>은 캐시로 자주 사용되어 나중에 빠르게 검색할 데이터를 저장하기도 합니다. ECMAScript 5에는 공식적으로 <em>Set</em>과 <em>Map</em>이 없었지만 개발자는 <em>Array</em>가 아닌 오브젝트를 사용하여 이 제한을 풀었습니다.</p>
<p>ECMAScript 6은 JavaScript에 <em>Set</em>과 <em>Map</em>을 추가했으며 이 장에서는 이 두 가지 컬렉션 유형에 대해 알아야할 모든 내용에 대해 설명합니다.</p>
<p>먼저 ECMAScript 6 이전에 <em>Set</em>과 <em>Map</em>을 구현하는데 사용된 방법과 그 구현이 왜 문제가되는지 설명합니다. 중요한 배경 지식을 얻은 후에 ECMAScript 6에서 <em>Set</em>과 <em>Map</em>의 작동 방법을 설명하겠습니다.</p>
<h2 id="ECMAScript-5에서의-Set과-Map"><a href="#ECMAScript-5에서의-Set과-Map" class="headerlink" title="ECMAScript 5에서의 Set과 Map"></a>ECMAScript 5에서의 <em>Set</em>과 <em>Map</em></h2><p>ECMAScript 5에서 개발자는 다음과 같이 객체 프로퍼티를 사용하여 <em>Set</em> 및 <em>Map</em>을 모방했습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> set = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</div><div class="line"></div><div class="line">set.foo = <span class="literal">true</span>;</div><div class="line"></div><div class="line"><span class="comment">// 존재 확인하기</span></div><div class="line"><span class="keyword">if</span> (set.foo) &#123;</div><div class="line"></div><div class="line">    <span class="comment">// do something</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>이 예제에서 <code>set</code> 변수는 객체 상에 상속된 프로퍼티가 없음을 보장하는 <code>null</code> 프로토 타입을 가진 객체입니다. 객체 프로퍼티를 검사할 고유 값으로 사용하는 것은 ECMAScript 5에서 일반적인 접근법입니다. 프로퍼티가 <code>set</code> 객체에 추가되면, 이 객체는 <code>true</code>로 설정되어 조건문 (이 예에서 <code>if</code> 문)에서 값이 존재하는지 쉽게 확인할 수 있습니다.</p>
<p><em>Set</em>으로 사용된 객체와 <em>Map</em>으로 사용되는 객체 사이의 차이점은 저장되는 값뿐입니다. 예를 들어, 아래 예제는 객체를 <em>Map</em>으로 사용합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> map = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</div><div class="line"></div><div class="line">map.foo = <span class="string">"bar"</span>;</div><div class="line"></div><div class="line"><span class="comment">// 값을 추출</span></div><div class="line"><span class="keyword">let</span> value = map.foo;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(value);         <span class="comment">// "bar"</span></div></pre></td></tr></table></figure>
<p>이 코드는 <code>foo</code> 키 아래에 문자열 값 <code>&quot;bar&quot;</code>를 저장합니다. <em>Set</em>과 달리, <em>Map</em>은 키의 존재를 확인하기 보다는 정보를 검색하는 데 주로 사용됩니다.</p>
<h2 id="해결-방법의-문제점"><a href="#해결-방법의-문제점" class="headerlink" title="해결 방법의 문제점"></a>해결 방법의 문제점</h2><p>객체를 <em>Set</em> 및 <em>Map</em>으로 사용하는 것은 간단한 상황에서 문제 없이 작동하지만 객체 프로퍼티의 한계를 뛰어 넘으면 접근법이 더 복잡해질 수 있습니다. 예를 들어 모든 객체 프로퍼티는 문자열이어야 하므로 동일한 문자열로 평가되는 두 개의 키가 없어야합니다. 다음 사항을 생각해 보겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> map = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</div><div class="line"></div><div class="line">map[<span class="number">5</span>] = <span class="string">"foo"</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(map[<span class="string">"5"</span>]);      <span class="comment">// "foo"</span></div></pre></td></tr></table></figure>
<p>이 예제에서는 문자열 값 <code>&quot;foo&quot;</code>를 숫자 키 <code>5</code>에 할당합니다. 내부적으로 숫자 값은 문자열로 변환되므로 <code>map[&quot;5&quot;]</code> 및 <code>map[5]</code>는 실제로 동일한 프로퍼티를 참조합니다. 내부 변환은 숫자와 문자열을 키로 사용하려는 경우 문제를 일으킬 수 있습니다. 다음과 같이 객체를 키로 사용할 때 또 다른 문제가 발생합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> map = <span class="built_in">Object</span>.create(<span class="literal">null</span>),</div><div class="line">    key1 = &#123;&#125;,</div><div class="line">    key2 = &#123;&#125;;</div><div class="line"></div><div class="line">map[key1] = <span class="string">"foo"</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(map[key2]);     <span class="comment">// "foo"</span></div></pre></td></tr></table></figure>
<p>여기서 <code>map[key2]</code>와 <code>map[key1]</code>은 같은 값을 참조합니다. 객체 프로퍼티는 문자열이어야 하므로 객체 <code>key1</code> 및 <code>key2</code>는 문자열로 변환됩니다. <code>&quot;[object Object]&quot;</code>는 객체의 기본 문자열 표현이기 때문에 <code>key1</code>과 <code>key2</code>가 모두 해당 문자열로 변환됩니다. 이는 사실상 다른 객체의 키가 같은 값으로 가정되는 것이 논리적의로 명백하지 않을 수있는 오류를 유발할 수 있습니다.</p>
<p>기본 문자열 표현으로 변환하면 객체를 키로 사용하기가 어렵습니다. (객체를 <em>Set</em>으로 사용하려고할 때도 같은 문제가 발생합니다.)</p>
<p>거짓으로 표현되는 값을 가지는 키가 있는 <em>Map</em>은 특정 문제를 발생시킵니다. 거짓 값은 <code>if</code> 문과 같은 부울 값이 필요한 상황에서 사용될 때 자동으로 false로 변환됩니다. 이 변환만으로는 문제가되지 않습니다. 값을 사용하는 방법에 대해 신중해야합니다. 예를 들어 다음 코드를 살펴보십시오.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> map = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</div><div class="line"></div><div class="line">map.count = <span class="number">1</span>;</div><div class="line"></div><div class="line"><span class="comment">// "count"값이 존재하는지 또는 0이 아닌지 어떤걸 체크 하나요?</span></div><div class="line"><span class="keyword">if</span> (map.count) &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>이 예제는 <code>map.count</code>가 어떻게 사용되어야하는지 모호합니다. <code>if</code> 문은 <code>map.count</code>의 존재를 검사할지 아니면 값이 0이 아닌 것을 검사할지 모호합니다. 그래서 숫자 1은 true로 표현되어 <code>if</code>문 안의 코드가 실행됩니다. 그러나 <code>map.count</code>가 0이거나 <code>map.count</code>가 없으면 <code>if</code> 문 안의 코드는 실행되지 않습니다.</p>
<p>ECMAScript 6가 <em>Set</em>과 <em>Map</em> 모두를 언어에 추가하는 가장 큰 이유는 대규모 응용 프로그램에서 발생하는 문제를 식별하고 디버그하는 것이 어렵기 때문입니다.</p>
<blockquote>
<p>JavaScript는 객체의 값을 읽지 않고 객체에 프로퍼티가 있으면 true를 반환하는 <code>in</code> 연산자를 가지고 있습니다. 그러나 <code>in</code> 연산자는 객체의 프로토 타입을 검색하기 때문에 객체가 <code>null</code> 프로토 타입을 가지고있을 때만 안전하게 사용할 수 있습니다. 그럼에도 불구하고, 많은 개발자들은 여전히 <code>in</code>을 사용하는 대신 마지막 예제 에서처럼 코드를 잘못 사용합니다.</p>
</blockquote>
<h2 id="ECMAScript-6에서-Set"><a href="#ECMAScript-6에서-Set" class="headerlink" title="ECMAScript 6에서 Set"></a>ECMAScript 6에서 <em>Set</em></h2><p>ECMAScript 6이 중복되지 않은 값의 정렬된 목록인 <code>Set</code> 타입을 추가 했습니다. <em>Set</em>을 사용하면 포함된 데이터에 빠르게 액세스할 수 있으므로 불연속 값을 보다 효율적으로 추적할 수 있습니다.</p>
<h3 id="Set-만들기와-아이템-추가하기"><a href="#Set-만들기와-아이템-추가하기" class="headerlink" title="Set 만들기와 아이템 추가하기"></a><em>Set</em> 만들기와 아이템 추가하기</h3><p><em>Set</em>은 <code>new Set()</code>를 사용하여 생성할수 있고, 항목은 <code>add()</code> 메서드를 호출하여 추가할 수 있습니다. <code>size</code> 프로퍼티를 확인하여 <em>Set</em>에 포함된 항목 수를 확인할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>();</div><div class="line">set.add(<span class="number">5</span>);</div><div class="line">set.add(<span class="string">"5"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(set.size);    <span class="comment">// 2</span></div></pre></td></tr></table></figure>
<p><em>Set</em>은 값이 동일한지 확인하기 위해 값을 강제 변환하지 않습니다. 이는 <em>Set</em>이 숫자 <code>5</code>와 문자열 <code>&quot;5&quot;</code>를 두 개의 개별 항목을 포함할 수 있음을 의미합니다. 유일한 예외는 <code>-0</code>과 <code>+0</code>은 같은 것으로 간주된다는 것입니다. 또한 <em>Set</em>에 여러 객체를 추가할 수 있으며 이러한 객체는 구별됩니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>(),</div><div class="line">    key1 = &#123;&#125;,</div><div class="line">    key2 = &#123;&#125;;</div><div class="line"></div><div class="line">set.add(key1);</div><div class="line">set.add(key2);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(set.size);    <span class="comment">// 2</span></div></pre></td></tr></table></figure>
<p><code>key1</code>과 <code>key2</code>는 문자열로 변환되지 않으므로 <em>Set</em>에서 두 개의 고유 항목으로 간주됩니다. (문자열로 변환하면 <code>&quot;[Object object]&quot;</code>와 같이 둘은 서로 같습니다.)</p>
<p><code>add()</code> 메서드가 같은 값으로 두 번 이상 호출되면 첫 번째 호출 이후의 모든 호출은 무시됩니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>();</div><div class="line">set.add(<span class="number">5</span>);</div><div class="line">set.add(<span class="string">"5"</span>);</div><div class="line">set.add(<span class="number">5</span>);     <span class="comment">// duplicate - this is ignored</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(set.size);    <span class="comment">// 2</span></div></pre></td></tr></table></figure>
<p><em>Array</em>를 사용하여 <em>Set</em>을 초기화할 수 있으며 <em>Set</em> 생성자는 고유 한 값만 사용합니다. 예를 들어 아래와 같습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>]);</div><div class="line"><span class="built_in">console</span>.log(set.size);    <span class="comment">// 5</span></div></pre></td></tr></table></figure>
<p>이 예제에서는 중복 값이 있는 <em>Array</em>를 사용하여 <em>Set</em>을 초기화합니다. 숫자 <code>5</code>는 <em>Array</em>에 네 번 나타나지만 <em>Set</em>에 한 번만 입력됩니다. 이 기능을 사용하여 기존 코드 또는 JSON을  쉽게 <em>Set</em>으로 사용할 수 있습니다.</p>
<blockquote>
<p><em>Set</em> 생성자는 실제로 모든 반복 가능한 객체를 인수로 받습니다. <em>Array</em>는 <em>Set</em>과 <em>Map</em>처럼 기본적으로 반복 가능하기 때문입니다. <em>Set</em> 생성자는 <em>Iterator</em>를 사용하여 인수에서 값을 추출합니다. (<em>Iterables</em>과 <em>Iterator</em>는 8 장에서 자세히 논의됩니다.)</p>
</blockquote>
<p>다음과 같이 <code>has()</code> 메서드를 사용하여 어떤 값이 <em>Set</em>에 있는지 테스트할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>();</div><div class="line">set.add(<span class="number">5</span>);</div><div class="line">set.add(<span class="string">"5"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(set.has(<span class="number">5</span>));    <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(set.has(<span class="number">6</span>));    <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p><em>Set</em>에는 값이 없기 때문에 <code>set.has(6)</code>는 <code>false</code>를 반환합니다.</p>
<h3 id="값-지우기"><a href="#값-지우기" class="headerlink" title="값 지우기"></a>값 지우기</h3><p><em>Set</em>에서 값을 제거할 수도 있습니다. <code>delete()</code> 메서드를 사용하여 단일 값을 제거하거나 <code>clear()</code> 메서드를 호출하여 <em>Set</em>에서 모든 값을 제거할 수 있습니다. 아래 코드는 두 가지를 모두 보여줍니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>();</div><div class="line">set.add(<span class="number">5</span>);</div><div class="line">set.add(<span class="string">"5"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(set.has(<span class="number">5</span>));    <span class="comment">// true</span></div><div class="line"></div><div class="line">set.delete(<span class="number">5</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(set.has(<span class="number">5</span>));    <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log(set.size);      <span class="comment">// 1</span></div><div class="line"></div><div class="line">set.clear();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(set.has(<span class="string">"5"</span>));  <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log(set.size);      <span class="comment">// 0</span></div></pre></td></tr></table></figure>
<p><code>delete()</code> 호출 후 <code>5</code>가 삭제되었습니다. <code>clear()</code> 메서드가 실행된 후 <code>set</code>은 모두 비어 있습니다.</p>
<p>이 모든 것이 정렬된 값을 추적하기 위한 매우 쉬운 메커니즘입니다. 그리고 <em>Set</em>에 항목을 추가한 다음 각 항목에 대해 일부 작업을 수행하려면 <code>forEach()</code> 메소드를 이용합니다.</p>
<h3 id="Set의-forEach-메서드"><a href="#Set의-forEach-메서드" class="headerlink" title="Set의 forEach 메서드"></a><em>Set</em>의 forEach 메서드</h3><p><em>Array</em> 작업에 익숙하다면 이미 <code>forEach()</code> 메서드에 익숙할 것입니다. ECMAScript 5는 <code>forEach()</code>를 <em>Array</em>에 추가하여 <em>Array</em>의 각 항목에서 <code>for</code> 루프를 설정하지 않고 작업을 쉽게할 수 있게했습니다. 이 방법은 개발자들 사이에서 인기가 높으며 동일한 방법이 <em>Set</em>에서 사용 가능하고 동일한 방식으로 실행됩니다.</p>
<p><code>forEach()</code> 메서드는 세 개의 파라미터를 받는 콜백 함수가 전달됩니다.</p>
<ol>
<li><em>Set</em> 내의 다음의 위치 값입니다.</li>
<li>첫 번째 파라미터와 같은 값</li>
<li>값을 읽는 <em>Set</em></li>
</ol>
<p><em>Set</em>의 <code>forEach()</code>가 <em>Array</em>의 <code>forEach()</code>와 특이한 차이점은 콜백 함수에 대한 첫 번째 및 두 번째 파라미터가 동일하다는 것입니다. 이것은 실수처럼 보일 수 있지만 타당한 이유가 있습니다.</p>
<p><code>forEach()</code> 메서드 (<em>Array</em> 및 <em>Map</em>)가 있는 다른 객체는 콜백 함수에 세 개의 파라미터를 전달합니다. <em>Array</em>와 <em>Map</em>의 최초의 2 개의 파라미터는, 값과 키 (<em>Array</em>의 인덱스 숫자)입니다.</p>
<p>그러나 <em>Set</em>에는 키가 없습니다. ECMAScript 6 표준을 작성한 사람들은 <code>forEach()</code>의 <em>Set</em> 버전에서 콜백 함수에 두 개의 파라미터를 허용하지만, <em>Array</em>와 <em>Map</em>의 파라미터와 다르게 만들었습니다. 대신 콜백 함수를 동일하게 유지하고 세 개의 파라미터를 허용하는 방법을 찾았습니다. <em>Set</em>의 첫 번째, 두 번째 파라미터는 키와 값으로 간주됩니다. 따라서 첫 번째와 두 번째 파라미터는 <em>Array</em>와 <em>Map</em>의 <code>forEach()</code> 메서드와 일관된 기능을 유지합니다.</p>
<p>파라미터의 차이 이외에, <code>forEach()</code>를 사용하는 것은 기본적으로 <em>Array</em>와 같습니다. 다음은 메서드가 실행되는 방식을 보여주는 코드입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>]);</div><div class="line"></div><div class="line">set.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value, key, ownerSet</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(key + <span class="string">" "</span> + value);</div><div class="line">    <span class="built_in">console</span>.log(ownerSet === set);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>이 코드는 <em>Set</em>의 각 항목을 반복하여 <code>forEach()</code> 콜백 함수에 전달된 값을 출력합니다. 콜백 함수가 실행될 때마다 <code>key</code>와 <code>value</code>는 같고 <code>ownerSet</code>는 항상 <code>set</code>과 같습니다. 이 코드의 출력 결과는 아래와 같습니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1 1</div><div class="line">true</div><div class="line">2 2</div><div class="line">true</div></pre></td></tr></table></figure>
<p>콜백 함수에서 <code>this</code>를 사용해야한다면 <code>forEach()</code>의 두 번째 파라미터로 <code>this</code> 값을 전달할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>]);</div><div class="line"></div><div class="line"><span class="keyword">let</span> processor = &#123;</div><div class="line">    output(value) &#123;</div><div class="line">        <span class="built_in">console</span>.log(value);</div><div class="line">    &#125;,</div><div class="line">    process(dataSet) &#123;</div><div class="line">        dataSet.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">            <span class="keyword">this</span>.output(value);</div><div class="line">        &#125;, <span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">processor.process(set);</div></pre></td></tr></table></figure>
<p>이 예제에서 <code>processor.process()</code> 메서드는 <em>Set</em>에서 <code>forEach()</code>를 호출하고 <code>this</code>를 콜백을 위한 <code>this</code> 값으로 전달합니다. 그래서 <code>this.output()</code>은 <code>processor.output()</code> 메서드로 올바르게 해석됩니다. <code>forEach()</code> 콜백 함수는 첫 번째 파라미터인 <code>value</code>만을 사용하므로 나머지는 생략합니다. <em>Arrow</em> 함수를 사용하여 두 번째 파라미터를 전달하지 않고 동일한 효과를 얻을 수도 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>]);</div><div class="line"></div><div class="line"><span class="keyword">let</span> processor = &#123;</div><div class="line">    output(value) &#123;</div><div class="line">        <span class="built_in">console</span>.log(value);</div><div class="line">    &#125;,</div><div class="line">    process(dataSet) &#123;</div><div class="line">        dataSet.forEach(<span class="function">(<span class="params">value</span>) =&gt;</span> <span class="keyword">this</span>.output(value));</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">processor.process(set);</div></pre></td></tr></table></figure>
<p>위 예제의 <em>Arrow</em> 함수는 <code>process()</code> 함수에서 <code>this</code>를 읽어서 <code>this.output()</code>을 <code>processor.output()</code>호출로 올바르게 해석합니다.</p>
<p><em>Set</em>은 값을 추적하는데 적합하고 <code>forEach()</code>를 사용하여 순차적으로 각 값을 처리할 수 있지만, <em>Array</em> 처럼 인덱스를 사용하여 값에 직접 액세스할 수는 없습니다. 그렇게해야 할 경우, 가장 좋은 방법은 <em>Set</em>을 <em>Array</em>로 변환하는 것입니다.</p>
<h3 id="Set을-Array로-변환"><a href="#Set을-Array로-변환" class="headerlink" title="Set을 Array로 변환"></a>Set을 Array로 변환</h3><p><em>Array</em>를 <code>Set</code> 생성자에 전달할 수 있기 때문에 <em>Array</em>를 <em>Set</em>으로 쉽게 변환할 수 있습니다. <em>Spread</em> 연산자를 사용하여 <em>Set</em>을 다시 <em>Array</em>로 변환하는 것도 쉽습니다. 3 장에서는 <em>Array</em>의 항목을 별도의 함수 매개 변수로 분할하는 방법으로 <em>Spread</em> 연산자 (<code>...</code>)를 설명했습니다. 또한 <em>Spread</em> 연산자를 사용하여 <em>Set</em>과 같은 반복 가능한 객체를 <em>Array</em>로 변환할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]),</div><div class="line">    array = [...set];</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(array);             <span class="comment">// [1,2,3,4,5]</span></div></pre></td></tr></table></figure>
<p>여기서, <em>Set</em>은 초기에 중복을 포함하는 <em>Array</em>로 로드됩니다. <em>Set</em>은 중복을 제거한 다음 <em>Spread</em> 연산자를 사용하여 항목을 새로운 <em>Array</em>에 배치합니다. <em>Set</em> 자체에는 생성될 때받은 것과 동일한 항목 (<code>1</code>, <code>2</code>, <code>3</code>, <code>4</code> 및 <code>5</code>)이 여전히 포함되어 새로운 <em>Array</em>로 복사됩니다.</p>
<p>이 방법은 이미 <em>Array</em>가 있지만 새로운 중복값 없이 <em>Array</em>를 만들려는 경우에 유용합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">eliminateDuplicates</span>(<span class="params">items</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> [...new <span class="built_in">Set</span>(items)];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>],</div><div class="line">    noDuplicates = eliminateDuplicates(numbers);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(noDuplicates);      <span class="comment">// [1,2,3,4,5]</span></div></pre></td></tr></table></figure>
<p><code>eliminateDuplicates()</code> 함수에서 <em>Set</em>은 중복이 없는 새로운 <em>Array</em>를 만들기 전에 중복 값을 필터링하는데 사용되는 임시 매개체 일뿐입니다.</p>
<h3 id="Weak-Set"><a href="#Weak-Set" class="headerlink" title="Weak Set"></a>Weak Set</h3><p><code>Set</code> 타입은 오브젝트 참조를 저장하는 방식 때문에 Strong <em>Set</em>이 라고 부를 수 있습니다. <code>Set</code>의 인스턴스에 저장된 객체는 그 객체를 변수 안에 저장하는 것과 실질적으로 동일합니다. 해당 <code>Set</code> 인스턴스에 대한 참조가 존재하는 한, 객체는 가비지 컬랙트되어 메모리를 비울 수 없습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>(),</div><div class="line">    key = &#123;&#125;;</div><div class="line"></div><div class="line">set.add(key);</div><div class="line"><span class="built_in">console</span>.log(set.size);      <span class="comment">// 1</span></div><div class="line"></div><div class="line"><span class="comment">// 원래의 참조 삭제</span></div><div class="line">key = <span class="literal">null</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(set.size);      <span class="comment">// 1</span></div><div class="line"></div><div class="line"><span class="comment">// 원래의 참조를 되찾습니다.</span></div><div class="line">key = [...set][<span class="number">0</span>];</div></pre></td></tr></table></figure>
<p>이 예제에서 <code>key</code>를 <code>null</code>로 설정하면 <code>key</code> 객체의 참조를 지우지만 다른 참조는 <code>set</code> 안에 남아 있습니다. 집합을 <em>Spread</em> 연산자로 <em>Array</em>로 변환하고 첫 번째 항목에 액세스하면 여전히 <code>key</code>를 검색할 수 있습니다. 대부분의 프로그램에서는 괜찮지만 때때로 다른 모든 참조가 사라지면 <em>Set</em>의 참조가 사라지는 것이 좋을 때도 있습니다. 예를 들어 웹 페이지에서 JavaScript 코드가 실행 중이고 다른 스크립트에 의해 제거 될 수있는 DOM 요소를 추적하려는 경우 코드가 DOM 요소에 대한 마지막 참조를 유지하지 못하게해야 합니다. (이 상황을 <em>메모리 누수(memory leak)</em>라고합니다.)</p>
<p>이러한 문제를 줄이기 위해 ECMAScript 6에는 약한 객체 참조만 저장하고 원시 값을 저장할 수없는 <em>Weak Set</em>도 포함하고 있습니다. 객체에 대한 약한 참조가 유일하게 남아있는 참조인 경우 가비지 컬렉션 대상이 됩니다.</p>
<h4 id="Weak-Set-생성하기"><a href="#Weak-Set-생성하기" class="headerlink" title="Weak Set 생성하기"></a><em>Weak Set</em> 생성하기</h4><p><em>Weak Set</em>은 <code>WeakSet</code> 생성자를 사용하여 생성되며 <code>add()</code>, <code>has()</code> 및 <code>delete()</code> 메서드를 포함합니다. 다음은이 세 가지를 모두 사용하는 예제입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">WeakSet</span>(),</div><div class="line">    key = &#123;&#125;;</div><div class="line"></div><div class="line"><span class="comment">// add the object to the set</span></div><div class="line">set.add(key);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(set.has(key));      <span class="comment">// true</span></div><div class="line"></div><div class="line">set.delete(key);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(set.has(key));      <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p><em>Weak Set</em>을 사용하는 것은 보통 <em>Set</em>을 사용하는 것과 같습니다. <em>Weak Set</em>에서 참조를 추가, 제거 및 확인할 수 있습니다. <em>Iterable</em>을 생성자에 전달하여 값이 있는 <em>Weak Set</em>를 생성할 수도 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> key1 = &#123;&#125;,</div><div class="line">    key2 = &#123;&#125;,</div><div class="line">    set = <span class="keyword">new</span> <span class="built_in">WeakSet</span>([key1, key2]);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(set.has(key1));     <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(set.has(key2));     <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>이 예제에서 <em>Array</em>는 <code>WeakSet</code> 생성자에 전달됩니다. 이 <em>Array</em>에는 두 개의 객체가 포함되어 있으므로 해당 객체가 <em>Weak Set</em>에 추가됩니다. <code>WeakSet</code>은 <em>Primitive</em> 값을 받아 들일 수 없으므로 <em>Array</em>에 객체가 아닌 값이 포함되어 있으면 오류가 발생합니다.</p>
<h4 id="Set-타입-간의-주요-차이점"><a href="#Set-타입-간의-주요-차이점" class="headerlink" title="Set 타입 간의 주요 차이점"></a><em>Set</em> 타입 간의 주요 차이점</h4><p><em>Weak Set</em>와 정규 <em>Set</em>의 가장 큰 차이점은 객체 값에 약한 참조를 보유한다는 것입니다. 다음은 그 차이를 보여주는 예입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">WeakSet</span>(),</div><div class="line">    key = &#123;&#125;;</div><div class="line"></div><div class="line"><span class="comment">// add the object to the set</span></div><div class="line">set.add(key);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(set.has(key));      <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="comment">// 키에 대한 마지막 strong reference를 제거하고 Weak Set에서 제거합니다.</span></div><div class="line">key = <span class="literal">null</span>;</div></pre></td></tr></table></figure>
<p>이 코드가 실행된 후에, <em>Weak Set</em>의 <code>key</code>에 대한 참조는 더 이상 접근 가능하지 않습니다. 하지만 <code>has()</code> 메서드에 전달할 객체에 대한 참조가 필요하기 때문에 객체의 제거를 확인할 수 없습니다. 이렇게하면 <em>Weak Set</em> 테스트가 다소 혼란스럽지만, JavaScript 엔진이 참조를 제대로 제거했다는 것을 신뢰해야 합니다.</p>
<p>이 예제는 <em>Weak Set</em>이 일반 <em>Set</em>과 몇 가지 특성은 공유하지만 또한 몇 가지 중요한 차이점이 있음을 알려줍니다.</p>
<ol>
<li>WeakSet 인스턴스에서, 비 객체 <code>add()</code> 메서드는 오류를 throw합니다.(<code>has()</code> 및 <code>delete()</code>는 객체가 아닌 파라미터에 대해 항상 false를 반환) </li>
<li><em>Weak Set</em>은 <em>Iterable</em>이 아니므로 <code>for-of</code> 루프에서 사용할 수 없습니다.</li>
<li><em>Weak Set</em>은 <em>Iterator</em>(<code>keys()</code> 및 <code>values()</code> 메소드와 같은)를 노출시키지 않으므로 프로그래밍 방식으로 <em>Weak Set</em>의 내용을 판별할 수는 없습니다.</li>
<li><em>Weak Set</em>에는 <code>forEach()</code> 메서드가 없습니다.</li>
<li><em>Weak Set</em>에는 <code>size</code> 프로퍼티가 없습니다.</li>
</ol>
<p>메모리를 적절히 처리하려면 <em>Weak Set</em>의 기능을 제한적으로 사용하는 것이 필요합니다. 객체 참조 추적을 한다면 일반 <em>Set</em> 대신 <em>Weak Set</em>를 사용합니다.</p>
<p><em>Set</em>은 값 목록을 처리하는 새로운 방법을 제공하지만 추가 정보를 해당 값과 연결해야하는 경우 유용하지 않습니다. 그래서 ECMAScript 6은 <em>Map</em>을 추가했습니다.</p>
<h2 id="ECMAScript-6의-Map"><a href="#ECMAScript-6의-Map" class="headerlink" title="ECMAScript 6의 Map"></a>ECMAScript 6의 <em>Map</em></h2><p>ECMAScript 6 <code>Map</code> 타입은 키-값 쌍의 정렬된 목록입니다. 여기서 키와 값은 어떤 타입도 가질 수 있습니다. 키는 <code>Set</code> 객체와 같은 접근법을 사용하여 결정됩니다. 그래서 <code>5</code>키와 <code>&#39;5&#39;</code>키를 가질 수 있습니다. 객체에서 프로퍼티를 키로 사용하는 것과 매우 다릅니다. 왜냐하면 객체의 프로퍼티는 항상 문자열로 강제 변환합니다.</p>
<p><code>set()</code> 메서드를 호출하고 키와 값을 전달하여 <em>Map</em>에 항목을 추가할 수 있습니다. 나중에 <code>get()</code> 메서드에 키를 전달하여 값을 검색할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</div><div class="line">map.set(<span class="string">"title"</span>, <span class="string">"Understanding ES6"</span>);</div><div class="line">map.set(<span class="string">"year"</span>, <span class="number">2016</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(map.get(<span class="string">"title"</span>));      <span class="comment">// "Understanding ES6"</span></div><div class="line"><span class="built_in">console</span>.log(map.get(<span class="string">"year"</span>));       <span class="comment">// 2016</span></div></pre></td></tr></table></figure>
<p>이 예에서는 두 개의 키-값 쌍이 저장됩니다. <code>&quot;title&quot;</code>키에는 문자열이 저장되고 <code>&quot;year&quot;</code>키에는 숫자가 저장됩니다. <code>get()</code> 메서드는 나중에 호출되어 두 키의 값을 검색합니다. <em>Map</em>에 키가 하나도 없으면 <code>get()</code>은 값 대신에 <code>undefined</code>라는 특수 값을 반환했을 것입니다.</p>
<p>객체를 키로 사용할 수도 있습니다. 이 방법은 이전에 객체 프로퍼티를 사용하여 <em>Map</em>을 만들던 방법으로는 불가능 했던걸 가능하게 합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(),</div><div class="line">    key1 = &#123;&#125;,</div><div class="line">    key2 = &#123;&#125;;</div><div class="line"></div><div class="line">map.set(key1, <span class="number">5</span>);</div><div class="line">map.set(key2, <span class="number">42</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(map.get(key1));         <span class="comment">// 5</span></div><div class="line"><span class="built_in">console</span>.log(map.get(key2));         <span class="comment">// 42</span></div></pre></td></tr></table></figure>
<p>이 코드는 <code>key1</code>과 <code>key2</code> 객체를 <em>Map</em>의 키로 사용하여 두 개의 다른 값을 저장합니다. 이러한 키는 다른 형태로 강제 변환되지 않으므로 각 객체는 고유 한 것으로 간주됩니다. 이렇게하면 객체 자체를 수정하지 않고도 객체에 추가 데이터를 연결할 수 있습니다.</p>
<h3 id="Map-메서드"><a href="#Map-메서드" class="headerlink" title="Map 메서드"></a><em>Map</em> 메서드</h3><p><em>Map</em>은 여러 메서드를 <em>Set</em>과 공유합니다. 이는 의도적인 것이며, 비슷한 방식으로 <em>Map</em> 및 <em>Set</em>과 상호 작용할 수 있습니다. 아래의 세 가지 메서드는 <em>Map</em>과 <em>Set</em>에서 사용할 수 있습니다.</p>
<ul>
<li><code>has(key)</code> - 지정된 키가 <em>Map</em>에 있는지 확인합니다.</li>
<li><code>delete(key)</code> - <em>Map</em>에서 키와 관련 값을 제거합니다.</li>
<li><code>clear()</code> - <em>Map</em>에서 모든 키와 값을 제거합니다.</li>
</ul>
<p>또한 <em>Map</em>에는 키-값 쌍이 얼마나 많은지 나타내는 <code>size</code> 프로퍼티가 있습니다. 아래 코드는 세 가지 메서드와 사이즈를 모두 다른 방식으로 사용합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</div><div class="line">map.set(<span class="string">"name"</span>, <span class="string">"Nicholas"</span>);</div><div class="line">map.set(<span class="string">"age"</span>, <span class="number">25</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(map.size);          <span class="comment">// 2</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(map.has(<span class="string">"name"</span>));   <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(map.get(<span class="string">"name"</span>));   <span class="comment">// "Nicholas"</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(map.has(<span class="string">"age"</span>));    <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(map.get(<span class="string">"age"</span>));    <span class="comment">// 25</span></div><div class="line"></div><div class="line">map.delete(<span class="string">"name"</span>);</div><div class="line"><span class="built_in">console</span>.log(map.has(<span class="string">"name"</span>));   <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log(map.get(<span class="string">"name"</span>));   <span class="comment">// undefined</span></div><div class="line"><span class="built_in">console</span>.log(map.size);          <span class="comment">// 1</span></div><div class="line"></div><div class="line">map.clear();</div><div class="line"><span class="built_in">console</span>.log(map.has(<span class="string">"name"</span>));   <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log(map.get(<span class="string">"name"</span>));   <span class="comment">// undefined</span></div><div class="line"><span class="built_in">console</span>.log(map.has(<span class="string">"age"</span>));    <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log(map.get(<span class="string">"age"</span>));    <span class="comment">// undefined</span></div><div class="line"><span class="built_in">console</span>.log(map.size);          <span class="comment">// 0</span></div></pre></td></tr></table></figure>
<p><em>Set</em>과 마찬가지로 <code>size</code> 프로퍼티는 항상 키-값 쌍의 수를 <em>Map</em>에 포함합니다. 이 예제에서 <code>Map</code> 인스턴스는 <code>&quot;name&quot;</code>과 <code>&quot;age&quot;</code>키들로 시작합니다. 그래서 <code>has()</code> 메서드는 <code>true</code>를 리턴합니다. <code>&quot;name&quot;</code> 키가 <code>delete()</code> 메서드에 의해 제거된 후에 <code>has()</code> 메서드는<br> <code>false</code>를 리턴하고 <code>size</code> 프로퍼티는 1을 나타냅니다. 그런 다음 <code>clear()</code> 메서드는 나머지 키를 제거하고, <code>size</code>프로퍼티는 <code>0</code>, <code>has()</code>는 <code>false</code>를 반환합니다.</p>
<p><code>clear()</code> 메서드는 <em>Map</em>에서 많은 데이터를 빠르게 제거하는 방법이지만 한 번에 많은 데이터를 <em>Map</em>에 추가하는 방법도 있습니다.</p>
<h3 id="Map-초기화"><a href="#Map-초기화" class="headerlink" title="Map 초기화"></a><em>Map</em> 초기화</h3><p>또한 <em>Set</em>과 유사하게 <em>Array</em>를 <code>Map</code> 생성자에 전달하여 데이터로 <em>Map</em>을 초기화할 수 있습니다. <em>Array</em>의 각 항목은 첫 번째 항목이 키이고 두 번째 항목이 키의 값인 <em>Array</em>이어야합니다. 따라서 전체 <em>Map</em>은 다음과 같은 <em>Array</em>의 <em>Array</em>입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">"name"</span>, <span class="string">"Nicholas"</span>], [<span class="string">"age"</span>, <span class="number">25</span>]]);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(map.has(<span class="string">"name"</span>));   <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(map.get(<span class="string">"name"</span>));   <span class="comment">// "Nicholas"</span></div><div class="line"><span class="built_in">console</span>.log(map.has(<span class="string">"age"</span>));    <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(map.get(<span class="string">"age"</span>));    <span class="comment">// 25</span></div><div class="line"><span class="built_in">console</span>.log(map.size);          <span class="comment">// 2</span></div></pre></td></tr></table></figure>
<p>키 <code>&quot;name&quot;</code>과 <code>&quot;age&quot;</code>는 생성자의 초기화를 통해 <code>map</code>에 추가됩니다. <em>Array</em>의 <em>Array</em>가 조금 이상하게 보일 수도 있지만 키는 모든 데이터 타입이 될 수 있으므로 키를 정확하게 나타내야합니다. 키를 <em>Array</em>에 저장하는 것이 <em>Map</em>에 저장되기 전에 다른 데이터 타입으로 강제 변환되지 않도록하는 유일한 방법입니다.</p>
<h3 id="Map에서의-forEach-메서드"><a href="#Map에서의-forEach-메서드" class="headerlink" title="Map에서의 forEach 메서드"></a><em>Map</em>에서의 forEach 메서드</h3><p><em>Map</em>에 대한 <code>forEach()</code> 메서드는 세 개의 파라미터를 받는 콜백 함수를 허용한다는 점에서 <em>Set</em> 및 <em>Array</em>의 <code>forEach()</code>와 유사합니다.</p>
<ol>
<li><em>Map</em>의 다음 위치 값</li>
<li>그 값의 키</li>
<li>값을 읽는 <em>Map</em></li>
</ol>
<p>이러한 콜백 파라미터는 첫 번째 파라미터가 값이고 두 번째 파라미터가 키 (<em>Array</em>의 숫자 인덱스에 해당) 인 <em>Array</em>의 forEach () 동작과 비슷합니다. 다음은 그 예입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([ [<span class="string">"name"</span>, <span class="string">"Nicholas"</span>], [<span class="string">"age"</span>, <span class="number">25</span>]]);</div><div class="line"></div><div class="line">map.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value, key, ownerMap</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(key + <span class="string">" "</span> + value);</div><div class="line">    <span class="built_in">console</span>.log(ownerMap === map);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><code>forEach()</code> 콜백 함수는 전달된 정보를 출력합니다. <code>value</code>와 <code>key</code>는 직접 출력되고, <code>ownerMap</code>은 <code>map</code>과 비교되어 값이 동일 함을 보여줍니다. 결과는 다음과 같습니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">name Nicholas</div><div class="line">true</div><div class="line">age 25</div><div class="line">true</div></pre></td></tr></table></figure>
<p><code>forEach()</code>에 전달된 콜백은 <em>Map</em>에 삽입된 순서대로 각 키-값 쌍을 받습니다. 이 동작은 콜백이 숫자 인덱스 순서대로 각 항목을 받는 <em>Array</em>의 <code>forEach()</code>가 호출되는 것과 약간 다릅니다.</p>
<blockquote>
<p><code>forEach()</code>에 두 번째 파라미터를 제공하여 콜백 함수 내에서 <code>this</code> 값을 지정할 수도 있습니다. 이와 같은 호출은 <em>Set</em> 버전의<br> <code>forEach()</code> 메서드와 동일하게 작동합니다.</p>
</blockquote>
<h3 id="Weak-Map"><a href="#Weak-Map" class="headerlink" title="Weak Map"></a>Weak Map</h3><p><em>Weak Map</em>은 약한 객체 참조를 저장하는 방법입니다. <em>Weak Map</em>에서는 모든 키가 객체여야 하며 (객체가 아닌 키를 사용하려고하면 오류가 발생 함) 이러한 객체 참조는 가비지 컬랙트를 방해하지 않도록 약하게 유지됩니다. <em>Weak Map</em> 외부의 키에 대한 참조가 없으면 <em>Weak Map</em>에서 키-값 쌍이 제거됩니다.</p>
<p><em>Weak Map</em>을 사용하는 가장 유용한 장소는 웹 페이지의 특정 DOM 엘리먼트와 관련된 객체를 만드는 경우입니다. 예를 들어 웹 페이지용 JavaScript 라이브러리 중 일부는 라이브러리에서 참조하는 모든 DOM 엘리먼트에 대해 특정 사용자 정의 객체를 유지하고 해당 매핑은 내부적으로 객체 캐시에 저장됩니다.</p>
<p>이 접근법의 어려운 부분은 DOM 엘리먼트가 웹 페이지에 더 이상 존재하지 않아 라이브러리가 관련 객체를 제거할 수 없을 때를 결정하는 것입니다. 그렇지 않으면 라이브러리가 참조 엘리먼트의 유용성을 넘어 DOM 엘리먼트 참조를 유지하고 메모리 누수가 발생합니다. <em>Weak Map</em>으로 DOM 엘리먼트를 추적하면 라이브러리가 모든 DOM 엘리먼트와 객체를 연결할 수 있으며 해당 객체의 DOM 엘러먼트가 더 이상 존재하지 않으면 <em>Map</em>의 객체를 자동으로 삭제할 수 있습니다.</p>
<blockquote>
<p><em>Weak Map</em> 값이 아닌 <em>Weak Map</em> 키만 약한 참조임을 유의해야합니다. <em>Weak Map</em> 값으로 저장된 오브젝트는 다른 모든 참조가 제거되어도 가비지 콜렉션 대상이 아닙니다.</p>
</blockquote>
<h4 id="Weak-Map-사용하기"><a href="#Weak-Map-사용하기" class="headerlink" title="Weak Map 사용하기"></a><em>Weak Map</em> 사용하기</h4><p>ECMAScript 6 <code>WeakMap</code> 타입은 키와 값 쌍의 정렬되지 않은 목록입니다. 여기서 키는 <code>null</code>이 아닌 객체여야 하며 값은 모든 타입이 될 수 있습니다. <code>WeakMap</code>은 <code>set()</code>과 <code>get()</code>이 각각 데이터를 추가하고 검색하는 데 사용된다는 점에서 <em>Map</em>의 인터페이스와 매우 유사합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">WeakMap</span>(),</div><div class="line">    element = <span class="built_in">document</span>.querySelector(<span class="string">".element"</span>);</div><div class="line"></div><div class="line">map.set(element, <span class="string">"Original"</span>);</div><div class="line"></div><div class="line"><span class="keyword">let</span> value = map.get(element);</div><div class="line"><span class="built_in">console</span>.log(value);             <span class="comment">// "Original"</span></div><div class="line"></div><div class="line"><span class="comment">// remove the element</span></div><div class="line">element.parentNode.removeChild(element);</div><div class="line">element = <span class="literal">null</span>;</div><div class="line"></div><div class="line"><span class="comment">// the weak map is empty at this point</span></div></pre></td></tr></table></figure>
<p>이 예제는 키-값 쌍 하나가 저장됩니다. <code>element</code> 키는 해당 문자열 값을 저장하는 데 사용되는 DOM 엘리먼트입니다. 그 값은 DOM 엘레멘트를 <code>get()</code> 메서드에 전달해서 얻습니다. 나중에 DOM 엘리먼트가 Document에서 제거되고 이를 참조하는 변수가 <code>null</code>로 설정되면 데이터도 <em>Weak Map</em>에서 제거됩니다.</p>
<p><em>Weak Set</em>과 마찬가지로 <code>size</code> 프로퍼티가 없기 때문에 <em>Weak Map</em>이 비어 있는지 확인할 방법이 없습니다. 키에 대한 참조가 남아 있지 않으므로 <code>get()</code> 메서드를 호출하여 값을 검색할 수 없습니다. <em>Weak Map</em>은 그 키에 대한 값의 액세스를 차단하고, 가비지 컬렉터가 실행될 때 값으로 점유된 메모리는 해제됩니다.</p>
<h4 id="Weak-Map-초기화"><a href="#Weak-Map-초기화" class="headerlink" title="Weak Map 초기화"></a><em>Weak Map</em> 초기화</h4><p><em>Weak Map</em>을 초기화하려면 <code>WeakMap</code> 생성자에 <em>Array</em>의 <em>Array</em>를 전달합니다. 일반 <em>Map</em>을 초기화하는 것처럼 포함하는 <em>Array</em>의 각 <em>Array</em>에는 두 개의 항목이 있어야합니다. 첫 번째 항목은 <code>null</code>이 아닌 객체 키이고 두 번째 항목은 값 (모든 데이터 유형)입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> key1 = &#123;&#125;,</div><div class="line">    key2 = &#123;&#125;,</div><div class="line">    map = <span class="keyword">new</span> <span class="built_in">WeakMap</span>([[key1, <span class="string">"Hello"</span>], [key2, <span class="number">42</span>]]);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(map.has(key1));     <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(map.get(key1));     <span class="comment">// "Hello"</span></div><div class="line"><span class="built_in">console</span>.log(map.has(key2));     <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(map.get(key2));     <span class="comment">// 42</span></div></pre></td></tr></table></figure>
<p><code>key1</code> 및 <code>key2</code> 객체는 <em>Weak Map</em>에서 키로 사용되며 <code>get()</code> 및 <code>has()</code> 메서드를 통해 해당 객체에 액세스할 수 있습니다. <code>WeakMap</code> 생성자가 어떤 키-값 쌍에서 객체가 아닌 키를 받으면 오류가 발생합니다.</p>
<h4 id="Weak-Map-메서드"><a href="#Weak-Map-메서드" class="headerlink" title="Weak Map 메서드"></a><em>Weak Map</em> 메서드</h4><p><em>Weak Map</em>에는 키-값 쌍과 상호 작용할 수있는 두 가지 추가 방법이 있습니다. 특정 키가 <em>Map</em>에 있는지 확인하는 <code>has()</code> 메소드와 특정 키-값 쌍을 제거하는 <code>delete()</code> 메소드가 있습니다. <em>Weak Map</em>에서는 <em>Weak Set</em> 처럼 키를 열거하는 것이 불가능 하기 때문에 <code>clear()</code> 메서드가 없습니다. 아래 예제에서는 <code>has()</code> 및 <code>delete()</code> 메서드를 모두 사용합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">WeakMap</span>(),</div><div class="line">    element = <span class="built_in">document</span>.querySelector(<span class="string">".element"</span>);</div><div class="line"></div><div class="line">map.set(element, <span class="string">"Original"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(map.has(element));   <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(map.get(element));   <span class="comment">// "Original"</span></div><div class="line"></div><div class="line">map.delete(element);</div><div class="line"><span class="built_in">console</span>.log(map.has(element));   <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log(map.get(element));   <span class="comment">// undefined</span></div></pre></td></tr></table></figure>
<p>위 예제에서 DOM 엘리먼트를 <em>Weak Map</em>에서 키로 사용됩니다. <code>has()</code> 메서드는 참조가 현재 <em>Weak Map</em>에서 키로 사용되고 있는지 확인하는 데 유용합니다. 이것은 키에 대한 <code>null</code>이 아닌 참조가 있는 경우에만 작동한다는 점에 유의하십시오. 키는 <code>delete()</code> 메서드에 의해 <em>Weak Map</em>에서 강제로 제거됩니다. 그리고 <code>has()</code>는 false를 반환하고 <code>get()</code>은 <code>undefined</code>를 반환합니다.</p>
<h4 id="Private-Object-Data"><a href="#Private-Object-Data" class="headerlink" title="Private Object Data"></a>Private Object Data</h4><p>대부분의 개발자는 <em>Weak Map</em>의 주요 유스 케이스가 DOM 엘리먼트와 관련된 데이터라고 생각하지만 다른 많은 용도가 있습니다 (의심의 여지가 있지만 아직 발견되지 않은 것). <em>Weak Map</em>을 실제로 사용하는 한 가지 방법은 객체 인스턴스에 <em>Private</em> 데이터를 저장하는 것입니다. ECMAScript 6에서는 모든 객체 프로퍼티가 <code>public</code>이므로 객체에 액세스할 수있는 데이터를 만들려면 창의력을 사용해야하지만 모든 객체에 액세스할 수는 없습니다 다음 예제를 살펴 보겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>._name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._name;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>이 코드는 일반적인 규칙인 선행 밑줄을 사용하였기 때문에 프로퍼티가 <em>Private</em>으로 간주되므로 객체 인스턴스 외부에서 수정하면 안됩니다. 의도는 <code>getName()</code>을 사용하여 <code>this._name</code>을 읽고 <code>_name</code> 값을 변경하지 못하게하는 것입니다. 그러나 <code>_name</code> 프로퍼티를 작성하는 사람은 의도적으로 또는 실수로 덮어 쓸 수 있습니다.</p>
<p>ECMAScript 5에서는 다음과 같은 패턴을 사용하여 객체를 생성하여 진정한 <em>Private</em> 데이터를 가질 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Person = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> privateData = &#123;&#125;,</div><div class="line">        privateId = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">        <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>, <span class="string">"_id"</span>, &#123; <span class="attr">value</span>: privateId++ &#125;);</div><div class="line"></div><div class="line">        privateData[<span class="keyword">this</span>._id] = &#123;</div><div class="line">            <span class="attr">name</span>: name</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> privateData[<span class="keyword">this</span>._id].name;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> Person;</div><div class="line">&#125;());</div></pre></td></tr></table></figure>
<p>이 예제는 두 개의 <em>Private</em> 변수 인 <code>privateData</code>와 <code>privateId</code>를 포함하는 IIFE에 <code>Person</code>의 정의를 래핑합니다. <code>privateData</code> 객체는 각 인스턴스에 대한 개인 정보를 저장하는 반면 <code>privateId</code>는 각 인스턴스에 대해 고유 한 ID를 생성하는데 사용됩니다. <code>Person</code> 생성자가 호출 될 때, nonumerable, nonconfigurable, 그리고 nonwritable  <code>_id</code> 프로퍼티가 추가됩니다.</p>
<p>그런 다음 객체 인스턴스의 ID에 해당하는 <code>privateData</code> 객체에 항목이 만들어지고 그 이름이 저장됩니다. 나중에 <code>getName()</code> 함수에서 <code>this._id</code>를 <code>privateData</code>의 키로 사용하여 이름을 검색할 수 있습니다.  <code>privateData</code>는 IIFE 외부에서 접근할 수 없으므로<br> <code>this._id</code>가 공개 되어도 실제 데이터는 안전합니다.</p>
<p>이 접근법의 가장 큰 문제점은 객체 인스턴스가 언제 파괴되는지를 알 수 없기 때문에 <code>privateData</code>의 데이터가 사라지지 않는다는 것입니다. <code>privateData</code> 객체는 항상 여분의 데이터를 포함합니다. 이 문제는 다음과 같이 <em>Weak Map</em>을 대신 사용하여 해결할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> Person = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> privateData = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">        privateData.set(<span class="keyword">this</span>, &#123; <span class="attr">name</span>: name &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> privateData.get(<span class="keyword">this</span>).name;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> Person;</div><div class="line">&#125;());</div></pre></td></tr></table></figure>
<p>이 버전의 <code>Person</code> 예제는 객체가 아닌 <em>Private</em> 데이터용 <em>Weak Map</em>을 사용합니다. <code>Person</code> 객체 인스턴스 자체를 키로 사용할 수 있기 때문에 별도의 ID를 추적할 필요가 없습니다. <code>Person</code> 생성자가 호출되면 weak 필드에 <code>this</code>키와 개인 정보가 들어있는 객체의 값을 가진 새로운 항목이 만들어집니다. 이 경우 값은 <code>name</code>만 포함하는 객체입니다. <code>getName()</code> 함수는 <code>privateData.get()</code> 메소드에 <code>this</code>를 전달하여 해당 개인 정보를 검색합니다. <code>privateData.get()</code> 메소드는 값 객체를 입력받아 <code>name</code> 프로퍼티에 액세스합니다. 이 기법은 개인 정보를 비공개로 유지하고, 관련 정보가 파괴될 때마다 정보도 파괴됩니다.</p>
<h4 id="Weak-Map-사용-및-제한-사항"><a href="#Weak-Map-사용-및-제한-사항" class="headerlink" title="Weak Map 사용 및 제한 사항"></a><em>Weak Map</em> 사용 및 제한 사항</h4><p><em>Weak Map</em> 또는 일반 <em>Map</em>을 사용할지 여부를 결정할 때 고려해야 할 기본 결정은 객체 키만 사용할지 여부입니다. 언제든지 객체 키만 사용하려고 할 때 가장 좋은 선택은 <em>Weak map</em>입니다. 이렇게하면 여분의 데이터는 더이상 유지되지 않고 액세스할 수 없어 메모리 사용을 최적화하고 메모리 누수를 피할 수 있습니다.</p>
<p><em>Weak Map</em>은 내용을 거의 볼 수 없으므로 <code>forEach()</code> 메서드, <code>size</code> 프로퍼티 또는 <code>clear()</code> 메서드를 사용하여 항목을 관리할 수 없습니다. 몇 가지 검사 기능이 필요한 경우 일반 <em>Map</em>을 사용하는 것이 좋습니다. 메모리 사용을 주시하십시오.</p>
<p>물론 객체가 아닌 키만 사용하려는 경우 일반 <em>Map</em>만 선택할 수 있습니다.</p>
<h2 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h2><p>ECMAScript 6은 정식으로 <em>Set</em>과 <em>Map</em>을 JavaScript에 도입했습니다. 이전에는 개발자가 객체를 사용하여 <em>Set</em>과 <em>Map</em>을 모방하는 경우가 많았습니다. 하지만 객체 프로퍼티와 관련된 제한으로 인해 종종 문제가 발생했습니다.</p>
<p><em>Set</em>은 고유한 값의 정렬된 목록입니다. 같은지 여부를 판별하는 값을 가지고 있지 않습니다. <em>Set</em>는 중복값을 자동으로 제거하므로 <em>Set</em>을 사용하여 <em>Array</em>의 중복된 값을 필터링하고 결과를 반환할 수 있습니다. <em>Set</em>은 <em>Array</em>의 하위 클래스가 아니므로 <em>Set</em>의 값에 임의로 액세스할 수는 없습니다. 대신 <code>has()</code> 메서드를 사용하여 값이 <em>Set</em>에 포함되어 있는지 확인하고 <em>Set</em>의 개수를 알려주는 <code>size</code> 프로퍼티를 사용할 수 있습니다. <code>Set</code> 타입은 각 값을 처리하기 위한 <code>forEach()</code> 메서드를 가지고 있습니다.</p>
<p><em>Weak Set</em>은 객체만 포함할 수있는 특수 <em>Set</em>입니다. 해당 객체는 약한 참조로 저장됩니다. 즉, <em>Weak Set</em>의 항목은 해당 항목이 객체에 대한 유일한 참조인 경우 가비지 컬렉트 대상이 됩니다. <em>Weak Set</em> 내용은 메모리 관리의 복잡성 때문에 검사할 수 없으므로 함께 그룹화 해야하는 객체 추적에만 <em>Weak Set</em>를 사용하는 것이 가장 좋습니다.</p>
<p><em>Map</em>은 정렬된 키-값 쌍입니다. 여기서 키는 모든 데이터 타입이 될 수 있습니다. <em>Set</em>과 마찬가지로 키는 같음여부를 판별하기 위해 강제변환이 실행되지 않으므로 숫자 키 <code>5</code>와 문자열 <code>&quot;5&quot;</code>를 별개의 두 개의 키로 가질 수 있습니다. 모든 데이터 타입의 값은 <code>set()</code> 메서드를 사용하여 키의 값이 될수 있으며, 그 값은 나중에 <code>get()</code> 메소드를 사용하여 검색할 수 있습니다. <em>Map</em>에는 <code>size</code> 프로퍼티와 <code>forEach()</code> 메서드가 있어 보다 쉽게 항목에 액세스할 수 있습니다.</p>
<p><em>Weak Map</em>은 객체 키만 가질 수있는 특별한 타입의 <em>Map</em>입니다. <em>Weak Set</em>과 마찬가지로 객체 키 참조는 약하며 객체에 대한 유일하게 남아있는 참조인 경우 가비지 컬렉트 대상이 됩니다. 키가 가비지 컬렉트되면 키와 연관된 값도 <em>Weak Map</em>에서 제거됩니다. 이 메모리 관리 측면은 추가 정보를 액세스하는 코드 외부에서 라이프사이클이 관리되는 구조에 <em>Weak Map</em>이 적합합니다.</p>
<hr>
<blockquote>
<p>이 내용은 나중에 참고하기 위해 제가 공부하며 정리한 내용입니다.<br>의역, 오역, 직역이 있을 수 있음을 알려드립니다.<br>This post is a translation of this original article [<a href="https://leanpub.com/understandinges6/read#leanpub-auto-sets-and-maps" target="_blank" rel="external">https://leanpub.com/understandinges6/read#leanpub-auto-sets-and-maps</a>]</p>
</blockquote>
<h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul>
<li><a href="https://infoscis.github.io/2018/01/24/ecmascript-6-block-binding/">ECMAScript 6 Block Binding</a></li>
<li><a href="https://infoscis.github.io/2018/01/24/ecmascript-6-strings-and-regular-expressions/">ECMAScript 6 문자열과 정규 표현식</a></li>
<li><a href="https://infoscis.github.io/2018/01/24/ecmascript-6-functions/">ECMAScript 6 함수</a></li>
<li><a href="https://infoscis.github.io/2018/01/25/ecmascript-6-expanded-object-functionality/">ECMAScript 6 객체의 확장된 기능</a></li>
<li><a href="https://infoscis.github.io/2018/01/26/ecmascript-6-destructuring-for-easier-data-access/">ECMAScript 6 쉬운 데이터 액세스를 위한 Destructuring</a></li>
<li><a href="https://infoscis.github.io/2018/01/27/ecmascript-6-symbols-and-symbol-properties/">ECMAScript 6 Symbol과 Symbol 프로퍼티</a></li>
<li><a href="https://infoscis.github.io/2018/01/27/ecmascript-6-sets-and-maps/">ECMAScript 6 Set과 Map</a></li>
<li><a href="https://infoscis.github.io/2018/01/31/ecmascript-6-iterators-and-generators/">ECMAScript 6 Iterator와 Generator</a></li>
<li><a href="https://infoscis.github.io/2018/02/13/ecmascript-6-introducing-javascript-classes/">ECMAScript 6 JavaScript 클래스 소개</a></li>
<li><a href="https://infoscis.github.io/2018/02/13/ecmascript-6-improved-array-capabilities/">ECMAScript 6 Array 기능 향상</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-promises-and-asynchronous-programming/">ECMAScript 6 Promise와 비동기 프로그램밍</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-proxies-and-the-reflection-api/">ECMAScript 6 프록시와 리플렉션 API</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-encapsulating-code-with-modules/">ECMAScript 6 Module로 코드 캡슐화하기</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-appendix-a-smaller-changes/">ECMAScript 6 부록 A. 작은 변경 사항</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-appendix-b-understanding-ecmascript-7/">ECMAScript 6 부록 B. ECMAScript 7(2016) 이해하기</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Set과-Map&quot;&gt;&lt;a href=&quot;#Set과-Map&quot; class=&quot;headerlink&quot; title=&quot;Set과 Map&quot;&gt;&lt;/a&gt;Set과 Map&lt;/h1&gt;&lt;p&gt;JavaScript의 역사에서 컬렉션 타입은 &lt;em&gt;Array&lt;/em&gt; 타입 하나만
    
    </summary>
    
      <category term="JavaScript" scheme="http://infoscis.github.io/categories/JavaScript/"/>
    
      <category term="ECMAScript 2015" scheme="http://infoscis.github.io/categories/JavaScript/ECMAScript-2015/"/>
    
    
      <category term="JavaScript" scheme="http://infoscis.github.io/tags/JavaScript/"/>
    
      <category term="ECMAScript 2015" scheme="http://infoscis.github.io/tags/ECMAScript-2015/"/>
    
  </entry>
  
  <entry>
    <title>ECMAScript 6 Symbol과 Symbol 프로퍼티</title>
    <link href="http://infoscis.github.io/2018/01/27/ecmascript-6-symbols-and-symbol-properties/"/>
    <id>http://infoscis.github.io/2018/01/27/ecmascript-6-symbols-and-symbol-properties/</id>
    <published>2018-01-27T14:08:05.000Z</published>
    <updated>2018-02-27T14:12:27.117Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Symbols과-Symbol-프로퍼티"><a href="#Symbols과-Symbol-프로퍼티" class="headerlink" title="Symbols과 Symbol 프로퍼티"></a>Symbols과 Symbol 프로퍼티</h1><p><em>Symbol</em>은 ECMAScript 6에서 도입된 Primitive 타입으로, 기존의 <code>string</code>, <code>number</code>, <code>boolean</code>, <code>null</code>, <code>undefined</code>와 같은 타입입니다. <em>Symbol</em>은 객체의 <em>Private</em> 멤버를 생성하는 방법으로 시작되었는데, JavaScript 개발자들이 오랫동안 원했던 기능입니다. <em>Symbol</em> 이전에는 이름이 있는 프로퍼티는 이름의 모호함에 관계없이 쉽게 액세스할 수 있었고 <em>Private name</em> 기능은 개발자가 문자열이 아닌 프로퍼티 이름을 만들 수 있도록 하기위한 것입니다. 그리고 일반적인 방법으로 <em>Private name</em>에 대한 탐지는 작동하지 않습니다.</p>
<p><em>Private name</em>에 대한 제안은 마침내 ECMAScript 6 <em>Symbol</em>로 진화했습니다. 이장에서는 <em>Symbol</em>을 효과적으로 사용하는 법을 가르쳐줄 것입니다. 구현 세부 사항은 동일하게 유지되었지만 (즉, 프로퍼티 이름에 문자열이 아닌 값을 추가 한 경우) <em>Privacy</em>에 대한 부분은 삭제되었습니다. 대신 <em>Symbol</em> 프로퍼티는 다른 객체 프로퍼티와 구분되어 분류됩니다.</p>
<h2 id="Symbol-생성하기"><a href="#Symbol-생성하기" class="headerlink" title="Symbol 생성하기"></a>Symbol 생성하기</h2><p><em>Symbol</em>은 JavaScript Primitive 중, boolean은 <code>true</code>, number는 <code>42</code>와 같은 리터럴이 없는 유일한 타입니다. 아래 예제와 같이 전역<code>Symbol</code> 함수를 사용하여 <em>Symbol</em>을 만들 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> firstName = <span class="built_in">Symbol</span>();</div><div class="line"><span class="keyword">let</span> person = &#123;&#125;;</div><div class="line"></div><div class="line">person[firstName] = <span class="string">"Nicholas"</span>;</div><div class="line"><span class="built_in">console</span>.log(person[firstName]);     <span class="comment">// "Nicholas"</span></div></pre></td></tr></table></figure>
<p>위 예제의 <em>Symbol</em> <code>firstName</code>은 <code>person</code> 객체에 새로운 프로퍼티를 할당하기 위해 만들어지고 사용됩니다. 이 <em>Symbol</em>은 동일한 프로퍼티에 액세스할 때마다 사용 해야합니다. <em>Symbol</em> 변수에 적절한 이름을 부여하는 것은 좋은 생각입니다. <em>Symbol</em>이 무엇을 나타내는지 쉽게 알 수 있기 때문입니다.</p>
<blockquote>
<p><em>Symbol</em>은 Primitive이기 때문에 <code>new Symbol()</code>을 호출하면 오류가 발생합니다. <code>Symbol</code>의 인스턴스를 <code>new Object (yourSymbol)</code>을 통해서 만들 수도 있습니다. 하지만 이 기능이 그렇게 유용하지 않습니다.</p>
</blockquote>
<p><code>Symbol</code> 함수는 <em>Symbol</em>에 대한 설명을 위해 <em>Optional</em> 파라미터도 받아들입니다. 설명 자체는 프로퍼티에 액세스하는데 사용할 수 없지만 디버깅 목적으로 사용될 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> firstName = <span class="built_in">Symbol</span>(<span class="string">"first name"</span>);</div><div class="line"><span class="keyword">let</span> person = &#123;&#125;;</div><div class="line"></div><div class="line">person[firstName] = <span class="string">"Nicholas"</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"first name"</span> <span class="keyword">in</span> person);        <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log(person[firstName]);             <span class="comment">// "Nicholas"</span></div><div class="line"><span class="built_in">console</span>.log(firstName);                     <span class="comment">// "Symbol(first name)"</span></div></pre></td></tr></table></figure>
<p><em>Symbol</em>의 설명은 내부적으로 <code>[[Description]]</code> 프로퍼티에 저장됩니다. 이 프로퍼티는 <em>Symbol</em>의 <code>toString()</code> 메서드가 명시적으로 또는 암시적으로 호출될 때마다 읽혀집니다. <code>firstName</code> <em>Symbol</em>의 <code>toString()</code> 메서드는 이 예제에서 <code>console.log()</code>에 의해 암시적으로 호출되므로 설명이 log에 출력됩니다. 코드에서 직접 <code>[[Description]]</code>에 액세스할 수 없습니다. 필자는 항상 <em>Symbol</em>을 읽고 디버깅하기 쉽도록 설명을 제공할 것을 권장합니다.</p>
<h3 id="Symbol-식별하기"><a href="#Symbol-식별하기" class="headerlink" title="Symbol 식별하기"></a>Symbol 식별하기</h3><p><em>Symbol</em>은 Primitive이기 때문에 <code>typeof</code> 연산자를 사용하여 변수에 <em>Symbol</em>이 포함되어 있는지 확인할 수 있습니다. ECMAScript 6은 <code>typeof</code>를 확장하여 <em>Symbol</em>에 사용될 때 <code>&quot;symbol&quot;</code>을 반환하도록 합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> symbol = <span class="built_in">Symbol</span>(<span class="string">"test symbol"</span>);</div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> symbol);         <span class="comment">// "symbol"</span></div></pre></td></tr></table></figure>
<p>변수가 <em>Symbol</em>인지 여부를 결정하는 다른 간접적인 방법이 있지만 <code>typeof</code> 연산자가 가장 정확하고 선호되는 기술입니다.</p>
<h2 id="Symbol-사용하기"><a href="#Symbol-사용하기" class="headerlink" title="Symbol 사용하기"></a>Symbol 사용하기</h2><p>계산된 프로퍼티 이름을 사용하는 곳이면 어디에서나 <em>Symbol</em>을 사용할 수 있습니다. 이장에서 <em>Symbol</em> 과 함께 사용된 괄호 표기법을 이미 보았지만 아래의 호출과 같이 <code>Object.defineProperty()</code>와 <code>Object.defineProperties()</code>뿐만 아니라 계산된 객체 리터럴 프로퍼티 이름에서도 <em>Symbol</em>을 사용할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> firstName = <span class="built_in">Symbol</span>(<span class="string">"first name"</span>);</div><div class="line"></div><div class="line"><span class="comment">// 계산된 객체 리터럴 프로퍼티 사용</span></div><div class="line"><span class="keyword">let</span> person = &#123;</div><div class="line">    [firstName]: <span class="string">"Nicholas"</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 프로퍼티를 읽기전용으로 만듭니다.</span></div><div class="line"><span class="built_in">Object</span>.defineProperty(person, firstName, &#123; <span class="attr">writable</span>: <span class="literal">false</span> &#125;);</div><div class="line"></div><div class="line"><span class="keyword">let</span> lastName = <span class="built_in">Symbol</span>(<span class="string">"last name"</span>);</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.defineProperties(person, &#123;</div><div class="line">    [lastName]: &#123;</div><div class="line">        <span class="attr">value</span>: <span class="string">"Zakas"</span>,</div><div class="line">        <span class="attr">writable</span>: <span class="literal">false</span></div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person[firstName]);     <span class="comment">// "Nicholas"</span></div><div class="line"><span class="built_in">console</span>.log(person[lastName]);      <span class="comment">// "Zakas"</span></div></pre></td></tr></table></figure>
<p>위 예제는 먼저 계산된 객체 리터럴 프로퍼티를 사용하여 <code>firstName</code> <em>Symbol</em> 프로퍼티를 만듭니다. 그 다음 라인은 프로퍼티를 읽기 전용으로 설정합니다. 그후에, <code>Object.defineProperties()</code> 메서드를 사용하여 읽기 전용 <code>lastName</code> <em>Symbol</em> 프로퍼티를 생성합니다. 계산된 객체 리터럴 프로퍼티가 다시 한번 사용되지만 <code>Object.defineProperties()</code> 호출의 두 번째 파라미터의 일부입니다.</p>
<p><em>Symbol은 계산된 프로퍼티 이름이 허용되는 곳이면 어디에서나 사용할 수 있지만, 효과적으로 사용할 수 있도록 이들 </em>Symbol*을 다른 코드 사이에서 공유할 수있는 시스템이 필요합니다.</p>
<h2 id="Symbol-공유하기"><a href="#Symbol-공유하기" class="headerlink" title="Symbol 공유하기"></a>Symbol 공유하기</h2><p>여러분은 코드의 다른 부분에서 같은 <em>Symbol</em>을 사용하기 원할 수도 있습니다. 예를 들어, 응용 프로그램에서 고유 식별자를 나타내기 위해 동일한 <em>Symbol</em> 프로퍼티를 사용해야하는 두개의 다른 객체 타입이 있다고 가정하겠습니다. 파일이나 큰 코드베이스에서 <em>Symbol</em>을 추적하는 것은 어렵고 오류가 발생할 수 있습니다. 그래서 ECMAScript 6는 어느 시점에서나 액세스할 수 있는 전역 <em>Symbol</em> 레지스트리를 제공합니다.</p>
<p>공유할 <em>Symbol</em>을 생성하려면 <code>Symbol()</code> 메서드를 호출하는 대신 <code>Symbol.for()</code> 메서드를 사용합니다. <code>Symbol.for()</code> 메서드는 여러분이 생성하고자하는 <em>Symbol</em>을 위한 문자열 식별자로 단일 파라미터를 받아들입니다. 그리고 이 파라미터는 <em>Symbol</em>의 설명으로도 사용됩니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> uid = <span class="built_in">Symbol</span>.for(<span class="string">"uid"</span>);</div><div class="line"><span class="keyword">let</span> object = &#123;&#125;;</div><div class="line"></div><div class="line">object[uid] = <span class="string">"12345"</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(object[uid]);       <span class="comment">// "12345"</span></div><div class="line"><span class="built_in">console</span>.log(uid);               <span class="comment">// "Symbol(uid)"</span></div></pre></td></tr></table></figure>
<p><code>Symbol.for()</code> 메서드는 먼저 전역 <em>Symbol</em> 레지스트리를 검색하여 “uid” 키가 있는 <em>Symbol</em>이 있는지 확인합니다. 만약 <em>Symbol</em>이 있다면 이 메서드는 기존의 <em>Symbol</em>을 리턴합니다. 그런데 만약 없다면 새로운 <em>Symbol</em>을 생성하고 지정된 키를 사용하여 전역 <em>Symbol</em> 레지스트리에 등록합니다. 그리고 새로운 <em>Symbol</em>을 리턴합니다. 즉, 같은 키를 사용하는 <code>Symbol.for()</code>에 대한 후속 호출은 다음과 같이 동일한 <em>Symbol</em>을 반환합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> uid = <span class="built_in">Symbol</span>.for(<span class="string">"uid"</span>);</div><div class="line"><span class="keyword">let</span> object = &#123;</div><div class="line">    [uid]: <span class="string">"12345"</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(object[uid]);       <span class="comment">// "12345"</span></div><div class="line"><span class="built_in">console</span>.log(uid);               <span class="comment">// "Symbol(uid)"</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> uid2 = <span class="built_in">Symbol</span>.for(<span class="string">"uid"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(uid === uid2);      <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(object[uid2]);      <span class="comment">// "12345"</span></div><div class="line"><span class="built_in">console</span>.log(uid2);              <span class="comment">// "Symbol(uid)"</span></div></pre></td></tr></table></figure>
<p>위 예제에서 <code>uid</code>와 <code>uid2</code>는 같은 <em>Symbol</em>을 사용하고 있습니다. 그래서 서로 바꿔서 사용할 수도 있습니다. <code>Symbol.for()</code>에 대한 첫 번째 호출은 <em>Symbol</em>을 생성하고 두 번째 호출은 전역 <em>Symbol</em> 저장소에서 <em>Symbol</em>을 가져옵니다.</p>
<p>공유 <em>Symbol</em>의 또 다른 독특한 부분은 <code>Symbol.keyFor()</code> 메서드를 호출하여 전역 <em>Symbol</em> 레지스트리에서 <em>Symbol</em>과 연관된 키를 검색할 수 있다는 것입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> uid = <span class="built_in">Symbol</span>.for(<span class="string">"uid"</span>);</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.keyFor(uid));    <span class="comment">// "uid"</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> uid2 = <span class="built_in">Symbol</span>.for(<span class="string">"uid"</span>);</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.keyFor(uid2));   <span class="comment">// "uid"</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> uid3 = <span class="built_in">Symbol</span>(<span class="string">"uid"</span>);</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.keyFor(uid3));   <span class="comment">// undefined</span></div></pre></td></tr></table></figure>
<p><code>uid</code>와 <code>uid2</code>는 모두 “uid”키를 반환합니다. <em>Symbol</em> <code>uid3</code>은 전역 <em>Symbol</em> 레지스트리에 존재하지 않으므로, 관련된 키가 없으며<code>Symbol.keyFor()</code>는 <code>undefined</code>를 리턴합니다.</p>
<p>글로벌 <em>Symbol</em> 레지스트리는 글로벌 <em>Scope</em>와 같은 공유 환경입니다. 이는 해당 환경에 이미 존재하거나 존재하지 않는 것에 대해 가정할 수 없음을 의미합니다. 서드파티 컴포넌트를 사용할 때 충돌을 일으킬 가능성을 줄이기 위해 <em>Symbol</em> 키의 네임 스페이스를 사용할 수 있습니다. 예를 들어,<code>jQuery</code> 코드는 <code>&quot;jquery.element&quot;</code>또는 유사한 방법으로 모든 키에 <code>&quot;jquery.&quot;</code> 접두사를 사용할 수 있습니다.</p>
<h2 id="Symbol-강제-변환-Coercion"><a href="#Symbol-강제-변환-Coercion" class="headerlink" title="Symbol 강제 변환 (Coercion)"></a>Symbol 강제 변환 (Coercion)</h2><p>타입 강제 변환은 JavaScript의 중요한 부분이며, 한 데이터 타입을 다른 데이터 타입으로 강제 변환하는 것은 많은 유연성이 있습니다. 그러나 <em>Symbol</em>은 타입 강제 변환에 있어서는 꽤 융통성이 없습니다. 왜냐하면 다른 타입은 <em>Symbol</em>과 논리적으로 동등하지 않기 때문입니다. 특히 <em>Symbol</em>은 <code>string</code>이나 <code>number</code>로 강제 변환 될 수 없으므로 실수로 <em>Symbol</em>로 예상되는 프로퍼티에 다른 타입을 사용할 수 없습니다.</p>
<p>이 장에서는 <code>console.log()</code>를 사용하여 <em>Symbol</em>에 대한 결과를 보여줍니다. <code>console.log()</code>가 <em>Symbol</em>에 대해 <code>String()</code>을 호출하여 유용한 출력을 생성합니다. <code>String()</code>을 직접 사용해도 같은 결과를 얻을 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> uid = <span class="built_in">Symbol</span>.for(<span class="string">"uid"</span>),</div><div class="line">    desc = <span class="built_in">String</span>(uid);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(desc);              <span class="comment">// "Symbol(uid)"</span></div></pre></td></tr></table></figure>
<p><code>String()</code> 함수는 <code>uid.toString()</code>을 호출고 <em>Symbol</em>은 설명 문자열을 반환합니다. 그러나 <em>Symbol</em>을 문자열과 직접 연결하려고 하면 오류가 발생합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> uid = <span class="built_in">Symbol</span>.for(<span class="string">"uid"</span>),</div><div class="line">    desc = uid + <span class="string">""</span>;            <span class="comment">// error!</span></div></pre></td></tr></table></figure>
<p><code>uid</code>와 빈 문자열을 연결하려면 <code>uid</code>가 먼저 <code>string</code>으로 강제 변환 되어야합니다. JavaScript는 <em>Symbol</em>의 강제 변환이 발견되면 에러를 발생시킵니다. 비슷하게, <em>Symbol</em>을 <code>number</code>로 강제 변환할 수도 없습니다. 모든 수학 연산자가 <em>Symbol</em>에 적용될 때 오류를 발생시킵니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> uid = <span class="built_in">Symbol</span>.for(<span class="string">"uid"</span>),</div><div class="line">    sum = uid / <span class="number">1</span>;            <span class="comment">// error!</span></div></pre></td></tr></table></figure>
<p>이 예제는 <em>Symbol</em> 변수를 <code>1</code>로 나눕니다. 사용된 수학 연산자에 관계없이 모두 오류가 발생합니다. 하지만 논리 연산자는 JavaScript의 다른 비어 있지 않은 값과 마찬가지로 true와 동일한 것으로 간주되기 때문에 오류가 발생하지 않습니다.</p>
<h2 id="Symbol-프로퍼티-검색하기"><a href="#Symbol-프로퍼티-검색하기" class="headerlink" title="Symbol 프로퍼티 검색하기"></a>Symbol 프로퍼티 검색하기</h2><p><code>Object.keys()</code> 및 <code>Object.getOwnPropertyNames()</code> 메서드는 객체의 모든 프로퍼티 이름을 검색할 수 있습니다. 전자의 경우 열거 가능한 모든 프로퍼티 이름을 반환하고 후자는 열거 가능 여부에 관계없이 모든 프로퍼티를 반환합니다. 그러나 두 메서드 모두 ECMAScript 5 기능을 유지하기 위해 <em>Symbol</em> 프로퍼티를 반환하지 않습니다. 대신, 객체로부터 <em>Symbol</em> 프로퍼티를 검색할 수 있도록하기 위해 <code>Object.getOwnPropertySymbols()</code> 메서드가 ECMAScript 6에 추가되었습니다.</p>
<p><code>Object.getOwnPropertySymbols()</code>의 리턴 값은 자신의 <em>Symbol</em> 프로퍼티의 <em>Array</em>입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> uid = <span class="built_in">Symbol</span>.for(<span class="string">"uid"</span>);</div><div class="line"><span class="keyword">let</span> object = &#123;</div><div class="line">    [uid]: <span class="string">"12345"</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> symbols = <span class="built_in">Object</span>.getOwnPropertySymbols(object);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(symbols.length);        <span class="comment">// 1</span></div><div class="line"><span class="built_in">console</span>.log(symbols[<span class="number">0</span>]);            <span class="comment">// "Symbol(uid)"</span></div><div class="line"><span class="built_in">console</span>.log(object[symbols[<span class="number">0</span>]]);    <span class="comment">// "12345"</span></div></pre></td></tr></table></figure>
<p>이 코드에서 <code>object</code>는 <code>uid</code>라는 단일 <em>Symbol</em> 프로퍼티를 가지고 있습니다. <code>Object.getOwnPropertySymbols()</code>에서 반환된 <em>Array</em>은 <em>Symbol</em>을 포함하는 <em>Array</em>입니다.</p>
<p>모든 객체는 <code>0개</code>의 자체 <em>Symbol</em> 프로퍼티로 시작하지만 프로토타입에서 <em>Symbol</em> 프로퍼티를 상속받을 수 있습니다. ECMAScript 6는 <em>Well-known Symbol</em>이라고 불리는 미리 구현된 여러 프로퍼티를 정의합니다.</p>
<h2 id="Well-Known-Symbol을-이용한-내부-Operation-표현"><a href="#Well-Known-Symbol을-이용한-내부-Operation-표현" class="headerlink" title="Well-Known Symbol을 이용한 내부 Operation 표현"></a>Well-Known Symbol을 이용한 내부 Operation 표현</h2><p>ECMAScript 5의 핵심 테마는 JavaScript의 “magic” 부분 중 일부를 노출하고 정의하는 것이 었습니다. 이부분은 개발자가 Emulate할 수 없는 부분이었습니다. ECMAScript 6는 이전 버전 언어의 내부 논리를 더 많이 드러냄으로써 그 전통을 이어 나갔습니다. 주로 특정 객체의 기본 동작을 정의하기 위해 <em>Symbol</em> 프로토 타입 프로퍼티를 사용합니다.</p>
<p>ECMAScript 6에는 이전에 내부 전용 작업으로 간주되었던 JavaScript의 일반적인 동작을 나타내는 <em>Well-known Symbol</em>이라는 미리 정의된 <em>Symbol</em>이 있습니다. 각각의 <em>Well-known Symbol</em>은 <code>Symbol.create</code>와 같이 <code>Symbol</code> 객체의 프로퍼티로 표현됩니다.</p>
<p><em>Well-known Symbol</em>은 아래와 같습니다.</p>
<ul>
<li><code>Symbol.hasInstance</code> - 객체의 상속을 결정하기 위해 <code>instanceof</code>가 사용하는 메서드.</li>
<li><code>Symbol.isConcatSpreadable</code> - 컬렉션이 <code>Array.prototype.concat()</code>에 파라미터로 전달되면 <code>Array.prototype.concat()</code>이 컬렉션의 요소를 flat하게 해야한다는 것을 나타내는 boolean 값.</li>
<li><code>Symbol.iterator</code> - <em>Iterator</em>를 반환하는 메서드. (<em>Iterator</em>는 7 장에서 다룹니다.)</li>
<li><code>Symbol.match</code> - 문자열을 비교하기 위해 <code>String.prototype.match()</code>에 의해 사용되는 메서드.</li>
<li><code>Symbol.replace</code> - <code>String.prototype.replace()</code>가 substring을 치환하기 위해서 사용하는 메서드.</li>
<li><code>Symbol.search</code> - <code>String.prototype.search()</code>가 substring의 위치를 찾아 내기 위해서 사용하는 메서드.</li>
<li><code>Symbol.species</code> - 파생된(Derived) 객체를 만들기위한 생성자. (Derived 객체에 대해서는 8 장에서 다룹니다.)</li>
<li><code>Symbol.split</code> - 문자열을 분할하기 위해 <code>String.prototype.split()</code>에서 사용하는 메서드.</li>
<li><code>Symbol.toPrimitive</code> - 객체의 Primitive 값 표현을 반환하는 메서드.</li>
<li><code>Symbol.toStringTag</code> - Object 설명을 생성하기 위해서 <code>Object.prototype.toString()</code>에 의해 사용되는 문자열.</li>
<li><code>Symbol.unscopables</code> - <code>with</code> 문에 포함되어서는 안되는 프로퍼티가 객체 프로퍼티의 이름인 객체.</li>
</ul>
<p>흔히 사용되는 <em>Well-known Symbol</em>은 다음 절에서 논의하고 나머지는 책의 나머지 전체에서 논의합니다.</p>
<blockquote>
<p>정의된 메서드를 <em>Well-known Symbol</em>로 덮어 쓰는 것은 내부 객체를 외부 객체로 바꾸는 것입니다. 결과적으로 코드에 실제적인 영향은 없으며, 객체 사양을 설명하는 방식이 변경됩니다.</p>
</blockquote>
<h3 id="Symbol-hasInstance-프로퍼티"><a href="#Symbol-hasInstance-프로퍼티" class="headerlink" title="Symbol.hasInstance 프로퍼티"></a>Symbol.hasInstance 프로퍼티</h3><p>모든 함수는 주어진 객체가 그 함수의 인스턴스인지 아닌지를 결정하는 <code>Symbol.hasInstance</code> 메서드를 가지고 있습니다. 이 메서드는 <code>Function.prototype</code>에 정의되어 모든 함수가 <code>instanceof</code> 프로퍼티에 대한 기본 동작을 상속받으며 메서드는 쓰기가 불가능(nonwritable)하고 설정이 불가능(nonconfigurable)하고 열거가 불가능(nonenumerable)하여 실수로 덮어 쓸수 없습니다.</p>
<p><code>Symbol.hasInstance</code> 메서드는 하나의 파라미터, 즉 확인할 값만 받아들입니다. 전달된 값이 함수의 인스턴스이면 true를 반환합니다. <code>Symbol.hasInstance</code>가 어떻게 작동하는지 이해하기 위해 다음 코드를 살펴보겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">obj <span class="keyword">instanceof</span> <span class="built_in">Array</span>;</div></pre></td></tr></table></figure>
<p>이 코드는 다음과 같습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Array</span>[<span class="built_in">Symbol</span>.hasInstance](obj);</div></pre></td></tr></table></figure>
<p>ECMAScript 6은 근본적으로 <code>instanceof</code> 연산자를 메서드 호출의 축약 구문으로 재정의했습니다. 메서드 호출로 변경되었기 때문에 여러분이  실제로 <code>instanceof</code>가 어떻게 작동하는지 원하는데로 바꿀 수 있습니다.</p>
<p>예를 들어, 객체를 인스턴스로 요구하지 않는 함수를 정의한다고 가정합니다. <code>Symbol.hasInstance</code>의 반환 값을 <code>false</code>로 하드 코딩하면 다음과 같이할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyObject</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.defineProperty(MyObject, <span class="built_in">Symbol</span>.hasInstance, &#123;</div><div class="line">    <span class="attr">value</span>: <span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> MyObject();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(obj <span class="keyword">instanceof</span> MyObject);       <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p>쓰기가 불가능한(nonwritable) 프로퍼티를 덮어 쓰려면 <code>Object.defineProperty()</code>를 사용 해야합니다. 그래서 이 예제는 그 메서드를 사용하여<code>Symbol.hasInstance</code> 메서드를 새로운 함수로 덮어 씁니다. 새로운 함수는 항상 <code>false</code>를 반환하기 때문에 <code>obj</code>가 실제로 <code>MyObject</code> 클래스의 인스턴스이더라도 <code>instanceof</code> 연산자는 <code>Object.defineProperty()</code>호출 후에 <code>false</code>를 반환합니다.</p>
<p>물론 여러분은 값을 검사하고 임의의 조건을 기반으로 값을 인스턴스로 간주해야하는지 여부를 결정할 수도 있습니다. 예를 들어, 1과 100 사이의 값을 가진 숫자는 특별한 number 타입의 인스턴스로 간주됩니다. 이 동작을 수행하기 위해 다음과 같이 코드를 작성할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SpecialNumber</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// empty</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.defineProperty(SpecialNumber, <span class="built_in">Symbol</span>.hasInstance, &#123;</div><div class="line">    <span class="attr">value</span>: <span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> (v <span class="keyword">instanceof</span> <span class="built_in">Number</span>) &amp;&amp; (v &gt;=<span class="number">1</span> &amp;&amp; v &lt;= <span class="number">100</span>);</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">let</span> two = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">2</span>),</div><div class="line">    zero = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">0</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(two <span class="keyword">instanceof</span> SpecialNumber);    <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(zero <span class="keyword">instanceof</span> SpecialNumber);   <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p>이 코드는 값이 <code>Number</code>의 인스턴스이고 또한 1과 100 사이의 값을 가지면 <code>true</code>를 리턴하는 <code>Symbol.hasInstance</code> 메서드를 정의합니다. 따라서 <code>SpecialNumber</code> 함수와 <code>two</code> 변수 사이에 직접 정의된 관계가 없더라도 <code>SpecialNumber</code>는 <code>two</code>를 인스턴스로 요구합니다. <code>instanceof</code>의 왼쪽 피연산자는 <code>Symbol.hasInstance</code> 호출을 트리거하는 객체여야합니다. 왜냐하면 객체가 아니면 <code>instanceof</code>가 항상 단순히 <code>false</code>를 반환하도록 해야하기 때문입니다.</p>
<blockquote>
<p>또한 <code>Date</code>와 <code>Error</code> 함수와 같은 모든 내장 함수에 대한 기본 <code>Symbol.hasInstance</code> 프로퍼티을 덮어 쓸 수 있습니다. 그러나 코드에 미치는 영향이 예기치 않게 혼동될 수 있기 때문에 권장하지 않습니다. 자신의 함수에 대해서만 <code>Symbol.hasInstance</code>를 덮어 쓰는 것이 좋은 생각입니다.</p>
</blockquote>
<h3 id="Symbol-isConcatSpreadable-Symbol"><a href="#Symbol-isConcatSpreadable-Symbol" class="headerlink" title="Symbol.isConcatSpreadable Symbol"></a>Symbol.isConcatSpreadable Symbol</h3><p>JavaScript <em>Array</em>는 두개의 <em>Array</em>을 연결하기 위해 <code>concat()</code> 메서드를 가지고 있습니다. 다음 예제를 살펴 보겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> colors1 = [ <span class="string">"red"</span>, <span class="string">"green"</span> ],</div><div class="line">    colors2 = colors1.concat([ <span class="string">"blue"</span>, <span class="string">"black"</span> ]);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(colors2.length);    <span class="comment">// 4</span></div><div class="line"><span class="built_in">console</span>.log(colors2);           <span class="comment">// ["red","green","blue","black"]</span></div></pre></td></tr></table></figure>
<p>이 코드는 새로운 <em>Array</em>을 <code>colors1</code>의 끝에 연결하여 <code>colors2</code>를 생성합니다. 생성된 <em>Array</em>는 두 <em>Array</em>의 모든 항목을 갖는 <em>Array</em>입니다. 그러나 <code>concat()</code> 메서드는 <em>Array</em>이 아닌 파라미터도 받아 들일 수 있으며, 이 경우 그 파라미터는 단순히 <em>Array</em>의 끝에 추가됩니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> colors1 = [ <span class="string">"red"</span>, <span class="string">"green"</span> ],</div><div class="line">    colors2 = colors1.concat([ <span class="string">"blue"</span>, <span class="string">"black"</span> ], <span class="string">"brown"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(colors2.length);    <span class="comment">// 5</span></div><div class="line"><span class="built_in">console</span>.log(colors2);           <span class="comment">// ["red","green","blue","black","brown"]</span></div></pre></td></tr></table></figure>
<p>여기에서 여분의 파라미터 <code>&quot;brown&quot;</code>은 <code>concat()</code>에 전달되고 <code>colors2</code> <em>Array</em>의 다섯 번째 항목이됩니다. <em>Array</em> 파라미터가 문자열 파라미터와 다르게 취급되는 이유는 무엇일까요? JavaScript 사양에서는 <em>Array</em>가 자동으로 개별 항목으로 분리되고 다른 타입은 자동으로 분리되지 않는다고 말합니다. ECMAScript 6 이전에는 이 동작을 조정할 방법이 없었습니다.</p>
<p><code>Symbol.isConcatSpreadable</code> 프로퍼티는 객체가 length 프로퍼티와 숫자 키를 가지고 있으며 숫자 프로퍼티 값이 <code>concat()</code> 호출의 결과에 개별적으로 추가되어야 함을 나타내는 boolean 값입니다. 다른 <em>Well-known Symbol</em>과 달리 이 <em>Symbol</em> 프로퍼티는 기본적으로 표준 객체에 나타나지 않습니다. 대신 <em>Symbol</em>은 특정 타입의 객체에서 <code>concat()</code>이 어떻게 동작 하는지를 보완하는 방법으로 사용할 수 있어 기본 동작을 효과적으로 만듭니다. 다음과 같이 <em>Array</em>가 <code>concat()</code> 호출에서와 같이 동작하도록 모든 타입을 정의할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> collection = &#123;</div><div class="line">    <span class="number">0</span>: <span class="string">"Hello"</span>,</div><div class="line">    <span class="number">1</span>: <span class="string">"world"</span>,</div><div class="line">    <span class="attr">length</span>: <span class="number">2</span>,</div><div class="line">    [<span class="built_in">Symbol</span>.isConcatSpreadable]: <span class="literal">true</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> messages = [ <span class="string">"Hi"</span> ].concat(collection);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(messages.length);    <span class="comment">// 3</span></div><div class="line"><span class="built_in">console</span>.log(messages);           <span class="comment">// ["Hi","Hello","world"]</span></div></pre></td></tr></table></figure>
<p>이 예제의 <code>collection</code> 객체는 length 프로퍼티와 두 개의 숫자 키를 가지고 있어 <em>Array</em> 처럼 보이도록 설정되어 있습니다. <code>Symbol.isConcatSpreadable</code> 프로퍼티는 <code>true</code>로 설정되어 프로퍼티 값이 <em>Array</em>의 개별 항목으로 추가되어야 함을 나타냅니다. <code>collection</code>이 <code>concat()</code> 메서드에 전달 될 때, 결과 <em>Array</em>는 <code>&quot;Hello&quot;</code>와 <code>&quot;world&quot;</code>가 분리되어 <code>&quot;Hi&quot;</code> 엘리먼트 다음에 나타납니다.</p>
<blockquote>
<p><code>concat()</code> 호출로 항목이 분리되지 않도록 <em>Array</em> 서브 클래스에서 <code>Symbol.isConcatSpreadable</code>을 <code>false</code>로 설정할 수도 있습니다. 서브 클래스는 8 장에서 논의합니다.</p>
</blockquote>
<h3 id="Symbol-match-Symbol-replace-Symbol-search-그리고-Symbol-split-Symbol들"><a href="#Symbol-match-Symbol-replace-Symbol-search-그리고-Symbol-split-Symbol들" class="headerlink" title="Symbol.match, Symbol.replace, Symbol.search, 그리고 Symbol.split Symbol들"></a>Symbol.match, Symbol.replace, Symbol.search, 그리고 Symbol.split Symbol들</h3><p>문자열과 정규 표현식은 JavaScript에서 밀접한 관계가 있습니다. 특히 문자열 타입에는 정규 표현식을 파라미터로 사용하는 여러 가지 메서드가 있습니다.</p>
<ul>
<li><code>match(regex)</code> - 주어진 문자열이 정규 표현식과 일치하는지 여부를 판별합니다.</li>
<li><code>replace(regex, replacement)</code> - 정규 표현식에 매치된 문자열을 <code>replacement</code> 로 대체합니다.</li>
<li><code>search(regex)</code> - 문자열 내에서 정규 표현식과 일치하는 문자열을 찾습니다.</li>
<li><code>split(regex)</code> - 문자열을 정규 표현식과 일치하는 문자열 <em>Array</em>로 나눕니다.</li>
</ul>
<p>ECMAScript 6 이전에는 이러한 메서드가 정규 표현식과 상호 작용하는 방식이 개발자에게 숨겨져 있어 개발자가 정의한 객체에 정규 표현식을 사용할 수 없었습니다. ECMAScript 6은 이러한 네 가지 메서드에 해당하는 네 개의 <em>Symbol</em>을 정의하여 네이티브 동작을 <code>RegExp</code> 내장 객체에 효과적으로 아웃소싱할 수 있습니다.</p>
<p><code>Symbol.match</code>, <code>Symbol.replace</code>, <code>Symbol.search</code> 및 <code>Symbol.split</code> <em>Symbol</em>은 정규 표현식 파라미터에 대한 <code>match()</code> ,<code>replace()</code>, <code>search()</code>, <code>split ()</code> 메서드 각각에 대한 첫 번째 파라미터에서 호출되어야 합니다. 네 개의 <em>Symbol</em> 프로퍼티는 <code>RegExp.prototype</code>에 문자열 메서드가 사용해야하는 기본 구현으로 정의됩니다.</p>
<p>이것을 알면 정규 표현식과 비슷한 방식으로 문자열 메서드에 사용할 객체를 만들 수 있습니다. 그렇게하기 위해 코드에서 다음과 같은 <em>Symbol</em> 함수를 사용할 수 있습니다.</p>
<ul>
<li><code>Symbol.match</code> - 문자열 파라미터를 받아들이고 일치하는 <em>Array</em>를 반환하는 함수. 일치하는 것이 없으면 <code>null</code>입니다.</li>
<li><code>Symbol.replace</code> - 문자열 파라미터와 대체 문자열을 받아들이고 문자열을 반환하는 함수입니다.</li>
<li><code>Symbol.search</code> - 문자열 파라미터를 받아들이고 일치 항목의 숫자 인덱스를 반환하는 함수입니다. 일치하는 항목이 없으면 -1을 반환합니다.</li>
<li><code>Symbol.split</code> - 문자열 파라미터를 받아들이고 일치하는 문자열을 포함하는 <em>Array</em>를 반환하는 함수입니다.</li>
</ul>
<p>객체에 이러한 프로퍼티를 정의할 수 있으므로 정규 표현식 없이 패턴 일치를 구현하는 객체를 만들고 정규 표현식을 필요로하는 메서드에서 사용할 수 있습니다. 다음은 이러한 <em>Symbol</em>이 실제로 작동하는 것을 보여주는 예입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// effectively equivalent to /^.&#123;10&#125;$/</span></div><div class="line"><span class="keyword">let</span> hasLengthOf10 = &#123;</div><div class="line">    [<span class="built_in">Symbol</span>.match]: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> value.length === <span class="number">10</span> ? [value] : <span class="literal">null</span>;</div><div class="line">    &#125;,</div><div class="line">    [<span class="built_in">Symbol</span>.replace]: <span class="function"><span class="keyword">function</span>(<span class="params">value, replacement</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> value.length === <span class="number">10</span> ? replacement : value;</div><div class="line">    &#125;,</div><div class="line">    [<span class="built_in">Symbol</span>.search]: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> value.length === <span class="number">10</span> ? <span class="number">0</span> : <span class="number">-1</span>;</div><div class="line">    &#125;,</div><div class="line">    [<span class="built_in">Symbol</span>.split]: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> value.length === <span class="number">10</span> ? [<span class="string">""</span>, <span class="string">""</span>] : [value];</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> message1 = <span class="string">"Hello world"</span>,   <span class="comment">// 11 characters</span></div><div class="line">    message2 = <span class="string">"Hello John"</span>;    <span class="comment">// 10 characters</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">let</span> match1 = message1.match(hasLengthOf10),</div><div class="line">    match2 = message2.match(hasLengthOf10);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(match1);            <span class="comment">// null</span></div><div class="line"><span class="built_in">console</span>.log(match2);            <span class="comment">// ["Hello John"]</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> replace1 = message1.replace(hasLengthOf10, <span class="string">"Howdy!"</span>),</div><div class="line">    replace2 = message2.replace(hasLengthOf10, <span class="string">"Howdy!"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(replace1);          <span class="comment">// "Hello world"</span></div><div class="line"><span class="built_in">console</span>.log(replace2);          <span class="comment">// "Howdy!"</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> search1 = message1.search(hasLengthOf10),</div><div class="line">    search2 = message2.search(hasLengthOf10);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(search1);           <span class="comment">// -1</span></div><div class="line"><span class="built_in">console</span>.log(search2);           <span class="comment">// 0</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> split1 = message1.split(hasLengthOf10),</div><div class="line">    split2 = message2.split(hasLengthOf10);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(split1);            <span class="comment">// ["Hello world"]</span></div><div class="line"><span class="built_in">console</span>.log(split2);            <span class="comment">// ["", ""]</span></div></pre></td></tr></table></figure>
<p><code>hasLengthOf10</code> 객체는 문자열 길이가 정확히 10일 때마다 일치하는 정규 표현식처럼 작동합니다. <code>hasLengthOf10</code>에있는 네 개의 메서드는 각각 적절한 <em>Symbol</em> 을 사용하여 구현되고 두 문자열에 상응하는 메서드가 호출됩니다. 첫 번째 문자열인 <code>message1</code>은 11 개의 문자를 가지므로 일치하지 않습니다. 두 번째 문자열 <code>message2</code>는 10 개의 문자를 가지므로 일치합니다. 정규식이 아니더라도 <code>hasLengthOf10</code>은 각 문자열 메서드에 전달되고 추가 메서드로 인해 올바르게 사용됩니다.</p>
<p>이것은 간단한 예제지만 보다 복잡한 매칭를 수행하는 기능도 가능합니다. 그리고 현재 정규 표현식으로 가능했던 것보다 커스텀 패턴 매처에 대한 많은 가능성을 열어줍니다.</p>
<h3 id="Symbol-toPrimitive-메서드"><a href="#Symbol-toPrimitive-메서드" class="headerlink" title="Symbol.toPrimitive 메서드"></a>Symbol.toPrimitive 메서드</h3><p>JavaScript는 특정 작업을 적용할 때 객체를 <em>Primitive</em> 값으로 암시적으로 변환하려고 시도합니다. 예를 들어 문자열을 double equals (<code>==</code>) 연산자를 사용하여 객체와 비교하면 비교하기 전에 객체가 <em>Primitive</em> 값으로 변환됩니다. 정확하게 어떤 <em>Primitive</em> 값이 사용되어야 하는가는 이전에는 내부 연산 이었지만, ECMAScript 6에서는 <code>Symbol.toPrimitive</code> 메서드를 통해 그 값을 밖으로 노출시킵니다.</p>
<p><code>Symbol.toPrimitive</code> 메서드는 각 표준 타입의 프로토 타입에 정의되어 있으며, 객체가 <em>Primitive</em>로 변환 될 때 어떻게되어야 하는지를 규정합니다. <em>Primitive</em> 변환이 필요할 때, <code>Symbol.toPrimitive</code>는 하나의 파라미터를 가지고 호출되며, 명세서에서 <code>hint</code>라고 설명합니다. <code>hint</code> 파라미터는 세 개의 문자열 값 중 하나입니다. <code>hint</code>가 <code>&quot;number&quot;</code>이면 <code>Symbol.toPrimitive</code>는 number를 반환해야합니다. <code>hint</code>가 <code>&quot;string&quot;</code>이면 string이 반환되어야하고, “default”이면 해당 연산은 그 타입에 대한 선호도가 없습니다.</p>
<p>대부분의 표준 객체에서 number 모드는 우선 순위에 따라 다음과 같은 동작을합니다.</p>
<ol>
<li><code>valueOf()</code> 메서드를 호출해, 결과가 <em>Primitive</em>인 경우는 그 값을 돌려 준다.</li>
<li>그렇지 않은 경우는,<code>toString()</code> 메서드를 호출해, 결과가 <em>Primitive</em>인 경우는 그 값을 돌려 준다.</li>
<li>그렇지 않으면 오류를 발생시킵니다.</li>
</ol>
<p>마찬가지로 대부분의 표준 객체에서 string 모드의 동작은 다음과 같은 우선 순위를 갖습니다.</p>
<ol>
<li><code>toString()</code> 메서드를 호출해, 결과가 <em>Primitive</em>인 경우는 그 값을 돌려 준다.</li>
<li>그렇지 않은 경우는, <code>valueOf()</code> 메서드를 호출해, 결과가 <em>Primitive</em>인 경우는 그 값을 돌려 준다.</li>
<li>그렇지 않으면 오류를 발생시킵니다.</li>
</ol>
<p>대부분의 경우 표준 객체는 <em>Default</em> 모드를 number 모드와 동일하게 취급합니다 (<em>Default</em> 모드를 string 모드와 동일하게 취급하는 <code>Date</code>제외). <code>Symbol.toPrimitive</code> 메서드를 정의함으로써, 여러분은 이 <em>Default</em> 모드를 오버라이드 할 수 있습니다.</p>
<blockquote>
<p><em>Default</em> 모드는 <code>==</code>연산자, <code>+</code>연산자 및 <code>Date</code> 생성자에 단일 파라미터를 전달할 때만 사용됩니다. 대부분의 작업에는 string 또는 number 모드가 사용됩니다.</p>
</blockquote>
<p><em>Default</em> 변환 행동을 무시하려면 아래 예제 처럼 <code>Symbol.toPrimitive</code>를 사용하고 함수를 값으로 지정하십시오.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Temperature</span>(<span class="params">degrees</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.degrees = degrees;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Temperature.prototype[<span class="built_in">Symbol</span>.toPrimitive] = <span class="function"><span class="keyword">function</span>(<span class="params">hint</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">switch</span> (hint) &#123;</div><div class="line">        <span class="keyword">case</span> <span class="string">"string"</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.degrees + <span class="string">"\u00b0"</span>; <span class="comment">// degrees symbol</span></div><div class="line"></div><div class="line">        <span class="keyword">case</span> <span class="string">"number"</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.degrees;</div><div class="line"></div><div class="line">        <span class="keyword">case</span> <span class="string">"default"</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.degrees + <span class="string">" degrees"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> freezing = <span class="keyword">new</span> Temperature(<span class="number">32</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(freezing + <span class="string">"!"</span>);            <span class="comment">// "32 degrees!"</span></div><div class="line"><span class="built_in">console</span>.log(freezing / <span class="number">2</span>);              <span class="comment">// 16</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(freezing));          <span class="comment">// "32째"</span></div></pre></td></tr></table></figure>
<p>위의 예제는 <code>Temperature</code> 생성자를 정의하고 프로토타입에 대한 기본 <code>Symbol.toPrimitive</code> 메서드를 오버라이드합니다. <code>hint</code> 파라미터가<code>string</code> 모드,<code>number</code> 모드 또는 <em>Default</em> 모드 (JavaScript 엔진에 의해 <code>hint</code> 파라미터로 채워짐)를 나타내는지에 따라 다른값이 리턴됩니다. <code>string</code> 모드에서, <code>Symbol.toPrimitive</code> 메서드는 유니 코드 <em>Symbol</em>로 온도를 반환합니다. <code>number</code> 모드에서는 숫자값만 반환하고, <em>Default</em> 모드에서는 숫자 뒤에 <code>&quot;degrees&quot;</code>라는 단어를 추가합니다.</p>
<p>각각의 로그문은 다른 <code>hint</code> 파라미터를 트리거합니다. <code>+</code>연산자는 <code>hint</code>를 <code>&quot;default&quot;</code>로 설정함으로써 <em>Default</em> 모드를 트리거하고, <code>/</code> 연산자는 <code>hint</code>를 <code>&quot;number&quot;</code>로 설정함으로써 <code>number</code> 모드를 트리거하고, <code>String()</code> 함수는 <code>hint</code>를 <code>&quot;string&quot;</code>으로 설정함으로써 <code>string</code> 모드로 트리거합니다. 세 가지 모드 모두에 대해 다른 값을 반환하는 것이 가능합니다. 하지만 <em>Default</em> 모드를 <code>string</code> 또는 <code>number</code> 모드와 동일하게 설정하는 것이 훨씬 더 일반적입니다.</p>
<h3 id="Symbol-toStringTag-Symbol"><a href="#Symbol-toStringTag-Symbol" class="headerlink" title="Symbol.toStringTag Symbol"></a>Symbol.toStringTag Symbol</h3><p>JavaScript에서 가장 흥미로운 문제중 하나는 여러 글로벌 실행환경을 사용할 수 있다는 것입니다. 이는 페이지에 iframe이 포함될 때 웹 브라우저에서 발생합니다. 페이지와 iframe에는 각각 자체 실행 환경이 있기 때문입니다. 대부분의 경우 데이터를 주고받을 수 있으므로 문제가되지 않습니다. 하지만 문제는 객체가 다른 객체에 전달된 후 처리할 객체의 타입을 식별하려고 할 때 발생합니다.</p>
<p>이 문제의 일반적인 예는 iframe의 <em>Array</em>의 포함 페이지로 또는 그 반대로 전달하는 것입니다. ECMAScript 6 용어에서 iframe 및 포함 페이지는 각각 JavaScript의 실행 환경인 다른 영역(<em>realm</em>)을 나타냅니다. 각 영역에는 전역 객체의 자체 사본이 있는 고유한 전역 Scope이 있습니다. <em>Array</em>는 생성되는 영역에 관계없이 <em>Array</em>이어야 합니다. 그러나 다른 영역으로 넘어 갔을 때 <em>Array</em>가 이전 영역의 생성자로 만들어졌고 <code>Array</code>가 현재 영역의 생성자를 나타내므로 <code>instanceof Array</code> 호출은 <code>false</code>를 반환합니다.</p>
<h4 id="식별-문제에-대한-해결-방법"><a href="#식별-문제에-대한-해결-방법" class="headerlink" title="식별 문제에 대한 해결 방법"></a>식별 문제에 대한 해결 방법</h4><p>이 문제에 직면한 개발자들은 곧 <em>Array</em>를 식별하는 좋은 방법을 발견했습니다. 그들은 객체에 대해 표준 <code>toString()</code>메서드를 호출하면 항상 예측 가능한 문자열이 반환된다는 것을 발견했습니다. 그래서 많은 JavaScript 라이브러리는 다음과 같은 함수를 포함하기 시작했습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArray</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(value) === <span class="string">"[object Array]"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(isArray([]));   <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>이 방법이 조금 어색해 보일지 모르지만 모든 브라우저에서 <em>Array</em>를 식별하는 데는 매우 효과적입니다. <em>Array</em>의 <code>toString()</code> 메서드는 객체를 포함하는 문자열 표현을 반환하기 때문에 객체 식별에 유용하지 않습니다. 그러나 <code>Object.prototype</code>에 대한 <code>toString()</code> 메서드는 quirk를 가지고 있습니다 : 반환된 결과에 <code>[[Class]]</code>로 불리는 내부적으로 정의된 이름을 포함합니다. 개발자는 객체에서 이 메서드를 사용하여 JavaScript 환경에서 객체의 데이터 타입이 무엇이라고 생각 하는지를 검색할 수 있습니다.</p>
<p>개발자는 이 동작을 변경할 방법이 없었기 때문에 동일한 방법을 사용하여 <em>Native</em> 객체와 개발자가 만든 객체를 구별할 수 있다는 것을 신속하게 깨달았습니다. 가장 중요한 경우는 ECMAScript 5 <code>JSON</code> 객체입니다.</p>
<p>ECMAScript 5 이전에는 많은 개발자들이 Douglas Crockford의 <em>json2.js</em>를 사용하여 글로벌 JSON 객체를 생성했습니다. 하지만 브라우저가 <code>JSON</code> 전역 객체를 구현하기 시작하면서, JavaScript 환경에서 또는 다른 라이브러리를 통해 제공되는 전역 JSON이 필요하다는 것을 깨달았습니다. <code>isArray()</code> 함수에서 보여준 것과 같은 기술을 사용하여 많은 개발자들이 다음과 같은 함수를 만들었습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">supportsNativeJSON</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> <span class="built_in">JSON</span> !== <span class="string">"undefined"</span> &amp;&amp;</div><div class="line">        <span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">JSON</span>) === <span class="string">"[object JSON]"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>개발자가 iframe 경계를 넘어서 <em>Array</em>를 식별할 수있게 해주는 <code>Object.prototype</code>과 동일한 특성을 사용해 <code>JSON</code>이 기본 <code>JSON</code> 객체인지 여부를 알 수있는 방법을 제공합니다. 기본이 아닌 <code>JSON</code> 객체는 <code>[object Object]</code>를 반환하지만 <em>Native</em> 버전은 <code>[object JSON]</code>을 반환합니다. 이 접근법은 <em>Native</em> 객체를 식별하기 위한 사실상의 표준이되었습니다.</p>
<h3 id="ECMAScript-6의-해결책"><a href="#ECMAScript-6의-해결책" class="headerlink" title="ECMAScript 6의 해결책"></a>ECMAScript 6의 해결책</h3><p>ECMAScript 6은 <code>Symbol.toStringTag</code> <em>Symbol</em>을 통해 이 동작을 재정의합니다. 이 <em>Symbol</em>은 <code>Object.prototype.toString.call()</code>이 호출될 때 생성되어야 하는 값을 정의하는 각 객체의 프로퍼티를 나타냅니다. <em>Array</em>의 경우 함수가 반환하는 값은 <code>Symbol.toStringTag</code> 프로퍼티에 <code>&quot;Array&quot;</code>를 저장하여 설명합니다.</p>
<p>마찬가지로, 자신의 객체에 대한 <code>Symbol.toStringTag</code> 값을 정의할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype[<span class="built_in">Symbol</span>.toStringTag] = <span class="string">"Person"</span>;</div><div class="line"></div><div class="line"><span class="keyword">let</span> me = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(me.toString());                         <span class="comment">// "[object Person]"</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(me));    <span class="comment">// "[object Person]"</span></div></pre></td></tr></table></figure>
<p>이 예제에서 <code>Symbol.toStringTag</code> 프로퍼티는 <code>Person.prototype</code>에 정의되어 문자열 표현을 생성하기 위한 기본 동작을 제공합니다. <code>Person.prototype</code>은 <code>Object.prototype.toString()</code> 메서드를 상속 받기 때문에 <code>Symbol.toStringTag</code>에서 반환된 값은 <code>me.toString()</code> 메서드를 호출할 때도 사용됩니다. 그러나 <code>Object.prototype.toString.call()</code> 메서드의 사용에 영향을 미치지 않고 다른 동작을 제공하는 자신만의 <code>toString()</code> 메서드를 정의할 수 있습니다. 다음과 같이 사용할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype[<span class="built_in">Symbol</span>.toStringTag] = <span class="string">"Person"</span>;</div><div class="line"></div><div class="line">Person.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> me = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(me.toString());                         <span class="comment">// "Nicholas"</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(me));    <span class="comment">// "[object Person]"</span></div></pre></td></tr></table></figure>
<p>이 코드는 <code>Person.prototype.toString()</code>을 정의하여 <code>name</code> 프로퍼티 값을 반환합니다. <code>Person</code> 인스턴스가 더 이상 <code>Object.prototype.toString()</code> 메서드를 상속하지 않기 때문에 <code>me.toString()</code>을 호출하면 다른 행동을 보입니다.</p>
<blockquote>
<p>달리 명시하지 않는한 모든 객체는 <code>Object.prototype</code>에서 <code>Symbol.toStringTag</code>을 상속받습니다. <code>&quot;Object&quot;</code>문자열이 기본 프로퍼티 값입니다.</p>
</blockquote>
<p>개발자가 정의한 객체에서 <code>Symbol.toStringTag</code>에 어떤 값을 사용할 수 있는지에 대한 제한은 없습니다. 예를 들어, 다음과 같이 <code>Symbol.toStringTag</code> 프로퍼티의 값으로 <code>&quot;Array&quot;</code>를 사용하지 못하게하는 방법은 없습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype[<span class="built_in">Symbol</span>.toStringTag] = <span class="string">"Array"</span>;</div><div class="line"></div><div class="line">Person.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> me = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(me.toString());                         <span class="comment">// "Nicholas"</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(me));    <span class="comment">// "[object Array]"</span></div></pre></td></tr></table></figure>
<p><code>Object.prototype.toString()</code>을 호출 한 결과는 이 코드에서 <code>&quot;[object Array]&quot;</code>이며 실제 <em>Array</em>에서 얻은 결과와 같습니다. 이것은 <code>Object.prototype.toString()</code>이 더 이상 객체 타입을 식별하는 완전히 신뢰할 수있는 방법이 아니라는 사실을 강조합니다.</p>
<p><em>Native</em> 객체에 대한 문자열 태그 변경도 가능합니다. 다음과 같이 객체의 프로토 타입에 <code>Symbol.toStringTag</code>을 할당하면 됩니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Array</span>.prototype[<span class="built_in">Symbol</span>.toStringTag] = <span class="string">"Magic"</span>;</div><div class="line"></div><div class="line"><span class="keyword">let</span> values = [];</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(values));    <span class="comment">// "[object Magic]"</span></div></pre></td></tr></table></figure>
<p>이 예제에서 <code>Symbol.toStringTag</code>가 <em>Array</em>에 대해 덮어 쓰여지더라도 <code>Object.prototype.toString()</code>을 호출하면 대신 <code>[[Object Magic]]</code>이 됩니다. 이런 방식으로 내장 객체를 변경하지 말 것을 권고 하지만 JavaScript에서 이것을 금지하지는 않습니다.</p>
<h3 id="Symbol-unscopables-Symbol"><a href="#Symbol-unscopables-Symbol" class="headerlink" title="Symbol.unscopables Symbol"></a>Symbol.unscopables Symbol</h3><p><code>with</code>문은 JavaScript에서 가장 논쟁의 여지가 있는 부분중 하나입니다. 원래 반복적인 타이핑을 피하도록 설계된 <code>with</code> 문은 나중에 코드를 이해하기 어렵게 만들고 성능에 부정적이고 오류가 발생하기 쉬워서 많은 비난을 받고 있습니다.</p>
<p>결과적으로 <code>with</code> 문은 <em>strict</em> 모드에서는 허용되지 않습니다. 이러한 제한은 클래스와 모듈에도 영향을 미칩니다. 클래스와 모듈은 기본적으로 <em>strict</em> 모드이며 opt-out이 없습니다.</p>
<p>미래의 코드는 의심할 여지없이 <code>with</code> 문을 사용하지 않지만, ECMAScript 6는 하위 호환성을 위한 <code>nonstrict</code> 모드를 여전히 지원하며, <code>with</code>를 사용하는 코드가 계속해서 제대로 작동하도록 하는 방법을 찾아야만 합니다.</p>
<p>이 작업의 복잡성을 이해하기 위해 다음 코드를 살펴보겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</div><div class="line">    colors = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>],</div><div class="line">    color = <span class="string">"black"</span>;</div><div class="line"></div><div class="line"><span class="keyword">with</span>(colors) &#123;</div><div class="line">    push(color);</div><div class="line">    push(...values);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(colors);    <span class="comment">// ["red", "green", "blue", "black", 1, 2, 3]</span></div></pre></td></tr></table></figure>
<p>이 예제에서, <code>with</code>문 안에서 <code>push()</code>를 두 번 호출하면 <code>colors.push()</code>와 동등합니다. 왜냐하면 <code>with</code> 문은 push를 로컬 바인딩으로 추가했기 때문입니다. <code>color</code>의 참조는 <code>values</code> 참조처럼 <code>with</code>문 밖에서 생성된 변수를 참조합니다.</p>
<p>ECMAScript 6는 <em>Array</em>에 <code>values</code> 메서드를 추가했습니다. (<code>values</code> 메서드에 대해서는 7 장  “Iterator와 Generator”에서 자세히 설명합니다.) 즉, ECMAScript 6 환경에서 <code>with</code>문 내의 <code>values</code> 참조는 지역 변수 <code>values</code>를 참조하는 것이 아니라 코드를 깨뜨릴 수 있는 <em>Array</em>의 <code>values</code> 메서드를 참조해야합니다. 이것이 <code>Symbol.unscopables</code> <em>Symbol</em>이 존재하는 이유입니다.</p>
<p><code>Symbol.unscopables</code> 심볼은 <code>Array.prototype</code>에 사용되어 어떤 프로퍼티가 <code>with</code>문 안에서 바인딩을 생성해서는 안된다는 것을 나타냅니다. 현재 존재하는 <code>Symbol.unscopables</code>는 <code>with</code> 명령문 바인딩을 생략하고 <code>values</code>가 <code>true</code> 인 블록을 시행하기 위한 식별자를 키로 가지는 객체입니다. 다음은 <em>Array</em>에 대한 기본 <code>Symbol.unscopables</code> 프로퍼티입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// built into ECMAScript 6 by default</span></div><div class="line"><span class="built_in">Array</span>.prototype[<span class="built_in">Symbol</span>.unscopables] = <span class="built_in">Object</span>.assign(<span class="built_in">Object</span>.create(<span class="literal">null</span>), &#123;</div><div class="line">    <span class="attr">copyWithin</span>: <span class="literal">true</span>,</div><div class="line">    <span class="attr">entries</span>: <span class="literal">true</span>,</div><div class="line">    <span class="attr">fill</span>: <span class="literal">true</span>,</div><div class="line">    <span class="attr">find</span>: <span class="literal">true</span>,</div><div class="line">    <span class="attr">findIndex</span>: <span class="literal">true</span>,</div><div class="line">    <span class="attr">keys</span>: <span class="literal">true</span>,</div><div class="line">    <span class="attr">values</span>: <span class="literal">true</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><code>Symbol.unscopables</code> 객체는 <code>Object.create(null)</code> 호출에 의해 생성되고 ECMAScript 6에 있는 새로운 <em>Array</em> 메서드들을 모두 포함하는 <code>null</code> 프로토 타입을 가지고 있습니다. (이 메서드들은 7장 “Iterator와 Generator”및 9장 “Arrays.”에서 설명합니다.) 이러한 메서드에 대한 바인딩은 <code>with</code> 문 내에 만들어지지 않으므로 이전 코드가 아무런 문제없이 계속 작동할 수 있습니다.</p>
<p>일반적으로 <code>with</code> 문을 사용하지 않고 코드베이스의 기존 객체를 변경하지 않는한 객체에 <code>Symbol.unscopables</code>을 정의할 필요가 없습니다.</p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p><em>Symbol</em>은 JavaScript에서 새로운 유형의 <em>Primitive</em> 타입이며 <em>Symbol</em>을 참조하지 않고는 액세스할 수 없는 프로퍼티를 만드는데 사용됩니다.</p>
<p>진정한 <em>Private</em>은 아니지만 이러한 프로퍼티는 실수로 변경하거나 덮어 쓰기가 어렵기 때문에 개발자로부터 일정 수준의 보호가 필요한 기능에 적합합니다.</p>
<p><em>Symbol</em> 값을 쉽게 식별할 수 있도록 <em>Symbol</em>에 대한 설명을 제공할 수 있습니다. 동일한 설명을 사용하여 코드의 다른 부분에서 공유 <em>Symbol</em>을 사용할 수 있는 전역 <em>Symbol</em> 레지스트리가 있습니다. 이런 식으로 여러 장소에서 같은 이유로 동일한 <em>Symbol</em>을 사용할 수 있습니다.</p>
<p><code>Object.keys()</code> 또는 <code>Object.getOwnPropertyNames()</code>와 같은 메서드는 <em>Symbol</em>을 반환하지 않고, ECMAScript 6에 새로운 메서드인  <code>Object.getOwnPropertySymbols()</code>가 추가되어 <em>Symbol</em> 프로퍼티를 검색할 수 있습니다. <code>Object.defineProperty()</code>및<code>Object.defineProperties ()</code>메서드를 호출하여 <em>Symbol</em> 프로퍼티를 변경할 수 있습니다.</p>
<p><em>Well-known Symbol</em>은 표준 객체에 대한 이전의 내부 전용 기능을 정의하고 <code>Symbol.hasInstance</code> 프로퍼티와 같이 전역적으로 사용 가능한 <em>Symbol</em> 상수를 사용합니다. 이 <em>Symbol</em>은 스펙에서 접두어 <code>Symbol.</code>을 사용하며 개발자가 다양한 방법으로 표준 객체의 동작을 수정할 수 있도록 합니다.</p>
<hr>
<blockquote>
<p>이 내용은 나중에 참고하기 위해 제가 공부하며 정리한 내용입니다.<br>의역, 오역, 직역이 있을 수 있음을 알려드립니다.<br>This post is a translation of this original article [<a href="https://leanpub.com/understandinges6/read#leanpub-auto-symbols-and-symbol-properties" target="_blank" rel="external">https://leanpub.com/understandinges6/read#leanpub-auto-symbols-and-symbol-properties</a>]</p>
</blockquote>
<h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul>
<li><a href="https://infoscis.github.io/2018/01/24/ecmascript-6-block-binding/">ECMAScript 6 Block Binding</a></li>
<li><a href="https://infoscis.github.io/2018/01/24/ecmascript-6-strings-and-regular-expressions/">ECMAScript 6 문자열과 정규 표현식</a></li>
<li><a href="https://infoscis.github.io/2018/01/24/ecmascript-6-functions/">ECMAScript 6 함수</a></li>
<li><a href="https://infoscis.github.io/2018/01/25/ecmascript-6-expanded-object-functionality/">ECMAScript 6 객체의 확장된 기능</a></li>
<li><a href="https://infoscis.github.io/2018/01/26/ecmascript-6-destructuring-for-easier-data-access/">ECMAScript 6 쉬운 데이터 액세스를 위한 Destructuring</a></li>
<li><a href="https://infoscis.github.io/2018/01/27/ecmascript-6-symbols-and-symbol-properties/">ECMAScript 6 Symbol과 Symbol 프로퍼티</a></li>
<li><a href="https://infoscis.github.io/2018/01/27/ecmascript-6-sets-and-maps/">ECMAScript 6 Set과 Map</a></li>
<li><a href="https://infoscis.github.io/2018/01/31/ecmascript-6-iterators-and-generators/">ECMAScript 6 Iterator와 Generator</a></li>
<li><a href="https://infoscis.github.io/2018/02/13/ecmascript-6-introducing-javascript-classes/">ECMAScript 6 JavaScript 클래스 소개</a></li>
<li><a href="https://infoscis.github.io/2018/02/13/ecmascript-6-improved-array-capabilities/">ECMAScript 6 Array 기능 향상</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-promises-and-asynchronous-programming/">ECMAScript 6 Promise와 비동기 프로그램밍</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-proxies-and-the-reflection-api/">ECMAScript 6 프록시와 리플렉션 API</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-encapsulating-code-with-modules/">ECMAScript 6 Module로 코드 캡슐화하기</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-appendix-a-smaller-changes/">ECMAScript 6 부록 A. 작은 변경 사항</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-appendix-b-understanding-ecmascript-7/">ECMAScript 6 부록 B. ECMAScript 7(2016) 이해하기</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Symbols과-Symbol-프로퍼티&quot;&gt;&lt;a href=&quot;#Symbols과-Symbol-프로퍼티&quot; class=&quot;headerlink&quot; title=&quot;Symbols과 Symbol 프로퍼티&quot;&gt;&lt;/a&gt;Symbols과 Symbol 프로퍼티&lt;/h1&gt;&lt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://infoscis.github.io/categories/JavaScript/"/>
    
      <category term="ECMAScript 2015" scheme="http://infoscis.github.io/categories/JavaScript/ECMAScript-2015/"/>
    
    
      <category term="JavaScript" scheme="http://infoscis.github.io/tags/JavaScript/"/>
    
      <category term="ECMAScript 2015" scheme="http://infoscis.github.io/tags/ECMAScript-2015/"/>
    
  </entry>
  
  <entry>
    <title>ECMAScript 6 쉬운 데이터 액세스를 위한 Destructuring</title>
    <link href="http://infoscis.github.io/2018/01/26/ecmascript-6-destructuring-for-easier-data-access/"/>
    <id>http://infoscis.github.io/2018/01/26/ecmascript-6-destructuring-for-easier-data-access/</id>
    <published>2018-01-25T15:08:59.000Z</published>
    <updated>2018-02-27T14:12:17.847Z</updated>
    
    <content type="html"><![CDATA[<h1 id="쉬운-데이터-액세스를-위한-Destructuring"><a href="#쉬운-데이터-액세스를-위한-Destructuring" class="headerlink" title="쉬운 데이터 액세스를 위한 Destructuring"></a>쉬운 데이터 액세스를 위한 Destructuring</h1><p>객체와 <em>Array</em> 리터럴은 JavaScript에서 가장 많이 사용되는 표기법중 두가지이며, 널리 사용되는 JSON 데이터 형식 덕분에 특히 중요한 부분이되었습니다. 객체와 <em>Array</em>를 정의한 다음 해당 구조에서 관련 정보를 체계적으로 추출하는 것이 일반적인 사용법입니다. ECMAScript 6은 데이터 구조를 더작은 부분으로 나누는 과정인 <em>Destructuring</em>을 추가하여 이 작업을 단순화했습니다. 이 장에서는 객체와 <em>Array</em> 모두에 대해 <em>Destructuring</em>을 이용하는 방법을 설명합니다.</p>
<h2 id="왜-Destructuring이-유용할까요"><a href="#왜-Destructuring이-유용할까요" class="headerlink" title="왜 Destructuring이 유용할까요?"></a>왜 Destructuring이 유용할까요?</h2><p>ECMAScript 5 및 이전 버전에서는 객체 및<em>Array</em>의 정보를 가져와서 로컬 변수에 대입할 때 코드가 많이 생길 수 있었습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> options = &#123;</div><div class="line">        <span class="attr">repeat</span>: <span class="literal">true</span>,</div><div class="line">        <span class="attr">save</span>: <span class="literal">false</span></div><div class="line">    &#125;;</div><div class="line"></div><div class="line"><span class="comment">// 객체에서 데이터를 추출합니다.</span></div><div class="line"><span class="keyword">let</span> repeat = options.repeat,</div><div class="line">    save = options.save;</div></pre></td></tr></table></figure>
<p>위 코드는 <code>options</code> 객체에서 <code>repeat</code>와 <code>save</code>의 값을 추출하여 같은 이름의 로컬 변수에 저장합니다. 위 코드는 단순하지만, 만약 할당할 변수가 많은 경우를 생각해보십시오. 그들 모두를 하나씩 할당해야할 것입니다. 정보를 찾기 위해 순회하는 중첩된 데이터 구조가 있는 경우 전체 구조를 파헤쳐 한조각의 데이터를 찾아야할 수도 있습니다.</p>
<p>그래서 ECMAScript 6는 객체와 <em>Array</em> 모두에 <em>Destructuring</em>을 추가 했습니다. 데이터 구조를 작은 부분으로 나누면 필요한 정보를 얻는 것이 훨씬 쉬워집니다. 많은 언어들이 최소한의 문법으로 <em>Destructuring</em>를 구현하여 프로세스를 더 간단하게 사용합니다. ECMAScript 6의 구현은 실제로 익숙한 구문을 사용합니다(객체 및 <em>Array</em> 리터럴 구문).</p>
<h2 id="객체-Destructuring"><a href="#객체-Destructuring" class="headerlink" title="객체 Destructuring"></a>객체 Destructuring</h2><p>객체 <em>Destructuring</em> 문법은 할당 연산의 왼쪽에 객체 리터럴을 사용합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> node = &#123;</div><div class="line">        <span class="attr">type</span>: <span class="string">"Identifier"</span>,</div><div class="line">        <span class="attr">name</span>: <span class="string">"foo"</span></div><div class="line">    &#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> &#123; type, name &#125; = node;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(type);      <span class="comment">// "Identifier"</span></div><div class="line"><span class="built_in">console</span>.log(name);      <span class="comment">// "foo"</span></div></pre></td></tr></table></figure>
<p>이 코드에서 <code>node.type</code>의 값은 <code>type</code>이라는 변수에 저장되고 <code>node.name</code>의 값은 <code>name</code>이라는 변수에 저장됩니다. 이 문법은 4 장에서 소개된 객체 리터럴 프로퍼티 초기화와 동일합니다. 변수 <code>type</code>과 <code>name</code>은 지역 변수이며 <code>node</code> 객체에서 값을 읽어올 프로퍼티들입니다.</p>
<h3 id="초기화를-잊지마세요"><a href="#초기화를-잊지마세요" class="headerlink" title="초기화를 잊지마세요."></a>초기화를 잊지마세요.</h3><p><em>Destructuring</em> 을 사용하여 <code>var</code>, <code>let</code> 또는 <code>const</code>를 사용하여 변수를 선언할 때 초기화값(등호 뒤에 오는 값)를 제공해야합니다. 다음 코드는 모두 초기화 프로그램이 없어서 구문 오류를 발생시킵니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// syntax error!</span></div><div class="line"><span class="keyword">var</span> &#123; type, name &#125;;</div><div class="line"></div><div class="line"><span class="comment">// syntax error!</span></div><div class="line"><span class="keyword">let</span> &#123; type, name &#125;;</div><div class="line"></div><div class="line"><span class="comment">// syntax error!</span></div><div class="line"><span class="keyword">const</span> &#123; type, name &#125;;</div></pre></td></tr></table></figure>
<p><code>const</code>는 <em>Nondestructured</em> 변수를 사용하는 경우에도 항상 초기화가 필요하고, <code>var</code>와 <code>let</code>은 <em>Destructuring</em> 을 사용할 때만 초기화가 필요합니다.</p>
<h3 id="Destructuring-할당"><a href="#Destructuring-할당" class="headerlink" title="Destructuring 할당"></a>Destructuring 할당</h3><p>지금까지 객체의 <em>Destructuring</em> 예제는 변수 선언을 사용했습니다. 그러나 할당에서 <em>Destructuring</em>을 사용할 수도 있습니다. 예를 들어, 다음과 같이 정의된 변수 값을 변경하기로 결정할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> node = &#123;</div><div class="line">        <span class="attr">type</span>: <span class="string">"Identifier"</span>,</div><div class="line">        <span class="attr">name</span>: <span class="string">"foo"</span></div><div class="line">    &#125;,</div><div class="line">    type = <span class="string">"Literal"</span>,</div><div class="line">    name = <span class="number">5</span>;</div><div class="line"></div><div class="line"><span class="comment">// destructuring 사용하여 다른 값 할당</span></div><div class="line">(&#123; type, name &#125; = node);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(type);      <span class="comment">// "Identifier"</span></div><div class="line"><span class="built_in">console</span>.log(name);      <span class="comment">// "foo"</span></div></pre></td></tr></table></figure>
<p>이 예제에서 <code>type</code>과 <code>name</code>은 선언될 때 초기화 되고, 같은 이름의 서로 다른 변수는 각각 다른 값으로 초기화됩니다. 다음 줄은 <em>Destructuring</em> 할당을 사용하여 <code>node</code> 객체의 값을 변경합니다. <em>Destructuring</em> 할당문에 괄호를 써야하는 것을 잊지 마세요. 여는 중괄호는 블록문이어야하고 블록문은 할당의 왼쪽에 나타날 수 없기 때문입니다. 괄호는 다음 중괄호가 블록문이 아니며 표현식으로 해석 되어야하며 할당이 완료될 수 있음을 나타냅니다.</p>
<p><em>Destructuring</em> 할당 표현식은 표현식의 오른쪽 (<code>=</code> 뒤)으로 평가됩니다. 즉, 값이 예상되는 모든 위치에서 <em>Destructuring</em> 할당 표현식을 사용할 수 있습니다. 예를 들어, 함수에 값을 전달하는 경우</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> node = &#123;</div><div class="line">        <span class="attr">type</span>: <span class="string">"Identifier"</span>,</div><div class="line">        <span class="attr">name</span>: <span class="string">"foo"</span></div><div class="line">    &#125;,</div><div class="line">    type = <span class="string">"Literal"</span>,</div><div class="line">    name = <span class="number">5</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">outputInfo</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(value === node);        <span class="comment">// true</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">outputInfo(&#123; type, name &#125; = node);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(type);      <span class="comment">// "Identifier"</span></div><div class="line"><span class="built_in">console</span>.log(name);      <span class="comment">// "foo"</span></div></pre></td></tr></table></figure>
<p><code>outputInfo()</code> 함수는 <em>Destructuring</em> 할당 표현식으로 호출됩니다. 표현식은 표현식에서 오른쪽 값이기 때문에 <code>node</code>로 평가됩니다. <code>type</code>과 <code>name</code>에 대한 할당은 정상적으로 동작하고 <code>node</code>는 <code>outputInfo()</code>에 전달됩니다.</p>
<blockquote>
<p><em>Destructuring</em> 할당 표현식 (<code>=</code> 뒤의 표현식)의 오른쪽이 <code>null</code> 또는 <code>undefined</code>로 평가되면 에러가 발생합니다. 이는 <code>null</code> 또는 <code>undefined</code> 속성을 읽으려고 하면 런타임 오류가 발생하기 때문입니다.</p>
</blockquote>
<h3 id="Default-값"><a href="#Default-값" class="headerlink" title="Default 값"></a>Default 값</h3><p><em>Destructuring</em> 할당 문을 사용할 때, 객체에 존재하지 않는 프로퍼티 이름을 가진 지역 변수를 지정하면, 그 지역 변수는 <code>undefined</code>의 값이 할당됩니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> node = &#123;</div><div class="line">        <span class="attr">type</span>: <span class="string">"Identifier"</span>,</div><div class="line">        <span class="attr">name</span>: <span class="string">"foo"</span></div><div class="line">    &#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> &#123; type, name, value &#125; = node;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(type);      <span class="comment">// "Identifier"</span></div><div class="line"><span class="built_in">console</span>.log(name);      <span class="comment">// "foo"</span></div><div class="line"><span class="built_in">console</span>.log(value);     <span class="comment">// undefined</span></div></pre></td></tr></table></figure>
<p>이 코드는 <code>value</code>라는 추가 로컬 변수를 정의하고 값을 할당하려고 시도합니다. 그러나, <code>node</code> 객체에는 상응하는 <code>value</code> 속성이 없으므로, <code>value</code> 변수는 <code>undefined</code> 값이 할당됩니다.</p>
<p>선택적으로 지정된 속성이 존재하지 않을때 사용할 <em>Default</em> 값을 정의할 수 있습니다. 이렇게하려면 속성 이름 뒤에 등호 (<code>=</code>)를 삽입하고 다음과 같이 <em>Default</em> 값을 지정하십시오.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> node = &#123;</div><div class="line">        <span class="attr">type</span>: <span class="string">"Identifier"</span>,</div><div class="line">        <span class="attr">name</span>: <span class="string">"foo"</span></div><div class="line">    &#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> &#123; type, name, value = <span class="literal">true</span> &#125; = node;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(type);      <span class="comment">// "Identifier"</span></div><div class="line"><span class="built_in">console</span>.log(name);      <span class="comment">// "foo"</span></div><div class="line"><span class="built_in">console</span>.log(value);     <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>이 예제에서 변수 <code>value</code>는 <em>Default</em> 값으로 true가 주어집니다. <em>Default</em> 값은 프로퍼티가 <code>node</code>에 없거나 <code>undefined</code> 값을 가진 경우에만 사용됩니다. <code>node.value</code> 프로퍼티가 없기 때문에, 변수 값은 <em>Default</em> 값을 사용합니다. 이는 3장에서 논의된 것처럼 함수에 대한 <em>Default</em> 파라미터와 비슷하게 작동합니다.</p>
<h3 id="다른-이름의-지역-변수-지정"><a href="#다른-이름의-지역-변수-지정" class="headerlink" title="다른 이름의 지역 변수 지정"></a>다른 이름의 지역 변수 지정</h3><p>지금까지 각 예제의 <em>Destructuring</em> 할당은 객체 프로퍼티 이름을 로컬 변수 이름으로 사용했습니다. 예를 들어, <code>node.type</code>의 값은<br> <code>type</code> 변수에 저장되었습니다. 같은 이름을 사용하고 싶을 때 잘 작동하지만 그렇지 않은 경우 어떻게 해야할까요? ECMAScript 6에는 지역 변수에 다른 이름을 할당할 수있는 확장 구문이 있으며 그 구문은 객체 리터럴 비단축 프로퍼티 초기화 구문과 비슷합니다. 다음은 그 예입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> node = &#123;</div><div class="line">        <span class="attr">type</span>: <span class="string">"Identifier"</span>,</div><div class="line">        <span class="attr">name</span>: <span class="string">"foo"</span></div><div class="line">    &#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> &#123; <span class="attr">type</span>: localType, <span class="attr">name</span>: localName &#125; = node;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(localType);     <span class="comment">// "Identifier"</span></div><div class="line"><span class="built_in">console</span>.log(localName);     <span class="comment">// "foo"</span></div></pre></td></tr></table></figure>
<p>이 코드는 <em>Destructuring</em> 할당을 사용하여 각각 <code>node.type</code>과 <code>node.name</code> 프로퍼티의 값을 포함하는 <code>localType</code>과 <code>localName</code> 변수를 선언합니다. <code>type:localType</code> 구문은 <code>type</code>이라는 프로퍼티를 읽고 그 값을 <code>localType</code> 변수에 저장한다는 의미입니다. 이 구문은  콜론 왼쪽에 이름이 있고 오른쪽에 값이 있는 전통적인 객체 리터럴 구문의 반대입니다. 콜론 오른쪽에 이름이 표시되고 읽을 값의 위치는 왼쪽에 있습니다.</p>
<p>다른 변수 이름을 사용할 때 <em>Default</em> 값을 추가할 수 있습니다. 등호와 <em>Default</em> 값은 지역 변수 이름 뒤에 위치합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> node = &#123;</div><div class="line">        <span class="attr">type</span>: <span class="string">"Identifier"</span></div><div class="line">    &#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> &#123; <span class="attr">type</span>: localType, <span class="attr">name</span>: localName = <span class="string">"bar"</span> &#125; = node;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(localType);     <span class="comment">// "Identifier"</span></div><div class="line"><span class="built_in">console</span>.log(localName);     <span class="comment">// "bar"</span></div></pre></td></tr></table></figure>
<p>여기서 <code>localName</code> 변수는 <code>&quot;bar&quot;</code>의 <em>Default</em> 값을 가집니다. <code>node.name</code> 프로퍼티가 없으므로 변수에 <em>Default</em> 값이 할당됩니다.</p>
<p>지금까지 프로퍼티가 Primitive 값인 객체의 <em>Destructuring</em>을 처리하는 방법을 살펴 보았습니다. 객체의 <em>Destructuring</em>은 중첩된 객체 구조의 값을 검색하는 데에도 사용할 수 있습니다.</p>
<h3 id="중첩된-객체-Destructuring"><a href="#중첩된-객체-Destructuring" class="headerlink" title="중첩된 객체 Destructuring"></a>중첩된 객체 Destructuring</h3><p>객체 리터럴과 유사한 구문을 사용하여 중첩된 객체 구조에서 원하는 정보만 검색할 수 있습니다. 다음은 그 예입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> node = &#123;</div><div class="line">        <span class="attr">type</span>: <span class="string">"Identifier"</span>,</div><div class="line">        <span class="attr">name</span>: <span class="string">"foo"</span>,</div><div class="line">        <span class="attr">loc</span>: &#123;</div><div class="line">            <span class="attr">start</span>: &#123;</div><div class="line">                <span class="attr">line</span>: <span class="number">1</span>,</div><div class="line">                <span class="attr">column</span>: <span class="number">1</span></div><div class="line">            &#125;,</div><div class="line">            <span class="attr">end</span>: &#123;</div><div class="line">                <span class="attr">line</span>: <span class="number">1</span>,</div><div class="line">                <span class="attr">column</span>: <span class="number">4</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> &#123; <span class="attr">loc</span>: &#123; start &#125;&#125; = node;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(start.line);        <span class="comment">// 1</span></div><div class="line"><span class="built_in">console</span>.log(start.column);      <span class="comment">// 1</span></div></pre></td></tr></table></figure>
<p>이 예제에서 <em>Destructuring</em> 패턴은 중괄호를 사용하여 패턴이 <code>node</code>에서 <code>loc</code>이라는 이름의 프로퍼티로 내려 가야하고 <code>start</code> 프로퍼티를 찾는다는 것을 나타냅니다. 마지막 섹션에서 <em>Destructuring</em> 패턴에 콜론 전에 검사할 위치를 제공하는 식별자를 의미하고 오른쪽은 값을 할당한다는 것을 기억하세요. 콜론 다음에 중괄호가 있으면 목적지가 객체의 다른 레벨에 중첩되어 있음을 나타냅니다.</p>
<p>한단계 더 나아가 로컬 변수에 다른 이름을 사용할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> node = &#123;</div><div class="line">        <span class="attr">type</span>: <span class="string">"Identifier"</span>,</div><div class="line">        <span class="attr">name</span>: <span class="string">"foo"</span>,</div><div class="line">        <span class="attr">loc</span>: &#123;</div><div class="line">            <span class="attr">start</span>: &#123;</div><div class="line">                <span class="attr">line</span>: <span class="number">1</span>,</div><div class="line">                <span class="attr">column</span>: <span class="number">1</span></div><div class="line">            &#125;,</div><div class="line">            <span class="attr">end</span>: &#123;</div><div class="line">                <span class="attr">line</span>: <span class="number">1</span>,</div><div class="line">                <span class="attr">column</span>: <span class="number">4</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line"><span class="comment">// extract node.loc.start</span></div><div class="line"><span class="keyword">let</span> &#123; <span class="attr">loc</span>: &#123; <span class="attr">start</span>: localStart &#125;&#125; = node;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(localStart.line);   <span class="comment">// 1</span></div><div class="line"><span class="built_in">console</span>.log(localStart.column); <span class="comment">// 1</span></div></pre></td></tr></table></figure>
<p>이 버전의 코드에서 <code>node.loc.start</code>는 <code>localStart</code>라는 새로운 로컬 변수에 저장됩니다. <em>Destructuring</em> 패턴은 임의의 레벨 깊이로 중첩될 수 있으며 각 레벨에서 모든 기능을 사용할 수 있습니다.</p>
<p>객체 <em>Destructuring</em>은 매우 강력하고 많은 옵션을 가지고 있습니다. 그러나 <em>Array Destructuring</em>은 <em>Array</em>로부터 정보를 추출할 수 있는 몇 가지 독특한 기능을 제공합니다.</p>
<h3 id="Syntax-Gotcha"><a href="#Syntax-Gotcha" class="headerlink" title="Syntax Gotcha"></a>Syntax Gotcha</h3><p>부작용이 없는 문장을 실수로 생성할 수 있기 때문에 중첩된 <em>Destructuring</em>을 사용할 때는 주의해야 합니다. 빈 중괄호는 객체<em>Destructuring</em>에서 유효하지만 아무 것도 하지않습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 아무 변수도 선언하지 않았습니다.</span></div><div class="line"><span class="keyword">let</span> &#123; <span class="attr">loc</span>: &#123;&#125; &#125; = node;</div></pre></td></tr></table></figure>
<p>이 선언문에 선언된 바인딩이 없습니다. 오른쪽에 있는 중괄호로 인해 <code>loc</code>는 바인딩 만들기가 아닌 검사할 위치로 사용됩니다. 이 경우, 의도를 정의하기 위해 <code>:</code> 대신에 <em>Default</em> 값을 정의하는 <code>=</code>를 사용하는 것이 그럴듯합니다. 이 구문이 앞으로 유효하지 않을 가능성이 있지만, 현재로서는 이 부분을 주의해야합니다.</p>
<h2 id="Array-Destructuring"><a href="#Array-Destructuring" class="headerlink" title="Array Destructuring"></a>Array Destructuring</h2><p><em>Array Destructuring</em> 문법은 객체 <em>Destructuring</em>과 매우 비슷합니다. 객체 리터럴 구문 대신 <em>Array</em> 리터럴 구문을 사용합니다. <em>Destructuring</em>은 객체에서 사용 가능한 명명된 프로퍼티가 아니라 <em>Array</em> 내의 위치에 작동합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> colors = [ <span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span> ];</div><div class="line"></div><div class="line"><span class="keyword">let</span> [ firstColor, secondColor ] = colors;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(firstColor);        <span class="comment">// "red"</span></div><div class="line"><span class="built_in">console</span>.log(secondColor);       <span class="comment">// "green"</span></div></pre></td></tr></table></figure>
<p>여기서 <em>Destructuring Array</em>는 <code>colors</code> <em>Array</em>에서 <code>&quot;red&quot;</code>와 <code>&quot;green&quot;</code>값을 꺼내서 <code>firstColor</code>와 <code>secondColor</code> 변수에 저장합니다. 이러한 값은 <em>Array</em>에서의 위치 때문에 선택됩니다. 실제 변수 이름은 무엇이든 될 수 있습니다. <em>Destructuring</em> 패턴에서 명시적으로 언급되지 않은 항목은 무시됩니다. <em>Array</em> 자체는 어떤식으로든 변경되지 않는다는 것을 명심하십시오.</p>
<p><em>Destructuring</em> 패턴의 항목을 생략하고 관심있는 항목에 대해서만 변수 이름을 제공할 수도 있습니다. 예를 들어 <em>Array</em>의 세 번째 값만 원하면 첫 번째 및 두 번째 항목에 변수 이름을 제공할 필요가 없습니다. 방식은 다음과 같습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> colors = [ <span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span> ];</div><div class="line"></div><div class="line"><span class="keyword">let</span> [ , , thirdColor ] = colors;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(thirdColor);        <span class="comment">// "blue"</span></div></pre></td></tr></table></figure>
<p>이 코드는 <em>Destructuring</em> 할당을 사용하여 <code>colors</code>에서 세 번째 항목을 검색합니다. 패턴에서 <code>thirdColor</code> 앞에 오는 쉼표는 그앞에 오는 <em>Array</em> 항목의 자리 표시입니다. 이 접근법을 사용하면 변수 이름을 제공할 필요없이 <em>Array</em>의 중간에 있는 슬롯에서 값을 쉽게 선택할 수 있습니다.</p>
<blockquote>
<p>객체 <em>Destructuring</em> 과 마찬가지로 <em>Array Destructuring</em>을 <code>var</code>, <code>let</code> 또는 <code>const</code>로 사용할 때 항상 초기화를 해야 합니다.</p>
</blockquote>
<h3 id="Destructuring-할당-1"><a href="#Destructuring-할당-1" class="headerlink" title="Destructuring 할당"></a>Destructuring 할당</h3><p>할당에서 <em>Array Destructuring</em>을 사용할 수 있지만 객체 <em>Destructuring</em>과는 달리 괄호 안에 표현식을 감쌀 필요는 없습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> colors = [ <span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span> ],</div><div class="line">    firstColor = <span class="string">"black"</span>,</div><div class="line">    secondColor = <span class="string">"purple"</span>;</div><div class="line"></div><div class="line">[ firstColor, secondColor ] = colors;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(firstColor);        <span class="comment">// "red"</span></div><div class="line"><span class="built_in">console</span>.log(secondColor);       <span class="comment">// "green"</span></div></pre></td></tr></table></figure>
<p>이 코드에서 <em>Destructuring</em> 할당은 마지막 <em>Array Destructuring</em> 예제와 비슷한 방식으로 작동합니다. 유일한 차이점은 <code>firstColor</code>와 <code>secondColor</code>가 이미 정의되었다는 것입니다. 지금까지 설명한 내용이 <em>Array Destructuring</em> 할당에 대해 알아야할 것이 전부이지만 조금 더 유용한 내용이 있습니다.</p>
<p><em>Array Destructuring</em> 할당은 두변수의 값을 쉽게 바꿀 수있게 해주는 매우 독특한 사용 사례입니다. 값 교환은 정렬 알고리즘에서 일반적인 작업이며 ECMAScript 5 변수값 교환 방법은 아래 예제에서와 같이 세 번째 임시 변수를 사용합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ECMAScript 5에서 변수값 교환</span></div><div class="line"><span class="keyword">let</span> a = <span class="number">1</span>,</div><div class="line">    b = <span class="number">2</span>,</div><div class="line">    tmp;</div><div class="line"></div><div class="line">tmp = a;</div><div class="line">a = b;</div><div class="line">b = tmp;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(a);     <span class="comment">// 2</span></div><div class="line"><span class="built_in">console</span>.log(b);     <span class="comment">// 1</span></div></pre></td></tr></table></figure>
<p>임시변수 <code>tmp</code>는 <code>a</code>와 <code>b</code> 값을 교환하기 위해 필요합니다. 그러나 <em>Array Destructuring</em> 할당을 사용하면 추가 변수가 필요하지 않습니다. ECMAScript 6에서 변수를 교환하는 방법은 다음과 같습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ECMAScript 6에서 변수값 교환</span></div><div class="line"><span class="keyword">let</span> a = <span class="number">1</span>,</div><div class="line">    b = <span class="number">2</span>;</div><div class="line"></div><div class="line">[ a, b ] = [ b, a ];</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(a);     <span class="comment">// 2</span></div><div class="line"><span class="built_in">console</span>.log(b);     <span class="comment">// 1</span></div></pre></td></tr></table></figure>
<p>이 예제에서 <em>Destructuring Array</em>는 미러 이미지처럼 보입니다. 할당의 왼쪽(등호 앞에)은 다른 <em>Array Destructuring</em>의 예제와 마찬가지인 <em>Destructuring</em> 패턴입니다. 오른쪽은 교환에 대해 임시로 생성되는 <em>Array</em> 리터럴입니다. <em>Destructuring</em>은 임시 <em>Array</em>에서 발생합니다. 이 <em>Array</em>는 <code>b</code>와 <code>a</code> 값이 첫 번째와 두 번째 위치에 복사됩니다. 결과는 변수 값을 바꿉니다.</p>
<blockquote>
<p>객체의 <em>Destructuring</em> 할당과 마찬가지로 <em>Array</em>의 <em>Destructuring</em> 할당 표현식의 오른쪽이 <code>null</code> 또는 <code>undefined</code>로 평가되면 에러가 발생합니다.</p>
</blockquote>
<h3 id="Default-값-1"><a href="#Default-값-1" class="headerlink" title="Default 값"></a>Default 값</h3><p><em>Array Destructuring</em> 할당은 <em>Array</em>의 어느 위치에 대해서도 <em>Default</em> 값을 지정할 수 있게합니다. <em>Default</em> 값은 주어진 위치의 프로퍼티가 존재하지 않거나 <code>undefined</code> 값을 가질 때 사용됩니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> colors = [ <span class="string">"red"</span> ];</div><div class="line"></div><div class="line"><span class="keyword">let</span> [ firstColor, secondColor = <span class="string">"green"</span> ] = colors;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(firstColor);        <span class="comment">// "red"</span></div><div class="line"><span class="built_in">console</span>.log(secondColor);       <span class="comment">// "green"</span></div></pre></td></tr></table></figure>
<p>위 코드에서 <code>colors</code> <em>Array</em>에는 하나의 항목만 있으므로 <code>secondColor</code>가 일치하는 항목은 없습니다. 하지만 <em>Default</em> 값이 있기 때문에 <code>secondColor</code>는 <code>undefined</code> 대신에 <code>&quot;green&quot;</code>으로 설정됩니다.</p>
<h3 id="중첩된-Destructuring"><a href="#중첩된-Destructuring" class="headerlink" title="중첩된 Destructuring"></a>중첩된 Destructuring</h3><p>중첩된 객체를 <em>Destructuring</em>하는 것과 비슷한 방식으로 중첩된 <em>Array</em>를 <em>Destructuring</em> 시킬 수 있습니다. 전체 패턴에 다른 <em>Array</em> 패턴을 삽입하면 <em>Destructuring</em>은 다음과 같이 중첩 <em>Array</em>로 내려갑니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> colors = [ <span class="string">"red"</span>, [ <span class="string">"green"</span>, <span class="string">"lightgreen"</span> ], <span class="string">"blue"</span> ];</div><div class="line"></div><div class="line"><span class="comment">// later</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> [ firstColor, [ secondColor ] ] = colors;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(firstColor);        <span class="comment">// "red"</span></div><div class="line"><span class="built_in">console</span>.log(secondColor);       <span class="comment">// "green"</span></div></pre></td></tr></table></figure>
<p>여기서 <code>secondColor</code> 변수는 <code>colors</code> <em>Array</em> 안의 <code>&quot;green&quot;</code>값을 가리킵니다. 이 항목은 두 번째 <em>Array</em>에 포함되어 있으므로 <em>Destructuring</em> 패턴에서 <code>secondColor</code> 주위에 여분의 대괄호가 필요합니다. 객체와 마찬가지로 <em>Array</em>를 반복적으로 중첩시킬 수 있습니다.</p>
<h3 id="Rest-아이템"><a href="#Rest-아이템" class="headerlink" title="Rest 아이템"></a>Rest 아이템</h3><p>3 장에서는 함수에 대한 <em>Rest</em> 파라미터를 소개했고, <em>Array Destructuring</em>에는 <em>Rest</em> 아이템이라는 유사한 개념이 있습니다. <em>Rest</em> 아이템은 <code>...</code> 구문을 사용하여 <em>Array</em>의 나머지 아이템을 특정 변수에 지정합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> colors = [ <span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span> ];</div><div class="line"></div><div class="line"><span class="keyword">let</span> [ firstColor, ...restColors ] = colors;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(firstColor);        <span class="comment">// "red"</span></div><div class="line"><span class="built_in">console</span>.log(restColors.length); <span class="comment">// 2</span></div><div class="line"><span class="built_in">console</span>.log(restColors[<span class="number">0</span>]);     <span class="comment">// "green"</span></div><div class="line"><span class="built_in">console</span>.log(restColors[<span class="number">1</span>]);     <span class="comment">// "blue"</span></div></pre></td></tr></table></figure>
<p><code>colors</code>의 첫 번째 항목은 <code>firstColor</code>에 할당되고 나머지는 새로운 <code>restColors</code> <em>Array</em>에 할당됩니다. 그러므로<code>restColors</code> <em>Array</em>에는 두개의 항목, <code>&quot;green&quot;</code>과 <code>&quot;blue&quot;</code>가 입력됩니다. <em>Rest</em> 아이템은 <em>Array</em>에서 특정 아이템을 추출하고 나머지 아이템을 유지하는데 유용하지만 또 다른 유용한 용도가 있습니다.</p>
<p>JavaScript <em>Array</em>에서 눈에 띄지 않는 부분중 하나는 복제본을 쉽게 만들 수 있는 기능입니다. ECMAScript 5에서 개발자는 <em>Array</em>을 복제하는 쉬운 방법으로 <code>concat()</code> 메서드를 자주 사용했습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ECMAScript 5에서 Array 복제본 만들기</span></div><div class="line"><span class="keyword">var</span> colors = [ <span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span> ];</div><div class="line"><span class="keyword">var</span> clonedColors = colors.concat();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(clonedColors);      <span class="comment">//"[red,green,blue]"</span></div></pre></td></tr></table></figure>
<p><code>concat()</code> 메서드는 두개의 <em>Array</em>를 연결 하기위한 것이지만, 인자없이 호출하면 <em>Array</em>의 복제본을 반환합니다. ECMAScript 6에서는 <em>Rest</em> 아이템을 사용하여 같은 방식으로 작동하도록 할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ECMAScript 6에서 Array 복제본 만들기</span></div><div class="line"><span class="keyword">let</span> colors = [ <span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span> ];</div><div class="line"><span class="keyword">let</span> [ ...clonedColors ] = colors;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(clonedColors);      <span class="comment">//"[red,green,blue]"</span></div></pre></td></tr></table></figure>
<p>이 예제에서 <em>Rest</em> 아이템은 <code>colors</code> <em>Array</em>의 값을 <code>clonedColors</code> <em>Array</em>에 복제하는데 사용됩니다. 이 기법이 <code>concat()</code> 메서드를 사용하는 것보다 개발자의 의도를 더 명확하게 하는지 여부에 대한 문제는 있지만 유용한 기능입니다.</p>
<blockquote>
<p><em>Rest</em> 아이템은 <em>Destructuring Array</em>의 마지막 엔트리여야하며 뒤에 쉼표를 붙일 수 없습니다. <em>Rest</em> 아이템 뒤에 쉼표를 포함시키면 구문 오류가 발생합니다.</p>
</blockquote>
<h2 id="혼합된-Destructuring"><a href="#혼합된-Destructuring" class="headerlink" title="혼합된 Destructuring"></a>혼합된 Destructuring</h2><p>객체와 <em>Array Destructuring</em>은 더 복잡한 표현식을 만들기 위해 함께 사용될 수 있습니다. 이렇게하면 객체와 <em>Array</em>을 혼합하여 원하는 정보만 추출할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> node = &#123;</div><div class="line">        <span class="attr">type</span>: <span class="string">"Identifier"</span>,</div><div class="line">        <span class="attr">name</span>: <span class="string">"foo"</span>,</div><div class="line">        <span class="attr">loc</span>: &#123;</div><div class="line">            <span class="attr">start</span>: &#123;</div><div class="line">                <span class="attr">line</span>: <span class="number">1</span>,</div><div class="line">                <span class="attr">column</span>: <span class="number">1</span></div><div class="line">            &#125;,</div><div class="line">            <span class="attr">end</span>: &#123;</div><div class="line">                <span class="attr">line</span>: <span class="number">1</span>,</div><div class="line">                <span class="attr">column</span>: <span class="number">4</span></div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">range</span>: [<span class="number">0</span>, <span class="number">3</span>]</div><div class="line">    &#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> &#123;</div><div class="line">    <span class="attr">loc</span>: &#123; start &#125;,</div><div class="line">    <span class="attr">range</span>: [ startIndex ]</div><div class="line">&#125; = node;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(start.line);        <span class="comment">// 1</span></div><div class="line"><span class="built_in">console</span>.log(start.column);      <span class="comment">// 1</span></div><div class="line"><span class="built_in">console</span>.log(startIndex);        <span class="comment">// 0</span></div></pre></td></tr></table></figure>
<p>이 코드는 <code>node.loc.start</code>와 <code>node.range[0]</code>을 <code>start</code>와 <code>startIndex</code>로 각각 추출합니다. <em>Destructuring</em> 패턴의 <code>loc:</code>과 <code>range:</code>는 <code>node</code> 객체의 프로퍼티에 해당하는 위치에 지나지 않습니다. 객체와 <em>Array Destructuring</em>의 조합을 사용할 때 <code>node</code>에서 <em>Destructuring</em>을 사용하여 모두 추출 가능합니다. 이 방법은 전체 구조를 탐색하지 않고도 JSON 설정에서 값을 가져 오는데 특히 유용합니다.</p>
<h2 id="Destructuring-파라미터"><a href="#Destructuring-파라미터" class="headerlink" title="Destructuring 파라미터"></a>Destructuring 파라미터</h2><p><em>Destructuring</em>은 특히 유용한 유스케이스를 가지고 있으며, 그것은 함수 파라미터를 전달할 때입니다. JavaScript 함수가 많은 수의 <em>Optional</em>  파라미터를 가질때의 공통 패턴은 다음과 같이 추가 파라미터를 지정하는 프로퍼티가 있는 <code>options</code> 객체를 만드는 것입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// options의 프로퍼티는 추가 파라미터를 나타냅니다.</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params">name, value, options</span>) </span>&#123;</div><div class="line"></div><div class="line">    options = options || &#123;&#125;;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> secure = options.secure,</div><div class="line">        path = options.path,</div><div class="line">        domain = options.domain,</div><div class="line">        expires = options.expires;</div><div class="line"></div><div class="line">    <span class="comment">// code to set the cookie</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 세 번째 파라미터가 options에 매핑됩니다.</span></div><div class="line">setCookie(<span class="string">"type"</span>, <span class="string">"js"</span>, &#123;</div><div class="line">    <span class="attr">secure</span>: <span class="literal">true</span>,</div><div class="line">    <span class="attr">expires</span>: <span class="number">60000</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>많은 JavaScript 라이브러리에는 위 예제와 비슷한 <code>setCookie()</code> 함수를 가지고 있습니다. 이 함수에서 <code>name</code>과 <code>value</code> 파라미터는 있지만 <code>secure</code>, <code>path</code>, <code>domain</code>, <code>expires</code>는 없습니다. 다른 데이터에 대한 우선 순위가 없으므로 이름이 붙은 속성을 가진 <code>options</code> 객체를 파라미터로 받는 것은 효율적입니다. 하지만 이 접근 방식은 잘 작동하지만 함수 정의를 보면 함수가 예상하는 입력을 알 수 없고 함수 본문을 봐야합니다.</p>
<p><em>Destructured</em> 파라미터는 함수가 예상하는 인수를 명확하게 하는 대안을 제공합니다. <em>Destructured</em> 파라미터는 명명된 파라미터 대신에 객체 또는 <em>Array Destructuring</em> 패턴을 사용합니다. 이것을 실제로 보기위해 <code>setCookie()</code> 함수를 다시 작성해 보겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params">name, value, &#123; secure, path, domain, expires &#125;</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// code to set the cookie</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">setCookie(<span class="string">"type"</span>, <span class="string">"js"</span>, &#123;</div><div class="line">    <span class="attr">secure</span>: <span class="literal">true</span>,</div><div class="line">    <span class="attr">expires</span>: <span class="number">60000</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>이 함수는 이전 예제와 비슷하게 동작하지만, 이제는 세 번째 파라미터가 <em>Destructuring</em>을 사용하여 필요한 데이터를 추출합니다. <em>Destructured</em> 파라미터 밖의 파라미터는 명확하게 예상되는 동시에 <code>setCookie()</code>를 사용하는 사람에게는 여분의 인수로 <code>options</code>를 사용할 수 있다는 것을 분명히합니다. 물론 세 번째 파라미터가 필요한 경우에는 그 값을 명확히 해야합니다. <em>Destructured</em> 파라미터는 전달되지 않는 경우 <code>undefined</code>로 설정된다는 점에서 일반 파라미터 처럼 작동합니다.</p>
<p><em>Destructured</em> 파라미터는 지금까지 이 장에서 배웠던 <em>Destructuring</em>의 모든 기능을 가지고 있습니다. <em>Default</em> 값, 혼합 객체 및 <em>Array</em> 패턴을 사용할 수 있으며, 읽고있는 프로퍼티 이름과 다른 변수 이름을 사용할 수 있습니다.</p>
<h3 id="Destructured-파라미터는-필수-항목-입니다"><a href="#Destructured-파라미터는-필수-항목-입니다" class="headerlink" title="Destructured 파라미터는 필수 항목 입니다."></a>Destructured 파라미터는 필수 항목 입니다.</h3><p><em>Destructured</em> 파라미터의 한가지 단점은 기본적으로 함수 호출에서 파라미터가 제공되지 않으면 오류가 발생한다는 것입니다. 예를 들어, 마지막 예제에서 <code>setCookie()</code> 함수를 아래와 같이 호출하면 에러가 발생합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Error!</span></div><div class="line">setCookie(<span class="string">"type"</span>, <span class="string">"js"</span>);</div></pre></td></tr></table></figure>
<p>세 번째 파라미터가 누락되어 예상대로 <code>undefined</code>으로 평가됩니다. 이것은 <em>Destructured</em> 파라미터가 <em>Destructuring</em> 선언의 축약이기 때문에 오류가 발생합니다. <code>setCookie()</code> 함수가 호출될 때, JavaScript 엔진은 실제로 아래와 같이 수행합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params">name, value, options</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> &#123; secure, path, domain, expires &#125; = options;</div><div class="line"></div><div class="line">    <span class="comment">// code to set the cookie</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>오른쪽 표현식이 <code>null</code> 또는 <code>undefined</code>로 평가될 때 <em>Destructuring</em>은 에러를 던지기 때문에 세 번째 파라미터가 <code>setCookie()</code>함수에 전달되지 않을 때도 마찬가지입니다.</p>
<p><em>Destructured</em> 파라미터가 필요하다면 이 동작이 문제가 되지 않습니다. 그러나 <em>Destructured</em> 파라미터를 <em>Optional</em>로 하고 싶다면 다음과 같이 <em>Destructured</em> 파라미터에 <em>Default</em> 값을 제공하면 이 문제를 해결할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params">name, value, &#123; secure, path, domain, expires &#125; = &#123;&#125;</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>이 예제는 새로운 객체를 세 번째 파라미터의 <em>Default</em> 값으로 제공합니다. <code>setCookie()</code>의 세 번째 파라미터인 <em>Destructured</em> 파라미터에 <em>Default</em> 값을 지정하면 <code>secure</code>, <code>path</code>, <code>domain</code>, <code>expires</code>는 <code>undefined</code>가 제공되며 오류가 발생하지 않습니다.</p>
<h3 id="Destructuring-파라미터의-Default-값"><a href="#Destructuring-파라미터의-Default-값" class="headerlink" title="Destructuring 파라미터의 Default 값"></a>Destructuring 파라미터의 <em>Default</em> 값</h3><p><em>Destructured</em> 파라미터에 <em>Default</em> 값을 지정할 수 있습니다. 파라미터에 등호를 추가하고 <em>Default</em> 값을 지정하면됩니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params">name, value,</span></span></div><div class="line">    &#123;</div><div class="line">        secure = false,</div><div class="line">        path = <span class="string">"/"</span>,</div><div class="line">        domain = <span class="string">"example.com"</span>,</div><div class="line">        expires = new Date(Date.now() + 360000000)</div><div class="line">    &#125; = &#123;&#125;</div><div class="line">) &#123;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><em>Destructured</em> 파라미터의 각 프로퍼티는 이 코드에서 <em>Default</em> 값을 가지므로 올바른 값을 사용하기 위해 주어진 프로퍼티가 포함되었는지 확인하는 것을 피할 수 있습니다. 또한, 전체 <em>Destructured</em> 파라미터는 빈 객체의 기본값을 가지며, 파라미터는 <em>Optional</em> 입니다. 이렇게 하면 함수 선언이 평소보다 약간 더 복잡해 보이지만 각 파라미터에 사용할 수있는 값이 있는지 확인하는데 드는 비용이 더 적습니다.</p>
<h2 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h2><p><em>Destructuring</em>은 JavaScript에서 객체와 <em>Array</em>로 작업하는 것을 더 쉽게 만듭니다. 익숙한 객체 리터럴 및 <em>Array</em> 리터럴 구문을 사용하면 관심있는 정보만 얻을 수 있는 데이터 구조를 선택할 수 있습니다. 객체 패턴을 사용하면 객체에서 데이터를 추출할 수 있으며 <em>Array</em> 패턴을 사용하면 <em>Array</em>에서 데이터를 추출할 수 있습니다.</p>
<p>객체와 <em>Array Destructuring</em>은 <code>undefined</code>인 프로퍼티나 항목에 대해 <em>Default</em> 값을 지정할 수 있으며, 할당의 오른쪽이 <code>null</code> 또는<br> <code>undefined</code>로 평가되면 오류를 던집니다. 임의의 깊이로 내림차순으로 오브젝트와 <em>Array Destructuring</em>을 사용하여 깊이 중첩된 데이터 구조를 탐색할 수도 있습니다.</p>
<p><em>Destructuring</em> 선언은 변수를 만들기 위해 <code>var</code>, <code>let</code> 또는 <code>const</code>를 사용하며 항상 초기화를 해야합니다. <em>Destructuring</em> 할당은 다른 할당 대신에 사용되며, 객체 프로퍼티와 이미 존재하는 변수로 분해할 수 있습니다.</p>
<p><em>Destructured</em> 파라미터는 <em>Destructuring</em> 구문을 사용하여 함수 파라미터로 사용될 때 <code>&quot;options&quot;</code>객체를 더 투명하게 만듭니다. 관심있는 실제 데이터를 다른 명명된 파라미터와 함께 나열할 수 있습니다. <em>Destructured</em> 파라미터는 <em>Array</em> 패턴, 오브젝트 패턴 또는 혼합 패턴이 될 수 있으며 <em>Destructuring</em>의 모든 기능을 사용할 수 있습니다.</p>
<hr>
<blockquote>
<p>이 내용은 나중에 참고하기 위해 제가 공부하며 정리한 내용입니다.<br>의역, 오역, 직역이 있을 수 있음을 알려드립니다.<br>This post is a translation of this original article [<a href="https://leanpub.com/understandinges6/read#leanpub-auto-destructuring-for-easier-data-access" target="_blank" rel="external">https://leanpub.com/understandinges6/read#leanpub-auto-destructuring-for-easier-data-access</a>]</p>
</blockquote>
<h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul>
<li><a href="https://infoscis.github.io/2018/01/24/ecmascript-6-block-binding/">ECMAScript 6 Block Binding</a></li>
<li><a href="https://infoscis.github.io/2018/01/24/ecmascript-6-strings-and-regular-expressions/">ECMAScript 6 문자열과 정규 표현식</a></li>
<li><a href="https://infoscis.github.io/2018/01/24/ecmascript-6-functions/">ECMAScript 6 함수</a></li>
<li><a href="https://infoscis.github.io/2018/01/25/ecmascript-6-expanded-object-functionality/">ECMAScript 6 객체의 확장된 기능</a></li>
<li><a href="https://infoscis.github.io/2018/01/26/ecmascript-6-destructuring-for-easier-data-access/">ECMAScript 6 쉬운 데이터 액세스를 위한 Destructuring</a></li>
<li><a href="https://infoscis.github.io/2018/01/27/ecmascript-6-symbols-and-symbol-properties/">ECMAScript 6 Symbol과 Symbol 프로퍼티</a></li>
<li><a href="https://infoscis.github.io/2018/01/27/ecmascript-6-sets-and-maps/">ECMAScript 6 Set과 Map</a></li>
<li><a href="https://infoscis.github.io/2018/01/31/ecmascript-6-iterators-and-generators/">ECMAScript 6 Iterator와 Generator</a></li>
<li><a href="https://infoscis.github.io/2018/02/13/ecmascript-6-introducing-javascript-classes/">ECMAScript 6 JavaScript 클래스 소개</a></li>
<li><a href="https://infoscis.github.io/2018/02/13/ecmascript-6-improved-array-capabilities/">ECMAScript 6 Array 기능 향상</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-promises-and-asynchronous-programming/">ECMAScript 6 Promise와 비동기 프로그램밍</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-proxies-and-the-reflection-api/">ECMAScript 6 프록시와 리플렉션 API</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-encapsulating-code-with-modules/">ECMAScript 6 Module로 코드 캡슐화하기</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-appendix-a-smaller-changes/">ECMAScript 6 부록 A. 작은 변경 사항</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-appendix-b-understanding-ecmascript-7/">ECMAScript 6 부록 B. ECMAScript 7(2016) 이해하기</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;쉬운-데이터-액세스를-위한-Destructuring&quot;&gt;&lt;a href=&quot;#쉬운-데이터-액세스를-위한-Destructuring&quot; class=&quot;headerlink&quot; title=&quot;쉬운 데이터 액세스를 위한 Destructuring&quot;&gt;&lt;/a&gt;쉬운
    
    </summary>
    
      <category term="JavaScript" scheme="http://infoscis.github.io/categories/JavaScript/"/>
    
      <category term="ECMAScript 2015" scheme="http://infoscis.github.io/categories/JavaScript/ECMAScript-2015/"/>
    
    
      <category term="JavaScript" scheme="http://infoscis.github.io/tags/JavaScript/"/>
    
      <category term="ECMAScript 2015" scheme="http://infoscis.github.io/tags/ECMAScript-2015/"/>
    
  </entry>
  
  <entry>
    <title>ECMAScript 6 객체의 확장된 기능</title>
    <link href="http://infoscis.github.io/2018/01/25/ecmascript-6-expanded-object-functionality/"/>
    <id>http://infoscis.github.io/2018/01/25/ecmascript-6-expanded-object-functionality/</id>
    <published>2018-01-25T14:51:56.000Z</published>
    <updated>2018-02-27T14:12:12.901Z</updated>
    
    <content type="html"><![CDATA[<h1 id="객체의-확장된-기능"><a href="#객체의-확장된-기능" class="headerlink" title="객체의 확장된 기능"></a>객체의 확장된 기능</h1><p>ECMAScript 6은 객체의 유용성을 향상 시키는데 중점을 두고 있습니다. 이것은 JavaScript의 거의 모든 값이 어떤 유형의 객체이기 때문에 의미가 있습니다. 또한 JavaScript 프로그램에 평균적으로 사용되는 객체의 수는 JavaScript 응용 프로그램의 복잡성이 증가함에 따라 계속 증가하고 있습니다. 이는 복잡한 프로그램이 항상 더 많은 객체를 생성한다는 것을 의미합니다. 객체가 많을수록 객체를 보다 효과적으로 사용할 필요성이 커집니다.</p>
<p>ECMAScript 6는 간단한 구문 확장부터 조작 및 상호 작용을 위한 옵션에 이르기까지 다양한 방법으로 객체의 사용성을 향상시킵니다.</p>
<h2 id="객체-카테고리-Object-Category"><a href="#객체-카테고리-Object-Category" class="headerlink" title="객체 카테고리 (Object Category)"></a>객체 카테고리 (Object Category)</h2><p>JavaScript는 브라우저나 Node.js와 같은 실행 환경에 의해 추가된 것과 다르게, 표준에 정의된 객체를 설명하기 위해 여러 용어를 사용하며, ECMAScript 6 사양은 이러한 객체의 각 카테고리에 대한 명확한 정의를 가지고 있습니다.</p>
<p>또한 언어 전체를 잘 이해하려면 이러한 용어를 이해하는 것이 매우 중요합니다. 객체의 카테고리는 다음과 같습니다.</p>
<ul>
<li><em>평범한 객체(Ordinary object)</em>는 JavaScript의 객체에 대한 모든 기본 내부 동작을 가집니다.</li>
<li><em>특수한 객체(Exotic object)</em>는 어떤면에서 기본과 다른 내부 동작이 있습니다.</li>
<li><em>표준 객체(Standard object)</em>는 <code>Array</code>, <code>Date</code>등과 같이 ECMAScript 6에 의해 정의된 객체입니다. 표준 객체는 평범하거나 특이할 수 있습니다.</li>
<li><em>Built-in 객체</em>는 스크립트가 실행되기 시작하면 JavaScript 실행 환경에 존재하게 됩니다. 모든 표준 객체는 Built-in 객체입니다.</li>
</ul>
<p>ECMAScript 6에 정의된 다양한 객체를 설명하기 위해 위의 용어를 사용합니다.</p>
<h2 id="객체-리터럴-문법-확장"><a href="#객체-리터럴-문법-확장" class="headerlink" title="객체 리터럴 문법 확장"></a>객체 리터럴 문법 확장</h2><p>객체 리터럴은 JavaScript에서 가장 인기있는 패턴 중 하나입니다. 구문에 따라 작성된 JSON은 인터넷의 거의 모든 JavaScript 파일에 있습니다. 객체 리터럴은 여러줄의 코드를 필요로하는 객체를 만드는 간결한 구문이기 때문에 매우 유용합니다. 다행히도 개발자를 위해 ECMAScript 6은 여러 가지 방법으로 구문을 확장하여 객체 리터럴을 더욱 강력하고 간결하게 만듭니다.</p>
<h3 id="프로퍼티-초기화-단축-Property-Initializer-Shorthand-기능"><a href="#프로퍼티-초기화-단축-Property-Initializer-Shorthand-기능" class="headerlink" title="프로퍼티 초기화 단축 (Property Initializer Shorthand) 기능"></a>프로퍼티 초기화 단축 (Property Initializer Shorthand) 기능</h3><p>ECMAScript 5 및 이전 버전에서 객체 리터럴은 단순히 name-value 쌍의 모음이었습니다. 즉, 값을 초기화할 때 중복이 있을 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">name</span>: name,</div><div class="line">        <span class="attr">age</span>: age</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>createPerson()</code> 함수는 프로퍼티 이름이 함수 파라미터 이름과 같은 객체를 생성합니다. 하나는 객체 프로퍼티의 이름이고 다른 하나는 그 프로퍼티에 대한 값을 제공하지만 결과는 <code>name</code>과 <code>age</code>의 중복으로 나타납니다. 리턴 객체의 키 <code>name</code>에는 파라미터 <code>name</code> 값이 할당되고 키 <code>age</code>에는 파라미터 <code>age</code>의 값이 할당됩니다.</p>
<p>ECMAScript 6에서는 프로퍼티 초기화의 단축(Property Initializer Shorthand)을 사용하여 프로퍼티 이름과 로컬 변수에 존재하는 중복을 제거할 수 있습니다. 객체 프로퍼티 이름이 로컬 변수 이름과 같으면 콜론과 값 없이 <code>name</code>을 포함할 수 있습니다. 예를 들어, <code>createPerson()</code>은 다음과 같이 ECMAScript 6으로 재작성할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        name,</div><div class="line">        age</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>객체 리터럴의 프로퍼티에 이름만 있으면 JavaScript 엔진은 Scope내의 같은 이름의 변수를 조사합니다. 변수를 찾으면 해당 변수의 값이 객체 리터럴의 동일한 이름에 지정됩니다. 위 예제에서, 객체 리터럴 프로퍼티 <code>name</code>에는 로컬 변수 <code>name</code>의 값이 할당됩니다.</p>
<p>이러한 확장 기능은 객체 리터럴 초기화를 훨씬 간결하게 만들고 명명 오류를 제거하는데 도움이됩니다. 로컬 변수와 같은 이름의 프로퍼티를 할당하는 것은 JavaScript에서 매우 빈번히 발견되는 패턴이므로 이런 확장기능은 환영할만 합니다.</p>
<h3 id="간결한-메서드-Concise-Method"><a href="#간결한-메서드-Concise-Method" class="headerlink" title="간결한 메서드 (Concise Method)"></a>간결한 메서드 (Concise Method)</h3><p>또한 ECMAScript 6은 메서드를 객체 리터럴에 할당하는 구문을 향상시켰습니다. ECMAScript 5 및 이전 버전에서는 다음과 같이 이름을 먼저 지정하고 함수 정의를 지정하여 객체에 메서드를 추가해야합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">"Nicholas"</span>,</div><div class="line">    <span class="attr">sayName</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>ECMAScript 6에서는 콜론 및 <code>function</code> 키워드를 제거하여 구문을 보다 간결하게 만듭니다. 이전 예제를 다음과 같이 다시 작성할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">"Nicholas"</span>,</div><div class="line">    sayName() &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>간결한 메서드 (Concise Method) 구문 이라고 하는 이 단축 구문은 앞의 예와 마찬가지로 <code>person</code> 객체에 대한 메서드를 만듭니다. <code>sayName()</code> 프로퍼티는 익명의 함수에 할당되며 ECMAScript 5 <code>sayName()</code> 함수와 동일한 특성을 가지고 있습니다. 한가지 차이점은 간결한 메서드 (Concise Method) 구문은 <code>super</code>(“super 참조를 사용한 쉬운 프로토 타입 액세스”섹션에서 나중에 설명합니다.)를 사용하는 반면 간결하지 않는 방법은 사용할 수 없다는 점입니다.</p>
<blockquote>
<p>간결한 메서드 (Concise Method) 구문을 사용하여 생성된 메서드의 <code>name</code> 프로퍼티는 괄호 앞에 사용된 이름입니다. 마지막 예제에서 <code>person.sayName()</code>의 <code>name</code> 프로퍼티는 “sayName”입니다.</p>
</blockquote>
<h3 id="프로퍼티의-계산된-이름"><a href="#프로퍼티의-계산된-이름" class="headerlink" title="프로퍼티의 계산된 이름"></a>프로퍼티의 계산된 이름</h3><p>ECMAScript 5 및 이전 버전에서는 프로퍼티를 점 표기 대신 대괄호로 설정하면 객체 인스턴스의 프로퍼티 이름을 계산하여 지정할 수 있었습니다. 대괄호를 사용하여 변수의 식별자를 사용하면, 구문 오류가 발생할 수 있는 문자가 포함된 문자열 및 문자열 리터럴을 사용하여 프로퍼티 이름을 지정할 수 있습니다. 아래 예제를 살펴보겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;&#125;,</div><div class="line">    lastName = <span class="string">"last name"</span>;</div><div class="line"></div><div class="line">person[<span class="string">"first name"</span>] = <span class="string">"Nicholas"</span>;</div><div class="line">person[lastName] = <span class="string">"Zakas"</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person[<span class="string">"first name"</span>]);      <span class="comment">// "Nicholas"</span></div><div class="line"><span class="built_in">console</span>.log(person[lastName]);          <span class="comment">// "Zakas"</span></div></pre></td></tr></table></figure>
<p><code>lastName</code>에 <code>&quot;last name&quot;</code> 값이 할당되어 이 예제의 두 프로퍼티 이름 모두 공백을 사용합니다. 그러므로 점 표기법을 사용하여 프로퍼티 이름을 참조할 수 없습니다. 그러나 대괄호 표기법을 사용하면 모든 문자열 값을 프로퍼티 이름으로 사용할 수 있으므로 <code>&quot;first name&quot;</code>을 <code>&quot;Nicholas&quot;</code>에 할당하고, <code>&quot;last name&quot;</code>을 “Zakas”에 할당하면 정상 실행됩니다.</p>
<p>또한 아래와 같이 문자열 리터럴을 객체 리터럴의 프로퍼티 이름으로 직접 사용할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">    <span class="string">"first name"</span>: <span class="string">"Nicholas"</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person[<span class="string">"first name"</span>]);      <span class="comment">// "Nicholas"</span></div></pre></td></tr></table></figure>
<p>이 패턴은 미리 알려진 프로퍼티 이름에 적용되며 문자열 리터럴로 나타낼 수 있습니다. 그러나 프로퍼티 이름 <code>&quot;first name&quot;</code>이 변수에 포함되어 있거나 (앞의 예에서와 같이) 계산되어야 하는 경우 ECMAScript 5에서 객체 리터럴을 사용하여 해당 프로퍼티를 정의할 수 있는 방법이 없습니다.</p>
<p>ECMAScript 6에서 계산된 프러퍼티 이름은 객체 리터럴 구문의 일부이며 객체 인스턴스에서 계산된 프로퍼티 이름을 참조하는데 사용된 동일한 대괄호 표기법을 사용합니다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> lastName = <span class="string">"last name"</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">    <span class="string">"first name"</span>: <span class="string">"Nicholas"</span>,</div><div class="line">    [lastName]: <span class="string">"Zakas"</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person[<span class="string">"first name"</span>]);      <span class="comment">// "Nicholas"</span></div><div class="line"><span class="built_in">console</span>.log(person[lastName]);          <span class="comment">// "Zakas"</span></div></pre></td></tr></table></figure>
<p>객체 리터럴 안의 대괄호는 속성 이름이 계산됨을 나타내므로 내용이 문자열로 평가됩니다. 즉, 다음과 같이 표현식을 포함할 수도 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> suffix = <span class="string">" name"</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">    [<span class="string">"first"</span> + suffix]: <span class="string">"Nicholas"</span>,</div><div class="line">    [<span class="string">"last"</span> + suffix]: <span class="string">"Zakas"</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person[<span class="string">"first name"</span>]);      <span class="comment">// "Nicholas"</span></div><div class="line"><span class="built_in">console</span>.log(person[<span class="string">"last name"</span>]);       <span class="comment">// "Zakas"</span></div></pre></td></tr></table></figure>
<p>이러한 속성은 “first name”과 “last name”으로 평가되며 나중에 이 문자열을 사용하여 프로퍼티를 참조할 수 있습니다. 객체 인스턴스에 대괄호 표기법을 사용하면, 객체 리터럴 내에서 계산된 프로퍼티 이름으로 적용되기 때문에 어떤것 이든 대괄호 안에 넣을 수 있습니다.</p>
<h2 id="새로운-메서드들"><a href="#새로운-메서드들" class="headerlink" title="새로운 메서드들"></a>새로운 메서드들</h2><p>ECMAScript가 ECMAScript 5를 시작할때 디자인한 목표 중 하나는 <code>Object.prototype</code>에 새로운 전역 함수 또는 메서드를 만드는 것을 피하고 대신 새 메서드를 사용할 수 있는 객체를 찾으려고 했습니다. 결과적으로, Global <code>Object</code>는 다른 오브젝트가 더 적합하지 않을 때 점점 많은 메서드가 추가되었습니다. ECMAScript 6에서는 특정 작업을 보다 쉽게하기 위해 디자인된 Global <code>Object</code>에 몇 가지 새로운 메서드를 도입했습니다.</p>
<h3 id="Object-is-메서드"><a href="#Object-is-메서드" class="headerlink" title="Object.is() 메서드"></a>Object.is() 메서드</h3><p>JavaScript에서 두 값을 비교하고자 할 때, <code>==</code>(equals 연산자) 또는 <code>===</code>(Identically equals 연산자)를 사용하는 데 익숙합니다. 많은 개발자들이 비교하는 동안 타입 강제(Type coercion)를 피하기 위해 후자를 선호합니다. 그러나 <code>===</code> 연산자조차도 완전히 정확하지는 않습니다. 예를 들어, +0과 -0 값은 JavaScript 엔진에서 다르게 표현 되더라도 <code>===</code>는 같은 값으로 간주됩니다. 또한 <code>NaN === NaN</code>은 <code>false</code>를 반환합니다. <code>NaN</code> 프로퍼티를 적절히 감지하기 위해서는 <code>isNaN()</code>을 사용해야합니다.</p>
<p>ECMAScript 6는 Identically equals 연산자의 단점을 보충하기 위해 <code>Object.is()</code> 메서드를 도입했습니다. 이 메서드는 두 개의 파라미터를 받아들여 값이 동일하면 true를 리턴합니다. 두 값은 동일한 타입이고 동일한 값을 가질 때 동등한 것으로 간주됩니다. 여기 몇 가지 예제를 살펴보겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(+<span class="number">0</span> == <span class="number">-0</span>);              <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(+<span class="number">0</span> === <span class="number">-0</span>);             <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(+<span class="number">0</span>, <span class="number">-0</span>));     <span class="comment">// false</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> == <span class="literal">NaN</span>);            <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> === <span class="literal">NaN</span>);           <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>));   <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="number">5</span> == <span class="number">5</span>);                <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="number">5</span> == <span class="string">"5"</span>);              <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="number">5</span> === <span class="number">5</span>);               <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="number">5</span> === <span class="string">"5"</span>);             <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="number">5</span>, <span class="number">5</span>));       <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="number">5</span>, <span class="string">"5"</span>));     <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p>대부분의 경우 <code>Object.is()</code>는 <code>===</code> 연산자와 똑같이 작동합니다. 유일한 차이점은 <code>+0</code>과 <code>-0</code>이 동등하지 않은 것으로 간주되고 <code>NaN</code>이 <code>NaN</code>과 같은 것으로 간주된다는 것입니다. 그렇기 때문에 Equal 연산자 사용을 중지할 필요는 없습니다. 위와 같이 특수한 경우에 <code>==</code> 또는 <code>===</code> 대신 <code>Object.is()</code> 사용을 선택할 수도 있습니다.</p>
<h3 id="Object-assign-메서드"><a href="#Object-assign-메서드" class="headerlink" title="Object.assign() 메서드"></a>Object.assign() 메서드</h3><p>Mixin은 JavaScript에서 객체 구성을 위한 가장 인기있는 패턴 중 하나입니다. Mixin에서 한 객체는 다른 객체에서 프로퍼티와 메서드를 받습니다. 많은 JavaScript 라이브러리에는 다음과 유사한 Mixin 메서드가 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mixin</span>(<span class="params">receiver, supplier</span>) </span>&#123;</div><div class="line">    <span class="built_in">Object</span>.keys(supplier).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</div><div class="line">        receiver[key] = supplier[key];</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> receiver;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>mixin()</code> 함수는 <code>supplier</code> 자신의 프로퍼티를 반복하여 <code>receiver</code>에 복사합니다 (얕은 복사, 프로퍼티 값이 객체 일 때 객체 참조가 공유됩니다). 이렇게하면 아래 코드와 같이 <code>receiver</code>가 상속 없이 새 프로퍼티를 얻을 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">EventTarget</span>(<span class="params"></span>) </span>&#123; <span class="comment">/*...*/</span> &#125;</div><div class="line">EventTarget.prototype = &#123;</div><div class="line">    <span class="attr">constructor</span>: EventTarget,</div><div class="line">    <span class="attr">emit</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">/*...*/</span> &#125;,</div><div class="line">    <span class="attr">on</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">/*...*/</span> &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> myObject = &#123;&#125;;</div><div class="line">mixin(myObject, EventTarget.prototype);</div><div class="line"></div><div class="line">myObject.emit(<span class="string">"somethingChanged"</span>);</div></pre></td></tr></table></figure>
<p>위 코드에서 <code>myObject</code>는 <code>EventTarget.prototype</code> 객체로부터 메서드를 받습니다. 이것은 <code>myObject</code>에게 이벤트를 퍼블리시하고 <code>emit()</code>과 <code>on()</code>메서드를 사용하여 이벤트를 구독하는 기능을 제공합니다.</p>
<p>이 패턴은 ECMAScript 6가 <code>Object.assign()</code> 메서드를 추가할 만큼 충분히 대중적이되어, 같은 방식으로 동작하고, Receiver 와 임의의 Supplier를 받아 들인 다음 Receiver를 반환합니다. <code>mixin()</code>에서 <code>assign()</code>으로 이름을 바꾸면 실제 작업이 반영됩니다. <code>mixin()</code>함수는 대입 연산자(<code>=</code>)를 사용하기 때문에 접근자(accessor) 프로퍼티를 접근자(accessor) 프로퍼티로 Receiver에 복사할 수 없습니다. 이러한 차이를 반영하기 위해 <code>Object.assign()</code>이라는 이름이 선택되었습니다.</p>
<blockquote>
<p>다양한 라이브러리에서 동일한 기능을 수행하는 비슷한 메서드가 있을 수 있으며 대부분 <code>extend()</code>및 <code>mix()</code>을 사용합니다. ECMAScript 6에는 <code>Object.assign()</code> 메서드 외에도 <code>Object.mixin()</code> 메서드가 있습니다. 가장 큰 차이점은 <code>Object.mixin()</code>도 접근자 프로퍼티를 이용해 복사되었지만 super (이 장의 “Super 참조를 이용한 쉬운 프로토 타입 액세스”절에서 설명 함) 사용에 대한 우려로 이 메서드가 제거 되었습니다.</p>
</blockquote>
<p><code>mixin()</code> 함수가 사용된 곳이면 어디에서나 <code>Object.assign()</code>을 사용할 수 있습니다. 다음 코드는 그러한 예제입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">EventTarget</span>(<span class="params"></span>) </span>&#123; <span class="comment">/*...*/</span> &#125;</div><div class="line">EventTarget.prototype = &#123;</div><div class="line">    <span class="attr">constructor</span>: EventTarget,</div><div class="line">    <span class="attr">emit</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">/*...*/</span> &#125;,</div><div class="line">    <span class="attr">on</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">/*...*/</span> &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> myObject = &#123;&#125;</div><div class="line"><span class="built_in">Object</span>.assign(myObject, EventTarget.prototype);</div><div class="line"></div><div class="line">myObject.emit(<span class="string">"somethingChanged"</span>);</div></pre></td></tr></table></figure>
<p><code>Object.assign()</code> 메서드는 여러 <code>Supplier</code>를 받아들이며 <code>Receiver</code>는 <code>Supplier</code>가 지정된 순서대로 프로퍼티를 수신합니다. 이는 두 번째 <code>Supplier</code>가 <code>Receiver</code>의 첫 번째 <code>Supplier</code>의 값을 덮어 쓸 수 있음을 의미합니다. 다음 코드를 살펴 보겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> receiver = &#123;&#125;;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.assign(receiver,</div><div class="line">    &#123;</div><div class="line">        <span class="attr">type</span>: <span class="string">"js"</span>,</div><div class="line">        <span class="attr">name</span>: <span class="string">"file.js"</span></div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">        <span class="attr">type</span>: <span class="string">"css"</span></div><div class="line">    &#125;</div><div class="line">);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(receiver.type);     <span class="comment">// "css"</span></div><div class="line"><span class="built_in">console</span>.log(receiver.name);     <span class="comment">// "file.js"</span></div></pre></td></tr></table></figure>
<p><code>receiver.type</code>의 값은 “css”입니다. 왜냐하면 두 번째 <code>Supplier</code>가 첫 번째 <code>Supplier</code>의 값을 덮어 쓰기 때문입니다.</p>
<p><code>Object.assign()</code> 메서드는 ECMAScript 6에 큰 변경사항은 아니지만 많은 JavaScript 라이브러리에서 볼 수있는 공통 기능을 공식화 한것입니다.</p>
<h3 id="접근자-Accessor-프로퍼티로-작업하기"><a href="#접근자-Accessor-프로퍼티로-작업하기" class="headerlink" title="접근자(Accessor) 프로퍼티로 작업하기"></a>접근자(Accessor) 프로퍼티로 작업하기</h3><p><code>Object.assign()</code>은 Supplier가 접근자(Accessor) 프로퍼티를 가질 때 Receiver에 접근자(Accessor) 프로퍼티를 생성하지 않는다는 것을 명심하십시오. <code>Object.assign()</code>은 대입 연산자를 사용하기 때문에 Supplier의 접근자(Accessor) 프로퍼티는 Receiver의 데이터 프로퍼티가 됩니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> receiver = &#123;&#125;,</div><div class="line">    supplier = &#123;</div><div class="line">        get name() &#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">"file.js"</span></div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.assign(receiver, supplier);</div><div class="line"></div><div class="line"><span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(receiver, <span class="string">"name"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(descriptor.value);      <span class="comment">// "file.js"</span></div><div class="line"><span class="built_in">console</span>.log(descriptor.get);        <span class="comment">// undefined</span></div></pre></td></tr></table></figure>
<p>이 코드에서 Supplier는 <code>name</code>이라는 접근자(Accessor) 프로퍼티를 가지고 있습니다.</p>
<p><code>Object.assign()</code> 메서드를 사용한 후에 <code>receiver.name</code>의 값은 <code>&quot;file.js&quot;</code>인 데이터 프로퍼티로서 존재합니다. 왜냐하면 <code>Object.assign()</code>을 호출 했기 때문에 <code>supplier.name</code>이 <code>&quot;file.js&quot;</code>를 리턴했기 때문입니다.</p>
<h2 id="객체-리터럴의-중복-프로퍼티-처리"><a href="#객체-리터럴의-중복-프로퍼티-처리" class="headerlink" title="객체 리터럴의 중복 프로퍼티 처리"></a>객체 리터럴의 중복 프로퍼티 처리</h2><p>ECMAScript 5 <em>strict</em> 모드는 중복이 발견되면 오류를 던질 중복 객체 프로퍼티에 대한 검사를 도입했습니다. 예를 들어, 이 코드는 문제가 있었습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">"Nicholas"</span>,</div><div class="line">    <span class="attr">name</span>: <span class="string">"Greg"</span>        <span class="comment">// ES5 strict mode에서는 구문오류가 발생합니다.</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>ECMAScript 5의 <em>strict</em> 모드에서 실행될 때, 두 번째 <code>name</code> 프로퍼티는 구문 오류를 일으킵니다. 그러나 ECMAScript 6에서는 중복 프로퍼티 검사가 제거되었습니다. <em>strict</em>와 <em>nonstrict</em> 모드 코드는 더 이상 중복 프로퍼티를 검사하지 않습니다. 대신, 아래 코드에서 보여주는 대로 같은 이름의 마지막 프로퍼티가 프로퍼티의 실제값이 됩니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">"Nicholas"</span>,</div><div class="line">    <span class="attr">name</span>: <span class="string">"Greg"</span>        <span class="comment">// ES6 strict mode에서 에러가 발생하지 않습니다.</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person.name);       <span class="comment">// "Greg"</span></div></pre></td></tr></table></figure>
<p>위 예제에서 <code>person.name</code>의 값은 그 프로퍼티에 할당된 마지막 값이기 때문에 “Greg”입니다.</p>
<h2 id="자신의-프로퍼티-열거-순서"><a href="#자신의-프로퍼티-열거-순서" class="headerlink" title="자신의 프로퍼티 열거 순서"></a>자신의 프로퍼티 열거 순서</h2><p>ECMAScript 5는 객체 프로퍼티의 열거순서를 정의하지 않았습니다. JavaScript 엔진 공급 업체에 맡겨 놓았기 때문입니다. 그러나 ECMAScript 6에서는 열거될 경우 자신의 프로퍼티를 반환해야하는 순서를 엄격하게 정의합니다. 이것은 <code>Object.getOwnPropertyNames()</code>와 <code>Reflect.ownKeys</code> (12 장에서 다룹니다.)를 사용하여 프로퍼티를 반환하는 방법에 영향을 미칩니다. 그리고 <code>Object.assign()</code>에 의해 프로퍼티가 처리되는 순서에도 영향을 미칩니다.</p>
<p>자신의 프로퍼티 기본 열거 순서는 다음과 같습니다.</p>
<ol>
<li>모든 숫자키는 오름차순으로 표시됩니다.</li>
<li>모든 문자열키는 객체에 추가된 순서대로 표시됩니다.</li>
<li>모든 <em>Symbol</em>(6 장에서 다룹니다.)키는 객체에 추가된 순서대로 표시됩니다.</li>
</ol>
<p>아래 예제를 살펴보겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    <span class="attr">a</span>: <span class="number">1</span>,</div><div class="line">    <span class="number">0</span>: <span class="number">1</span>,</div><div class="line">    <span class="attr">c</span>: <span class="number">1</span>,</div><div class="line">    <span class="number">2</span>: <span class="number">1</span>,</div><div class="line">    <span class="attr">b</span>: <span class="number">1</span>,</div><div class="line">    <span class="number">1</span>: <span class="number">1</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line">obj.d = <span class="number">1</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(obj).join(<span class="string">""</span>));     <span class="comment">// "012acbd"</span></div></pre></td></tr></table></figure>
<p><code>Object.getOwnPropertyNames()</code> 메서드는 <code>obj</code>의 프로퍼티를 <code>0</code>, <code>1</code>, <code>2</code>, <code>a</code>, <code>c</code>, <code>b</code>, <code>d</code> 순서로 리턴합니다. 숫자 키는 객체 리터럴에서 순서가 어긋나지만 함께 그룹화되고 정렬됩니다. 문자열 키는 숫자 키 뒤에 오며 <code>obj</code>에 추가된 순서대로 나타납니다. 객체 리터럴 자신의 키가 먼저오고 나중에 추가된 동적 키 (이 경우 d)가 옵니다.</p>
<blockquote>
<p><code>for-in</code> loop는 여전히 모든 JavaScript 엔진이 같은 방식으로 구현하지 않았기 때문에 불특정한 열거 순서를 가지고 있습니다. <code>Object.keys()</code> 메서드와 <code>JSON.stringify()</code>는 모두 <code>for-in</code>과 같은 (불특정한) 열거 순서를 사용하도록 지정되어 있습니다.</p>
</blockquote>
<p>열거 순서는 JavaScript가 작동하는 방식에 미묘한 변화이지만, 정확한 열거에 의존하는 프로그램을 찾는건 드문일이 아닙니다. 열거 순서를 정의함으로써 ECMAScript 6은 열거형에 의존하는 JavaScript 코드가 어디에 실행되는지에 관계없이 올바르게 작동하도록합니다.</p>
<h2 id="더-강력한-프로퍼티들"><a href="#더-강력한-프로퍼티들" class="headerlink" title="더 강력한 프로퍼티들"></a>더 강력한 프로퍼티들</h2><p><em>Prototype</em>은 JavaScript의 상속의 토대이며 ECMAScript 6는 <em>Prototype</em>을 계속해서 더 강력하게 만듭니다. 초기 버전의 JavaScript는 <em>Prototype</em>을 통해 수행할 수있는 작업을 심각하게 제한했습니다. 그러나 언어가 발전하고 개발자가 <em>Prototype</em>이 어떻게 작동하는지 더 잘 알게됨에 따라 개발자들은 <em>Prototype</em>을 더 많이 컨트롤 하고, 쉬운 방법으로 제어하기를 원했습니다. 결과적으로 ECMAScript 6는 <em>Prototype</em>을 약간 개선했습니다.</p>
<h3 id="Object의-Prototype-변경"><a href="#Object의-Prototype-변경" class="headerlink" title="Object의 Prototype 변경"></a>Object의 <em>Prototype</em> 변경</h3><p>일반적으로 객체의 <em>Prototype</em>은 객체가 생성될 때 생성자 또는 <code>Object.create()</code>메서드를 통해 지정됩니다. 인스턴스 생성후 객체의 <em>Prototype</em>이 변경되지 않는다는 생각은 ECMAScript 5까지 JavaScript 프로그래밍에서 가장 큰 가정 중 하나였습니다. ECMAScript 5는 주어진 객체의 <em>Prototype</em>을 찾기하기 위해 <code>Object.getPrototypeOf()</code> 메서드를 추가했지만 인스턴스화 후에 객체의 <em>Prototype</em>을 변경하는 표준 방법이 여전히 부족했습니다.</p>
<p>ECMAScript 6는 <code>Object.setPrototypeOf()</code> 메서드를 추가함으로써 이러한 가정을 바꿉니다. 이 메서드는 주어진 객체의 <em>Prototype</em>을 변경할 수 있게합니다. <code>Object.setPrototypeOf()</code> 메서드는 두 개의 파라미터를 받는데, 첫 번째는 <em>Prototype</em>이 변경 되어야하는 객체, 그리고 두 번째는 첫 번째 파라미터의 <em>Prototype</em>이 되어야하는 객체입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> person = &#123;</div><div class="line">    getGreeting() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"Hello"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> dog = &#123;</div><div class="line">    getGreeting() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"Woof"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// prototype은 person</span></div><div class="line"><span class="keyword">let</span> friend = <span class="built_in">Object</span>.create(person);</div><div class="line"><span class="built_in">console</span>.log(friend.getGreeting());                      <span class="comment">// "Hello"</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(friend) === person);  <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="comment">// prototype을 dog로 설정</span></div><div class="line"><span class="built_in">Object</span>.setPrototypeOf(friend, dog);</div><div class="line"><span class="built_in">console</span>.log(friend.getGreeting());                      <span class="comment">// "Woof"</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(friend) === dog);     <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>위 코드는 <code>person</code>과 <code>dog</code>라는 두 개의 기본 객체를 정의합니다. 두객체 모두 문자열을 반환하는 <code>getGreeting()</code> 메서드를 가지고 있습니다. 객체 <code>friend</code>는 먼저 <code>person</code> 객체를 상속받았기 때문에 <code>getGreeting()</code>은 <code>&quot;Hello&quot;</code>를 출력합니다. 그리고 <em>Prototype</em>이 <code>dog</code> 객체가 될 때 <code>person.getGreeting()</code>은 원래의 <code>person</code>과 관계가 깨졌기 때문에 <code>&quot;Woof&quot;</code>를 출력합니다.</p>
<p>객체의 <em>Prototype</em>의 실제 값은<code>[[Prototype]]</code>이라는 내부 전용 프로퍼티에 저장됩니다. <code>Object.getPrototypeOf()</code> 메서드는 <code>[[Prototype]]</code>에 저장된 값을 리턴하고 <code>Object.setPrototypeOf()</code>는 <code>[[Prototype]]</code>에 저장된 값을 변경합니다. 그러나 이 메서드들이 <code>[[Prototype]]</code>의 값을 이용해 작업하는 유일한 방법은 아닙니다.</p>
<h3 id="Super-참조를-이용한-쉬운-Prototype-접근"><a href="#Super-참조를-이용한-쉬운-Prototype-접근" class="headerlink" title="Super 참조를 이용한 쉬운 Prototype 접근"></a>Super 참조를 이용한 쉬운 <em>Prototype</em> 접근</h3><p>앞서 언급했듯이, <em>Prototype</em>은 JavaScript에 매우 중요하며 많은 작업이 ECMAScript 6에서 사용하기가 더 쉬워졌습니다. 또 다른 개선점은 객체의 <em>Prototype</em>에 대한 기능을 보다 쉽게 액세스할 수 있게 해주는 <code>super</code> 참조의 도입입니다. 예를 들어, 객체 인스턴스의 메서드를 오버라이드하여 동일한 이름의 <em>Prototype</em> 메서드도 호출하도록 하는 다음 예제를 참고하세요.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> person = &#123;</div><div class="line">    getGreeting() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"Hello"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> dog = &#123;</div><div class="line">    getGreeting() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"Woof"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">let</span> friend = &#123;</div><div class="line">    getGreeting() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.getPrototypeOf(<span class="keyword">this</span>).getGreeting.call(<span class="keyword">this</span>) + <span class="string">", hi!"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// prototype을 person으로 설정</span></div><div class="line"><span class="built_in">Object</span>.setPrototypeOf(friend, person);</div><div class="line"><span class="built_in">console</span>.log(friend.getGreeting());                      <span class="comment">// "Hello, hi!"</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(friend) === person);  <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="comment">// prototype을 dog로 설정</span></div><div class="line"><span class="built_in">Object</span>.setPrototypeOf(friend, dog);</div><div class="line"><span class="built_in">console</span>.log(friend.getGreeting());                      <span class="comment">// "Woof, hi!"</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(friend) === dog);     <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>위의 예제에서, <code>friend</code>에 대한 <code>getGreeting()</code>은 같은 이름의 <em>Prototype</em> 메서드를 호출합니다. <code>Object.getPrototypeOf()</code> 메서드는 올바른 <em>Prototype</em>이 호출되었는지 확인한 다음 추가 문자열이 출력에 더해집니다. 게다가 <code>.call(this)</code>는 <em>Prototype</em> 메서드 내의 <code>this</code> 값이 올바르게 설정되도록합니다.</p>
<p><em>Prototype</em>에서 메서드를 호출하기 위해 <code>Object.getPrototypeOf()</code>와 <code>.call(this)</code>를 사용하는 것은 다소 복잡하기 때문에 ECMAScript 6는 <code>super</code>를 도입했습니다. 간단히 말해,<code>super</code>는 현재 객체의 <em>Prototype</em>을 가리키는 포인터이며, 사실상<code>Object.getPrototypeOf(this)</code> 값입니다. 다음과 같이 <code>getGreeting()</code> 메서드를 단순화할 수있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> friend = &#123;</div><div class="line">    getGreeting() &#123;</div><div class="line">        <span class="comment">// 이전 예제에서 이것은 다음과 같습니다.</span></div><div class="line">        <span class="comment">// Object.getPrototypeOf(this).getGreeting.call(this)</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getGreeting() + <span class="string">", hi!"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>위 예제에서 <code>super.getGreeting()</code>에 대한 호출은 <code>Object.getPrototypeOf(this).getGreeting.call(this)</code>와 동일합니다. 비슷하게, 간결한 메서드 내부에 있는 경우 <code>super</code> 참조를 사용하여 객체 <em>Prototype</em>의 모든 메서드를 호출할 수 있습니다. 하지만 간결한 메서드 밖에서 <code>super</code>를 사용하려고 시도하면 다음과 같이 구문 오류가 발생합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> friend = &#123;</div><div class="line">    <span class="attr">getGreeting</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">// syntax error</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getGreeting() + <span class="string">", hi!"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>이 예제는 함수와 함께 명명된 프로퍼티를 사용하고 <code>super</code>가 이 컨텍스트에서 유효하지 않기 때문에 <code>super.getGreeting()</code>을 호출하면 구문 오류가 발생합니다.</p>
<p><code>super</code> 레퍼런스는 여러 레벨의 상속이있을 때 정말 강력합니다. 왜냐하면 <code>Object.getPrototypeOf()</code>가 더 이상 모든 상황에서 작동하지 않기 때문입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> person = &#123;</div><div class="line">    getGreeting() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"Hello"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// prototype is person</span></div><div class="line"><span class="keyword">let</span> friend = &#123;</div><div class="line">    getGreeting() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.getPrototypeOf(<span class="keyword">this</span>).getGreeting.call(<span class="keyword">this</span>) + <span class="string">", hi!"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="built_in">Object</span>.setPrototypeOf(friend, person);</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// prototype is friend</span></div><div class="line"><span class="keyword">let</span> relative = <span class="built_in">Object</span>.create(friend);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person.getGreeting());                  <span class="comment">// "Hello"</span></div><div class="line"><span class="built_in">console</span>.log(friend.getGreeting());                  <span class="comment">// "Hello, hi!"</span></div><div class="line"><span class="built_in">console</span>.log(relative.getGreeting());                <span class="comment">// error!</span></div></pre></td></tr></table></figure>
<p><code>relative.getGreeting()</code>이 호출되어 <code>Object.getPrototypeOf()</code>를 호출하면 오류가 발생합니다. 그것은 <code>this</code>가 <code>relative</code>이고, <code>relative</code>의 <em>Prototype</em>이 <code>friend</code> 객체이기 때문입니다. <code>friend.getGreeting().call()</code>이 <code>relative</code>를 <code>this</code>로 호출하면 프로세스는 다시 시작되어 스택 오버 플로우 오류가 발생할 때까지 재귀적으로 계속 호출됩니다.</p>
<p>이 문제를 ECMAScript 5에서는 해결하기가 어렵지만 ECMAScript 6의 <code>super</code>를 이용하면 쉽게 해결할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> person = &#123;</div><div class="line">    getGreeting() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"Hello"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// prototype is person</span></div><div class="line"><span class="keyword">let</span> friend = &#123;</div><div class="line">    getGreeting() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getGreeting() + <span class="string">", hi!"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="built_in">Object</span>.setPrototypeOf(friend, person);</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// prototype is friend</span></div><div class="line"><span class="keyword">let</span> relative = <span class="built_in">Object</span>.create(friend);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person.getGreeting());                  <span class="comment">// "Hello"</span></div><div class="line"><span class="built_in">console</span>.log(friend.getGreeting());                  <span class="comment">// "Hello, hi!"</span></div><div class="line"><span class="built_in">console</span>.log(relative.getGreeting());                <span class="comment">// "Hello, hi!"</span></div></pre></td></tr></table></figure>
<p><code>super</code> 참조는 동적이 아니기 때문에 항상 올바른 객체를 참조합니다. 이 경우, <code>super.getGreeting()</code>은 얼마나 많은 다른 객체가 그 메서드를 상속 받았는지에 관계없이 항상 <code>person.getGreeting ()</code>을 참조합니다.</p>
<h2 id="Method의-공식적인-정의"><a href="#Method의-공식적인-정의" class="headerlink" title="Method의 공식적인 정의"></a>Method의 공식적인 정의</h2><p>ECMAScript 6 이전에는 <code>&quot;Method&quot;</code>의 개념이 공식적으로 정의되지 않았습니다. <code>Method</code>는 데이터 대신 함수가 포함된 객체 프로퍼티었습니다. ECMAScript 6는 <code>Method</code>를 객체 내부의 <code>[[HomeObject]]</code> 프라퍼티를 가진 함수로 공식적으로 정의합니다. 다음 내용을 살펴보겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> person = &#123;</div><div class="line"></div><div class="line">    <span class="comment">// method</span></div><div class="line">    getGreeting() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"Hello"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// not a method</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">shareGreeting</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"Hi!"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>위 예제는 <code>getGreeting()</code>이라는 단일 메서드로 <code>person</code>을 정의합니다. <code>getGreeting()</code>의 <code>[[HomeObject]]</code>는 함수를 객체에 직접 할당함으로써 <code>person</code>을 정의합니다. 반면에 <code>shareGreeting()</code> 함수는 생성될 때 객체에 할당되지 않았으므로 <code>[[HomeObject]]</code>가 지정되어 있지 않습니다. 대부분의 경우 이 차이는 중요하지 않지만 <code>super</code> 참조를 사용할 때 매우 중요합니다.</p>
<p><code>super</code>에 대한 참조는 무엇을 할 것인가를 결정하기 위해 <code>[[HomeObject]]</code>를 사용합니다. 첫 번째 단계는 <code>[[HomeObject]]</code>에서 <code>Object.getPrototypeOf()</code>를 호출하여 <em>Prototype</em>에 대한 참조를 가져 오는 것입니다. 그런 다음 <em>Prototype</em>의 이름이 같은 함수가 검색됩니다. 마지막으로, 바인딩이 설정되고 <code>Method</code>가 호출됩니다. 다음은 예제를 살펴보겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> person = &#123;</div><div class="line">    getGreeting() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"Hello"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// prototype is person</span></div><div class="line"><span class="keyword">let</span> friend = &#123;</div><div class="line">    getGreeting() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getGreeting() + <span class="string">", hi!"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="built_in">Object</span>.setPrototypeOf(friend, person);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(friend.getGreeting());  <span class="comment">// "Hello, hi!"</span></div></pre></td></tr></table></figure>
<p><code>friend.getGreeting()</code> 호출은 <code>person.getGreeting()</code>의 값을 <code>&quot;, hi!&quot;</code>와 결합된 문자열을 반환합니다. <code>friend.getGreeting()</code>의<br> <code>[[HomeObject]]</code>는 <code>friend</code>이고 <code>friend</code>의 <em>Prototype</em>은 <code>person</code>이므로 <code>super.getGreeting()</code>은 <code>person.getGreeting.call(this)</code>와 동일합니다.</p>
<h2 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h2><p>객체는 JavaScript 프로그래밍의 중심이며, ECMAScript 6는 객체를 보다 쉽게 다루고 더 강력하게 만드는 유용한 변경 사항을 만들었습니다.</p>
<p>ECMAScript 6은 객체 리터럴을 몇 가지 변경했습니다. 간략한 프로퍼티 정의는 Scope 내 변수와 동일한 이름을 가진 프로퍼티를 쉽게 지정합니다. 계산된 프로퍼티 이름을 사용하면 리터럴 이외의 값을 프로퍼티 이름으로 지정할 수 있습니다. 간략한 메서드는 콜론과 <code>function</code> 키워드를 완전히 생략함으로써 훨씬 적은 수의 문자를 입력하여 객체 리터럴에 대한 메서드를 정의할 수 있게합니다. ECMAScript 6는 객체의 중복 프로퍼티 이름에 대해서도 strict 모드 검사를 느슨하게합니다. 즉, 객체 리터럴에 오류가 발생하지 않고 같은 이름의 두 프로퍼티를 가질 수 있습니다.</p>
<p><code>Object.assign()</code> 메서드는 한번에 하나의 객체에 대해 여러 속성을 변경하는 것을 더 쉽게 만듭니다. <code>mixin</code> 패턴을 사용하면 매우 유용할 수 있습니다. <code>Object.is()</code> 메서드는 어떤 값에 대해서도 엄격한 <em>equal</em>을 수행하며 특별한 JavaScript 값을 다룰 때 효과적인<br> <code>===</code>의 안전한 버전입니다.</p>
<p>ECMAScript 6에서는 자체 프로퍼티에 대한 열거 순서가 명확하게 정의되었습니다. 프로퍼티를 열거하면 숫자 키가 항상 오름차순으로 먼저 나오고 문자열 키가 삽입 순서에 맞춰 나오고 Symbol 키가 삽입 순서로 옵니다.</p>
<p>ECMAScript 6의<code>Object.setPrototypeOf()</code>메서드 덕택에 객체의 <em>Prototype</em>을 이미 생성 한 후에 수정할 수 있습니다.</p>
<p>마지막으로,<code>super</code> 키워드를 사용하여 객체의 <em>Prototype</em>에 대한 메서드를 호출할 수 있습니다. <code>super</code>를 사용하여 호출된 메서드 내부의 <code>this</code> 바인딩은 <code>this</code>의 현재 값으로 자동으로 작동하도록 설정됩니다.</p>
<hr>
<blockquote>
<p>이 내용은 나중에 참고하기 위해 제가 공부하며 정리한 내용입니다.<br>의역, 오역, 직역이 있을 수 있음을 알려드립니다.<br>This post is a translation of this original article [<a href="https://leanpub.com/understandinges6/read#leanpub-auto-expanded-object-functionality" target="_blank" rel="external">https://leanpub.com/understandinges6/read#leanpub-auto-expanded-object-functionality</a>]</p>
</blockquote>
<h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul>
<li><a href="https://infoscis.github.io/2018/01/24/ecmascript-6-block-binding/">ECMAScript 6 Block Binding</a></li>
<li><a href="https://infoscis.github.io/2018/01/24/ecmascript-6-strings-and-regular-expressions/">ECMAScript 6 문자열과 정규 표현식</a></li>
<li><a href="https://infoscis.github.io/2018/01/24/ecmascript-6-functions/">ECMAScript 6 함수</a></li>
<li><a href="https://infoscis.github.io/2018/01/25/ecmascript-6-expanded-object-functionality/">ECMAScript 6 객체의 확장된 기능</a></li>
<li><a href="https://infoscis.github.io/2018/01/26/ecmascript-6-destructuring-for-easier-data-access/">ECMAScript 6 쉬운 데이터 액세스를 위한 Destructuring</a></li>
<li><a href="https://infoscis.github.io/2018/01/27/ecmascript-6-symbols-and-symbol-properties/">ECMAScript 6 Symbol과 Symbol 프로퍼티</a></li>
<li><a href="https://infoscis.github.io/2018/01/27/ecmascript-6-sets-and-maps/">ECMAScript 6 Set과 Map</a></li>
<li><a href="https://infoscis.github.io/2018/01/31/ecmascript-6-iterators-and-generators/">ECMAScript 6 Iterator와 Generator</a></li>
<li><a href="https://infoscis.github.io/2018/02/13/ecmascript-6-introducing-javascript-classes/">ECMAScript 6 JavaScript 클래스 소개</a></li>
<li><a href="https://infoscis.github.io/2018/02/13/ecmascript-6-improved-array-capabilities/">ECMAScript 6 Array 기능 향상</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-promises-and-asynchronous-programming/">ECMAScript 6 Promise와 비동기 프로그램밍</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-proxies-and-the-reflection-api/">ECMAScript 6 프록시와 리플렉션 API</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-encapsulating-code-with-modules/">ECMAScript 6 Module로 코드 캡슐화하기</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-appendix-a-smaller-changes/">ECMAScript 6 부록 A. 작은 변경 사항</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-appendix-b-understanding-ecmascript-7/">ECMAScript 6 부록 B. ECMAScript 7(2016) 이해하기</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;객체의-확장된-기능&quot;&gt;&lt;a href=&quot;#객체의-확장된-기능&quot; class=&quot;headerlink&quot; title=&quot;객체의 확장된 기능&quot;&gt;&lt;/a&gt;객체의 확장된 기능&lt;/h1&gt;&lt;p&gt;ECMAScript 6은 객체의 유용성을 향상 시키는데 중점을 두고 
    
    </summary>
    
      <category term="JavaScript" scheme="http://infoscis.github.io/categories/JavaScript/"/>
    
      <category term="ECMAScript 2015" scheme="http://infoscis.github.io/categories/JavaScript/ECMAScript-2015/"/>
    
    
      <category term="JavaScript" scheme="http://infoscis.github.io/tags/JavaScript/"/>
    
      <category term="ECMAScript 2015" scheme="http://infoscis.github.io/tags/ECMAScript-2015/"/>
    
  </entry>
  
  <entry>
    <title>ECMAScript 6 함수</title>
    <link href="http://infoscis.github.io/2018/01/24/ecmascript-6-functions/"/>
    <id>http://infoscis.github.io/2018/01/24/ecmascript-6-functions/</id>
    <published>2018-01-24T14:15:28.000Z</published>
    <updated>2018-02-27T14:12:01.601Z</updated>
    
    <content type="html"><![CDATA[<h1 id="함수-Function"><a href="#함수-Function" class="headerlink" title="함수 (Function)"></a>함수 (Function)</h1><p>함수는 JavaScript 프로그래밍 언어의 중요한 부분이며, JavaScript가 시작된 이후로 ECMAScript 6 이전까지 많이 변경되지 않았습니다. 이로 인해 실수가 많았고, 아주 기본적인 행동을하기 위해 더 많은 코드가 필요했으며, 미묘한 행동의 <code>백 로그(backlog)</code>가 남았습니다.</p>
<p>ECMAScript 6 함수는 JavaScript 개발자의 수년간의 불만과 요청을 고려하여 큰 발전을 이루었습니다. 결과적으로 ECMAScript 5 기능 위에 점진적인 개선이 이루어져 JavaScript에서 오류를 발생시키지 않고 보다 강력하게 프로그래밍할 수있게 되었습니다.</p>
<h2 id="Default-파라미터-값이-있는-함수"><a href="#Default-파라미터-값이-있는-함수" class="headerlink" title="Default 파라미터 값이 있는 함수"></a><em>Default 파라미터</em> 값이 있는 함수</h2><p>JavaScript의 함수는 함수 정의에 선언된 파라미터 수에 관계없이 여러 파라미터를 전달할 수 있다는 점에서 독특합니다. 이렇게하면 파라미터가 제공되지 않을 때 <em>Default</em> 값을 채우기만 하면 다른 개수의 파라미터를 처리할 수있는 함수를 정의할 수 있습니다. 이 절에서는 <em>Default 파라미터</em>가 ECMAScript 6에서 작동하는 방법과 <code>arguments</code> 객체에 대한 몇 가지 중요한 정보, 표현식을 파라미터로 사용하는 방법 및 또다른 TDZ에 대해 설명합니다.</p>
<h3 id="ECMAScript-5에서-Default-파라미터-시뮬레이션"><a href="#ECMAScript-5에서-Default-파라미터-시뮬레이션" class="headerlink" title="ECMAScript 5에서 Default 파라미터 시뮬레이션"></a>ECMAScript 5에서 <em>Default 파라미터</em> 시뮬레이션</h3><p>ECMAScript 5 및 이전 버전에서는 다음 패턴을 사용하여 <em>Default 파라미터</em>가 있는 함수를 만들 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeRequest</span>(<span class="params">url, timeout, callback</span>) </span>&#123;</div><div class="line"></div><div class="line">    timeout = timeout || <span class="number">2000</span>;</div><div class="line">    callback = callback || <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line"></div><div class="line">    <span class="comment">// 함수의 나머지 부분</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>이 예제에서, <code>timeout</code>과 <code>callback</code>은 실제로 파라미터가 제공되지 않을 때 <em>Default</em> 값이 주어지기 때문에 Optional입니다. 논리합 연산자 (<code>||</code>)는 첫 번째가 거짓 일 때 항상 두 번째 피연산자를 반환합니다. 명시적으로 제공되지 않은 명명된 함수 파라미터는 <code>undefined</code>로 설정되므로 논리 OR 연산자는 누락된 파라미터의 <em>Default</em>값을 제공하는 데 자주 사용됩니다. 그러나 <code>timeout</code>이 유효한 값 <code>0</code>일 수 있지만 <code>0</code>은 false이기 때문에 <code>2000</code>으로 바꿀 수 있다는 점에서 이 접근법에 결함이 있습니다.</p>
<p>이 경우보다 안전한 대안은 다음 예와 같이 <code>typeof</code>를 사용하여 파라미터의 유형을 확인하는 것입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeRequest</span>(<span class="params">url, timeout, callback</span>) </span>&#123;</div><div class="line"></div><div class="line">    timeout = (<span class="keyword">typeof</span> timeout !== <span class="string">"undefined"</span>) ? timeout : <span class="number">2000</span>;</div><div class="line">    callback = (<span class="keyword">typeof</span> callback !== <span class="string">"undefined"</span>) ? callback : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line"></div><div class="line">    <span class="comment">// 함수의 나머지 부분</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>이 방법이 더 안전하지만 매우 기본적인 작업을 위해서는 많은 추가 코드가 필요합니다. 인기있는 JavaScript 라이브러리에는 이러한 비슷한 패턴으로 채워집니다. 이는 공통적으로 비슷한 패턴을 사용하기 때문입니다.</p>
<h3 id="ECMAScript-6의-Default-파라미터-값"><a href="#ECMAScript-6의-Default-파라미터-값" class="headerlink" title="ECMAScript 6의 Default 파라미터 값"></a>ECMAScript 6의 <em>Default 파라미터</em> 값</h3><p>ECMAScript 6을 사용하면 파라미터가 전달되지 않을 때 사용되는 <em>Default</em>값을 보다 쉽게 제공할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeRequest</span>(<span class="params">url, timeout = <span class="number">2000</span>, callback = function(</span>) </span>&#123;&#125;) &#123;</div><div class="line"></div><div class="line">    <span class="comment">// 함수의 나머지 부분</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>이 함수는 첫 번째 파라미터가 항상 전달될 것으로 예상합니다. 다른 두 파라미터에는 <em>Default</em> 값이 있으므로 누락된 값을 확인하기 위해 코드를 추가할 필요가 없으므로 함수 본문이 훨씬 단순해집니다.</p>
<p><code>makeRequest()</code>가 세개의 파라미터 모두로 호출될 때, <em>Default</em>값은 사용되지 않습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// uses default timeout and callback</span></div><div class="line">makeRequest(<span class="string">"/foo"</span>);</div><div class="line"></div><div class="line"><span class="comment">// uses default callback</span></div><div class="line">makeRequest(<span class="string">"/foo"</span>, <span class="number">500</span>);</div><div class="line"></div><div class="line"><span class="comment">// doesn't use defaults</span></div><div class="line">makeRequest(<span class="string">"/foo"</span>, <span class="number">500</span>, <span class="function"><span class="keyword">function</span>(<span class="params">body</span>) </span>&#123;</div><div class="line">    doSomething(body);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>ECMAScript 6에서는 <code>url</code>이 필요하다고 생각하기 때문에 <code>makeRequest()</code>를 호출할 때마다 <code>&quot;/foo&quot;</code>가 전달됩니다. <em>Default</em>값이 있는 두 개의 파라미터는 선택적으로 간주됩니다.</p>
<p><em>Default</em>값은 함수 선언에서 파라미터의 어느 위치나 지정할 수 있습니다. 그렇기 때문에 모든 파라미터에 <em>Default</em>값을 지정할 수 있습니다. 예를 들면 다음과 같습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeRequest</span>(<span class="params">url, timeout = <span class="number">2000</span>, callback</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// the rest of the function</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>이 경우 <code>timeout</code>의 <em>Default</em>값은 두 번째 파라미터가 전달되지 않았거나 두 번째 파라미터가 명시 적으로 <code>undefined</code>로 전달된 경우에만 사용됩니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// default timeout을 사용합니다.</span></div><div class="line">makeRequest(<span class="string">"/foo"</span>, <span class="literal">undefined</span>, <span class="function"><span class="keyword">function</span>(<span class="params">body</span>) </span>&#123;</div><div class="line">    doSomething(body);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// default timeout을 사용합니다.</span></div><div class="line">makeRequest(<span class="string">"/foo"</span>);</div><div class="line"></div><div class="line"><span class="comment">// default timeout을 사용하지 않습니다.</span></div><div class="line">makeRequest(<span class="string">"/foo"</span>, <span class="literal">null</span>, <span class="function"><span class="keyword">function</span>(<span class="params">body</span>) </span>&#123;</div><div class="line">    doSomething(body);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><em>Default 파라미터</em>의 경우, <code>null</code>의 값은 유효하다고 간주됩니다. 즉,<code>makeRequest()</code>에 대한 세 번째 호출에서 <code>timeout</code>의 <em>Default</em> 값은 사용되지 않습니다</p>
<h3 id="Default-파라미터-값이-arguments-Object에-미치는-영향"><a href="#Default-파라미터-값이-arguments-Object에-미치는-영향" class="headerlink" title="Default 파라미터 값이 arguments Object에 미치는 영향"></a><em>Default 파라미터</em> 값이 <code>arguments</code> Object에 미치는 영향</h3><p><em>Default 파라미터</em>가 존재할 때 <code>arguments</code> 객체의 동작이 다르다는 것을 기억 해야 합니다. ECMAScript 5 <code>nonstrict mode</code>에서<code>arguments</code> 객체는 함수의 명명된 파라미터의 변경을 반영합니다. 이러한 작동 방식을 보여주는 코드는 다음과 같습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mixArgs</span>(<span class="params">first, second</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(first === <span class="built_in">arguments</span>[<span class="number">0</span>]);</div><div class="line">    <span class="built_in">console</span>.log(second === <span class="built_in">arguments</span>[<span class="number">1</span>]);</div><div class="line">    first = <span class="string">"c"</span>;</div><div class="line">    second = <span class="string">"d"</span>;</div><div class="line">    <span class="built_in">console</span>.log(first === <span class="built_in">arguments</span>[<span class="number">0</span>]);</div><div class="line">    <span class="built_in">console</span>.log(second === <span class="built_in">arguments</span>[<span class="number">1</span>]);</div><div class="line">&#125;</div><div class="line"></div><div class="line">mixArgs(<span class="string">"a"</span>, <span class="string">"b"</span>);</div></pre></td></tr></table></figure>
<p>출력 결과 :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">true</div><div class="line">true</div><div class="line">true</div><div class="line">true</div></pre></td></tr></table></figure>
<p><code>arguments</code> 객체는  <code>nonstrict</code> mode에서 명명된 파라미터의 변경은 항상 업데이트 합니다. 따라서 첫 번째와 두 번째가 새로운 값으로 할당될 때 <code>arguments[0]</code>과 <code>arguments[1]</code>는 그에 따라 업데이트되어 모든 <code>===</code> 비교가 <code>true</code>로 해석됩니다.</p>
<p>ECMAScript 5의 <code>strict</code> 모드는 <code>arguments</code> 객체의 혼란스러운면을 제거합니다. <code>strict</code> 모드에서, <code>arguments</code> 객체는 명명된 파라미터에 대한 변경을 반영하지 않습니다. 아래의 예제는 <code>strict</code> 모드에서  <code>mixArgs()</code> 함수를 보여줍니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mixArgs</span>(<span class="params">first, second</span>) </span>&#123;</div><div class="line"><span class="meta">    "use strict"</span>;</div><div class="line"></div><div class="line">    <span class="built_in">console</span>.log(first === <span class="built_in">arguments</span>[<span class="number">0</span>]);</div><div class="line">    <span class="built_in">console</span>.log(second === <span class="built_in">arguments</span>[<span class="number">1</span>]);</div><div class="line">    first = <span class="string">"c"</span>;</div><div class="line">    second = <span class="string">"d"</span></div><div class="line">    <span class="built_in">console</span>.log(first === <span class="built_in">arguments</span>[<span class="number">0</span>]);</div><div class="line">    <span class="built_in">console</span>.log(second === <span class="built_in">arguments</span>[<span class="number">1</span>]);</div><div class="line">&#125;</div><div class="line"></div><div class="line">mixArgs(<span class="string">"a"</span>, <span class="string">"b"</span>);</div></pre></td></tr></table></figure>
<p><code>mixArgs()</code>의 실행 결과는 다음과 같습니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">true</div><div class="line">true</div><div class="line">false</div><div class="line">false</div></pre></td></tr></table></figure>
<p>이번에는 <code>first</code>와 <code>second</code>를 변경해도 <code>arguments</code>에 영향을 미치지 않으므로 예상대로 실행됩니다.</p>
<p>그러나 ECMAScript 6의 <em>Default 파라미터</em>를 사용하는 함수의 <code>arguments</code> 객체는 함수가 명시적으로 <code>strict</code> 모드로 실행되는지 여부에 관계없이 ECMAScript 5 <code>strict</code> 모드와 동일한 방식으로 동작합니다. <em>Default 파라미터</em>가 있으면 <code>arguments</code> 객체가 명명된 파라미터에서 분리된 상태로 유지됩니다. 이는 <code>arguments</code>객체가 어떻게 사용되는 지에 대한 미묘하지만 중요한 세부 변경사항입니다. 다음 코드를<br> 살펴 보겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// strict mode가 아님</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mixArgs</span>(<span class="params">first, second = <span class="string">"b"</span></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.length);</div><div class="line">    <span class="built_in">console</span>.log(first === <span class="built_in">arguments</span>[<span class="number">0</span>]);</div><div class="line">    <span class="built_in">console</span>.log(second === <span class="built_in">arguments</span>[<span class="number">1</span>]);</div><div class="line">    first = <span class="string">"c"</span>;</div><div class="line">    second = <span class="string">"d"</span></div><div class="line">    <span class="built_in">console</span>.log(first === <span class="built_in">arguments</span>[<span class="number">0</span>]);</div><div class="line">    <span class="built_in">console</span>.log(second === <span class="built_in">arguments</span>[<span class="number">1</span>]);</div><div class="line">&#125;</div><div class="line"></div><div class="line">mixArgs(<span class="string">"a"</span>);</div></pre></td></tr></table></figure>
<p>실행 결과 :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1</div><div class="line">true</div><div class="line">false</div><div class="line">false</div><div class="line">false</div></pre></td></tr></table></figure>
<p>이 예제에서 <code>arguments.length</code>는 1입니다. 왜냐하면 오직 하나의 파라미터가 <code>mixArgs()</code>에 전달 되었기 때문입니다. 이는 또한 <code>arguments[1]</code>이 <code>undefined</code>라는 것을 의미합니다. 이는 하나의 인수만 함수에 전달될 때 예상되는 동작입니다. 즉, <code>first</code>는<code>arguments[0]</code>과 같습니다. <code>first</code>와 <code>second</code>를 변경해도 <code>arguments</code>에는 아무런 영향을 미치지 않습니다. 이러한 현상은 <code>nonstrict</code>와 <code>strict</code> 모드 모두에서 발생하기 때문에 <code>arguments</code>를 사용하여 항상 초기 호출 상태를 확인할 수 있습니다.</p>
<h3 id="Default-파라미터-표현식"><a href="#Default-파라미터-표현식" class="headerlink" title="Default 파라미터 표현식"></a><em>Default 파라미터</em> 표현식</h3><p>아마도 <em>Default 파라미터</em>의 가장 흥미로운 특징은 <em>Default</em> 값이 Primitive 값일 필요는 없다는 것입니다. 예를 들어, 다음과 같이 함수를 실행하여 <em>Default 파라미터</em>를 검색할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">5</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">first, second = getValue(</span>)) </span>&#123;</div><div class="line">    <span class="keyword">return</span> first + second;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">1</span>));     <span class="comment">// 2</span></div><div class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>));        <span class="comment">// 6</span></div></pre></td></tr></table></figure>
<p>여기에서 마지막 파라미터가 제공되지 않으면 <code>getValue()</code> 함수가 호출되어 올바른 <em>Default</em> 값을 검색합니다. <code>getValue()</code>는 두 번째 파라미터 없이 <code>add()</code>가 호출될 때만 호출되며 함수 선언이 처음 구문 분석될 때 호출되지 않는다는 점에 유의하십시오. 즉, <code>getValue()</code>가 다르게 작성된 경우 잠재적으로 다른 값을 반환할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> value = <span class="number">5</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> value++;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">first, second = getValue(</span>)) </span>&#123;</div><div class="line">    <span class="keyword">return</span> first + second;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">1</span>));     <span class="comment">// 2</span></div><div class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>));        <span class="comment">// 6</span></div><div class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>));        <span class="comment">// 7</span></div></pre></td></tr></table></figure>
<p>이 예제에서, value는 5로 시작하고 <code>getValue()</code>가 호출될 때마다 증가합니다. <code>add(1)</code>에 대한 첫 번째 호출은 6을 반환하고, 두 번째 호출은 value가 증가했기 때문에 <code>add(1)</code>에 대한 호출은 7을 반환합니다. second에 대한 <em>Default</em> 값은 함수가 호출될 때만 평가되기 때문에 언제든지 그 값을 변경할 수 있습니다.</p>
<blockquote>
<p>함수 호출을 <em>Default 파라미터</em>로 사용할 때는 주의하십시오. 마지막 예제에서 <code>second = getValue</code>와 같이 괄호를 잊어 버린 경우 함수 호출 결과가 아닌 함수에 대한 참조를 전달합니다.</p>
</blockquote>
<p>이 동작은 또 다른 흥미로운 기능을 제공합니다. 이전 파라미터를 이후 파라미터의 <em>Default</em>로 사용할 수 있습니다. 다음은 그 예입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">first, second = first</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> first + second;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">1</span>));     <span class="comment">// 2</span></div><div class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>));        <span class="comment">// 2</span></div></pre></td></tr></table></figure>
<p>이 코드에서 파라미터 <code>second</code>는 <code>first</code>를 <em>Default</em> 값으로 받습니다. 즉, 하나의 파라미터만 전달하면 두 인수가 같은 값으로 남게됩니다. <code>add(1)</code>은 2를 반환하고 <code>add(1, 1)</code>도 2를 반환합니다. 이 단계를 더 진행하면, <code>first</code>를 <code>second</code>의 값을 얻기위한 함수로 다음과 같이 전달할 수 있습니다 :</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> value + <span class="number">5</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">first, second = getValue(first</span>)) </span>&#123;</div><div class="line">    <span class="keyword">return</span> first + second;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">1</span>));     <span class="comment">// 2</span></div><div class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>));        <span class="comment">// 7</span></div></pre></td></tr></table></figure>
<p>이 예제는 <code>second</code>를 <code>getValue(first)</code>에 의해 반환된 값과 동일하게 설정하므로 <code>add(1, 1)</code>은 여전히 2를 반환하지만 <code>add(1)</code>은 7 (1 + 6)을 반환합니다.</p>
<p><em>Default 파라미터</em> 지정에서 파라미터를 참조하는 기능은 앞의 <code>arguments</code> 에 대해서만 작동하므로 앞서는 <code>arguments</code>는 나중 <code>arguments</code>를 액세스할 수 없습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">first = second, second</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> first + second;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">1</span>));         <span class="comment">// 2</span></div><div class="line"><span class="built_in">console</span>.log(add(<span class="literal">undefined</span>, <span class="number">1</span>)); <span class="comment">// throws error</span></div></pre></td></tr></table></figure>
<p><code>second</code>가 <code>first</code> 다음에 정의되고 따라서 <em>Default</em> 값으로 사용할 수 없기 때문에 <code>add(undefined, 1)</code>에 대한 호출은 에러를 던집니다. 그런 일이 일어나는 이유를 이해하려면 <code>Temporal dead zone</code>을 다시 이해해야 합니다.</p>
<h3 id="Default-파라미터-Temporal-Dead-Zone"><a href="#Default-파라미터-Temporal-Dead-Zone" class="headerlink" title="Default 파라미터 Temporal Dead Zone"></a><em>Default 파라미터</em> Temporal Dead Zone</h3><p>1 장에서는 <code>let</code>과 <code>const</code>에 관련된 TDZ (Temporary Dead Zone)를 소개했고, <em>Default 파라미터</em> 중에 파라미터에 접근할 수 없는 TDZ도 있습니다. <code>let</code> 선언과 유사하게, 각 파라미터는 오류를 던지지 않고 초기화 전에 참조할 수 없는 새로운 식별자 바인딩을 생성합니다. 파라미터 초기화는 함수에 대한 값을 전달하거나 <em>Default 파라미터</em>를 사용하여 함수를 호출할 때 발생합니다.</p>
<p><em>Default 파라미터</em> TDZ를 알아 보기위해 아래 예제와 같이 “<em>Default 파라미터</em> 표현식”에 대해 생각해 보겠습니다..</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> value + <span class="number">5</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">first, second = getValue(first</span>)) </span>&#123;</div><div class="line">    <span class="keyword">return</span> first + second;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">1</span>));     <span class="comment">// 2</span></div><div class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>));        <span class="comment">// 7</span></div></pre></td></tr></table></figure>
<p><code>add(1, 1)</code>과 <code>add(1)</code>에 대한 호출은 효과적으로 <code>first</code>와 <code>second</code> 파라미터 값을 생성하기 위해 다음 코드를 실행합니다 :</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// add(1, 1)에 대한 JavaScript 표현</span></div><div class="line"><span class="keyword">let</span> first = <span class="number">1</span>;</div><div class="line"><span class="keyword">let</span> second = <span class="number">1</span>;</div><div class="line"></div><div class="line"><span class="comment">// add(1)에 대한 JavaScript 표현</span></div><div class="line"><span class="keyword">let</span> first = <span class="number">1</span>;</div><div class="line"><span class="keyword">let</span> second = getValue(first);</div></pre></td></tr></table></figure>
<p><code>add()</code>함수가 처음 실행될 때, <code>first</code>와 <code>second</code> 바인딩은 특정한 파라미터의 TDZ에 추가됩니다 (<code>let</code>의 동작과 유사합니다). 따라서 <code>second</code>가 <code>first</code>의 값으로 초기화될 수 있습니다. 왜냐하면 <code>first</code>는 항상 그때 초기화 되기 때문이고, 그 반대는 성립하지 않습니다. 이제, 다시 작성된 <code>add()</code>함수를 살펴 보겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">first = second, second</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> first + second;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">1</span>));         <span class="comment">// 2</span></div><div class="line"><span class="built_in">console</span>.log(add(<span class="literal">undefined</span>, <span class="number">1</span>)); <span class="comment">// throws error</span></div></pre></td></tr></table></figure>
<p>이 예제에서 <code>add(1, 1)</code>과 <code>add(undefined, 1)</code>에 대한 호출은 이제 아래 코드와 매핑됩니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// add(1, 1) 호출의 JavaScript 표현</span></div><div class="line"><span class="keyword">let</span> first = <span class="number">1</span>;</div><div class="line"><span class="keyword">let</span> second = <span class="number">1</span>;</div><div class="line"></div><div class="line"><span class="comment">// add(undefined, 1) 호출의 JavaScript 표현</span></div><div class="line"><span class="keyword">let</span> first = second;</div><div class="line"><span class="keyword">let</span> second = <span class="number">1</span>;</div></pre></td></tr></table></figure>
<p>이 예제에서 <code>add(undefined, 1)</code> 호출은 <code>first</code>가 초기화될 때 <code>second</code>가 아직 초기화되지 않았기 때문에 에러를 던집니다. 이 시점에서 <code>second</code>는 TDZ에 있으므로 <code>second</code>에 대한 참조는 오류를 발생시킵니다. 이것은 1 장에서 논의한 <code>let</code> 바인딩의 동작이 반영됩니다.</p>
<blockquote>
<p>함수의 파라미터는 자신의 <code>scope</code>와 함수 몸체 <code>scope</code>와는 별도의 TDZ를 가지고 있습니다. 즉, 파라미터의 <em>Default</em>값은 함수 본문 내에서 선언된 변수에 액세스할 수 없습니다.</p>
</blockquote>
<h2 id="Unnamed-파라미터로-작업하기"><a href="#Unnamed-파라미터로-작업하기" class="headerlink" title="Unnamed 파라미터로 작업하기"></a>Unnamed 파라미터로 작업하기</h2><p>지금까지 이 장의 예제는 함수 정의에서 명명된 파라미터만을 다뤘습니다. 그러나 JavaScript 함수는 정의된 이름이 부여된 파라미터의 개수로, 전달할 수있는 파라미터의 수를 제한하지 않습니다. 공식적으로 지정된 것보다 더 적은 또는 더 많은 파라미터를 항상 전달할 수 있습니다. <em>Default 파라미터</em> 값은 함수가 더 적은 수의 파라미터를 받아 들일 수 있을 때 명확하게하고, ECMAScript 6는 정의된 것보다 더 많은 파라미터를 전달하는 문제를 만들려고했습니다.</p>
<h3 id="ECMAScript-5의-Unnamed-파라미터"><a href="#ECMAScript-5의-Unnamed-파라미터" class="headerlink" title="ECMAScript 5의 Unnamed 파라미터"></a>ECMAScript 5의 Unnamed 파라미터</h3><p>초기에 JavaScript는 각 파라미터를 개별적으로 정의하지 않고 전달된 모든 함수 파라미터를 검사하는 방법으로 <code>arguments</code> 객체를 제공했습니다. 대부분의 경우 <code>arguments</code>의 검사는 잘 작동하지만, 이 객체는 작업하기가 약간 번거로울 수 있습니다. 예를 들어, <code>arguments</code> 객체를 검사하는 이 코드를 생각해 보겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">pick</span>(<span class="params">object</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> result = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 두 번째 파라미터에서 시작</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>, len = <span class="built_in">arguments</span>.length; i &lt; len; i++) &#123;</div><div class="line">        result[<span class="built_in">arguments</span>[i]] = object[<span class="built_in">arguments</span>[i]];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> book = &#123;</div><div class="line">    <span class="attr">title</span>: <span class="string">"Understanding ECMAScript 6"</span>,</div><div class="line">    <span class="attr">author</span>: <span class="string">"Nicholas C. Zakas"</span>,</div><div class="line">    <span class="attr">year</span>: <span class="number">2015</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> bookData = pick(book, <span class="string">"author"</span>, <span class="string">"year"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(bookData.author);   <span class="comment">// "Nicholas C. Zakas"</span></div><div class="line"><span class="built_in">console</span>.log(bookData.year);     <span class="comment">// 2015</span></div></pre></td></tr></table></figure>
<p>이 함수는 <em>Underscore.js</em> 라이브러리의 <code>pick ()</code> 메서드를 모방한 것입니다. 이 라이브러리는 원본 객체의 프로퍼티 중 일부가 복사된 객체를 반환합니다. 이 예에서는 하나의 파라미터만 정의하고 첫 번째 파라미터는 프로퍼티를 복사할 대상이될 것으로 예상합니다. 전달된 다른 모든 파라미터는 결과에 복사해야하는 프로퍼티의 이름입니다.</p>
<p>이 <code>pick ()</code>함수에 대해 주의해야 할 몇 가지 점이 있습니다. 첫째, 함수가 둘 이상의 파라미터를 처리할 수 있다는 것이 전혀 분명하지 않습니다. 몇 가지 파라미터를 더 정의할 수는 있지만 이 함수가 여러 파라미터를 사용할 수 있음을 나타낼 수는 없습니다. 둘째, 첫 번째 파라미터의 이름이 지정되어 직접 사용되므로 복사할 속성을 찾을 때 인덱스 0 대신 인덱스 1의 <code>arguments</code> 객체에서 시작해야합니다. 적절한 파라미터를 <code>arguments</code>와 함께 사용하는 것을 기억하는 것은 반드시 어렵다고는 할 수 없지만, 추적이 용이한 것이 더 중요합니다.</p>
<p>ECMAScript 6에서는 이러한 문제를 해결할 수있는 <em>Rest 파라미터</em>를 도입했습니다.</p>
<h3 id="Rest-파라미터"><a href="#Rest-파라미터" class="headerlink" title="Rest 파라미터"></a>Rest 파라미터</h3><p><em>Rest 파라미터</em>는 명명된 파라미터 앞에 세 개의 점 (<code>...</code>)으로 표시됩니다. 이 명명된 파라미터는 함수에 전달된 나머지 파라미터를 포함하는 Array가 되며, 이것이 “<em>Rest</em>“ 파라미터 이름의 출처입니다. 예를 들어 <code>pick()</code>은 다음과 같이 <em>Rest 파라미터</em>를 사용하여 다시 작성할 수 있습니다 :</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">pick</span>(<span class="params">object, ...keys</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> result = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = keys.length; i &lt; len; i++) &#123;</div><div class="line">        result[keys[i]] = object[keys[i]];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>이 버전의 함수에서 <code>keys</code>는 <code>object</code> 다음에 전달된 모든 파라미터를 포함하는 <em>Rest 파라미터</em>입니다 (첫 번째 파라미터를 포함하여 모든 파라미터를 포함하는 <code>arguments</code>와는 다릅니다). 즉, <code>keys</code>를 처음부터 끝까지 반복할 수 있다는 뜻입니다. 이 함수를 보면 보너스로 임의의 여러 파라미터를 처리할 수있다는 것을 알수 있습니다.</p>
<blockquote>
<p><em>Rest 파라미터</em>는 함수에서 이름이 지정된 파라미터의 수를 나타내는 <code>length</code> 프로퍼티에 영향을주지 않습니다. 이 예제에서 <code>pick()</code>에 대한<code>length</code> 값은<code>object</code> 만이 값으로 계산되기 때문에 1입니다.</p>
</blockquote>
<h4 id="Rest-파라미터-제약사항"><a href="#Rest-파라미터-제약사항" class="headerlink" title="Rest 파라미터 제약사항"></a><code>Rest</code> 파라미터 제약사항</h4><p><em>Rest 파라미터</em>에는 두 가지 제약이 있습니다. 첫 번째 제약 사항은 하나의 <em>Rest 파라미터</em>만 있을 수 있으며 <em>Rest 파라미터</em>가 마지막이어야 한다는 것입니다. 예를 들어 다음 코드는 작동하지 않습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Syntax error: rest 파라미터 다음에 명명된 파라미터를 가질 수 없습니다.</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">pick</span>(<span class="params">object, ...keys, last</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> result = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = keys.length; i &lt; len; i++) &#123;</div><div class="line">        result[keys[i]] = object[keys[i]];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>여기서 파라미터 <code>last</code>는 <em>Rest 파라미터</em> <code>keys</code> 다음에 오기 때문에 구문오류가 발생합니다.</p>
<p>두 번째 제약은 <em>Rest 파라미터</em>를 객체 리터럴 <code>Setter</code>에서 사용할 수 없다는 것입니다. 즉, 아래 코드도 구문 오류를 발생시킵니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> object = &#123;</div><div class="line"></div><div class="line">    <span class="comment">// Syntax error: Can't use rest param in setter</span></div><div class="line">    set name(...value) &#123;</div><div class="line">        <span class="comment">// do something</span></div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>이 제약은 개체 리터럴 setter가 단일 파라미터로 제한되기 때문에 발생합니다. <em>Rest 파라미터</em>는 정의상 무한한 수의 파라미터이므로 이 문맥에서는 허용되지 않습니다.</p>
<h4 id="Rest-파라미터가-arguments-객체에-미치는-영향"><a href="#Rest-파라미터가-arguments-객체에-미치는-영향" class="headerlink" title="Rest 파라미터가 arguments 객체에 미치는 영향"></a><em>Rest 파라미터</em>가 <code>arguments</code> 객체에 미치는 영향</h4><p><em>Rest 파라미터</em>는 ECMAScript의 <code>arguments</code>를 대체하도록 설계되었습니다. 원래 ECMAScript 4는 <code>arguments</code>를 없애고 <em>Rest 파라미터</em>를 추가하여 무제한의 파라미터를 함수에 전달할 수 있었습니다. 하지만 ECMAScript 4는 발표 되지 않았고, 이러한 내용은 ECMAScript 6에서 계속 유지되었습니다.</p>
<p><code>arguments</code> 객체는 이 프로그램에서 처럼 호출될 때 함수에 전달된 <code>arguments</code>를 반영하여 <em>Rest 파라미터</em>와 함께 작동합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkArgs</span>(<span class="params">...args</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(args.length);</div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.length);</div><div class="line">    <span class="built_in">console</span>.log(args[<span class="number">0</span>], <span class="built_in">arguments</span>[<span class="number">0</span>]);</div><div class="line">    <span class="built_in">console</span>.log(args[<span class="number">1</span>], <span class="built_in">arguments</span>[<span class="number">1</span>]);</div><div class="line">&#125;</div><div class="line"></div><div class="line">checkArgs(<span class="string">"a"</span>, <span class="string">"b"</span>);</div></pre></td></tr></table></figure>
<p><code>checkArgs()</code> 실행은 다음을 출력합니다 :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">2</div><div class="line">2</div><div class="line">a a</div><div class="line">b b</div></pre></td></tr></table></figure>
<p><code>arguments</code> 객체는 <em>Rest 파라미터</em> 사용에 관계없이 함수에 전달된 파라미터를 항상 정확하게 반영합니다.</p>
<p>이러한 내용이 <em>Rest 파라미터</em>를 사용하기 위해 알아야 할 전부입니다.</p>
<h2 id="함수-Constructor의-향상된-기능"><a href="#함수-Constructor의-향상된-기능" class="headerlink" title="함수 Constructor의 향상된 기능"></a>함수 Constructor의 향상된 기능</h2><p><code>Function</code>의 Constructor는 새로운 함수를 동적으로 생성할 수 있도록 하지만 JavaScript에서 자주 사용하지는 않습니다. Constructor에 대한 <code>arguments</code>는 함수 및 함수 본문에 대한 파라미터이며 모두 문자열입니다. 다음은 그 예입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> add = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"first"</span>, <span class="string">"second"</span>, <span class="string">"return first + second"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">1</span>));     <span class="comment">// 2</span></div></pre></td></tr></table></figure>
<p>ECMAScript 6는 <em>Default 파라미터</em>와 <em>Rest 파라미터</em>를 허용하기 위해 Function Constructor 함수의 기능을 보강했습니다. <em>Default</em><br> 파라미터는 다음과 같이 파라미터 이름에 등호와 값을 추가하기 만하면됩니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> add = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"first"</span>, <span class="string">"second = first"</span>,</div><div class="line">        <span class="string">"return first + second"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">1</span>));     <span class="comment">// 2</span></div><div class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>));        <span class="comment">// 2</span></div></pre></td></tr></table></figure>
<p>위의 예제에서 하나의 파라미터만 전달되면 <code>second</code> 파라미터에 <code>first</code>값이 할당됩니다. 이 구문은 <code>Function</code>을 사용하지 않는 함수 선언과 같습니다.</p>
<p><em>Rest 파라미터</em>의 경우, 마지막 파라미터 앞에 <code>...</code>를 다음과 같이 추가할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> pickFirst = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"...args"</span>, <span class="string">"return args[0]"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(pickFirst(<span class="number">1</span>, <span class="number">2</span>));   <span class="comment">// 1</span></div></pre></td></tr></table></figure>
<p>위 코드는 하나의 <em>Rest 파라미터</em>만을 사용하고 전달된 첫 번째 파라미터를 반환하는 함수를 만듭니다.</p>
<p><em>Default</em>와 <em>Rest 파라미터</em>가 추가되어 <code>Function</code>이 함수의 선언적 형식과 동일한 기능을 모두 갖췄습니다.</p>
<h2 id="Spread-연산자"><a href="#Spread-연산자" class="headerlink" title="Spread 연산자"></a>Spread 연산자</h2><p><em>Rest 파라미터</em>와 밀접하게 관련된 것은 <em>Spread 연산자</em>입니다. <em>Rest 파라미터</em>를 사용하면 여러 독립 파라미터를 <em>Array</em>에 결합해야 한다고 지정할 수 있지만 <em>Spread 연산자</em>를 사용하면 분할해야 하는 <em>Array</em>을 지정하고 해당 항목을 함수에 대한 별도 파라미터로 전달할 수 있습니다. <code>Math.max()</code> 메서드를 생각해 보겠습니다. 이 메서드는 파라미터를 받아들이고 값중 가장 큰 값을 반환합니다. 다음은 이 메서드의 간단한 사용 예입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> value1 = <span class="number">25</span>,</div><div class="line">    value2 = <span class="number">50</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max(value1, value2));      <span class="comment">// 50</span></div></pre></td></tr></table></figure>
<p>이 예제에서와 같이 단지 두 개의 값을 다룰 때, <code>Math.max()</code>는 매우 사용하기 쉽습니다. 두 값이 전달되고 더 큰 값이 반환됩니다. 그러나 <em>Array</em>에서 값을 추적하고 있고 이제 가장 높은 값을 찾고 싶다면 어떻게해야 할까요? <code>Math.max()</code> 메서드는 <em>Array</em>을 전달할 수 없기 때문에, ECMAScript 5와 그 이전 버전에서는 <em>Array</em>을 직접 찾거나 다음과 같이 <code>apply()</code>를 사용했습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> values = [<span class="number">25</span>, <span class="number">50</span>, <span class="number">75</span>, <span class="number">100</span>]</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max.apply(<span class="built_in">Math</span>, values));  <span class="comment">// 100</span></div></pre></td></tr></table></figure>
<p>이 방법으로 실행은 되지만, <code>apply()</code>를 이런 방식으로 사용하는 것은 다소 혼란스러울 수 있습니다. 실제로 추가 구문이 코드의 진정한 의미를 모호하게 만드는 것으로 보입니다.</p>
<p>ECMAScript 6 <em>Spread 연산자</em>는 이 경우를 매우 간단하게 만듭니다. <code>apply()</code>를 호출하는 대신 <em>Array</em>을 <code>Math.max()</code>에 직접 전달하고 <em>Rest 파라미터</em>와 함께 사용되는 <code>...</code>패턴의 접두사를 붙일 수 있습니다. 그러면 JavaScript 엔진이 <em>Array</em>을 개별 파라미터로 분리하여 다음과 같이 전달합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> values = [<span class="number">25</span>, <span class="number">50</span>, <span class="number">75</span>, <span class="number">100</span>]</div><div class="line"></div><div class="line"><span class="comment">// console.log(Math.max(25, 50, 75, 100));</span></div><div class="line"><span class="comment">// 위 코드와 동일합니다.</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max(...values));           <span class="comment">// 100</span></div></pre></td></tr></table></figure>
<p>이제 <code>Math.max()</code>에 대한 호출은 좀 더 보편적으로 보이며 간단한 수학 연산을 위해 <code>this</code>-binding(앞의 예제에서 <code>Math.max.apply()</code>의 첫 번째 파라미터)을 지정하는 복잡성을 피할 수 있습니다.</p>
<p><em>Spread 연산자</em>를 다른 파라미터와 혼합하여 사용할 수도 있습니다. <code>Math.max()</code>에서 반환되는 가장 작은 숫자가 0이 되길 원한다고 가정하십시오. (음수가 <em>Array</em>에 들어가는 경우를 대비해서). 그 파라미터를 개별적으로 전달할 수 있으며 다음과 같이 다른 파라미터에 대해서는 여전히 <em>Spread 연산자</em>를 사용합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> values = [<span class="number">-25</span>, <span class="number">-50</span>, <span class="number">-75</span>, <span class="number">-100</span>]</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max(...values, <span class="number">0</span>));        <span class="comment">// 0</span></div></pre></td></tr></table></figure>
<p>이 예제에서,<code>Math.max()</code>에 전달된 마지막 파라미터는 <code>0</code>이며, 다른 파라미터들은 <em>Spread 연산자</em>를 사용하여 전달됩니다.</p>
<p>파라미터 전달을 위한 <em>Spread 연산자</em>는 함수 파라미터에 대한 <em>Array</em> 사용을 훨씬 쉽게 만듭니다. 대부분의 상황에서 <code>apply()</code> 메서드를 적절하게 대체할 수있을 것입니다.</p>
<p>ECMAScript 6에서는 지금까지 <em>Default</em> 및 <em>Rest 파라미터</em>에서 사용한 용도 외에도 JavaScript의 Function 생성자에 두 파라미터 유형을 모두 적용할 수 있습니다.</p>
<h2 id="ECMAScript-6의-name-프로퍼티"><a href="#ECMAScript-6의-name-프로퍼티" class="headerlink" title="ECMAScript 6의 name 프로퍼티"></a>ECMAScript 6의 name 프로퍼티</h2><p>JavaScript에서 다양한 방법으로 함수를 정의할 수 있어면 함수 식별이 어려울 수 있습니다. 또한, 익명 함수식이 널리 보급됨에 따라 디버깅이 조금 더 어려워지고, 종종 스택 추적의 읽기 및 해독이 어려워질수 있습니다. 이러한 이유로 ECMAScript 6은 모든 함수에 <code>name</code> 프로퍼티을 추가했습니다.</p>
<h3 id="적절한-이름-선택하기"><a href="#적절한-이름-선택하기" class="headerlink" title="적절한 이름 선택하기"></a>적절한 이름 선택하기</h3><p>ECMAScript 6 프로그램의 모든 함수는 <code>name</code> 프로퍼티에 적절한 이름이 부여됩니다. 함수와 함수 표현식을 보여주는 다음 예제의 <code>name</code> 프로퍼티를 출력해 보겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> doAnotherThing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(doSomething.name);          <span class="comment">// "doSomething"</span></div><div class="line"><span class="built_in">console</span>.log(doAnotherThing.name);       <span class="comment">// "doAnotherThing"</span></div></pre></td></tr></table></figure>
<p>이 코드에서 <code>doSomething()</code>은 함수 선언이기 때문에 <code>&quot;doSomething&quot;</code>과 같은 <code>name</code> 프로퍼티를 가지고 있습니다. 익명 함수 표현 인 <code>doAnotherThing()</code>은 <code>&quot;doAnotherThing&quot;</code>의 <code>name</code>을 가지고 있습니다. 왜냐하면 그 이름이 할당된 변수의 이름이기 때문입니다.</p>
<h3 id="name-프로퍼티의-특별한-Case"><a href="#name-프로퍼티의-특별한-Case" class="headerlink" title="name 프로퍼티의 특별한 Case"></a><code>name</code> 프로퍼티의 특별한 Case</h3><p>함수 선언 및 함수 표현식에 대한 이름은 쉽게 찾을 수 있습니다. 그리고 ECMAScript 6은 모든 함수가 적절한 이름을 갖도록합니다. 이것을 설명하기 위해 다음 프로그램을 살펴보겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> doSomething = <span class="function"><span class="keyword">function</span> <span class="title">doSomethingElse</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">    get firstName() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"Nicholas"</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">sayName</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(doSomething.name);      <span class="comment">// "doSomethingElse"</span></div><div class="line"><span class="built_in">console</span>.log(person.sayName.name);   <span class="comment">// "sayName"</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(person, <span class="string">"firstName"</span>);</div><div class="line"><span class="built_in">console</span>.log(descriptor.get.name); <span class="comment">// "get firstName"</span></div></pre></td></tr></table></figure>
<p>이 예제에서,<code>doSomething.name</code>은 <code>&quot;doSomethingElse&quot;</code>입니다. 왜냐하면 함수 표현식 자체가 이름을 갖고, 그 이름이 함수가 할당된 변수보다 우선합니다. <code>person.sayName()</code>의 <code>name</code> 프로퍼티는 값이 객체 리터럴로부터 해석 되었기 때문에 <code>&quot;sayName&quot;</code>입니다. 비슷하게, <code>person.firstName</code>은 실제로 <code>Getter</code> 함수이므로 이 차이를 나타 내기 위해 이름은 <code>&quot;get firstName&quot;</code>입니다. <code>Setter</code> 함수 앞에는 <code>&quot;set&quot;</code>이 붙습니다.(<code>Getter</code> 및 <code>Setter</code> 함수는 모두 <code>Object.getOwnPropertyDescriptor()</code>를 사용하여 검색해야 합니다.)</p>
<p>함수 이름에도 몇 가지 특별한 경우가 있습니다. <code>bind()</code>를 사용하여 생성된 함수의 이름은 <code>&quot;bound&quot;</code>로 시작하고, <code>Function</code> 생성자를 사용하여 생성된 함수의 이름은 <code>&quot;anonymous&quot;</code>입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> doSomething = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(doSomething.bind().name);   <span class="comment">// "bound doSomething"</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log((<span class="keyword">new</span> <span class="built_in">Function</span>()).name);     <span class="comment">// "anonymous"</span></div></pre></td></tr></table></figure>
<p>Bound 함수의 <code>name</code>은 바운드되는 함수의 <code>name</code>에 문자열 <code>&quot;bound&quot;</code>로 접두사가 붙을 것이기 때문에 <code>doSomething()</code>의 바운드 버전은 <code>&quot;bound doSomething&quot;</code>입니다.</p>
<p>함수의 <code>name</code> 값이 반드시 같은 <code>name</code> 변수를 참조하는 것은 아닙니다. <code>name</code> 프로퍼티는 정보를 얻는 수단이되고 디버깅에 유익하지만, <code>name</code>의 값을 사용하여 함수에 대한 참조를 얻는 방법은 없습니다.</p>
<h2 id="함수의-이중-목적을-명확히-하기"><a href="#함수의-이중-목적을-명확히-하기" class="headerlink" title="함수의 이중 목적을 명확히 하기"></a>함수의 이중 목적을 명확히 하기</h2><p>ECMAScript 5 및 이전 버전에서는 함수가 <code>new</code> 유무에 관계없이 호출할 수있는 이중 목적을 제공합니다. <code>new</code>와 함께 사용하면, 함수 안에있는 이 값은 새로운 객체이며, 다음 예제와 같이 새로운 객체가 반환됩니다 :</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>);</div><div class="line"><span class="keyword">var</span> notAPerson = Person(<span class="string">"Nicholas"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person);        <span class="comment">// "[Object object]"</span></div><div class="line"><span class="built_in">console</span>.log(notAPerson);    <span class="comment">// "undefined"</span></div></pre></td></tr></table></figure>
<p><code>notAPerson</code>을 만들 때 <code>new</code>가 없이 <code>Person ()</code>을 호출하면 <code>undefined</code>가됩니다.(<code>nonstrict</code> 모드에서 전역 객체에 <code>name</code> 프로퍼티를 설정합니다). <code>Person</code>의 대문자 사용은 일반적인 JavaScript 프로그램에서 <code>new</code>를 사용하여 함수를 호출할 수 있다는 유일한 지표입니다. 함수의 이중 역할에 대한 혼란으로 인해 ECMAScript 6은 일부 변경되었습니다.</p>
<p>JavaScript는 함수를 위한 두 가지 내부 전용 메서드를 가지고있습니다. :<code>[[Call]]</code>과<code>[[Construct]]</code>. <code>new</code> 없이 함수가 호출되면 <code>[[Call]]</code>메서드가 실행되고 코드의 함수 본문이 실행됩니다. <code>new</code>로 함수를 호출하면, <code>[[Construct]]</code>메서드가 호출됩니다. <code>[[Construct]]</code>메서드는 <code>new.target</code>이라는 새로운 객체를 생성 한 후 <code>this</code>를 <code>new.target</code>으로 설정하여 함수 본문을 실행합니다. <code>[[Construct]]</code>메서드를 가진 함수를 <em>Constructor</em>라고 부릅니다.</p>
<blockquote>
<p>모든 함수가 <code>[[Construct]]</code>를 가지고있는 것은 아니므로 <code>new</code>로 모든 함수를 호출할 수있는 것은 아닙니다. <em>“Arrow Function”</em> 섹션에서 논의된 <em>Arrow 함수</em>에는 <code>[[Construct]]</code> 메서드가 없습니다.</p>
</blockquote>
<h3 id="ECMAScript-5에서-함수-호출-방법-결정"><a href="#ECMAScript-5에서-함수-호출-방법-결정" class="headerlink" title="ECMAScript 5에서 함수 호출 방법 결정"></a>ECMAScript 5에서 함수 호출 방법 결정</h3><p>ECMAScript 5에서 함수가 <code>new</code>와 함께 (그리고 <em>Constructor</em>와 함께) 호출되었는지 결정하는 가장 보편적 인 방법은 <code>instanceof</code>를 사용하는 것입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> Person) &#123;</div><div class="line">        <span class="keyword">this</span>.name = name;   <span class="comment">// using new</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"You must use new with Person."</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>);</div><div class="line"><span class="keyword">var</span> notAPerson = Person(<span class="string">"Nicholas"</span>);  <span class="comment">// throws error</span></div></pre></td></tr></table></figure>
<p>이 코드에서 <code>this</code> 값은 그것이 <em>Constructor</em>의 인스턴스인지를 검사하고, 만약 그렇다면 실행은 정상적으로 계속됩니다. <code>this</code>가<br> <code>Person</code>의 인스턴스가 아니라면 에러가 발생합니다. 이것은<code>[[Construct]]</code> 메서드가 <code>Person</code>의 새로운 인스턴스를 생성하고 이것을 <code>this</code>에 할당하기 때문에 작동합니다. 불행히도, 이 접근법은 완전히 신뢰할 만하지 않습니다. 왜냐하면 아래의 예제에서와 같이 <code>new</code>를 사용하지 않고 <code>Person</code>의 인스턴스가될 수 있기 때문입니다 :</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> Person) &#123;</div><div class="line">        <span class="keyword">this</span>.name = name;   <span class="comment">// using new</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"You must use new with Person."</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>);</div><div class="line"><span class="keyword">var</span> notAPerson = Person.call(person, <span class="string">"Michael"</span>);    <span class="comment">// works!</span></div></pre></td></tr></table></figure>
<p><code>Person.call()</code>을 호출하면 <code>person</code> 변수가 첫 번째 인수로 전달됩니다. 이는 <code>Person</code> 함수 안에서 <code>person</code>으로 설정되었음을 의미합니다. 이 함수에는 <code>new</code>로 불리는 것과 구별할 방법이 없습니다.</p>
<h3 id="new-target-MetaProperty"><a href="#new-target-MetaProperty" class="headerlink" title="new.target MetaProperty"></a>new.target MetaProperty</h3><p>이 문제를 해결하기 위해 ECMAScript 6는 <code>new.target metaproperty</code>를 도입했습니다. 메타 속성은 대상과 관련된 추가 정보 (예 : <code>new</code>)를 제공하는 비 객체의 프로퍼티입니다. 함수의 <code>[[Construct]]</code> 메서드가 호출되면 <code>new.target</code>은 <code>new</code> 연산자의 대상으로 채워집니다. 이 타겟은 일반적으로 새로 생성된 객체 인스턴스의 생성자이며, 이 객체 인스턴스는 함수 본문에서 <code>this</code>가 됩니다. <code>[[Call]]</code>이 실행되면 <code>new.target</code>은 <code>undefined</code>가됩니다.</p>
<p>이 새로운 메타 속성을 사용하면 <code>new.target</code>이 다음과 같이 정의되어 있는지 여부를 확인하여 <code>new</code> 함수가 호출되었는지를 안전하게 감지할 수 있습니다 :</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">new</span>.target !== <span class="string">"undefined"</span>) &#123;</div><div class="line">        <span class="keyword">this</span>.name = name;   <span class="comment">// using new</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"You must use new with Person."</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>);</div><div class="line"><span class="keyword">var</span> notAPerson = Person.call(person, <span class="string">"Michael"</span>);    <span class="comment">// error!</span></div></pre></td></tr></table></figure>
<p>이 <code>instanceof Person</code> 대신 <code>new.target</code>을 사용함으로써, <code>Person</code> 생성자는 <code>new</code>없이 사용될 때 정확하게 에러를 던집니다.</p>
<p>특정 생성자를 사용하여 <code>new.target</code>이 호출되었는지 확인할 수 있습니다. 예를 들어 다음 예제를 살펴보겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">new</span>.target === Person) &#123;</div><div class="line">        <span class="keyword">this</span>.name = name;   <span class="comment">// using new</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"You must use new with Person."</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">AnotherPerson</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    Person.call(<span class="keyword">this</span>, name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>);</div><div class="line"><span class="keyword">var</span> anotherPerson = <span class="keyword">new</span> AnotherPerson(<span class="string">"Nicholas"</span>);  <span class="comment">// error!</span></div></pre></td></tr></table></figure>
<p>이 코드를 보면 제대로 작동하기 위해서는 <code>new.target</code>이 <code>Person</code>이어야합니다. <code>new AnotherPerson( &quot;Nicholas&quot;)</code>가 호출될 때, <code>Person.call(this, name)</code>에 대한 후속 호출은 <code>new.target</code>이 <code>Person</code> 생성자 내부에서 <code>undefined</code>이기 때문에 오류를 던질 것입니다. (`new ‘없이 호출 되었다).</p>
<blockquote>
<p>경고 : 함수 밖에서 <code>new.target</code>을 사용하는 것은 구문 오류입니다.</p>
</blockquote>
<p><code>new.target</code>을 추가함으로써, ECMAScript 6은 함수 호출에 대한 모호함을 명확히하는 데 도움이되었습니다. 이 주제에 따라, ECMAScript 6은 언어의 또 다른 모호한 부분 인 <em>Block-level 함수</em>를 선언합니다.</p>
<h2 id="Block-Level-함수"><a href="#Block-Level-함수" class="headerlink" title="Block-Level 함수"></a>Block-Level 함수</h2><p>ECMAScript 3 및 이전 버전에서는 블록 내부에서 발생하는 함수 선언 (<em>Block-level 함수</em>)은 기술적으로 구문 오류 였지만 모든 브라우저가 여전히 이를 지원했습니다. 불행히도 구문을 허용하는 각 브라우저는 약간 다른 방식으로 동작하므로 블록 내부에서 함수 선언을 피하는 것이 가장 좋습니다 (함수 표현식을 사용하는 것이 가장 좋습니다).</p>
<p>이 호환되지 않는 동작을 억제하기 위해 ECMAScript 5 <code>strict</code> 모드에서는 함수 선언이 다음과 같이 블록 내부에서 사용될 때마다 오류가 발생했습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</div><div class="line"></div><div class="line">    <span class="comment">// ES5에서는 구문 오류가 발생하지만 ES6에서는 발생하지 않습니다.</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ECMAScript 5에서 이 코드는 구문 오류를 발생시킵니다. ECMAScript 6에서 <code>doSomething()</code> 함수는 <em>Block-level</em>선언으로 간주되며, 정의된 동일한 블록 내에서 액세스하고 호출할 수 있습니다. 예 :</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</div><div class="line"></div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> doSomething);        <span class="comment">// "function"</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    doSomething();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> doSomething);            <span class="comment">// "undefined"</span></div></pre></td></tr></table></figure>
<p><em>Block-level 함수</em>는 정의된 블럭의 맨 위로 올라가므로 <code>typeof doSomething</code>은 코드의 함수 선언 앞에 나타나도, “function”을 반환합니다. <code>if</code> 블록의 실행이 끝나면 <code>doSomething()</code>은 더 이상 존재하지 않습니다.</p>
<h3 id="Block-level-함수-사용시기-결정"><a href="#Block-level-함수-사용시기-결정" class="headerlink" title="Block-level 함수 사용시기 결정"></a>Block-level 함수 사용시기 결정</h3><p><em>Block-level 함수</em>는 <code>let</code> 함수 표현식과 유사합니다. 함수 정의는 함수가 정의된 블록에서 실행된 후 제거됩니다. 중요한 차이점은 <em>Block-level 함수</em>는 포함 블록의 상단에 <code>hoisting</code> 된다는 것입니다. <code>let</code>을 사용하는 함수 표현식은 다음 예제와 같이<code>hoisting</code>되지 않습니다 :</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</div><div class="line"></div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> doSomething);        <span class="comment">// throws error</span></div><div class="line"></div><div class="line">    <span class="keyword">let</span> doSomething = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    doSomething();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> doSomething);</div></pre></td></tr></table></figure>
<p>여기서 <code>typeof doSomething</code>이 실행되면 <code>let</code> 문이 아직 실행되지 않았기 때문에 코드 실행이 멈추고 TDZ에 <code>doSomething()</code>이 남게됩니다. 이 차이점을 안다면, <em>Block-level 함수</em>를 사용할 것인지, <code>hoisting</code>동작을 원하는지 여부에 따라 <code>let</code> 표현식을 사용할 것인지 선택할 수 있습니다.</p>
<h3 id="Nonstrict-모드의-Block-level-함수"><a href="#Nonstrict-모드의-Block-level-함수" class="headerlink" title="Nonstrict 모드의 Block-level 함수"></a>Nonstrict 모드의 <em>Block-level</em> 함수</h3><p>ECMAScript 6은 <code>nonstrict</code> 모드에서 <em>Block-level 함수</em>를 허용하지만, 동작은 약간 다릅니다. 함수 선언문을 블록의 상단으로 <code>hoisting</code> 하는 대신에, 함수를 포함하는 함수, 또는 전역 환경으로 계속 끌어 올립니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ECMAScript 6 behavior</span></div><div class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</div><div class="line"></div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> doSomething);        <span class="comment">// "function"</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    doSomething();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> doSomething);            <span class="comment">// "function"</span></div></pre></td></tr></table></figure>
<p>위 예제에서, <code>doSomething()</code>은 전역 Scope로 끌어 올려 지므로 <code>if</code> 블록의 바깥에 존재합니다. ECMAScript 6은 이 동작을 표준화하여 이전에는 존재하지 않는 호환되지 않는 브라우저 동작을 제거하므로 모든 ECMAScript 6 런타임은 동일한 방식으로 동작해야합니다.</p>
<p><em>Block-level 함수</em>는 JavaScript에서 함수를 선언하는 기능이 향상시켰지만 ECMAScript 6에서는 함수를 선언하는 완전히 새로운 방법을 도입했습니다.</p>
<h2 id="화살표-함수-Arrow-Function"><a href="#화살표-함수-Arrow-Function" class="headerlink" title="화살표 함수 (Arrow Function)"></a>화살표 함수 (Arrow Function)</h2><p>ECMAScript 6의 가장 흥미로운 부분 중 하나는 <em>Arrow 함수</em>입니다. <em>Arrow 함수</em>는 이름에서 알 수 있듯이 “Arrow”(<code>=&gt;</code>)를 사용하는 새로운 구문으로 정의된 함수입니다. 하지만 <em>Arrow 함수</em>는 여러 가지 중요한 부분이 기존의 JavaScript 함수와 다르게 작동합니다.</p>
<ul>
<li><strong>this, super, arguments 및 new.target 바인딩은 없습니다</strong> - 함수 내부의 this, super, arguments 및 new.target의 값은 가장 인접한 nonarrow 함수를 나타냅니다. (super는 4 장에서 다룬다.)</li>
<li><strong>new로 호출할 수 없습니다</strong> - <em>Arrow 함수</em>는 <code>[[Construct]]</code> 메서드를 가지지 않으므로 생성자를 사용할 수 없습니다. <em>Arrow 함수</em>는 <code>new</code>와 함께 사용될 때 에러를 던집니다.</li>
<li><strong>prototype이 없습니다</strong> - <em>Arrow 함수</em>에 <code>new</code>를 사용할 수 없으므로 prototype이 필요 없습니다. <em>Arrow 함수</em>는 prototype 프로퍼티가 존재하지 않습니다.</li>
<li><strong>this를 바꿀 수 없습니다</strong> - 함수 안의 <code>this</code> 값은 변경할 수 없습니다. 함수의 전체 라이프 사이클 동안 동일하게 유지됩니다.</li>
<li><strong>arguments 객체가 없습니다</strong> - <em>Arrow 함수</em>에는 <code>arguments</code> 바인딩이 없으므로 함수 파라미터에 액세스하려면 명명된 파라미터와 <em>rest 파라미터</em>에 의존해야합니다.</li>
<li><strong>이름이 중복된 파라미터가 없습니다</strong> - <em>Arrow 함수</em>는 <code>nonstrict</code> 모드에서 중복된 이름의 파라미터를 가질수 있는 <code>nonarrow</code> 함수와는 달리 <code>strict</code> 또는 <code>nonstrict</code> 모드에서 중복된 이름의 파라미터를 가질수 없습니다.</li>
</ul>
<p>이러한 차이에는 몇 가지 이유가 있습니다. 무엇보다 먼저, <code>this</code> 바인딩은 JavaScript의 일반적인 오류 원인입니다. 의도하지 않은 프로그램 동작을 초래할 수있는 함수 내에서 <code>this</code>값을 추적하는 것을 잃어 버리기가 매우 쉽습니다. <em>Arrow 함수</em>는 이러한 혼란을 없애줍니다. 둘째, <em>Arrow 함수</em>를 단일 <code>this</code>값으로 코드를 실행하는 것으로 제한함으로써 JavaScript 엔진은 생성자로 사용되거나 수정될 수있는 일반 함수와 달리 연산을 보다 쉽게 최적화할 수 있습니다.</p>
<p>나머지 차이점은 <em>Arrow 함수</em> 내부의 오류와 모호성을 줄이는 데에도 초점을 맞추고 있습니다. 그렇게함으로써, JavaScript 엔진은 <em>Arrow<br> 함수</em> 실행을 더 잘 최적화할 수 있습니다.</p>
<blockquote>
<p>참고 : <em>Arrow 함수</em>에는 다른 함수와 동일한 규칙을 따르는 <code>name</code> 프로퍼티는 있습니다.</p>
</blockquote>
<h3 id="Arrow-함수-Syntax"><a href="#Arrow-함수-Syntax" class="headerlink" title="Arrow 함수 Syntax"></a>Arrow 함수 Syntax</h3><p><em>Arrow 함수</em>의 구문은 여러분이 원하는 모양에 따라 다양한 형태로 가능합니다. 하지만 모든 <em>Arrow 함수는</em> 파라미터와 화살표, 함수 본문 순으로 시작됩니다. 파라미터와 본문 모두 사용법에 따라 다른 형태를 취할 수 있습니다. 예를 들어, 다음 <em>Arrow 함수</em>는 단일 파라미터를 받고 이를 단순히 반환합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> reflect = <span class="function"><span class="params">value</span> =&gt;</span> value;</div><div class="line"></div><div class="line"><span class="comment">// 다음과 동일한 효과를 나타냅니다.</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> reflect = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> value;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><em>Arrow 함수</em>에 대해 파라미터가 하나만 있을 경우, 그 파라미터는 더 이상의 구문없이 직접 사용될 수 있습니다. 다음에 화살표가오고 화살표 오른쪽에 있는 표현식이 계산되어 반환됩니다. 명시적 return 문이 없더라도 이 <em>Arrow 함수</em>는 전달된 첫 번째 파라미터를 반환합니다.</p>
<p>둘 이상의 파라미터를 전달하는 경우 다음과 같이 파라미터를 괄호로 묶어야합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> num1 + num2;</div><div class="line"></div><div class="line"><span class="comment">// 다음과 동일한 효과를 나타냅니다.</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>sum()</code> 함수는 두개의 파라미터를 더하고 그 결과를 반환합니다. 이 <em>Arrow 함수</em>와 <code>reflect()</code> 함수의 유일한 차이점은 파라미터가 괄호 안에 쉼표로 구분되어 있습니다 (기존 함수처럼).</p>
<p>함수에 대한 파라미터가가 없으면 다음과 같이 빈 괄호 세트를 선언에 포함해야합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> getName = <span class="function"><span class="params">()</span> =&gt;</span> <span class="string">"Nicholas"</span>;</div><div class="line"></div><div class="line"><span class="comment">// 다음과 동일한 효과를 나타냅니다.</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"Nicholas"</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>두 개 이상의 표현식으로 구성되는 더 전통적인 함수 본문을 제공하려면 이 버전의 <code>sum ()</code>에서와 같이 함수 본문을 중괄호로 묶고 반환 값을 명시적으로 정의해야합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 다음과 동일한 효과를 나타냅니다.</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>중괄호 내부는 <code>arguments</code>를 사용할 수 없다는 점을 제외하면 전통적인 함수와 동일합니다.</p>
<p>아무 것도하지 않는 함수를 만들려면 다음과 같이 중괄호를 포함해야합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> doNothing = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 다음과 동일한 효과를 나타냅니다.</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> doNothing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</div></pre></td></tr></table></figure>
<p>중괄호는 함수의 몸체를 나타 내기 위해 사용되며, 지금까지 보았던 경우에는 잘 작동합니다. 그러나 객체 리터럴을 반환하고자하는 화살표 함수는 괄호 안에 리터럴을 래핑해야합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> getTempItem = <span class="function"><span class="params">id</span> =&gt;</span> (&#123; <span class="attr">id</span>: id, <span class="attr">name</span>: <span class="string">"Temp"</span> &#125;);</div><div class="line"></div><div class="line"><span class="comment">// 다음과 동일한 효과를 나타냅니다.</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> getTempItem = <span class="function"><span class="keyword">function</span>(<span class="params">id</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">id</span>: id,</div><div class="line">        <span class="attr">name</span>: <span class="string">"Temp"</span></div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>괄호 안에 객체 리터럴을 래핑하면 중괄호가 함수 본문 대신 객체 리터럴임을 알립니다.</p>
<h3 id="즉시-호출-함수-표현식-만들기-Immediately-Invoked-Function-Expression"><a href="#즉시-호출-함수-표현식-만들기-Immediately-Invoked-Function-Expression" class="headerlink" title="즉시 호출 함수 표현식 만들기 (Immediately-Invoked Function Expression)"></a>즉시 호출 함수 표현식 만들기 (Immediately-Invoked Function Expression)</h3><p>JavaScript 함수의 인기있는 사용은 즉시 호출 함수 표현식 (Immediately-Invoked Function Expression - IIFE)을 작성하는 것입니다. IIFE를 사용하면 익명의 함수를 정의하여 참조를 저장하지 않고 즉시 호출할 수 있습니다. 이 패턴은 프로그램의 나머지 부분으로부터 보호되는 Scope를 만들 때 유용합니다. 예 :</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> person = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">getName</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> name;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">&#125;(<span class="string">"Nicholas"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person.getName());      <span class="comment">// "Nicholas"</span></div></pre></td></tr></table></figure>
<p>이 코드에서 IIFE는 <code>getName()</code> 메서드를 사용하여 객체를 만드는 데 사용됩니다. 이 메서드는 <code>name</code> 파라미터를 리턴 값으로 사용하여 반환된 객체의 private 멤버를 만듭니다.</p>
<p>괄호를 이용하여 래핑하면 동일한 작업을 수행 하는 <em>Arrow 함수</em>를 만들수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> person = <span class="function">(<span class="params">(name</span>) =&gt;</span> &#123;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">getName</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> name;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">&#125;)(<span class="string">"Nicholas"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person.getName());      <span class="comment">// "Nicholas"</span></div></pre></td></tr></table></figure>
<p>괄호는 <em>Arrow 함수</em> 정의 주위에서만 있고 <code>(&quot;Nicholas&quot;)</code>는 포함하지 않습니다. 이것이 기존의 함수와 다른데, 괄호는 입력된 파라미터를 포함하여 함수 정의 주변만 배치 할 수 있습니다.</p>
<h3 id="this-바인딩이-없음"><a href="#this-바인딩이-없음" class="headerlink" title="this 바인딩이 없음"></a>this 바인딩이 없음</h3><p>JavaScript에서 가장 일반적인 오류 중 하나는 함수 내부에 <code>this</code>를 바인딩하는 것입니다. <code>this</code>의 값은 함수가 호출되는 문맥에 따라 하나의 함수 안에서 바뀔 수 있기 때문에, 의도하지 않지만 실수로 다른 객체에 영향을 미칠 수 있습니다. 다음 예제를 살펴보겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> PageHandler = &#123;</div><div class="line"></div><div class="line">    <span class="attr">id</span>: <span class="string">"123456"</span>,</div><div class="line"></div><div class="line">    <span class="attr">init</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">document</span>.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">            <span class="keyword">this</span>.doSomething(event.type);     <span class="comment">// error</span></div><div class="line">        &#125;, <span class="literal">false</span>);</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    <span class="attr">doSomething</span>: <span class="function"><span class="keyword">function</span>(<span class="params">type</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"Handling "</span> + type  + <span class="string">" for "</span> + <span class="keyword">this</span>.id);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>위 코드에서 객체 <code>PageHandler</code>는 페이지와 상호 작용을 처리하도록 설계되었습니다. 상호 작용을 설정하기 위해 <code>init()</code> 메서드가 호출되고, 그 메서드는 차례대로 <code>this.doSomething()</code>을 호출하는 이벤트 핸들러를 할당합니다. 그러나 이 코드는 의도 한대로 정확하게 작동하지 않습니다.</p>
<p><code>this.doSomething()</code>에 대한 호출은 <code>this</code>가 <code>PageHandler</code>에 바인딩되는 대신 이벤트 대상 (이 경우 <code>document</code>)에 대한 참조이기 때문에 끊어집니다. 이 코드를 실행하려고하면 <code>this.doSomething()</code>이 대상 <code>document</code> 객체에 없기 때문에 이벤트 핸들러가 실행될 때 오류가 발생합니다.</p>
<p><code>bind()</code> 메서드를 이용해 명시적으로 <code>PageHandler</code>에 바인딩함으로써 이 문제를 해결할 수 있습니다 :</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> PageHandler = &#123;</div><div class="line"></div><div class="line">    <span class="attr">id</span>: <span class="string">"123456"</span>,</div><div class="line"></div><div class="line">    <span class="attr">init</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">document</span>.addEventListener(<span class="string">"click"</span>, (<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">            <span class="keyword">this</span>.doSomething(event.type);     <span class="comment">// no error</span></div><div class="line">        &#125;).bind(<span class="keyword">this</span>), <span class="literal">false</span>);</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    <span class="attr">doSomething</span>: <span class="function"><span class="keyword">function</span>(<span class="params">type</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"Handling "</span> + type  + <span class="string">" for "</span> + <span class="keyword">this</span>.id);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>이제 코드는 예상대로 작동하지만 약간 이상하게 보일 수 있습니다. <code>bind(this)</code>를 호출함으로써 실제로 <code>this</code>가 현재 <code>this</code>에 바인드된 새로운 함수,<code>PageHandler</code>를 생성하고 있습니다. 이 코드를 수정하는 더 좋은 방법은 <em>Arrow 함수</em>를 사용하는 것입니다.</p>
<p><em>Arrow 함수</em>에는 <code>this</code> 바인딩이 없습니다. 즉, <em>Arrow 함수</em> 안에있는 <code>this</code>의 값은 Scope 체인을 찾는 것으로만 결정될 수 있습니다. <em>Arrow 함수</em>가 <em>nonarrow 함수</em> 내에 포함되어 있다면, <code>this</code>는 포함 함수와 같습니다. 그렇지 않으면 <code>this</code>는 전역 Scope에서 <code>this</code>의 값과 같습니다. <em>Arrow 함수</em>를 사용하여 이 코드를 작성할 수있는 한 가지 방법은 다음과 같습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> PageHandler = &#123;</div><div class="line"></div><div class="line">    <span class="attr">id</span>: <span class="string">"123456"</span>,</div><div class="line"></div><div class="line">    <span class="attr">init</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">document</span>.addEventListener(<span class="string">"click"</span>,</div><div class="line">                event =&gt; <span class="keyword">this</span>.doSomething(event.type), <span class="literal">false</span>);</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    <span class="attr">doSomething</span>: <span class="function"><span class="keyword">function</span>(<span class="params">type</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"Handling "</span> + type  + <span class="string">" for "</span> + <span class="keyword">this</span>.id);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>이 예제의 이벤트 핸들러는 <code>this.doSomething()</code>을 호출하는 <em>Arrow 함수</em>입니다. <code>this</code>의 값은 <code>init()</code> 안에있는 것과 같기 때문에, 이 버전의 코드는 <code>bind (this)</code>를 사용하는 것과 비슷하게 동작합니다. <code>doSomething()</code> 메서드는 값을 반환하지 않지만, 여전히 함수 본문 내에서 실행되는 유일한 명령문이므로, 중괄호를 포함할 필요가 없습니다.</p>
<p><em>Arrow 함수</em>는 “제거 가능한(throwaway)” 함수로 설계되었으므로 새 타입을 정의하는 데 사용할 수 없습니다. 이것은 일반 함수에 있는 <code>prototype</code> 속성이 빠져 있음을 알 수 있습니다. 화살표 함수로 <code>new</code> 연산자를 사용하려고하면 다음 예제와 같이 오류가 발생합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> MyType = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;,</div><div class="line">    object = <span class="keyword">new</span> MyType();  <span class="comment">// error - you can't use arrow functions with 'new'</span></div></pre></td></tr></table></figure>
<p>이 코드에서, <code>MyType</code>은 <em>Arrow 함수</em>이므로 <code>[[Construct]]</code> 행위를 하지 않기 때문에 새로운 <code>MyType()</code>에 대한 호출은 실패합니다. JavaScript 엔진은 <em>Arrow 함수</em>가 <code>new</code>와 함께 사용할 수 없다는 사실을 알게 되면 자신의 행동을 더욱 최적화할 수 있습니다.</p>
<p>또한, <code>this</code>값은 <em>Arrow 함수</em>가 정의된 포함 함수에 의해 결정되므로 <code>call()</code>, <code>apply()</code> 또는 <code>bind()</code>를 사용하여 <code>this</code>의 값을 변경할 수 없습니다.</p>
<h3 id="Arrow-함수와-Array"><a href="#Arrow-함수와-Array" class="headerlink" title="Arrow 함수와 Array"></a>Arrow 함수와 Array</h3><p><em>Arrow 함수</em>의 간결한 구문은 <em>Array</em> 처리와 함께 사용하기에 이상적입니다. 예를 들어, 사용자 정의 Comparator를 사용하여<em>Array</em>을 정렬하려면 일반적으로 다음과 같이 작성합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> result = values.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> a - b;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>이것은 매우 간단한 기능을 위해 많은 구문이 필요합니다. 더 간결한 <em>Arrow 함수</em> 버전과 비교해보십시오.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> result = values.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</div></pre></td></tr></table></figure>
<p><code>sort()</code>, <code>map()</code>, <code>reduce()</code>와 같은 콜백 함수를 받아들이는 Array 메서드는 단순한 코드로 복잡한 프로세스를 변경하는 <em>Arrow 함수</em> 구문의 이점을 모두 누릴 수 있습니다.</p>
<h3 id="arguments-바인딩-없음"><a href="#arguments-바인딩-없음" class="headerlink" title="arguments 바인딩 없음"></a>arguments 바인딩 없음</h3><p><em>Arrow 함수</em>가 자신의 <code>arguments</code> 객체를 가지고 있지는 않지만 포함 함수의 <code>arguments</code> 객체에 접근할 수 있습니다. <em>Arrow<br>함수</em>가 어디에서 실행 되든 관계없이 포함 함수의 <code>arguments</code>객체를 사용할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createArrowFunctionReturningFirstArg</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">arguments</span>[<span class="number">0</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> arrowFunction = createArrowFunctionReturningFirstArg(<span class="number">5</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(arrowFunction());       <span class="comment">// 5</span></div></pre></td></tr></table></figure>
<p><code>createArrowFunctionReturningFirstArg()</code> 내부에서, <code>arguments[0]</code> 요소는 생성된 <em>Arrow 함수</em>에 의해 참조됩니다. 그 참조는<code>createArrowFunctionReturningFirstArg()</code> 함수에 전달 된 첫 번째 파라미터를 나타냅니다. <em>Arrow 함수</em>가 나중에 실행되면 5를 반환하는데, 이것은 <code>createArrowFunctionReturningFirstArg()</code>에 전달된 첫 번째 인파라미터입니다. <em>Arrow 함수</em>가 더 이상 자신를 생성 한 Scope에 없더라도 <code>arguments</code> 식별자의 Scope chain resolution 때문에 <code>arguments</code>는 여전히 접근 가능합니다.</p>
<h3 id="Arrow-함수-식별하기"><a href="#Arrow-함수-식별하기" class="headerlink" title="Arrow 함수 식별하기"></a>Arrow 함수 식별하기</h3><p>다른 구문에도 불구하고 <em>Arrow 함수</em>는 여전히 함수이며 식별 가능합니다. 다음 코드를 생각해 보겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> comparator = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> comparator);                 <span class="comment">// "function"</span></div><div class="line"><span class="built_in">console</span>.log(comparator <span class="keyword">instanceof</span> <span class="built_in">Function</span>);    <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p><code>console.log()</code> 결과는, <code>typeof</code>와 <code>instanceof</code>가 다른 함수와 마찬가지로 <em>Arrow 함수</em>가 똑같이 행동한다는 것을 보여줍니다.</p>
<p>함수의 <code>this</code>-binding은 영향을 받지 않지만, 다른 함수와 마찬가지로 <em>Arrow 함수</em>는 여전히 <code>call()</code>, <code>apply()</code> 및 <code>bind()</code>를 사용할 수 있습니다. 여기 몇 가지 예가 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> num1 + num2;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(sum.call(<span class="literal">null</span>, <span class="number">1</span>, <span class="number">2</span>));      <span class="comment">// 3</span></div><div class="line"><span class="built_in">console</span>.log(sum.apply(<span class="literal">null</span>, [<span class="number">1</span>, <span class="number">2</span>]));   <span class="comment">// 3</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> boundSum = sum.bind(<span class="literal">null</span>, <span class="number">1</span>, <span class="number">2</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(boundSum());                <span class="comment">// 3</span></div></pre></td></tr></table></figure>
<p><code>sum()</code> 함수는 다른 함수와 마찬가지로 <code>call()</code>과 <code>apply()</code>를 사용하여 파라미터를 전달합니다. <code>bind()</code>메서드는 <code>boundSum()</code>을 생성하는데 사용되며, 두개의 파라미터는 1과 2에 연결되어 직접 전달할 필요가 없습니다.</p>
<p><em>Arrow 함수</em>는 콜백과 같이 현재의 익명 함수 표현식을 사용하고있는 곳이면 어디서든 사용하기에 적합합니다. 다음 섹션은 또 다른 주요한 ECMAScript 6을 다루지만, 이것은 모두 내부적이며 <code>new</code> 구문을 가지고 있지 않습니다.</p>
<h2 id="Tail-Call-최적화"><a href="#Tail-Call-최적화" class="headerlink" title="Tail Call 최적화"></a>Tail Call 최적화</h2><p>아마도 ECMAScript 6의 기능 중 가장 흥미로운 변화는 Tail call 시스템을 변경하는 엔진 최적화입니다. Tail call은 함수가 다음과 같이  함수의 마지막 명령문으로 다른 함수를 호출하는 패턴입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> doSomethingElse();   <span class="comment">// tail call</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ECMAScript 5 엔진에서 구현된 Tail call은 다른 함수 호출과 마찬가지로 처리됩니다. 새 스택 프레임이 만들어지고 Call 스택에 푸시되어 함수 호출을 나타냅니다. 이는 모든 이전 스택 프레임이 메모리에 유지된다는 것을 의미하며, 호출 스택이 너무 커지면 문제가됩니다.</p>
<h3 id="무엇이-다른가"><a href="#무엇이-다른가" class="headerlink" title="무엇이 다른가?"></a>무엇이 다른가?</h3><p>ECMAScript 6는 <code>strict</code> 모드에서 특정 Tail call에 대한 호출 스택의 크기를 줄이려고 시도합니다 (<code>nonstrict</code> 모드 Tail call은 그대로 유지됩니다). 이 최적화를 통해 Tail call에 대한 새 스택 프레임을 만드는 대신 다음 조건이 충족되는 한 현재 스택 프레임이 지워지고 다시 사용됩니다.</p>
<ol>
<li>Tail call은 현재 스택 프레임의 변수에 액세스할 필요가 없습니다 (함수가 클로저가 아님을 의미)</li>
<li>Tail call을 수행하는 함수는 Tail call이 리턴 한 후에 더 이상 수행할 작업이 없습니다.</li>
<li>Tail call의 결과는 함수 값으로 반환됩니다.</li>
</ol>
<p>예를 들어 다음 코드는 세 가지 기준 모두에 적합하기 때문에 이 코드를 쉽게 최적화할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// optimized</span></div><div class="line">    <span class="keyword">return</span> doSomethingElse();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>위의 함수는 <code>doSomethingElse()</code>에 대해 Tail call을 하고 결과를 즉시 반환하며 로컬 범위의 변수에 액세스하지 않습니다. 하지만 아래의 함수는 결과를 반환하지 않기 때문에 최적화되지 않습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// not optimized - no return</span></div><div class="line">    doSomethingElse();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>마찬가지로 Tail call에서 복귀 한 후 작업을 수행하는 경우 함수를 최적화할 수 없습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// not optimized - must add after returning</span></div><div class="line">    <span class="keyword">return</span> <span class="number">1</span> + doSomethingElse();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>위 예제는 값을 반환하기 전에 <code>doSomethingElse()</code>에 단지 1을 더하지만 최적화를 끄기에 충분합니다.</p>
<p>실수로 최적화를 끄는 또 다른 일반적인 실수는 함수 호출 결과를 변수에 저장 한 다음 결과를 반환하는 것입니다. 예를 들면 다음과 같습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// not optimized - call isn't in tail position</span></div><div class="line">    <span class="keyword">var</span> result = doSomethingElse();</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>위 예제는 <code>doSomethingElse()</code>의 값이 즉시 리턴되지 않기 때문에 최적화될 수 없습니다.</p>
<p>아마도 가장 어려운 상황은 클로저 사용에 있습니다. 클로저가 포함된 Scope의 변수에 액세스할 수 있으므로 Tail call 최적화가 해제될 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> num = <span class="number">1</span>,</div><div class="line">        func = <span class="function"><span class="params">()</span> =&gt;</span> num;</div><div class="line"></div><div class="line">    <span class="comment">// not optimized - 함수가 closure 입니다.</span></div><div class="line">    <span class="keyword">return</span> func();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>클로저 <code>func()</code>는 이 예제에서 지역 변수 <code>num</code>에 접근할 수 있습니다. <code>func()</code>를 호출하면 즉시 결과가 반환되지만 변수 <code>num</code>을 참조하기 때문에 최적화할 수 없습니다.</p>
<h3 id="Tail-call-최적화를-활용하는-방법"><a href="#Tail-call-최적화를-활용하는-방법" class="headerlink" title="Tail call 최적화를 활용하는 방법"></a>Tail call 최적화를 활용하는 방법</h3><p>실제로 Tail call 최적화는 배후에서 발생하기 때문에 함수를 최적화하려고 시도하지 않는 한 생각할 필요가 없습니다. Tail call 최적화의 주요 사용 사례는 재귀 함수입니다. 최적화가 가장 큰 효과를 발휘하기 때문입니다. 팩토리얼을 계산하는 이 함수를 생각해 보겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">        <span class="comment">// not optimized - must multiply after returning</span></div><div class="line">        <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>곱셈이 <code>factorial()</code>을 재귀 호출 한 후에 일어나야하기 때문에 이 버전의 함수는 최적화될 수 없습니다. <code>n</code>이 매우 큰 경우 호출 스택 크기가 커지고 잠재적으로 스택 오버플로가 발생할 수 있습니다.</p>
<p>함수를 최적화 하려면 마지막 함수 호출 후에 곱셈이 발생하지 않도록 해야합니다. 이를 위해 <em>Default 파라미터</em>를 사용하여 곱하기 연산을 return 문 외부로 옮길 수 있습니다. 결과 함수는 임시 결과를 따라 다음 반복으로 전달되어 동일하게 동작하지만 ECMAScript 6 엔진에서 최적화할 수있는 함수를 만듭니다. 다음은 새로운 코드입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n, p = <span class="number">1</span></span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span> * p;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">let</span> result = n * p;</div><div class="line"></div><div class="line">        <span class="comment">// optimized</span></div><div class="line">        <span class="keyword">return</span> factorial(n - <span class="number">1</span>, result);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>이 다시 작성된 <code>factorial()</code> 버전에서 두 번째 파라미터 <code>p</code>가 추가되었고 <em>Default</em> 값이 1입니다. <code>p</code> 파라미터는 이전 곱셈 결과를 유지하므로 다른 함수 호출없이 다음 결과를 계산할 수 있습니다. <code>n</code>이 1보다 크면 곱셈이 먼저 수행된 후 두 번째 인수로 <code>factorial()</code>으로 전달됩니다. 이를 통해 ECMAScript 6 엔진이 재귀 호출을 최적화할 수 있습니다.</p>
<p>Tail call 최적화는 재귀 함수를 작성할 때, 특히 연산이 많은 함수에 적용할 때 상당한 성능 향상을 제공할 수 있으므로 생각해야할 부분입니다.</p>
<h2 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h2><p>함수는 ECMAScript 6에서 큰 변화를 겪지는 않았지만 일련의 점진적 변경으로 인해 작업이 더 쉬워졌습니다.</p>
<p>함수의 <em>Default 파라미터</em>를 사용하면 특정 파라미터가 전달되지 않을 때 사용할 값을 쉽게 지정할 수 있습니다. ECMAScript 6 이전에는 함수 내부에 몇 가지 추가 코드가 필요 했으므로 파라미터가 있는지 확인하고 다른 값을 할당할 수 있었습니다.</p>
<p><em>Rest 파라미터</em>를 사용하면 나머지 모든 파라미터를 배치할 <em>Array</em>을 지정할 수 있습니다. 실제 <em>Array</em>을 사용하고 포함시킬 파라미터를 지정하게하면 <em>Rest 파라미터</em>가 <code>arguments</code>보다 훨씬 더 유연한 해결책이됩니다.</p>
<p><em>Spread 연산자</em>는 <em>Rest 파라미터</em>와 함께 사용되므로 함수를 호출할 때 <em>Array</em>을 개별 파라미터로 분해할 수 있습니다. ECMAScript 6 이전에는 <em>Array</em>에 포함된 개별 파라미터를 전달하는 두 가지 방법이 있었습니다. 수동으로 각 파라미터를 지정하거나 <code>apply()</code>를 사용하는 것입니다. <em>Spread 연산자</em>를 사용하면 함수의 ‘this’ 바인딩에 대한 걱정없이 모든 함수에 <em>Array</em>을 쉽게 전달할 수 있습니다.</p>
<p><code>name</code> 프로퍼티을 추가하면 디버깅 및 평가 목적을 쉽게 식별할 수 있습니다. 또한 ECMAScript 6는 <em>Block-level 함수</em>의 동작을 공식적으로 정의하므로 더 이상 <code>strict</code> 모드에서는 구문 오류가 아닙니다.</p>
<p>ECMAScript 6에서 함수의 동작은 <code>[[Call]]</code>, 일반 함수 실행, <code>[[Construct]]</code>에 의해 정의되며, <code>new</code>로 호출이 됩니다. <code>new.target</code> 메타 속성은 <code>new</code>를 사용하여 함수가 호출되었는지 아닌지를 결정할 수 있게합니다.</p>
<p>ECMAScript 6에서 가장 많이 변경된 기능은 <em>Arrow 함수</em>가 추가된 것입니다. <em>Arrow 함수</em>는 익명의 함수 표현식 대신 사용되도록 설계되었습니다. <em>Arrow 함수</em>는 보다 간결한 문법, 어휘, <code>this</code> 바인딩 없음, <code>arguments</code> 객체를 가지고 있지 않습니다. 또한, <em>Arrow 함수</em>는 <code>this</code> 바인딩을 변경할 수 없으므로 Constructor로 사용할 수 없습니다.</p>
<p>Tail call 최적화는 더 작은 호출 스택을 유지하고 더 적은 메모리를 사용하며 스택 오버플로 오류를 방지하기 위해 일부 함수 호출을 최적화할 수 있습니다. 이 최적화는 엔진에서 자동으로 적용되므로 안전하지만 이 최적화를 이용하려면 재귀 함수를 다시 작성하기로 결정할 수도 있습니다.</p>
<hr>
<blockquote>
<p>이 내용은 나중에 참고하기 위해 제가 공부하며 정리한 내용입니다.<br>의역, 오역, 직역이 있을 수 있음을 알려드립니다.<br>This post is a translation of this original article [<a href="https://leanpub.com/understandinges6/read#leanpub-auto-functions" target="_blank" rel="external">https://leanpub.com/understandinges6/read#leanpub-auto-functions</a>]</p>
</blockquote>
<h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul>
<li><a href="https://infoscis.github.io/2018/01/24/ecmascript-6-block-binding/">ECMAScript 6 Block Binding</a></li>
<li><a href="https://infoscis.github.io/2018/01/24/ecmascript-6-strings-and-regular-expressions/">ECMAScript 6 문자열과 정규 표현식</a></li>
<li><a href="https://infoscis.github.io/2018/01/24/ecmascript-6-functions/">ECMAScript 6 함수</a></li>
<li><a href="https://infoscis.github.io/2018/01/25/ecmascript-6-expanded-object-functionality/">ECMAScript 6 객체의 확장된 기능</a></li>
<li><a href="https://infoscis.github.io/2018/01/26/ecmascript-6-destructuring-for-easier-data-access/">ECMAScript 6 쉬운 데이터 액세스를 위한 Destructuring</a></li>
<li><a href="https://infoscis.github.io/2018/01/27/ecmascript-6-symbols-and-symbol-properties/">ECMAScript 6 Symbol과 Symbol 프로퍼티</a></li>
<li><a href="https://infoscis.github.io/2018/01/27/ecmascript-6-sets-and-maps/">ECMAScript 6 Set과 Map</a></li>
<li><a href="https://infoscis.github.io/2018/01/31/ecmascript-6-iterators-and-generators/">ECMAScript 6 Iterator와 Generator</a></li>
<li><a href="https://infoscis.github.io/2018/02/13/ecmascript-6-introducing-javascript-classes/">ECMAScript 6 JavaScript 클래스 소개</a></li>
<li><a href="https://infoscis.github.io/2018/02/13/ecmascript-6-improved-array-capabilities/">ECMAScript 6 Array 기능 향상</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-promises-and-asynchronous-programming/">ECMAScript 6 Promise와 비동기 프로그램밍</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-proxies-and-the-reflection-api/">ECMAScript 6 프록시와 리플렉션 API</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-encapsulating-code-with-modules/">ECMAScript 6 Module로 코드 캡슐화하기</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-appendix-a-smaller-changes/">ECMAScript 6 부록 A. 작은 변경 사항</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-appendix-b-understanding-ecmascript-7/">ECMAScript 6 부록 B. ECMAScript 7(2016) 이해하기</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;함수-Function&quot;&gt;&lt;a href=&quot;#함수-Function&quot; class=&quot;headerlink&quot; title=&quot;함수 (Function)&quot;&gt;&lt;/a&gt;함수 (Function)&lt;/h1&gt;&lt;p&gt;함수는 JavaScript 프로그래밍 언어의 중요한 부
    
    </summary>
    
      <category term="JavaScript" scheme="http://infoscis.github.io/categories/JavaScript/"/>
    
      <category term="ECMAScript 2015" scheme="http://infoscis.github.io/categories/JavaScript/ECMAScript-2015/"/>
    
    
      <category term="JavaScript" scheme="http://infoscis.github.io/tags/JavaScript/"/>
    
      <category term="ECMAScript 2015" scheme="http://infoscis.github.io/tags/ECMAScript-2015/"/>
    
  </entry>
  
  <entry>
    <title>ECMAScript 6 문자열과 정규 표현식</title>
    <link href="http://infoscis.github.io/2018/01/24/ecmascript-6-strings-and-regular-expressions/"/>
    <id>http://infoscis.github.io/2018/01/24/ecmascript-6-strings-and-regular-expressions/</id>
    <published>2018-01-24T14:08:10.000Z</published>
    <updated>2018-02-27T14:12:07.677Z</updated>
    
    <content type="html"><![CDATA[<h1 id="문자열과-정규-표현식"><a href="#문자열과-정규-표현식" class="headerlink" title="문자열과 정규 표현식"></a>문자열과 정규 표현식</h1><p>논쟁의 여지는 있지만 <em>String</em>은 프로그래밍에서 가장 중요한 데이터 타입중 하나입니다. 문자열은 거의 모든 고급 프로그래밍 언어에 포함되어 있고, 개발자가 유용한 프로그램을 만드는데 중요한 요소입니다. 정규 표현식은 개발자가 문자열을 다양하게 다룰수 있도록 하기 때문에 매우 중요합니다. 이러한 내용을 고려한 ECMAScript 6의 제작자는 새로운 기능과 오랫동안 누락된 기능들을 추가하여 문자열과 정규 표현식을 향상 시켰습니다. 이 장에서는 이러한 두가지 타입의 변경 사항에 대해 설명합니다.</p>
<h2 id="더-나은-Unicode-지원"><a href="#더-나은-Unicode-지원" class="headerlink" title="더 나은 Unicode 지원"></a>더 나은 Unicode 지원</h2><p>ECMAScript 6 이전에는 JavaScript 문자열이 16-bit 문자 인코딩(UTF-16)이 중심이었습니다. 각 16-bit 시퀀스는 문자를 나타내는 코드 단위입니다. <code>length</code> 속성과 <code>charAt()</code> 메서드와 같은 모든 문자열 속성과 메서드는 이 16-bit 코드 단위를 기반으로 했습니다. 물론 16-bit는 모든 문자를 포함하기에 충분했습니다. 하지만 Unicode가 도입 한 확장 문자 세트 덕분에 더 이상 충분하지 않습니다.</p>
<h3 id="UTF-16-Code-Point"><a href="#UTF-16-Code-Point" class="headerlink" title="UTF-16 Code Point"></a>UTF-16 Code Point</h3><p>문자 길이를 16-bit로 제한하는 것은 세계의 모든 문자를 전 세계적으로 고유 한 식별자로 제공하겠다는 Unicode의 목표를 이룰수 없습니다. <em>Code Point</em>라고 하는 이러한 전역적으로 고유 한 식별자는 단순히 0부터 시작하는 숫자일 뿐입니다. <em>Code Point</em>는 문자 코드로 생각할 수 있습니다. 숫자는 문자를 나타냅니다. 문자 인코딩은 <em>Code Point</em>를 내부적으로 일관된 <em>Code Unit</em>으로 인코딩해야 합니다. UTF-16의 경우 <em>Code Point</em>를 많은 <em>Code Unit</em>으로 구성할 수 있습니다.</p>
<p>UTF-16의 첫 2^16 개 <em>Code Point</em>는 하나의 16-bit <em>Code Unit</em>으로 표현됩니다. 이 범위를 <em>BMP (Basic Multilingual Plane)</em>이라고 합니다. 그 이상에 있는 것은 <em>Supplementary plane</em> 중 하나에있는 것으로 생각되어 더 이상 16-bit만으로 <em>Code Point</em>를 표현할 수 없습니다. UTF-16은 단일 <em>Code Point</em>가 두 개의 16-bit <em>Code Unit</em>으로 표현되는 <em>Surrogate pair</em>을 도입하여 이 문제를 해결했습니다. 즉, 문자열의 모든 단일 문자는, BMP 문자의 경우 하나의 <em>Code Unit</em>이 되어 총 16-bit를 제공하거나 <em>Supplementary plane</em> 문자의 경우 총 32-bit를 제공 합니다.</p>
<p>ECMAScript5에서 모든 문자열 연산은 16-bit <em>Code Unit</em>에서 작동합니다. 즉, 아래 코드에서와 같이 <em>Surrogate pair</em>가 포함된 UTF-16 인코딩된 문자열에서 예기치 않은 결과가 발생할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> text = <span class="string">"𠮷"</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(text.length);           <span class="comment">// 2</span></div><div class="line"><span class="built_in">console</span>.log(<span class="regexp">/^.$/</span>.test(text));      <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log(text.charAt(<span class="number">0</span>));        <span class="comment">// ""</span></div><div class="line"><span class="built_in">console</span>.log(text.charAt(<span class="number">1</span>));        <span class="comment">// ""</span></div><div class="line"><span class="built_in">console</span>.log(text.charCodeAt(<span class="number">0</span>));    <span class="comment">// 55362</span></div><div class="line"><span class="built_in">console</span>.log(text.charCodeAt(<span class="number">1</span>));    <span class="comment">// 57271</span></div></pre></td></tr></table></figure>
<p>Unicode 문자<code>&quot;𠮷&quot;</code>는 <em>Surrogate pair</em>를 사용하여 표현되며 위의 JavaScript 문자열 연산은 문자열을 두 개의 16-bit 문자로 취급합니다. 이러한 의미는 다음을 나타냅니다.</p>
<ul>
<li><code>text</code>의<code>length</code>는 1이어야 할 때 2입니다.</li>
<li>한 문자와 일치하는 정규식은 두 문자가 있다고 생각하기 때문에 실패합니다.</li>
<li><code>charAt()</code> 메서드는 유효한 문자열을 반환 할 수 없습니다. 왜냐하면 16-bit의 문자는 출력 가능한 문자가 아니기 때문입니다.</li>
</ul>
<p>또한 <code>charCodeAt()</code> 메서드는 문자를 제대로 식별 할 수 없습니다. 각 <em>Code Unit</em>에 대해 적절한 16-bit 숫자를 반환하지만 ECMAScript5에서 <code>text</code>의 실제 값에 유사한 값이기 때문입니다.</p>
<p>반면 ECMAScript 6은 이러한 Address Problem을 해결하기 위해 UTF-16 문자열 인코딩을 시행합니다. 이 문자 인코딩을 기반으로 문자열 연산을 표준화하면 JavaScript가 <em>Surrogate pair</em>와 함께 작동하도록 설계된 기능을 사용할 수 있습니다. 이 절의 나머지 부분에서는 해당 기능의 몇 가지 주요한 예제를 설명합니다.</p>
<h3 id="codePointAt-메서드"><a href="#codePointAt-메서드" class="headerlink" title="codePointAt() 메서드"></a><code>codePointAt()</code> 메서드</h3><p>완벽하게 UTF-16을 지원하기 위해 추가된 ECMAScript 6 메서드 중 하나는 <code>codePointAt()</code> 메서드입니다.이 메서드는 문자열의 주어진 위치에 매핑되는 유니 코드 <em>Code Point</em>를 검색합니다. 이 메서드는 문자 위치가 아닌 <em>Code Unit</em> 위치를 받아 들여 정수 값을 반환합니다. 아래 예제를 살펴 보겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> text = <span class="string">"𠮷a"</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(text.charCodeAt(<span class="number">0</span>));    <span class="comment">// 55362</span></div><div class="line"><span class="built_in">console</span>.log(text.charCodeAt(<span class="number">1</span>));    <span class="comment">// 57271</span></div><div class="line"><span class="built_in">console</span>.log(text.charCodeAt(<span class="number">2</span>));    <span class="comment">// 97</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(text.codePointAt(<span class="number">0</span>));   <span class="comment">// 134071</span></div><div class="line"><span class="built_in">console</span>.log(text.codePointAt(<span class="number">1</span>));   <span class="comment">// 57271</span></div><div class="line"><span class="built_in">console</span>.log(text.codePointAt(<span class="number">2</span>));   <span class="comment">// 97</span></div></pre></td></tr></table></figure>
<p><code>codePointAt()</code> 메서드는 문자가 BMP이면 <code>charCodeAt()</code>메서드와 같은 값을 반환합니다. 변수 <code>text</code>의 첫 번째 문자는 BMP가 아니기 때문에 두 개의 <em>Code Unit</em>으로 구성됩니다. 즉, <code>length</code> 값은 2가 아니라 3입니다. <code>charCodeAt()</code> 메서드는 0 번 위치의 첫 번째 <em>Code Unit</em>만 반환하지만 <code>codePointAt()</code>는 <em>Code Point</em>가 여러 개의 <em>Code Unit</em>에 걸쳐 있더라도 전체 <em>Code Point</em>를 반환합니다. 두 메서드는 모두 위치 1 (첫 번째 문자의 두 번째 <em>Code Unit</em>)과 2 ( <code>&quot;a&quot;</code>문자)에 대해 동일한 값을 반환합니다.</p>
<p>문자에 대해 <code>codePointAt()</code> 메서드를 호출하는 것은 그 문자가 하나 또는 두 개의 코드 포인트로 표현되는지를 결정하는 가장 쉬운 방법이다. 이러한 확인을 위해 다음 코드를 사용할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">is32Bit</span>(<span class="params">c</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> c.codePointAt(<span class="number">0</span>) &gt; <span class="number">0xFFFF</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(is32Bit(<span class="string">"𠮷"</span>));         <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(is32Bit(<span class="string">"a"</span>));          <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p>16-bit로 표시가능한 최대 숫자는 16 진수로 <code>FFFF</code>로 표현되므로, 그 숫자 위의 모든 <em>Code Point</em>는 총 32-bit의 두 <em>Code Unit</em>으로 표현되어야 합니다.</p>
<h3 id="String-fromCodePoint-메서드"><a href="#String-fromCodePoint-메서드" class="headerlink" title="String.fromCodePoint() 메서드"></a><code>String.fromCodePoint()</code> 메서드</h3><p>ECMAScript는 어떤 일을 할 수있는 방법을 제공 할 때, 또한 반대로도 할 수있는 방법을 제공하는 경향이 있습니다. <code>codePointAt()</code> 메서드를 사용하여 문자열의 문자에 대한 <em>Code Point</em>를 찾을 수 있고, `String.fromCodePoint()’ 메서드는 주어진 <em>Code Point</em>에서 단일 문자열을 생성합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.fromCodePoint(<span class="number">134071</span>));  <span class="comment">// "𠮷"</span></div></pre></td></tr></table></figure>
<p><code>String.fromCharCode()</code> 메서드의 보다 완벽한 버전 인 <code>String.fromCodePoint()</code>를 생각해 보십시오. 둘 다 BMP의 모든 문자에 대해 동일한 결과를 제공합니다. 하지만 BMP 외부의 문자에 대한 <em>Code Point</em>를 전달할 때 차이가 있습니다.</p>
<h3 id="normalize-메서드"><a href="#normalize-메서드" class="headerlink" title="normalize() 메서드"></a><code>normalize()</code> 메서드</h3><p>Unicode의 또 다른 흥미로운 점은 정렬이나 다른 비교 기반 작업을 위해 서로 다른 문자를 비교할수 있다는 것입니다. 비교를 위한 이러한 연관 관계를 정의하는 두 가지 방법이 있습니다. 첫째 <em>Canonical equivalence</em>는 모든 점에서 <em>Code Point</em>의 두 시퀀스가 상호 교환 가능하다고 간주됨을 의미합니다. 예를 들어, 두 문자의 조합은 기본적으로 한 문자와 같을 수 있습니다. 두 번째는 <em>Compatibility(호환성)</em>입니다. <em>Code point</em>의 시퀀스는 서로 다르게 보이지만 특정 상황에서는 서로 바꿔서 사용할 수 있습니다.</p>
<p>이러한 관계로 인해 근본적으로 동일한 텍스트를 나타내는 두 개의 문자열은 서로 다른 <em>Code point</em> 시퀀스를 포함 할 수 있습니다. 예를 들어, 문자 <code>&quot;æ&quot;</code>와 두 자의 문자열 <code>&quot;ae&quot;</code>는 어떤 방식으로든 표준화를 하지 않으면 엄격하게 동등하지 않기 때문에 서로 바꿔서 사용할 수 없습니다.</p>
<p>ECMAScript 6는 문자열에 <code>normalize()</code>가 있어서 Unicode 정규화 형식을 지원합니다. 이 메서드에 사용할 정규화 타입중 하나를 나타내는 하나의 문자열을 파라미터로 사용할 수 있습니다.</p>
<ul>
<li>Normalization Form Canonical Composition (<code>&quot;NFC&quot;</code>) - 기본값</li>
<li>Normalization Form Canonical Decomposition (<code>&quot;NFD&quot;</code>)</li>
<li>Normalization Form Compatibility Composition (<code>&quot;NFKC&quot;</code>)</li>
<li>Normalization Form Compatibility Decomposition (<code>&quot;NFKD&quot;</code>)</li>
</ul>
<p>이 네 가지 형식의 차이점을 설명하는 것은이 책의 범위를 벗어납니다. 문자열을 비교할 때 두 문자열을 같은 형식으로 정규화해야한다는 점을 명심하십시오.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> normalized = values.map(<span class="function"><span class="keyword">function</span>(<span class="params">text</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> text.normalize();</div><div class="line">&#125;);</div><div class="line"></div><div class="line">normalized.sort(<span class="function"><span class="keyword">function</span>(<span class="params">first, second</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (first &lt; second) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (first === second) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>위 코드는 변수 <code>values</code> <em>Array</em>의 문자열을 정규화된 형식으로 변환하여 <em>Array</em>을 적절히 정렬 할 수 있도록 합니다. 아래 코드와 같이 Comparator의 일부로서<code>normalize()</code> 를 호출하여 원래의 <em>Array</em>을 정렬 할 수도 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">values.sort(<span class="function"><span class="keyword">function</span>(<span class="params">first, second</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> firstNormalized = first.normalize(),</div><div class="line">        secondNormalized = second.normalize();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (firstNormalized &lt; secondNormalized) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstNormalized === secondNormalized) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>위 코드의 중요한 점은 <code>first</code>와 <code>second</code>가 같은 방식으로 표준화 되어야 한다는 것입니다. 이 예제는 기본 <code>NFC</code>를 사용했지만 다음과 같이 나머지 중 하나를 쉽게 지정할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">values.sort(<span class="function"><span class="keyword">function</span>(<span class="params">first, second</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> firstNormalized = first.normalize(<span class="string">"NFD"</span>),</div><div class="line">        secondNormalized = second.normalize(<span class="string">"NFD"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (firstNormalized &lt; secondNormalized) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstNormalized === secondNormalized) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>이전에 Unicode 표준화에 대해 걱정 해 본 적이 없다면 아마 이 방법을 사용하지 않을 것입니다. 하지만 국제화된 응용 프로그램에서 작업한다면 <code>normalize()</code> 메서드가 도움이 될 것입니다.</p>
<p><code>normalize()</code> 메서드가 ECMAScript 6에서 Unicode 문자열 작업에 제공하는 유일한 메서드가 아닙니다. ECMAScript 6은 또한 두가지의 유용한 구문을 추가 했습니다.</p>
<h3 id="Regular-Expression의-u-플래그"><a href="#Regular-Expression의-u-플래그" class="headerlink" title="Regular Expression의 u 플래그"></a>Regular Expression의 <code>u</code> 플래그</h3><p>정규 표현식을 통해 일반적인 많은 문자열 연산을 수행 할 수 있습니다. 그러나 정규 표현식은 16-bit <em>Code unit</em>를 가정하고 각 <em>Code unit</em>은 하나의 문자를 나타냅니다. 이 문제를 해결하기 위해 ECMAScript 6에서 Unicode를 나타내는 정규 표현식에 대해 <code>u</code> 플래그를 정의합니다.</p>
<h4 id="실행중일-때의-u-플래그"><a href="#실행중일-때의-u-플래그" class="headerlink" title="실행중일 때의 u 플래그"></a>실행중일 때의 <code>u</code> 플래그</h4><p>정규 표현식에 <code>u</code> 플래그가 설정되면, <em>Code unit</em>이 아닌 문자에 대한 작업 모드로 전환됩니다. 즉 정규 표현식이 문자열의 <em>Surrogate pair</em>에 대해 더 이상 혼동하지 않아야 하며 예상대로 작동해야합니다. 예를 들어 다음 코드를 생각해 보겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> text = <span class="string">"𠮷"</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(text.length);           <span class="comment">// 2</span></div><div class="line"><span class="built_in">console</span>.log(<span class="regexp">/^.$/</span>.test(text));      <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log(<span class="regexp">/^.$/u</span>.test(text));     <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>정규 표현식 <code>/^.$/</code>은 입력 문자열을 단일 문자와 일치시킵니다. <code>u</code> 플래그없이 사용하면 이 정규 표현식이 <em>Code unit</em>으로 일치를 판단 하기 때문에 한자(두개의 <em>Code unit</em>으로 표현됨)가 정규 표현식과 일치하지 않습니다. <code>u</code> 플래그와 함께 사용하면 정규식은 <em>Code unit</em> 대신 문자들을 비교하므로 한자 문자가 일치합니다.</p>
<h4 id="Code-Point-카운트"><a href="#Code-Point-카운트" class="headerlink" title="Code Point 카운트"></a><em>Code Point</em> 카운트</h4><p>유감스럽게도 ECMAScript 6은 문자열의 <em>Code point</em> 수를 알려주는 메서드를 추가하지 않았습니다. 하지만 <code>u</code> 플래그를 사용하면 정규 표현식을 사용하여 다음과 같이 계산할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">codePointLength</span>(<span class="params">text</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> result = text.match(<span class="regexp">/[\s\S]/gu</span>);</div><div class="line">    <span class="keyword">return</span> result ? result.length : <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(codePointLength(<span class="string">"abc"</span>));    <span class="comment">// 3</span></div><div class="line"><span class="built_in">console</span>.log(codePointLength(<span class="string">"𠮷bc"</span>));   <span class="comment">// 3</span></div></pre></td></tr></table></figure>
<p>위 코드는 <code>match()</code>를 호출할 때 <code>u</code> 옵션을 이용하여 전체 문자열에서 공백 문자와 공백 문자가 아닌 문자(<code>[\s\S]</code>는 개행문자도 포함합니다.)를 <code>text</code>에서 둘다 확인합니다. <code>result</code>는 일치가 발생한 문자의 <em>Array</em>이기 때문에 <em>Array</em>의 길이는 문자열의 <em>Code point</em> 수가 됩니다. Unicode에서 문자열 <code>&quot;abc&quot;</code>와 <code>&quot;𠮷bc&quot;</code>는 둘 다 3 개의 문자를 가지므로 <em>Array</em> 길이는 3입니다.</p>
<blockquote>
<p>위의 예제는 효과적 일지는 몰라도, 특히 긴 문자열에 적용 할 때 빠르지는 않습니다. 문자열 Iterator(나중에 설명)를 사용할 수 있습니다. <em>Code point</em> 카운트를 최소화하는게 좋습니다.</p>
</blockquote>
<h4 id="u-플래그-지원-여부-확인하기"><a href="#u-플래그-지원-여부-확인하기" class="headerlink" title="u 플래그 지원 여부 확인하기"></a><code>u</code> 플래그 지원 여부 확인하기</h4><p><code>u</code> 플래그는 구문 변경이므로 ECMAScript 6과 호환되지 않는 JavaScript 엔진에서 사용하려고 시도하면 구문 오류가 발생합니다. <code>u</code> 플래그가 지원되는지를 결정하는 가장 안전한 방법은 다음과 같은 함수를 사용하는 것입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasRegExpU</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">var</span> pattern = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"."</span>, <span class="string">"u"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125; <span class="keyword">catch</span> (ex) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>이 함수는 <code>RegExp</code> 생성자를 사용하여 <code>u</code> 플래그를 인수로 전달합니다. 이 구문은 구형 JavaScript 엔진에서도 유효하지만, ‘u’가 지원되지 않으면 생성자는 오류를 발생시킵니다.</p>
<blockquote>
<p>코드가 오래된 JavaScript 엔진에서 작동해야하는 경우, <code>u</code> 플래그를 사용할 때 항상 <code>RegExp</code> 생성자를 사용하십시오. 이렇게하면 구문 오류가 방지되고, 실행을 중단하지 않고 선택적으로 <code>u</code>플래그를 감지하여 사용할 수 있습니다.</p>
</blockquote>
<h2 id="String의-다른-변경사항"><a href="#String의-다른-변경사항" class="headerlink" title="String의 다른 변경사항"></a>String의 다른 변경사항</h2><p>JavaScript 문자열 관련 기능들은 다른 언어보다 항상 뒤떨어져 있습니다. 예를 들어 ECMAScript 5에서 문자열의 <code>trim()</code> 메서드가 추가 되었으며 ECMAScript 6는 JavaScript의 기능을 확장하여 새로운 기능으로 문자열을 파싱합니다.</p>
<h3 id="Substring-문자열-식별-메서드"><a href="#Substring-문자열-식별-메서드" class="headerlink" title="Substring 문자열 식별 메서드"></a>Substring 문자열 식별 메서드</h3><p>개발자들은 JavaScript가 처음 소개된 이래로 <code>indexOf()</code> 메서드를 사용하여 문자열 내부에서 어떤 텍스트가 있는지 판단 했습니다. ECMAScript 6에는 다음과 같은 세 가지 방법이 추가 되었습니다.</p>
<ul>
<li><code>includes()</code> 메서드는 주어진 텍스트가 문자열 내의 어느 위치에서든 발견되면 true를 반환합니다. 그렇지 않으면 false를 반환합니다.</li>
<li><code>startsWith()</code> 메서드는 지정된 텍스트가 문자열의 시작 부분에서 발견되면 true를 반환합니다. 그렇지 않으면 false를 반환합니다.</li>
<li><code>endsWith()</code> 메서드는 주어진 텍스트가 문자열의 끝에서 발견되면 true를 반환합니다. 그렇지 않으면 false를 반환합니다.</li>
</ul>
<p>각 메서드는 검색 할 텍스트와 검색을 시작할 인덱스(Optional)라는 두 개의 파라미터를 사용할 수 있습니다. 두 번째 파라미터가 입력 되면 <code>includes()</code>는 입력된 파라미터 이후에 일치하는 텍스트가 있는지 확인하고, <code>startsWith()</code>는 입력받은 파라미터의 인덱스에 첫 번째 입력 받은 텍스트가 일치 하는지 검사합니다. 그리고 <code>endsWith ()</code>는 두 번째 파라미터를 문자열의 마지막으로 설정해서 문자열에서 마지막 텍스트가 일치하는지 확인합니다. 두 번째 인수가 생략되면 <code>endsWith()</code>가 맨 끝에서 시작하고, <code>includes ()</code> 및 <code>startsWith ()</code>는 문자열의 처음부터 검색합니다.결과적으로 두 번째 인수는 검색되는 문자열의 양을 최소화합니다. 다음은이 세 가지 방법을 보여주는 몇 가지 예입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> msg = <span class="string">"Hello world!"</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(msg.startsWith(<span class="string">"Hello"</span>));       <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(msg.endsWith(<span class="string">"!"</span>));             <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(msg.includes(<span class="string">"o"</span>));             <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(msg.startsWith(<span class="string">"o"</span>));           <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log(msg.endsWith(<span class="string">"world!"</span>));        <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(msg.includes(<span class="string">"x"</span>));             <span class="comment">// false</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(msg.startsWith(<span class="string">"o"</span>, <span class="number">4</span>));        <span class="comment">// msg: "o world!" =&gt; true</span></div><div class="line"><span class="built_in">console</span>.log(msg.endsWith(<span class="string">"o"</span>, <span class="number">8</span>));          <span class="comment">// msg: "Hello wo" =&gt; true</span></div><div class="line"><span class="built_in">console</span>.log(msg.includes(<span class="string">"o"</span>, <span class="number">8</span>));          <span class="comment">// msg: "rld!" =&gt; false</span></div></pre></td></tr></table></figure>
<p>처음 6 개 호출에는 두 번째 파라미터가 없으므로 전체 문자열을 검색에 사용합니다. 마지막 세 건의 호출은 문자열의 일부만 검사합니다. <code>msg.startsWith( &quot;o&quot;, 4)</code>를 호출하면 “Hello”에서 “o”인 <code>msg</code> 문자열의 4개의 문자를 건너뛰고 일치를 시작합니다. <code>msg.endsWith(&quot;o&quot;, 8)</code> 호출은 전체 문자열 길이(12)중에서 처음부터 입력받은 <code>8</code>개까지 문자열의 마지막에서 텍스트 일치를 시작합니다. <code>msg.includes(&quot;o&quot;, 8)</code>호출은 “world”의 “r”인 8개의 문자를 건너뛰고 일치를 시작합니다.</p>
<p>이 세 가지 방법을 사용하면 하위 문자열의 존재를 다 쉽게 식별 할 수 있지만 각각 true/false 값만 반환합니다. 한 문자열의 실제 위치를 다른 문자열 내에서 찾으려면 <code>indexOf()</code> 또는 <code>lastIndexOf ()</code> 메서드를 사용하십시오.</p>
<blockquote>
<p><code>startsWith()</code>, <code>endsWith()</code> 및 <code>includes()</code> 메서드는 문자열 대신 정규 표현식을 파라미터로 전달하면 오류가 발생합니다. 정규 표현식이 포함된 파라미터를 문자열로 변환 한 다음 해당 문자열을 검색하는 <code>indexOf()</code>, <code>lastIndexOf()</code>와는 대조적입니다.</p>
</blockquote>
<h3 id="repeat-메서드"><a href="#repeat-메서드" class="headerlink" title="repeat() 메서드"></a><code>repeat()</code> 메서드</h3><p>ECMAScript 6은 String에 <code>repeat ()</code> 메서드를 추가했습니다. 이 메서드는 파라미터로 입력한 회수 만큼 문자열을 반복합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="string">"x"</span>.repeat(<span class="number">3</span>));         <span class="comment">// "xxx"</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"hello"</span>.repeat(<span class="number">2</span>));     <span class="comment">// "hellohello"</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"abc"</span>.repeat(<span class="number">4</span>));       <span class="comment">// "abcabcabcabc"</span></div></pre></td></tr></table></figure>
<p>이 메서드는 텍스트를 조작 할 때 특히 유용하고 편리한 함수입니다. 다음과 같이 들여 쓰기 수준을 만들어야 하는 코드 서식 유틸리티에서 특히 유용합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// indent using a specified number of spaces</span></div><div class="line"><span class="keyword">var</span> indent = <span class="string">" "</span>.repeat(<span class="number">4</span>),</div><div class="line">    indentLevel = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="comment">// whenever you increase the indent</span></div><div class="line"><span class="keyword">var</span> newIndent = indent.repeat(++indentLevel);</div></pre></td></tr></table></figure>
<p>첫 번째 <code>repeat()</code> 호출은 4개의 공백이 포함된 문자열을 생성하고, <code>indentLevel</code> 변수는 들여 쓰기 레벨을 추적합니다. 그런 다음, <code>repeat()</code>를 증가된 <code>indentLevel</code>과 함께 호출하여 공백(“ “)의 수를 변경할 수 있습니다.</p>
<p>또한 ECMAScript 6은 특정 범주에 맞지 않는 정규 표현식 기능을 일부 변경했습니다. 다음 섹션에서는 몇 가지 사항을 집중적으로 설명합니다.</p>
<h2 id="정규-표현식-Regular-Expression-의-다른-변경-사항"><a href="#정규-표현식-Regular-Expression-의-다른-변경-사항" class="headerlink" title="정규 표현식(Regular Expression)의 다른 변경 사항"></a>정규 표현식(Regular Expression)의 다른 변경 사항</h2><p>정규 표현식은 JavaScript로 문자열을 다루는 중요한 부분이며, JavaScript의 다른 많은 부분과 마찬가지로 최근 버전까지 많이 변경되지 않았습니다. 하지만 ECMAScript 6에서 문자열에 대한 몇몇 업데이트와 함께 정규 표현식이 몇 가지 개선되었습니다.</p>
<h3 id="정규-표현식-Regular-Expression-y-플래그"><a href="#정규-표현식-Regular-Expression-y-플래그" class="headerlink" title="정규 표현식(Regular Expression) y 플래그"></a>정규 표현식(Regular Expression) <code>y</code> 플래그</h3><p>ECMAScript 6은 파이어 폭스에서 정규 표현식을 독점적으로 확장 구현 후 <code>y</code> 플래그를 표준화 했습니다. <code>y</code> 플래그는 정규 표현식 검색의 <code>sticky</code> 속성에 영향을 미치며 정규 표현식의 <code>lastIndex</code> 속성에 의해 지정된 위치의 문자열에서 일치하는 문자를 검색하도록 검색을 지시합니다. 해당 위치에서 일치하는 항목이 없으면 정규식은 매칭을 중지합니다. 이것이 어떻게 작동하는지 다음 코드를 보도록 하겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> text = <span class="string">"hello1 hello2 hello3"</span>,</div><div class="line">    pattern = <span class="regexp">/hello\d\s?/</span>,</div><div class="line">    result = pattern.exec(text),</div><div class="line">    globalPattern = <span class="regexp">/hello\d\s?/g</span>,</div><div class="line">    globalResult = globalPattern.exec(text),</div><div class="line">    stickyPattern = <span class="regexp">/hello\d\s?/y</span>,</div><div class="line">    stickyResult = stickyPattern.exec(text);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(result[<span class="number">0</span>]);         <span class="comment">// "hello1 "</span></div><div class="line"><span class="built_in">console</span>.log(globalResult[<span class="number">0</span>]);   <span class="comment">// "hello1 "</span></div><div class="line"><span class="built_in">console</span>.log(stickyResult[<span class="number">0</span>]);   <span class="comment">// "hello1 "</span></div><div class="line"></div><div class="line">pattern.lastIndex = <span class="number">1</span>;</div><div class="line">globalPattern.lastIndex = <span class="number">1</span>;</div><div class="line">stickyPattern.lastIndex = <span class="number">1</span>;</div><div class="line"></div><div class="line">result = pattern.exec(text);</div><div class="line">globalResult = globalPattern.exec(text);</div><div class="line">stickyResult = stickyPattern.exec(text);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(result[<span class="number">0</span>]);         <span class="comment">// "hello1 "</span></div><div class="line"><span class="built_in">console</span>.log(globalResult[<span class="number">0</span>]);   <span class="comment">// "hello2 "</span></div><div class="line"><span class="built_in">console</span>.log(stickyResult[<span class="number">0</span>]);   <span class="comment">// Error! stickyResult is null</span></div></pre></td></tr></table></figure>
<p>이 예제에는 3 개의 정규 표현식이 있습니다. <code>pattern</code>의 표현식에는 플래그가 없으며 <code>globalPattern</code>의 표현식은 <code>g</code> 플래그를 사용하고<code>stickyPattern</code>의 표현식은 <code>y</code> 플래그를 사용합니다. 첫 번째의 3개 <code>console.log()</code>에서 세 정규식은 모두 끝에 스페이스가 포함된 <code>&quot;hello1 &quot;</code>를 반환 합니다.</p>
<p>그런 다음 <code>lastIndex</code> 속성은 세 패턴 모두에서 1로 변경됩니다. 즉 정규 표현식이 두 번째에서 일치를 시작합니다. 플래그가 없는 정규 표현식은<code>lastIndex</code>에 대한 변경 사항을 완전히 무시하고 <code>&quot;hello1 &quot;</code>과 아무런 문제없이 일치합니다. <code>g</code> 플래그를 사용하는 정규 표현식은 문자열의 두 번째 문자(<code>&quot;e&quot;</code>)에서 검색을 시작하기 때문에 <code>&quot;hello2 &quot;</code>와 일치합니다. <code>sticky</code> 정규 표현은 두 번째 문자에서 시작하는 것과 일치하지 않으므로<code>stickyResult</code>는 <code>null</code>입니다.</p>
<p><code>sticky</code> 플래그는 작업이 수행될 때마다 <code>lastIndex</code>에서 마지막으로 일치 한 다음 문자 다음의 인덱스를 저장합니다. 연산 결과가 일치하지 않으면 <code>lastIndex</code>가 0으로 다시 설정됩니다. 전역 <code>stickyPattern.lastIndex</code>는 다음과 같이 동일한 방식으로 동작합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> text = <span class="string">"hello1 hello2 hello3"</span>,</div><div class="line">    pattern = <span class="regexp">/hello\d\s?/</span>,</div><div class="line">    result = pattern.exec(text),</div><div class="line">    globalPattern = <span class="regexp">/hello\d\s?/g</span>,</div><div class="line">    globalResult = globalPattern.exec(text),</div><div class="line">    stickyPattern = <span class="regexp">/hello\d\s?/y</span>,</div><div class="line">    stickyResult = stickyPattern.exec(text);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(result[<span class="number">0</span>]);         <span class="comment">// "hello1 "</span></div><div class="line"><span class="built_in">console</span>.log(globalResult[<span class="number">0</span>]);   <span class="comment">// "hello1 "</span></div><div class="line"><span class="built_in">console</span>.log(stickyResult[<span class="number">0</span>]);   <span class="comment">// "hello1 "</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(pattern.lastIndex);         <span class="comment">// 0</span></div><div class="line"><span class="built_in">console</span>.log(globalPattern.lastIndex);   <span class="comment">// 7</span></div><div class="line"><span class="built_in">console</span>.log(stickyPattern.lastIndex);   <span class="comment">// 7</span></div><div class="line"></div><div class="line">result = pattern.exec(text);</div><div class="line">globalResult = globalPattern.exec(text);</div><div class="line">stickyResult = stickyPattern.exec(text);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(result[<span class="number">0</span>]);         <span class="comment">// "hello1 "</span></div><div class="line"><span class="built_in">console</span>.log(globalResult[<span class="number">0</span>]);   <span class="comment">// "hello2 "</span></div><div class="line"><span class="built_in">console</span>.log(stickyResult[<span class="number">0</span>]);   <span class="comment">// "hello2 "</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(pattern.lastIndex);         <span class="comment">// 0</span></div><div class="line"><span class="built_in">console</span>.log(globalPattern.lastIndex);   <span class="comment">// 14</span></div><div class="line"><span class="built_in">console</span>.log(stickyPattern.lastIndex);   <span class="comment">// 14</span></div></pre></td></tr></table></figure>
<p><code>lastIndex</code>의 값은 <code>stickyPattern</code> 변수와 <code>globalPattern</code> 변수 모두에 대해 <code>exec()</code>의 첫 번째 호출 후에 7로 변경되고 두 번째 호출 후에 14로 변경됩니다.</p>
<p>염두에 두어야 할 sticky 플래그에 대한 두 가지 미묘한 세부 사항이 있습니다.</p>
<ol>
<li><code>lastIndex</code> 속성은 <code>exec()</code>및 <code>test()</code> 메서드와 같이 정규 표현식 객체에 존재하는 메서드를 호출 할 때만 적용됩니다. 정규 표현식을 <code>match ()</code>와 같은 문자열 메서드에 전달하면 sticky를 실행하지 않습니다.</li>
<li>문자열의 시작과 일치시키기 위해<code>^</code>문자를 사용할 때, sticky 정규 표현식은 문자열의 시작 부분 또는 여러 줄 모드의 줄 시작 부분에서만 일치합니다. <code>lastIndex</code>가 0 일때  <code>^</code>는 non-sticky 정규 표현식과 sticky 정규 표현식의 결과가 같습니다. <code>lastIndex</code>가 단일 행 모드에서 문자열의 시작이나 다중 행 모드에서 행의 시작과 일치하지 않으면 sticky 정규 표현식은 절대로 매칭하지 않습니다.</li>
</ol>
<p>일반 다른 정규식 플래그와 마찬가지로 프로퍼티를 사용하여 <code>sticky</code> 플래그의 존재를 확인 할 수 있습니다. 다음 코드는 <code>sticky</code> 속성을 검사 하는 예제입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> pattern = <span class="regexp">/hello\d/y</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(pattern.sticky);    <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p><code>sticky</code> 속성은 sticky 플래그가 있으면 true로 설정되고, 그렇지 않으면 false로 설정됩니다. <code>sticky</code> 속성은 플래그의 존재에 기초한 읽기 전용이며 코드라서 변경할 수 없습니다.</p>
<p><code>u</code> 플래그와 비슷하게, <code>y</code> 플래그는 구문 변경이므로 오래된 JavaScript 엔진에서는 구문 오류가 발생할 수 있습니다. 다음 방법을 사용하여 <code>sticky</code> 지원을 검사 할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasRegExpY</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">var</span> pattern = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"."</span>, <span class="string">"y"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125; <span class="keyword">catch</span> (ex) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>u</code> 검사와 마찬가지로, <code>y</code> 플래그를 가진 정규 표현식을 만들 수 없다면 false를 반환합니다. <code>u</code> 플래그와 유사하게 오래된 JavaScript 엔진에서 실행되는 코드 내부에 <code>y</code>를 사용해야 할 경우, 정규 표현식을 정의 할 때 <code>RegExp</code> 생성자를 사용하여 구문 오류를 피하십시오.</p>
<h3 id="정규-표현식-복제-Duplicating-Regular-Expressions"><a href="#정규-표현식-복제-Duplicating-Regular-Expressions" class="headerlink" title="정규 표현식 복제(Duplicating Regular Expressions)"></a>정규 표현식 복제(Duplicating Regular Expressions)</h3><p>ECMAScript 5에서는 다음과 같이 <code>RegExp</code> 생성자에 정규 표현식을 전달하여 복제할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> re1 = <span class="regexp">/ab/i</span>,</div><div class="line">    re2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(re1);</div></pre></td></tr></table></figure>
<p><code>re2</code> 변수는 <code>re1</code> 변수의 복사본입니다. 그러나 정규식에 대한 플래그를 지정하는 <code>RegExp</code> 생성자에 두 번째 파라미터를 제공하면 다음 코드와 같이 정상 작동하지 않습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> re1 = <span class="regexp">/ab/i</span>,</div><div class="line"></div><div class="line">    <span class="comment">// ES5에서는 error 발생, ES6에서는 OK</span></div><div class="line">    re2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(re1, <span class="string">"g"</span>);</div></pre></td></tr></table></figure>
<p>ECMAScript 5 환경에서 이 코드를 실행하면 첫 번째 파라미터가 정규 표현식 일 때 두 번째 파라미터를 사용할 수 없다는 오류가 발생합니다. ECMAScript 6은 두 번째 파라미터가 허용되고 첫 번째 파라미터에있는 플래그를 무시하도록이 동작이 변경 되었습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> re1 = <span class="regexp">/ab/i</span>,</div><div class="line"></div><div class="line">    <span class="comment">// ES5에서는 error 발생, ES6에서는 OK</span></div><div class="line">    re2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(re1, <span class="string">"g"</span>);</div><div class="line"></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(re1.toString());            <span class="comment">// "/ab/i"</span></div><div class="line"><span class="built_in">console</span>.log(re2.toString());            <span class="comment">// "/ab/g"</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(re1.test(<span class="string">"ab"</span>));            <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(re2.test(<span class="string">"ab"</span>));            <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(re1.test(<span class="string">"AB"</span>));            <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(re2.test(<span class="string">"AB"</span>));            <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p>이 코드에서,<code>re1</code>은 대소 문자를 구분하지 않는 <code>i</code> 플래그를, <code>re2</code>는 전역 <code>g</code> 플래그만을 가지고 있습니다. <code>RegExp</code> 생성자는 <code>re1</code>에서 패턴을 복사하고 <code>i</code> 플래그를 <code>g</code> 플래그로 대체했습니다. 두 번째 인수가 없으면 <code>re2</code>는 <code>re1</code>과 같은 플래그를가집니다.</p>
<h3 id="플래그-프로퍼티"><a href="#플래그-프로퍼티" class="headerlink" title="플래그 프로퍼티"></a>플래그 프로퍼티</h3><p>새 플래그를 추가하고 플래그를 사용하여 작업하는 방법을 변경하는 것과 함께 ECMAScript 6은 이와 관련된 프로퍼티를 추가했습니다. ECMAScript 5에서는 <code>source</code> 프로퍼티를 사용하여 정규 표현식의 텍스트를 얻을 수 있지만 플래그 문자열을 얻으려면 아래와 같이<code>toString ()</code>메서드의 출력을 파싱해야합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFlags</span>(<span class="params">re</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> text = re.toString();</div><div class="line">    <span class="keyword">return</span> text.substring(text.lastIndexOf(<span class="string">"/"</span>) + <span class="number">1</span>, text.length);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// toString() is "/ab/g"</span></div><div class="line"><span class="keyword">var</span> re = <span class="regexp">/ab/g</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(getFlags(re));          <span class="comment">// "g"</span></div></pre></td></tr></table></figure>
<p>정규식을 문자열로 변환 한 다음 마지막 <code>/</code> 다음에 나오는 문자를 반환합니다. <code>/</code> 이후의 문자가 플래그입니다.</p>
<p>ECMAScript 6는 <code>flags</code> 프로퍼티를 <code>source</code> 프로퍼티와 함께 추가하여 플래그를 쉽게 가져옵니다. 두 프로퍼티는 모두 getter 만 할당된 프로토 타입 접근자이므로 읽기 전용입니다. <code>flags</code> 프로퍼티는 디버깅과 상속 목적을 위해 정규 표현식을 더 쉽게 검사하게 합니다.</p>
<p>ECMAScript 6에 추가된 <code>flags</code> 프로퍼티는 정규 표현식에 적용된 플래그의 문자열 표현을 반환합니다. 예 :</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> re = <span class="regexp">/ab/g</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(re.source);     <span class="comment">// "ab"</span></div><div class="line"><span class="built_in">console</span>.log(re.flags);      <span class="comment">// "g"</span></div></pre></td></tr></table></figure>
<p>위 코드는 <code>re</code>에 있는 모든 플래그를 가져 와서 <code>toString ()</code> 기법보다 훨씬 적은 코드로 결과를 콘솔에 출력합니다. <code>source</code>와 <code>flags</code>를 함께 사용하면 정규식 문자열을 직접 파싱하지 않고도 필요한 정규 표현식을 추출할 수 있습니다.</p>
<p>이 장에서 지금까지 다루었던 일반 문자열과 정규 표현식에 대한 변경 사항은 분명 강력하지만 ECMAScript 6는 훨씬 더 강력한 방식의 문자열을 지원합니다.</p>
<h2 id="Template-literal-템플릿-리터럴"><a href="#Template-literal-템플릿-리터럴" class="headerlink" title="Template literal(템플릿 리터럴)"></a>Template literal(템플릿 리터럴)</h2><p>항상 JavaScript의 문자열 처리 기능은 다른 언어와 비교하면 기능이 제한적이었습니다. 예를 들어, ECMAScript 6까지 문자열은 지금까지 위에서 다루었던 메서드가 없었으며 문자열 연결은 가능한 간단했습니다. 개발자가 보다 복잡한 문제를 해결할 수 있도록 ECMAScript 6의 <em>Template literal</em>은 ECMAScript 5 이하에서 사용할 수있는 솔루션보다 안전한 방법으로 콘텐츠 작업을 위한 도메인 별 언어 (DSL) 생성 구문을 제공합니다. (DSL은 JavaScript와 같은 범용 언어와 달리 특정 목적을 위해 설계된 프로그래밍 언어입니다.) ECMAScript wiki는 <a href="http://wiki.ecmascript.org/doku.php?id=harmony:quasis" target="_blank" rel="external">template literal strawman</a>에 대해 다음과 같이 설명합니다.</p>
<blockquote>
<p>이 스키마는 Syntactic sugar를 활용한 ECMAScript 구문을 확장하여 라이브러리가 다른 언어의 내용을 쉽게 생성, 쿼리 및 조작할 수있는 DSL을 제공 하여 XSS, SQL Injection 등과 같이 Injection attack에 대항하거나 면역 기능을 부여 합니다.</p>
</blockquote>
<p>실제로 <em>Template literal</em>은 JavaScript가 ECMAScript 5를 통해 부족했던 다음 기능에 대한 ECMAScript 6의 대답입니다.</p>
<ul>
<li><strong>Multiline strings</strong> 여러 줄 문자열의 공식 개념.</li>
<li><strong>Basic string formatting</strong> 변수값으로 문자열의 일부를 대체할 수있는 기능.</li>
<li><strong>HTML escaping</strong> HTML에 삽입하는 것이 안전하도록 문자열을 변환하는 기능.</li>
</ul>
<p><em>Template literal</em>은 JavaScript의 기존 문자열에 더 많은 기능을 추가하기 보다는 이러한 문제를 해결하기 위한 완전히 새로운 접근 방식입니다.</p>
<h3 id="기본-문법-Basic-Syntax"><a href="#기본-문법-Basic-Syntax" class="headerlink" title="기본 문법 (Basic Syntax)"></a>기본 문법 (Basic Syntax)</h3><p>가장 단순한 <em>Template literal</em>은 이중 따옴표(<code>&quot;</code>) 나 작은 따옴표(<code>&#39;</code>) 대신 백팅(<code>` </code>)으로 문자열을 감싸면 됩니다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> message = <span class="string">`Hello world!`</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(message);               <span class="comment">// "Hello world!"</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> message);        <span class="comment">// "string"</span></div><div class="line"><span class="built_in">console</span>.log(message.length);        <span class="comment">// 12</span></div></pre></td></tr></table></figure>
<p>위 코드는 <code>message</code> 변수가 일반적인 JavaScript 문자열을 포함하고 있음을 보여줍니다. <em>Template literal</em> 구문은 문자열의 <em>Code point</em>을 생성하는 데 사용되며, 이 <em>Code point</em>는 <code>message</code> 변수에 할당됩니다.</p>
<p>문자열에서 백틱을 사용하려면 아래의 코드의 <code>message</code> 변수 처럼 백 슬래시 (<code>\</code>)를 사용하여 이스케이프합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> message = <span class="string">`\`Hello\` world!`</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(message);               <span class="comment">// "`Hello` world!"</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> message);        <span class="comment">// "string"</span></div><div class="line"><span class="built_in">console</span>.log(message.length);        <span class="comment">// 14</span></div></pre></td></tr></table></figure>
<p><em>Template literal</em> 안의 이중 따옴표 나 작은 따옴표는 이스케이프할 필요가 없습니다.</p>
<h3 id="여러-줄의-문자열-Multiline-String"><a href="#여러-줄의-문자열-Multiline-String" class="headerlink" title="여러 줄의 문자열 (Multiline String)"></a>여러 줄의 문자열 (Multiline String)</h3><p>JavaScript 개발자는 첫 번째 버전 이후로 항상 여러 줄을 만드는 방법을 원했습니다. 그러나 이중 따옴표 나 작은 따옴표를 사용하는 경우 문자열은 한줄로 완전히 포함되어야합니다.</p>
<h4 id="ECMAScript-6-이전-방법"><a href="#ECMAScript-6-이전-방법" class="headerlink" title="ECMAScript 6 이전 방법"></a>ECMAScript 6 이전 방법</h4><p>하지만 오래 지속되는 문법 버그 덕분에 JavaScript는 해결 방법이 있습니다. 개행 전에 백 슬래시 (<code>\</code>)가 있으면 여러 줄을 만들 수 있습니다. 다음은 그 예입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> message = <span class="string">"Multiline \</span></div><div class="line">string";</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(message);       <span class="comment">// "Multiline string"</span></div></pre></td></tr></table></figure>
<p>하지만 백 슬래시가 개행이 아닌 연속으로 처리되기 때문에 <code>message</code> 문자열에는 콘솔에 출력할 때 개행 문자가 없습니다. 출력에 개행 문자를 표시하려면 수동으로 포함시켜야합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> message = <span class="string">"Multiline \n\</span></div><div class="line">string";</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(message);       <span class="comment">// "Multiline</span></div><div class="line">                            <span class="comment">//  string"</span></div></pre></td></tr></table></figure>
<p>이것은 모든 주요한 JavaScript 엔진에서 두줄로된 <code>Multiline String</code>을 출력 하는 방법입니다. 그러나 이 동작은 버그로 정의되어 있으므로 많은 개발자들은 이를 피하는 것을 권장합니다.</p>
<p>일반적으로 ECMAScript 6 이전 버전으로 다중 문자열을 만들기 위한 방법은 다음과 같이 <em>Array</em>이나 문자열 연결에 의존합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> message = [</div><div class="line">    <span class="string">"Multiline "</span>,</div><div class="line">    <span class="string">"string"</span></div><div class="line">].join(<span class="string">"\n"</span>);</div><div class="line"></div><div class="line"><span class="keyword">let</span> message = <span class="string">"Multiline \n"</span> +</div><div class="line">    <span class="string">"string"</span>;</div></pre></td></tr></table></figure>
<p>JavaScript에서 여러 줄을 사용하지 못하게하는 하는 문제는 개발자의 오랜 숙원이었습니다.</p>
<h4 id="쉽게-여러줄의-문자열-만드는-방법"><a href="#쉽게-여러줄의-문자열-만드는-방법" class="headerlink" title="쉽게 여러줄의 문자열 만드는 방법"></a>쉽게 여러줄의 문자열 만드는 방법</h4><p>ECMAScript 6의 <em>Template literal</em>은 특수 구문이 없기 때문에 여러 줄 문자열을 쉽게 만듭니다. 원하는 위치에 개행을 포함하면 결과에 나타납니다. 예 :</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> message = <span class="string">`Multiline</span></div><div class="line">string`;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(message);           <span class="comment">// "Multiline</span></div><div class="line">                                <span class="comment">//  string"</span></div><div class="line"><span class="built_in">console</span>.log(message.length);    <span class="comment">// 16</span></div></pre></td></tr></table></figure>
<p>백틱의 모든 공백은 문자열의 일부이므로 들여 쓰기에 주의하십시오.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> message = <span class="string">`Multiline</span></div><div class="line">               string`;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(message);           <span class="comment">// "Multiline</span></div><div class="line">                                <span class="comment">//                 string"</span></div><div class="line"><span class="built_in">console</span>.log(message.length);    <span class="comment">// 31</span></div></pre></td></tr></table></figure>
<p>이 코드에서 <em>Template literal</em>의 두 번째 줄 앞에있는 공백은 모두 문자열 자체의 일부로 간주됩니다. 적절한 들여 쓰기로 텍스트 줄을 만드는 것이 중요하다면 다음과 같이 여러 줄 <em>Template literal</em>의 첫 줄에 아무 것도 남기지 말고 그 다음에 들여 쓰기하는 것을 생각해 볼수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> html = <span class="string">`</span></div><div class="line">&lt;div&gt;</div><div class="line">    &lt;h1&gt;Title&lt;/h1&gt;</div><div class="line">&lt;/div&gt;`.trim();</div></pre></td></tr></table></figure>
<p>이 코드는 첫 번째 줄에서 <em>Template literal</em>을 시작하지만 두 번째 줄까지는 텍스트가 없습니다. HTML 태그는 올바른 모양으로 들여 쓰여지고 <code>trim()</code> 메서드가 호출되어 초기 빈 줄이 제거됩니다.</p>
<p>원하는 경우, <em>Template literal</em>에서 <code>\n</code>을 사용하여 개행을 삽입할 위치를 지정할 수도 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> message = <span class="string">`Multiline\nstring`</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(message);           <span class="comment">// "Multiline</span></div><div class="line">                                <span class="comment">//  string"</span></div><div class="line"><span class="built_in">console</span>.log(message.length);    <span class="comment">// 16</span></div></pre></td></tr></table></figure>
<h3 id="문자열-치환-하기"><a href="#문자열-치환-하기" class="headerlink" title="문자열 치환 하기"></a>문자열 치환 하기</h3><p>이 시점에서 <em>Template literal</em>은 일반적인 JavaScript 문자열보다 더 멋진 버전처럼 보일 수 있습니다. 하지만 일반 JavaScript의 문자열과 <em>Template literal</em>의 실제 차이는 <em>Substitution(치환)</em>에 있습니다. 치환 기능을 사용하면 유효한 JavaScript 표현식을 <em>Template literal</em>에 포함시키고 결과를 문자열의 일부로 출력할 수 있습니다.</p>
<p>문자열 치환은 문자열 내부에 임의의 JavaScript 표현식이 포함된 여는 <code>${</code> 및 닫는<code>}</code>로 처리 됩니다. 가장 간단한 치환은 다음과 같이 결과 문자열에 지역 변수를 직접 포함시킬 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> name = <span class="string">"Nicholas"</span>,</div><div class="line">    message = <span class="string">`Hello, <span class="subst">$&#123;name&#125;</span>.`</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(message);       <span class="comment">// "Hello, Nicholas."</span></div></pre></td></tr></table></figure>
<p>치환 <code>${name}</code>은 로컬 변수 <code>name</code>에 접근하여 <code>name</code>을 <code>message</code> 문자열에 삽입합니다. <code>message</code> 변수는 즉시 치환 결과를 저장합니다.</p>
<blockquote>
<p><em>Template literal</em>은 정의된 Scope에서 액세스할 수있는 모든 변수를 액세스할 수 있습니다. <em>Template literal</em>에서 선언되지 않은 변수를 사용하려고 시도하면 엄격 모드와 비 엄격 모드 모두에서 오류가 발생합니다.</p>
</blockquote>
<p>모든 치환은 JavaScript 표현식이므로 간단한 변수 값의 치환 그 이상을 할 수 있습니다. 계산, 함수 호출 등도 쉽게 포함할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> count = <span class="number">10</span>,</div><div class="line">    price = <span class="number">0.25</span>,</div><div class="line">    message = <span class="string">`<span class="subst">$&#123;count&#125;</span> items cost $<span class="subst">$&#123;(count * price).toFixed(<span class="number">2</span>)&#125;</span>.`</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(message);       <span class="comment">// "10 items cost $2.50."</span></div></pre></td></tr></table></figure>
<p>이 코드는 <em>Template literal</em>의 일부로 계산 기능을 수행합니다. <code>count</code>와 <code>price</code> 변수를 곱해서 결과를 얻은 다음<code>.toFixed()</code>를 사용하여 소수점 두 자리까지 포맷합니다. 두 번째 치환 이전의 달러 기호는 여는 중괄호가 없기 때문에 그대로 출력됩니다.</p>
<p><em>Template literal</em>은 JavaScript 표현식이기도합니다. 즉,이 예제에서와 같이 다른 <em>Template literal</em>의 치환 내부에 <em>Template literal</em>을 배치할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> name = <span class="string">"Nicholas"</span>,</div><div class="line">    message = <span class="string">`Hello, <span class="subst">$&#123;</span></span></div><div class="line">        <span class="string">`my name is <span class="subst">$&#123; name &#125;</span>`</span></div><div class="line">    &#125;.`;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(message);        <span class="comment">// "Hello, my name is Nicholas."</span></div></pre></td></tr></table></figure>
<p>이 예제는 첫 번째 템플릿 안에 두 번째 <em>Template literal</em>을 중첩합니다. 첫 번째 <code>${</code> 다음에 다른 <em>Template literal</em>이 시작됩니다. 두 번째 <code>${</code>는 내부 <em>Template literal</em> 안에 삽입된 표현식의 시작을 나타냅니다. 그 표현식은 결과에 삽입되는 변수 <code>name</code>입니다.</p>
<h3 id="템플릿-Tag-Tagged-Template"><a href="#템플릿-Tag-Tagged-Template" class="headerlink" title="템플릿 Tag(Tagged Template)"></a>템플릿 Tag(Tagged Template)</h3><p>지금까지 <em>Template literal</em>이 여러 줄을 만들고 따로 연결없이(<code>+</code>) 문자열에 값을 삽입하는 방법을 살펴 보았습니다. 그러나 <em>Template literal</em>의 진정한 힘은 태그가있는 템플릿에서 비롯됩니다. <em>Template tag</em>는 <em>Template literal</em>에 대한 치환을 수행하고 최종 문자열 값을 반환합니다. 이 태그는 첫 번째<code>` </code>문자 바로 앞에있는 템플릿의 시작 부분에 다음과 같이 지정합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> message = tag<span class="string">`Hello world`</span>;</div></pre></td></tr></table></figure>
<p>이 예제에서 <code>tag</code>는 <code>`Hello world` </code><em>Template literal</em>에 적용할 템플릿 태그입니다.</p>
<h4 id="Tag-정의하기"><a href="#Tag-정의하기" class="headerlink" title="Tag 정의하기"></a>Tag 정의하기</h4><p><em>Tag</em>는 단순히 처리된 <em>Template literal</em> 데이터가 호출되는 함수입니다. <em>Tag</em>는 <em>Template literal</em>에 대한 데이터를 개별 조각으로 수신하고 조각을 결합하여 결과를 만들어야 합니다. 첫 번째 파라미터는 JavaScript에 의해 해석되는 리터럴 문자열을 포함하는 <em>Array</em>입니다. 후속 파라미터는 각 치환에 사용될 값입니다.</p>
<p><em>Tag</em> 함수는 일반적으로 다음과 같은 파라미터를 사용하여 정의되어 데이터를 보다 쉽게 처리할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">literals, ...substitutions</span>) </span>&#123;</div><div class="line">    <span class="comment">// return a string</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>무엇이 <em>Tag</em>로 전달되는지 더 잘 이해하기 위해 다음 코드를 살펴 보겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> count = <span class="number">10</span>,</div><div class="line">    price = <span class="number">0.25</span>,</div><div class="line">    message = passthru<span class="string">`<span class="subst">$&#123;count&#125;</span> items cost $<span class="subst">$&#123;(count * price).toFixed(<span class="number">2</span>)&#125;</span>.`</span>;</div></pre></td></tr></table></figure>
<p>위 코드를 보면, <code>passthru()</code> 함수는 3 개의 파라미터를 받습니다. 첫 번째 파라미터는 아래의 요소를 포함하는 <code>literals</code> <em>Array</em>입니다.</p>
<ul>
<li>첫 번째 치환 전의 빈 문자열 (<code>&quot;&quot;</code>)</li>
<li>첫 번째 치환 후 두 번째 문자열 앞에있는 문자열 <code>( &quot;items cost $&quot;)</code></li>
<li>두 번째 치환 후의 문자열 <code>(&quot;.&quot;)</code></li>
</ul>
<p>두 번째 파라미터는 <code>count</code> 변수에 대한 해석된 값인 <code>10</code>입니다. 이것은 <code>substitutions</code> <em>Array</em>의 첫 번째 요소가됩니다. 마지막 인수는<code>(count * price).toFixed(2)</code>의 해석된 값이고 <code>substitutions</code> <em>Array</em>의 두 번째 요소인 <code>&quot;2.50&quot;</code>이 될 것입니다.</p>
<p><code>literals</code>의 첫 번째 항목은 빈 문자열입니다. 이것은 <code>literals[literals.length - 1]</code>이 항상 문자열의 끝인 것처럼 <code>literals[0]</code>이 항상 문자열의 시작임을 보장합니다. 항상 <code>substitutions.length === literals.length - 1</code>이라는 표현이 true라는 것은 <code>substitutions</code>이 <code>literals</code>보다 항상 하나 더 적다는 것을 의미합니다.</p>
<p>이 패턴을 사용하면 <code>literals</code>과 <code>substitutions</code> <em>Array</em>을 결합하여 결과 문자열을 만들 수 있습니다. <code>literals</code>의 첫 번째 항목이 먼저오고, <code>substitutions</code>의 첫 번째 항목은 다음 항목이며, 이런 순서는 문자열이 완료될 때까지 계속됩니다. 예를 들어, 다음 두 <em>Array</em>의 값을 교대로 사용하여 <em>Template literal</em>의 기본 동작을 모방할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">passthru</span>(<span class="params">literals, ...substitutions</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> result = <span class="string">""</span>;</div><div class="line"></div><div class="line">    <span class="comment">// loop는 substitutions 카운트 만큼 실행합니다.</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; substitutions.length; i++) &#123;</div><div class="line">        result += literals[i];</div><div class="line">        result += substitutions[i];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 마지막 literal</span></div><div class="line">    result += literals[literals.length - <span class="number">1</span>];</div><div class="line"></div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> count = <span class="number">10</span>,</div><div class="line">    price = <span class="number">0.25</span>,</div><div class="line">    message = passthru<span class="string">`<span class="subst">$&#123;count&#125;</span> items cost $<span class="subst">$&#123;(count * price).toFixed(<span class="number">2</span>)&#125;</span>.`</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(message);       <span class="comment">// "10 items cost $2.50."</span></div></pre></td></tr></table></figure>
<p>위 예제는 <em>Template literal</em>의 기본 액션과 동일한 치환을 수행하는 <code>passthru</code> <em>Tag</em>를 정의합니다. 유일한 트릭은 <code>substitutions</code> <em>Array</em>의 끝을 지나치는 것을 피하기 위해 <code>literalals.length</code>가 아닌 <code>substitutions.length</code>를 loop에서 사용하는 것입니다. 이것은 <code>literalals</code>와 <code>substitutions</code> 사이의 관계가 ECMAScript 6에서 잘 정의되어 있기 때문에 가능합니다.</p>
<blockquote>
<p>‘substitutions’에 포함된 값은 반드시 문자열 일 필요는 없습니다. 앞의 예에서와 같이 표현식이 숫자로 평가되면 숫자 값이 전달됩니다. 이러한 값이 결과에 어떻게 출력되어야 하는지를 결정하는 것은 <em>Tag</em> 작업의 일부입니다.</p>
</blockquote>
<h4 id="Template-literal의-Raw-Value-사용하기"><a href="#Template-literal의-Raw-Value-사용하기" class="headerlink" title="Template literal의 Raw Value 사용하기"></a><em>Template literal</em>의 Raw Value 사용하기</h4><p>템플릿 <em>Tag</em>는 <em>Raw string</em> 정보에도 접근할 수 있습니다. 이 정보는 주로 문자 이스케이프에 대한 액세스를 의미합니다. <em>Raw string</em> 값으로 작업하는 가장 간단한 방법은 내장된 <code>String.raw()</code> <em>Tag</em>를 사용하는 것입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> message1 = <span class="string">`Multiline\nstring`</span>,</div><div class="line">    message2 = <span class="built_in">String</span>.raw<span class="string">`Multiline\nstring`</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(message1);          <span class="comment">// "Multiline</span></div><div class="line">                                <span class="comment">//  string"</span></div><div class="line"><span class="built_in">console</span>.log(message2);          <span class="comment">// "Multiline\\nstring"</span></div></pre></td></tr></table></figure>
<p>이 코드에서 <code>message1</code>의 <code>\n</code>은 개행 문자로 해석되고 <code>message2</code>의 <code>\n</code>은 <code>&quot;\\n&quot;</code>(역슬래시 및 문자 n)의 <code>Raw string</code>으로 해석됩니다. 이와 같이 <code>Raw string</code> 정보를 찾을려면 생각보다 복잡한 처리가 필요합니다.</p>
<p><em>Raw string</em> 정보는 또한 템플릿 <em>Tag</em>로 전달됩니다. <em>Tag</em> 함수의 첫 번째 파라미터는 <code>raw</code>라는 추가 프로퍼티가 있는 <em>Array</em>입니다. <code>raw</code> 프로퍼티는 각 리터럴 값과 정확히 일치하는 <em>Raw</em>을 포함하는 <em>Array</em>입니다. 예를 들어, <code>literals[0]</code>의 값은 항상 <code>Raw string</code> 정보를 포함하는 <code>literals.raw[0]</code>과 일치합니다. 다음 코드를 사용하여 <code>String.raw()</code>을 모방할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">raw</span>(<span class="params">literals, ...substitutions</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> result = <span class="string">""</span>;</div><div class="line"></div><div class="line">    <span class="comment">// loop는 substitutions 카운트 만큼 실행합니다.</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; substitutions.length; i++) &#123;</div><div class="line">        result += literals.raw[i];      <span class="comment">// 대신 raw 값을 사용하세요.</span></div><div class="line">        result += substitutions[i];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 마지막 리터럴을 더합니다.</span></div><div class="line">    result += literals.raw[literals.length - <span class="number">1</span>];</div><div class="line"></div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> message = raw<span class="string">`Multiline\nstring`</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(message);           <span class="comment">// "Multiline\\nstring"</span></div><div class="line"><span class="built_in">console</span>.log(message.length);    <span class="comment">// 17</span></div></pre></td></tr></table></figure>
<p><code>result</code>를 만들기 위해 위해 <code>literalals</code>대신에 <code>literals.raw</code>를 사용합니다. 즉, Unicode <em>Code point</em> 이스케이프를 비롯한 모든 문자 이스케이프는 <em>Raw 형식</em>으로 반환되어야합니다. <code>Raw string</code>은 이스케이프 문자를 포함해야 하는 코드가 포함된 문자열을 출력하려는 경우 유용합니다. (예를 들어, 일부 코드에 대한 설명서를 생성하려면 실제 코드가 나타나는대로 출력하고 싶을 수 있습니다.)</p>
<h2 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h2><p>완전한 Unicode 지원을 통해 JavaScript는 논리적 인 방식으로 UTF-16 문자를 처리할 수 있습니다. <code>codePointAt()</code>와 <code>String.fromCodePoint()</code>를 통해 <em>Code point</em>와 캐릭터 사이를 옮기는 능력은 문자열 조작을 위한 중요한 단계입니다. 정규 표현식 <code>u</code> 플래그를 추가하면 16-bit 문자 대신 <em>Code point</em>에서 연산을 수행할 수 있으며, <code>normalize()</code> 메서드는 보다 적절한 문자열 비교에 유용합니다.</p>
<p>ECMAScript 6는 문자열 작업을위한 새로운 방법을 추가하여 부모 문자열의 위치에 관계없이 하위 문자열을 보다 쉽게 식별할 수 있도록합니다. 정규 표현식에 더 많은 기능이 추가되었습니다.</p>
<p><em>Template literal</em>은 ECMAScript 6에 중요한 추가 기능으로 문자열 작성을 쉽게하기 위해 도메인 별 언어 (DSL)를 만들 수 있습니다. 변수를 <em>Template literal</em>에 직접 포함시킬 수 있다는 것은 개발자가 변수가 있는 긴 문자열을 작성하기 위해 문자열 연결보다 안전한 도구라는 것을 의미합니다.</p>
<p>여러 줄 문자열에 대한 지원 기능이 내장되어 있어 <em>Template literal</em>은 일반적인 JavaScript 문자열보다 유용합니다. <em>Template literal</em> 내부에 개행을 직접 허용하더라도 여전히 <code>\n</code>과 다른 문자 이스케이프 시퀀스를 사용할 수 있습니다.</p>
<p>템플릿 <em>Tag</em>는 DSL을 생성할 때 가장 중요한 부분입니다. <em>Tag</em>는 <em>Template literal</em> 조각을 인수로받는 함수입니다. 그런 다음 해당 데이터를 사용하여 적절한 문자열 값을 반환할 수 있습니다. 제공된 데이터에는 리터럴, raw 값 및 치환 값이 포함됩니다. 그런 다음 이러한 정보를 사용하여 태그의 정확한 리턴을 결정할 수 있습니다.</p>
<hr>
<blockquote>
<p>이 내용은 나중에 참고하기 위해 제가 공부하며 정리한 내용입니다.<br>의역, 오역, 직역이 있을 수 있음을 알려드립니다.<br>This post is a translation of this original article [<a href="https://leanpub.com/understandinges6/read#leanpub-auto-strings-and-regular-expressions" target="_blank" rel="external">https://leanpub.com/understandinges6/read#leanpub-auto-strings-and-regular-expressions</a>]</p>
</blockquote>
<h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul>
<li><a href="https://infoscis.github.io/2018/01/24/ecmascript-6-block-binding/">ECMAScript 6 Block Binding</a></li>
<li><a href="https://infoscis.github.io/2018/01/24/ecmascript-6-strings-and-regular-expressions/">ECMAScript 6 문자열과 정규 표현식</a></li>
<li><a href="https://infoscis.github.io/2018/01/24/ecmascript-6-functions/">ECMAScript 6 함수</a></li>
<li><a href="https://infoscis.github.io/2018/01/25/ecmascript-6-expanded-object-functionality/">ECMAScript 6 객체의 확장된 기능</a></li>
<li><a href="https://infoscis.github.io/2018/01/26/ecmascript-6-destructuring-for-easier-data-access/">ECMAScript 6 쉬운 데이터 액세스를 위한 Destructuring</a></li>
<li><a href="https://infoscis.github.io/2018/01/27/ecmascript-6-symbols-and-symbol-properties/">ECMAScript 6 Symbol과 Symbol 프로퍼티</a></li>
<li><a href="https://infoscis.github.io/2018/01/27/ecmascript-6-sets-and-maps/">ECMAScript 6 Set과 Map</a></li>
<li><a href="https://infoscis.github.io/2018/01/31/ecmascript-6-iterators-and-generators/">ECMAScript 6 Iterator와 Generator</a></li>
<li><a href="https://infoscis.github.io/2018/02/13/ecmascript-6-introducing-javascript-classes/">ECMAScript 6 JavaScript 클래스 소개</a></li>
<li><a href="https://infoscis.github.io/2018/02/13/ecmascript-6-improved-array-capabilities/">ECMAScript 6 Array 기능 향상</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-promises-and-asynchronous-programming/">ECMAScript 6 Promise와 비동기 프로그램밍</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-proxies-and-the-reflection-api/">ECMAScript 6 프록시와 리플렉션 API</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-encapsulating-code-with-modules/">ECMAScript 6 Module로 코드 캡슐화하기</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-appendix-a-smaller-changes/">ECMAScript 6 부록 A. 작은 변경 사항</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-appendix-b-understanding-ecmascript-7/">ECMAScript 6 부록 B. ECMAScript 7(2016) 이해하기</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;문자열과-정규-표현식&quot;&gt;&lt;a href=&quot;#문자열과-정규-표현식&quot; class=&quot;headerlink&quot; title=&quot;문자열과 정규 표현식&quot;&gt;&lt;/a&gt;문자열과 정규 표현식&lt;/h1&gt;&lt;p&gt;논쟁의 여지는 있지만 &lt;em&gt;String&lt;/em&gt;은 프로그래밍
    
    </summary>
    
      <category term="JavaScript" scheme="http://infoscis.github.io/categories/JavaScript/"/>
    
      <category term="ECMAScript 2015" scheme="http://infoscis.github.io/categories/JavaScript/ECMAScript-2015/"/>
    
    
      <category term="JavaScript" scheme="http://infoscis.github.io/tags/JavaScript/"/>
    
      <category term="ECMAScript 2015" scheme="http://infoscis.github.io/tags/ECMAScript-2015/"/>
    
  </entry>
  
  <entry>
    <title>ECMAScript 6 Block binding</title>
    <link href="http://infoscis.github.io/2018/01/24/ecmascript-6-block-binding/"/>
    <id>http://infoscis.github.io/2018/01/24/ecmascript-6-block-binding/</id>
    <published>2018-01-24T14:03:14.000Z</published>
    <updated>2018-02-27T14:11:53.789Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Block-Binding"><a href="#Block-Binding" class="headerlink" title="Block Binding"></a>Block Binding</h1><p>Javascript의 전통적인 식별자(Identifier - 변수, 상수, 이름 있는 함수 등) 선언이 작동하는 방식은 JavaScript 프로그래밍의 까다로운 부분 중 하나였습니다. 대부분의 C 기반 언어에서 식별자(Identifier - 변수 바인딩)는 선언이 발생한 지점에 만들어집니다. 그러나 JavaScript에서는 그렇지 않습니다. 식별자(Identifier)를 실제로 생성하는 위치는 선언하는 방법에 따라 다르며, ECMAScript 6에서는 제어 Scope을 더 쉽게 만들 수 있는 옵션을 제공합니다. 이 챕터에서는 고전적인 <code>var</code> 식별자 선언이 왜 혼란스럽게 하는지와, ECMAScript 6의 Block level binding의 소개, 그리고 이를 사용하는 몇 가지 모범 사례를 제시합니다.</p>
<h2 id="var-식별자-선언-및-Hoisting-호이스팅"><a href="#var-식별자-선언-및-Hoisting-호이스팅" class="headerlink" title="var 식별자 선언 및 Hoisting(호이스팅)"></a>var 식별자 선언 및 Hoisting(호이스팅)</h2><blockquote>
<p><strong>식별자</strong></p>
<p>JavaScript의 식별자는 간단히 말해서 이름입니다<br>JavaScript 식별자는 변수, 상수, 함수에 이름을 붙이거나 자바스크립트 코드 내 루프 문에 레이블을 붙이는 데 사용됩니다.<br>올바른 식별자가 되기 위한 규칙은 자바나 다른 수많은 언어의 규칙과 동일합니다.<br>첫 번째 문자는 알파벳(letter), 밑줄(_) 혹은 달러표시($) 여야 한다. 이어지는 문자들은 알바벳(letter), 숫자, 밑줄(_) 혹은 달러 표시여야 한다.<br>JavaScript가 숫자와 식별자를 쉽게 구별할 수 있게 하기 위해, 숫자는 첫 번째 문자로 허용되지 않는다.</p>
<p>출처 <a href="http://www.devholic.net/1000687" target="_blank" rel="external">http://www.devholic.net/1000687</a></p>
</blockquote>
<p><code>var</code>를 이용한 식별자 선언은 실제 선언이 어디에서 발생하는지에 관계없이 해당 Scope의 맨 위에있는 것처럼 처리됩니다. (또는 함수 외부에서 선언된 경우 전역 Scope로 처리됩니다.) 이것을 JavaScript에서 <em>Hoisting</em>이라고합니다. 아래 예제 함수를 보면 <em>Hoisting</em>에 대해 쉽게 이해할 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">condition</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (condition) &#123;</div><div class="line">        <span class="keyword">var</span> value = <span class="string">"blue"</span>;</div><div class="line">        <span class="comment">// 다른 코드들</span></div><div class="line">        <span class="keyword">return</span> value;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// value는 여기에서 'undefined' 입니다.</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// value는 여기에서 'undefined' 입니다.</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>JavaScript에 익숙하지 않은 경우 위 코드에서 <code>if</code> 조건이 <code>true</code>로 평가되는 경우에만 <code>value</code>가 생성될 것으로 예상할 수 있지만 실제로 <code>value</code> 변수는 선언한 위치와 관계없이 생성됩니다. JavaScript 엔진은 <code>getValue</code> 함수를 다음과 같이 변경합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">condition</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> value; <span class="comment">// 변수의 선언 위치가 바뀝니다.</span></div><div class="line">    <span class="keyword">if</span> (condition) &#123;</div><div class="line">        value = <span class="string">"blue"</span>; <span class="comment">// 변수의 초기화는 여기에서 이뤄집니다.</span></div><div class="line">        <span class="comment">// 다른 코드들</span></div><div class="line">        <span class="keyword">return</span> value;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>value</code> 변수의 선언은 Scope 맨 위로 올라가고 변수의 초기화는 동일한 지점에 남아 있습니다. 즉, <code>value</code>는 <code>else</code> 절에서 실제로 액세스할 수 있습니다. 하지만 <code>else</code> 구문에서 접근할 경우 변수는 초기화되지 않았기 때문에 <code>undefined</code>값을 갖게됩니다.</p>
<p>새로 JavaScript를 공부하는 개발자가 <em>Hoisting</em>에 익숙해지기까지 어느정도 시간이 걸리며, 이 독특한 동작을 잘못 이해하면 버그가 발생할 수 있습니다. 이러한 이유로 ECMAScript 6에는 식별자(Identifier)의 생명주기 제어를 좀 더 강력하게 만들기 위한 Block level scope 옵션이 도입되었습니다.</p>
<h2 id="Block-Level-식별자-선언"><a href="#Block-Level-식별자-선언" class="headerlink" title="Block-Level 식별자 선언"></a>Block-Level 식별자 선언</h2><p>Block level 식별자 선언은 지정된 Block scope 외부에서 액세스할 수없는 식별자(Identifier)를 정의하는 방법입니다. 이런 방식은 Lexical scope이라고도 하는 Block scope이 만들어집니다.</p>
<ol>
<li>Function 내부</li>
<li>Block 내부 ( <code>{</code>와 <code>}</code> 문자 사이를 나타냄)</li>
</ol>
<p>Block scope은 C 기반 언어의 작동 방식이며 ECMAScript 6의 Block-level 식별자(Identifier) 선언은 JavaScript에 C 기반 언어와 동일한 유연성(균일성)을 제공하기 위한 것입니다.</p>
<h3 id="let-식별자-선언"><a href="#let-식별자-선언" class="headerlink" title="let 식별자 선언"></a>let 식별자 선언</h3><p><code>let</code>을 이용한 식별자 선언 구문은 <code>var</code> 구문과 동일합니다. 기본적으로 <code>var</code>를 <code>let</code>으로 바꾸면 똑같이 식별자를 선언할 수 있지만 Scope이 현재 코드 Block으로 제한됩니다. (하지만 잠시후에 논의할 약간의 차이점은 있습니다). <code>let</code> 선언은 자동으로 Block의 맨 위로 올려지지 않기 때문에 <code>let</code> 선언을 Block의 최상단에 배치해야만 Block 전체에서 사용할 수 있습니다. 아래의 예제를 살펴 보도록 하겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">condition</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (condition) &#123;</div><div class="line">        <span class="keyword">let</span> value = <span class="string">"blue"</span>;</div><div class="line">        <span class="comment">// 다른 코드들</span></div><div class="line">        <span class="keyword">return</span> value;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// value 변수는 이 Block에 존재하지 않습니다.</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// value 변수는 이 Block에 존재하지 않습니다.</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>이 버전의 <code>getValue</code> 함수는 다른 C 기반 언어의 실행 방식과 매우 유사합니다. 변수 <code>value</code>는 <code>var</code> 대신에 <code>let</code>을 사용하여 선언 되었기 때문에, 변수 선언이 함수 정의 맨위로 끌어 올려지지 않습니다. 그리고 <code>value</code>는 <code>if</code>을 벗어나면 더 이상 접근할 수 없습니다. <code>if</code> 조건이 false로 평가되면 <code>value</code> 변수는 선언이 되지 않고 값의 초기화도 이뤄지지 않습니다.</p>
<h3 id="재선언-안됨"><a href="#재선언-안됨" class="headerlink" title="재선언 안됨"></a>재선언 안됨</h3><p>식별자(변수)가 이미 Scope내에서 정의된 경우 해당 Scope에서 같은 이름으로 <code>let</code> 선언을 다시하면 오류가 발생합니다. 예를 들어 아래의 코드는 에러가 발생합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> count = <span class="number">30</span>;</div><div class="line"><span class="comment">// 구문 오류</span></div><div class="line"><span class="keyword">let</span> count = <span class="number">40</span>;</div></pre></td></tr></table></figure>
<p>위의 예제에서 <code>count</code>는 두 번 선언되었습니다(한 번은 <code>var</code>, 다른 한 번은 <code>let</code>). <code>let</code>은 이미 선언된 식별자를 동일한 Scope에 다시 정의하지 않기 때문에 <code>let</code> 변수 선언은 오류를 발생시킵니다. 반면에 아래 예제와 같이 <code>let</code> 선언이 포함된 코드가 새로운 Scope에서 동일한 이름의 식별자로 선언될 경우 오류가 발생하지 않습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> count = <span class="number">30</span>;</div><div class="line"><span class="comment">// 에러가 발생하지 않습니다.</span></div><div class="line"><span class="keyword">if</span> (condition) &#123;</div><div class="line">    <span class="keyword">let</span> count = <span class="number">40</span>;</div><div class="line">    <span class="comment">// 다른 코드들</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>위 코드의 <code>let</code> 선언은 <code>if</code> 블럭에 <code>count</code>라는 새로운 변수를 생성하기 때문에 오류를 발생시키지 않습니다. <code>if</code> 블럭 안에서 선언한 <code>count</code> 변수가 <em>전역</em> <code>count</code> 변수를 shadows 처리하여 Block 내부에서는 <em>전역</em> <code>count</code>에 대한 암시적 접근을 차단합니다.</p>
<h3 id="Constant-선언"><a href="#Constant-선언" class="headerlink" title="Constant 선언"></a>Constant 선언</h3><p>ECMAScript 6에서 <code>const</code> 선언 구문을 사용하여 식별자를 정의할 수있습니다. <code>const</code>를 사용하여 선언된 식별자는 상수(Constant)로 간주되며, 일단 값을 설정하면 변경할 수 없습니다. 이런 이유로 모든 <code>const</code> 식별자는 다음 예제와 같이 선언시 초기화 되어야합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 유효한 상수 선언</span></div><div class="line"><span class="keyword">const</span> maxItems = <span class="number">30</span>;</div><div class="line"></div><div class="line"><span class="comment">// 초기화가 빠져있어서 구문 오류</span></div><div class="line"><span class="keyword">const</span> name;</div></pre></td></tr></table></figure>
<p>위 예제에서 <code>maxItems</code> 변수는 초기화 코드가 있어서 <code>const</code> 선언이 문제없이 실행됩니다. 그러나 <code>name</code> 변수는 초기화되지 않았으므로 만약 이 코드가 포함된 프로그램을 실행하려고 하면 <code>name</code> 변수 선언에서 구문 오류를 일으킬 수 있습니다.</p>
<h4 id="상수와-let-선언-관계"><a href="#상수와-let-선언-관계" class="headerlink" title="상수와 let 선언 관계"></a>상수와 let 선언 관계</h4><p><code>let</code> 선언 변수는 Block-level 변수 선언입니다. 이것은 프로그램의 실행 흐름이 변수가 선언된 Block을 벋어 나면 변수를 더이상 액세스할 수 없다는 것을 의미합니다. 아래의 예제에서 보듯이, 선언된 변수가 <em>Hoisting</em>되지 않습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (condition) &#123;</div><div class="line">    <span class="keyword">const</span> maxItems = <span class="number">5</span>;</div><div class="line">    <span class="comment">// 다른 코드</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// maxItems은 여기에서 액세스할 수 없습니다.</span></div></pre></td></tr></table></figure>
<p>이 코드에서 변수 <code>maxItems</code>는 <code>if</code> 블럭 안에서 선언되었습니다. 그리고 명령문 실행이 끝나면 <code>maxItems</code> 변수는 해당 블럭 외부에서 액세스할 수 없습니다. <code>let</code>과 동일하게 같은 Scope에 이미 정의된 식별자 이름을 또 사용하면 <code>const</code> 선언시 오류가 발생합니다. 변수가 <code>var</code> (전역 또는 함수 Scope의 경우) 또는 <code>let</code> (Block scope의 경우)을 사용하여 선언되었는지는 중요하지 않습니다. 예를 들어 다음 코드를 살펴 보겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> message = <span class="string">"Hello!"</span>;</div><div class="line"><span class="keyword">let</span> age = <span class="number">25</span>;</div><div class="line"></div><div class="line"><span class="comment">// 에러가 발생합니다.</span></div><div class="line"><span class="keyword">const</span> message = <span class="string">"Goodbye!"</span>;</div><div class="line"><span class="keyword">const</span> age = <span class="number">30</span>;</div></pre></td></tr></table></figure>
<p>위 예제에서 상위 두개의 <code>const</code> 선언을 단독으로 사용하면 유효하지만, 위 코드에서는 앞의 <code>var</code> 및 <code>let</code> 선언이 있어서 오류가 발생합니다.</p>
<p><code>let</code>과 <code>const</code>가 이러한 비슷한 점이 있지만 주요한 큰 차이점이 하나 있습니다. 아래의 예제에서 보듯이 이전에 정의된 <code>const</code> 식별자에 새로운 상수값을 할당하려고 하면 strict 모드와 non-strict 모드 모두에서 오류가 발생합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> maxItems = <span class="number">5</span>;</div><div class="line">maxItems = <span class="number">6</span>;      <span class="comment">// 에러가 발생합니다.</span></div></pre></td></tr></table></figure>
<p>다른 언어의 상수와 매우 비슷하게 나중에 <code>maxItems</code> 상수에 새로운 값을 할당할 수 없습니다. 그러나 다른 언어와 달리 JavaScript의 상수가 객체인 경우 객체의 프로퍼티값은 수정할 수 있습니다.</p>
<h4 id="const를-이용한-객체-선언"><a href="#const를-이용한-객체-선언" class="headerlink" title="const를 이용한 객체 선언"></a>const를 이용한 객체 선언</h4><p><code>const</code> 변수 선언은 값 자체가 아닌 바인딩의 수정을 방지합니다. 이는 객체의 <code>const</code> 선언이 객체의 수정을 막지 않는다는 것을 의미합니다. 예를 들어 아래 코드를 살펴 보겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> person = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">"Nicholas"</span></div><div class="line">&#125;;</div><div class="line"><span class="comment">// 실행됨</span></div><div class="line">person.name = <span class="string">"Greg"</span>;</div><div class="line"></div><div class="line"><span class="comment">// 에러 발생</span></div><div class="line">person = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">"Greg"</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>위 코드에서 <code>person</code> 변수는 하나의 프로퍼티를 가진 JavaScript 객체이고, 초기값을 가지고 생성됩니다. <code>person.name</code>의 값을 변경하는건 오류 없이 가능합니다. 왜냐하면 <code>person</code>에 바인드된 값을 변경하는 것이 아니고 <code>person</code>에 포함된 것을 변경하기 때문입니다. 만약 코드에서 <code>person</code>에 값을 할당하려고 시도하면 (바인딩을 변경하려고 하면) 오류가 발생합니다. <code>const</code>가 객체와 어떻게 작동하는지에 대한 이 미묘한 점이 오해하기 쉽습니다. <code>const</code>는 바인딩 값의 수정이 아니라 바인딩 자체의 수정을 방지한다는 것을 기억 해야 합니다.</p>
<h3 id="TDZ-The-Temporal-Dead-Zone"><a href="#TDZ-The-Temporal-Dead-Zone" class="headerlink" title="TDZ (The Temporal Dead Zone)"></a>TDZ (The Temporal Dead Zone)</h3><blockquote>
<p><code>let</code> 초기화와 관련하여 발생하는 오류를 가리켜 TDZ(TEMPORAL DEAD ZONE) 오류라고 부릅니다.</p>
</blockquote>
<p><code>let</code> 또는 <code>const</code>로 선언된 식별자는 선언 전에는 액세스할 수 없습니다. 아래의 예제와 같이  일반적으로 안전한 <code>typeof</code> 연산자를 사용하는 경우에도 참조 오류가 발생합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (condition) &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> value);  <span class="comment">// ReferenceError!</span></div><div class="line">    <span class="keyword">let</span> value = <span class="string">"blue"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>여기서 식별자 <code>value</code>는 <code>let</code>을 사용하여 정의되고 초기화 되지만 이전행에서 오류가 발생하므로 해당 명령문은 실행되지 않습니다. <code>value</code> 식별자가 JavaScript 커뮤니티에서 불리는 <em>The Temporal Dead Zone</em>(TDZ)에 존재한다는 것이 문제입니다. <strong>TDZ</strong>는 ECMAScript 사양에서 명시적으로 설명하고 있지는 않지만, 식별자를 <code>let</code> 및 <code>const</code> 선언전에 액세스할 수없는 이유를 설명할 때 자주 이용됩니다. 여기에서 <strong>TDZ</strong>를 발생시키는 선언 배치의 미묘한 부분에 대해 설명합니다. 모든 예제에서 <code>let</code>을 사용하지만 <code>const</code>에도 동일하게 적용됩니다.</p>
<p>JavaScript engine이 실행될 때에 블록(<code>{</code> <code>}</code>)에서 선언된 변수를 찾아 선언된 식별자가 <code>var</code> 선언자를 이용한 선언이면 변수의 선언을 함수의 최상단 또는 전역 Scope으로 가져가고, <code>let</code> 또는 <code>const</code> 선언자로 선언된 경우 변수의 선언을 <code>TDZ</code>에 배치합니다. <code>TDZ</code>의 변수에 대한 액세스는 런타임 오류가 발생합니다. 이러한 변수를 <code>TDZ</code>에서 제거하고 변수를 선언된 이후에 사용하면 안전하게 사용할 수 있습니다.</p>
<p><code>let</code> 또는 <code>const</code> 선언자로 선언된 변수는 사용하기 전에 <code>defined</code> 됩니다. 이런 부분은 이전 예제에서 보여줬던 안전한 연산자인 <code>typeof</code>에도 적용이 됩니다. 그리고 변수가 선언된 블록의 외부에서 변수에 대해 <code>typeof</code>를 사용할 수는 있지만 정상적인 결과를 받지 못합니다. 다음 코드를 살펴보겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> value);     <span class="comment">// "undefined"</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> (condition) &#123;</div><div class="line">    <span class="keyword">let</span> value = <span class="string">"blue"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>value</code>가 선언된 블록 외부에서 사용되기 때문에 <code>typeof</code> 연산자가 실행될 때 변수 <code>value</code>는 TDZ에 없습니다. 이 의미는 <code>value</code> 변수에 바인딩이 없기 대문에 <code>typeof</code> 연산자는 <code>&quot;undefined&quot;</code>를 반환합니다.</p>
<p><code>TDZ</code>는 Block-binding의 독특한 부분입니다.그리고 또 다른 독특한 부분은 루프 내부에서의 사용과 관련이 있습니다.</p>
<h2 id="Loop-안에서의-Block-Binding"><a href="#Loop-안에서의-Block-Binding" class="headerlink" title="Loop 안에서의 Block Binding"></a>Loop 안에서의 Block Binding</h2><p>개발자가 Block-level scope을 가장 많이 원하는 곳 중 하나는 <code>for loop</code> 이고, 일반적으로 임시로 사용하는 카운터 변수는 루프 내부에서만 사용해야 합니다. 예를 들어 기존 JavaScript 코드에서 아래와 같은 코드는 보기 드물지 않습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">    process(items[i]);</div><div class="line">&#125;</div><div class="line"><span class="comment">// i 는 여전히 여기에서 액세스 가능합니다.</span></div><div class="line"><span class="built_in">console</span>.log(i);                     <span class="comment">// 10</span></div></pre></td></tr></table></figure>
<p>Block level scope가 기본인 다른 언어에서는 이 예제가 의도 한대로 실행되고, <code>for loop</code> 내부에서만 <code>i</code> 변수에 액세스할 수 있습니다. 그러나 JavaScript에서는 <code>var</code> 선언이 <em>Hoisting</em>되기 때문에 loop가 완료된 후에도 변수 <code>i</code>를 계속 액세스할 수 있습니다. 다음 코드와 같이 <code>var</code> 선언자 대신 <code>let</code> 선언자를 사용하여 원래 의도 한 동작이 실행 되도록 해야 합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">    process(items[i]);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// i는 접근할 수 없기 때문에 error가 발생합니다.</span></div><div class="line"><span class="built_in">console</span>.log(i);</div></pre></td></tr></table></figure>
<p>위 코드에서 변수 <code>i</code>는 <code>for loop</code> 내에만 존재합니다. loop가 완료되면 변수는 더 이상 다른 곳에서 액세스할 수 없습니다.</p>
<h3 id="loop-안의-함수"><a href="#loop-안의-함수" class="headerlink" title="loop 안의 함수"></a>loop 안의 함수</h3><p><code>var</code> 변수 선언자의 특징 중에 loop 내부에서 생성한 변수를 loop 밖에서 액세스할 수 있는 특징 때문에 loop 내부에서 함수를 만들때 오랫동안 문제가 있었습니다. 다음 코드를 생각해 보겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> funcs = [];</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">    funcs.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(i); &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">funcs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">func</span>) </span>&#123;</div><div class="line">    func();     <span class="comment">// 숫자 '10'이 열번 출력됩니다.</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>이 코드는 일반적으로 0에서 9까지의 숫자를 출력할 것으로 예상되지만 <code>10</code>을 <code>10</code>번 출력합니다. 왜냐하면 <code>i</code>는 반복문의 반복마다 서로 공유되기 때문입니다. 즉, loop 내부에서 생성한 함수는 모두 동일한 변수를 참조합니다. 변수 <code>i</code>는 loop가 완료되면 <code>10</code>의 값을 가지므로 <code>console.log (i)</code>가 호출될 때마다 <code>10</code>을 매번 출력합니다.</p>
<p>이 문제를 해결하기 위해 대부분의 개발자는 루프 내에서 즉시 호출되는 함수 표현식 (IIFE: Immediately-invoked function expression)을 사용하여 아래 예제에서 처럼 반복할 변수의 새 복사본을 강제로 만듭니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> funcs = [];</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">    funcs.push((<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(value);</div><div class="line">        &#125;</div><div class="line">    &#125;(i)));</div><div class="line">&#125;</div><div class="line"></div><div class="line">funcs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">func</span>) </span>&#123;</div><div class="line">    func();     <span class="comment">// outputs 0, then 1, then 2, up to 9</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>위의 예제에서는 IIFE를 loop 내부에서 사용했습니다. 변수 <code>i</code>는 IIFE 형태로 전달되고, IIFE는 자체 복사본을 만들어 <code>value</code>로 저장합니다. 이것은 반복에서 함수가 사용하는 값이므로 각 함수를 호출하면 loop에서 0부터 9까지 카운트될 때 예상 값이 리턴됩니다. 하지만  ECMAScript 6에서는 <code>let</code>및 <code>const</code>를 사용하여 Block-level 바인딩을 하면 이러한 작업이 단순화 됩니다.</p>
<h3 id="Loop-안에서의-let-선언"><a href="#Loop-안에서의-let-선언" class="headerlink" title="Loop 안에서의 let 선언"></a>Loop 안에서의 <code>let</code> 선언</h3><p><code>let</code>선언은 앞의 예제에서 IIFE가 수행하는 것을 효과적으로 대체함으로써 loop를 단순화합니다. 각 반복에서 loop는 새 변수를 만들고 이전 반복과 같은 이름을 가진 변수 값으로 초기화합니다. 즉, IIFE를 생략하고 다음과 같이 원하는 결과를 얻을 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> funcs = [];</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">    funcs.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(i);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">funcs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">func</span>) </span>&#123;</div><div class="line">    func();     <span class="comment">// outputs 0, then 1, then 2, up to 9</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>위 예제는 <code>var</code>와 IIFE를 사용했던 예제와 정확히 똑같이 실행되지만 훨씬더 깔끔합니다. <code>let</code> 선언은 매번 loop를 통해 새로운 변수 <code>i</code>를 생성하므로 loop 안에 생성된 각 함수는 <code>i</code>의 복사된 값을 갖습니다. 각 <code>i</code>의 복사본은 loop의 시작 부분에서 생성된 값이 할당됩니다. 다음 예제와 같이 <code>for-in</code>, <code>for-of</code> loop에도 똑같이 적용됩니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> funcs = [],</div><div class="line">    object = &#123;</div><div class="line">        <span class="attr">a</span>: <span class="literal">true</span>,</div><div class="line">        <span class="attr">b</span>: <span class="literal">true</span>,</div><div class="line">        <span class="attr">c</span>: <span class="literal">true</span></div><div class="line">    &#125;;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> object) &#123;</div><div class="line">    funcs.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(key);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">funcs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">func</span>) </span>&#123;</div><div class="line">    func();     <span class="comment">// outputs "a", then "b", then "c"</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>이 예제에서 <code>for-in loop</code>는 <code>for loop</code>와 같은 결과를 보여줍니다. loop가 실행될 때마다 새로운 <code>key</code> 바인딩이 생성되고 각 함수는 <code>key</code> 변수의 복사본을 가지고 있습니다. 함수가 다른 값을 출력하는 결과를 보여줍니다. 만약 <code>key</code>를 <code>var</code> 선언자를 이용해 선언하면 모든 함수는 동일한 <code>&quot;c&quot;</code>를 출력할 것입니다.</p>
<blockquote>
<p>loop에서 <code>let</code> 선언 동작은 스펙에서 특별히 정의된 동작이고, <code>let</code>의 Non-Hoisting 특성과 반드시 관련이 없다는 것을 이해하는 것이 중요합니다. 실제로, <code>let</code>의 초기 구현은 이러한 동작을 하지 못했고, ECMAScript 6 명세 Process가 진행되면서 추가된 것입니다.</p>
</blockquote>
<h3 id="Loop-안에서의-상수-선언"><a href="#Loop-안에서의-상수-선언" class="headerlink" title="Loop 안에서의 상수 선언"></a>Loop 안에서의 상수 선언</h3><p>ECMAScript 6 명세는 loop내부 <code>const</code> 선언을 명시적으로 허용하지 않습니다. 그러나 여러분이 사용중인 loop 종류에 따라 <code>const</code> 선언을 사용하여 다른 처리를 할 수 있습니다. 일반적인 <code>for loop</code>의 경우 초기화시 <code>const</code>를 사용할 수 있지만 첫 번째 이터레이션 후 오류를 던집니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> funcs = [];</div><div class="line"></div><div class="line"><span class="comment">// 첫 번째 이터레이션 후에 에러를 던짐</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">const</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">    funcs.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(i);</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>위 예제에서 변수 <code>i</code>를 상수로 선언했습니다. <code>i</code>가 0 인 첫번째 loop의 반복은 성공적으로 실행됩니다. 하지만 <code>i++</code>가 상수를 수정하려하기 때문에 <code>i++</code> 구문이 실행되변 에러가 발생합니다. 따라서 변수를 수정하지 않는 loop 초기화 부분의 변수를 선언할 때만 <code>const</code>를 사용할 수 있습니다.</p>
<p>반면에 <code>for-in</code> 또는 <code>for-of</code> loop에서 사용될 때 <code>const</code> 변수는<code>let</code> 변수와 똑같이 동작합니다. 다음 코드는 오류가 발생하지 않습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> funcs = [],</div><div class="line">    object = &#123;</div><div class="line">        <span class="attr">a</span>: <span class="literal">true</span>,</div><div class="line">        <span class="attr">b</span>: <span class="literal">true</span>,</div><div class="line">        <span class="attr">c</span>: <span class="literal">true</span></div><div class="line">    &#125;;</div><div class="line"></div><div class="line"><span class="comment">// 에러를 발생하지 않습니다.</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> object) &#123;</div><div class="line">    funcs.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(key);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">funcs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">func</span>) </span>&#123;</div><div class="line">    func();     <span class="comment">// outputs "a", then "b", then "c"</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>이 코드는 “Loop 안에서의 <code>let</code> 선언” 부분의 두 번째 예제와 거의 동일한 실행 결과를 보여줍니다. 유일한 차이점은 <code>key</code>의 값을 loop 내에서 변경할 수 없다는 것입니다. <code>for-in</code>과 <code>for-of</code> loop는 <code>const</code>와 함께 실행할 수 있습니다. loop 초기화는 기존 바인딩의 값을 수정하려고 시도하는 대신 loop가 반복할 때마다 새로운 바인딩을 생성하기 때문입니다 (이전 예제에서 에러가 발생한 이유는 <code>for-in</code> 대신 <code>for loop</code>을 사용했기 때문입니다.).</p>
<h2 id="전역-Block-Binding"><a href="#전역-Block-Binding" class="headerlink" title="전역 Block Binding"></a>전역 Block Binding</h2><p><code>let</code>과 <code>const</code>가 <code>var</code>와 또 다른 부분은 전역 Scope 입니다. 전역 Scope에서 <code>var</code>을 사용할 때, 전역 객체 (브라우저의 <code>window</code>)에 대한 프로퍼티로 새로운 전역 변수를 만듭니다. 이는 실수로 <code>var</code>를 사용하여 기존 전역 변수의 값을 덮어 쓸 수 있음을 의미합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// browser에서 실행.</span></div><div class="line"><span class="keyword">var</span> <span class="built_in">RegExp</span> = <span class="string">"Hello!"</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.RegExp);     <span class="comment">// "Hello!"</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> ncz = <span class="string">"Hi!"</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.ncz);        <span class="comment">// "Hi!"</span></div></pre></td></tr></table></figure>
<p>글로벌 <code>RegExp</code>가 <code>window</code>에 정의되어 있더라도 <code>var</code> 선언으로 덮어 쓰는 것은 안전하지 않습니다. 이 예제는 원본을 덮어 쓰는 새로운 전역 변수 <code>RegExp</code>를 선언했습니다. 비슷하게 변수 <code>ncz</code>는 전역 변수로 정의되고 즉시 <code>window</code>에 프로퍼티로 정의됩니다. 이것이 항상 JavaScript가 작동하는 방법입니다.</p>
<p>전역 Scope에서 <code>let</code> 또는<code>const</code>를 <code>var</code> 대신 사용하면 전역 범위에 새로운 바인딩이 생성되지만 전역 객체에 프로퍼티가 추가 되지는 않습니다. 즉 <code>let</code> 또는 <code>const</code>를 사용하여 전역 변수를 덮어 쓸 수 없다는 것을 의미합니다. 다음 코드를 살펴 보겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// in a browser</span></div><div class="line"><span class="keyword">let</span> <span class="built_in">RegExp</span> = <span class="string">"Hello!"</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>);                    <span class="comment">// "Hello!"</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.RegExp === <span class="built_in">RegExp</span>);  <span class="comment">// false</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> ncz = <span class="string">"Hi!"</span>;</div><div class="line"><span class="built_in">console</span>.log(ncz);                       <span class="comment">// "Hi!"</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"ncz"</span> <span class="keyword">in</span> <span class="built_in">window</span>);           <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p>이 코드에서 <code>RegExp</code>에 대한 새로운 <code>let</code> 선언은 전역 변수 <code>RegExp</code>를 가리키는 바인딩을 만듭니다. 즉, <code>window.RegExp</code>와 <code>RegExp</code>는 같지 않으므로 전역 Scope에 혼란이 없습니다. 또한, <code>ncz</code>에 대한 <code>const</code> 선언은 바인딩은 생성하지만 전역 객체에 대한 프로퍼티를 추가하지 않습니다. 이 기능은 전역 객체에 프로퍼티을 생성하고 싶지 않을 때 전역 영역에서 <code>let</code>과 <code>const</code>가 훨씬 더 안전하게 할수 있도록 합니다.</p>
<blockquote>
<p>만약 전역 객체에서 사용할 수 있어야 하는 코드가 필요하다면 전역 Scope에서 <code>var</code>을 여전히 사용할 수 있습니다. 이런 방법은 일반적으로 프레임이나 윈도우에서 코드에 액세스하는 경우에 일반적으로 사용합니다.</p>
</blockquote>
<h2 id="Block-Binding에-대한-새로운-Best-Practices"><a href="#Block-Binding에-대한-새로운-Best-Practices" class="headerlink" title="Block-Binding에 대한 새로운 Best Practices"></a>Block-Binding에 대한 새로운 Best Practices</h2><p>ECMAScript 6가 개발 중에 있는 동안, 변수 선언에 <code>var</code> 대신에 <code>let</code>을 디폴트로 사용해야 한다는 생각이 널리 퍼졌습니다. 많은 JavaScript 개발자들은 <code>let</code>이 <code>var</code>의 실행 방식과 똑같이 실행된다고 생각했습니다. 그래서 선언자 키워드의 1:1 대체(Direct replacement)가 논리적으로 합당하게 생각되었습니다. 그리고 값의 수정에 대한 보호가 필요한 변수에는 <code>const</code>를 사용하도록 생각했습니다.</p>
<p>하지만 더많은 개발자가 ECMAScript 6으로 마이그레이션할 때에는 대체 접근법(Alternative approach)이 인기를 얻었습니다. 기본적으로 <code>const</code>를 사용하고 변수 값을 변경해야 한다는 것을 알때 <code>let</code>을 사용하십시오. 이유는 예상치 못한 값 변경이 버그의 원인이기 되기 때문에 초기화 후 대부분의 변수가 값을 변경해서는 안된다는 것입니다. 이 아이디어는 많은 공감을 얻었으면 ECMAScript 6을 채택할 때 고려할만한 가치가 있습니다.</p>
<h2 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h2><p><code>let</code>과 <code>const</code> Block-binding은 JavaScript에 Lexical scoping을 도입합니다. 이러한 선언은 <em>Hoisting</em>되지 않으며 선언된 블록내에만 존재합니다. 변수가 다른 언어와 더 유사하고 의도하지 않은 오류가 발생할 가능성이 적은 동작을 제공하므로 변수가 필요한 위치에 정확히 선언될 수 있습니다. 부작용으로 <code>typeof</code>와 같이 안전한 연산자를 사용하더라도 변수가 선언되기 전에 변수에 액세스할 수 없습니다. 선언전에 Block-binding에 액세스하려고 하면 TDZ(Temporary Dead Zone) 바인딩의 존재로 인해 오류가 발생합니다.</p>
<p>대부분의 경우 <code>let</code>과 <code>const</code>는 <code>var</code>와 비슷한 방식으로 동작합니다. 하지만 <code>for loop</code>에서는 그렇지 않습니다. <code>let</code>과 <code>const</code> 둘다에 대해서, <code>for-in</code>과 <code>for-of</code> loop는 반복할 때마다 새로운 바인딩을 생성합니다. 즉, loop 본문 내부에서 작성된 함수는 loop의 최종 반복 이후(loop를 벗어난 이후)가 아닌 현재 반복중인 loop 내부에서만 액세스할 수 있음을 의미합니다. <code>for loop</code>에서 <code>let</code> 선언에 대해서도 마찬가지입니다. 반면에 <code>for</code> loop에서 <code>const</code> 선언을 사용하려고 하면 에러가 발생할 수 있습니다.</p>
<p>Block-binding을 위한 현재의 최선의 관행은 디폴트로 <code>const</code>를 사용하고 변수의 값을 변경할 필요가 있을 때만 <code>let</code>을 사용하는 것입니다. 이렇게하면 특정 유형의 오류를 방지하는데 도움이되고 코드의 기본 무결성이 보장됩니다.</p>
<hr>
<blockquote>
<p>이 내용은 나중에 참고하기 위해 제가 공부하며 정리한 내용입니다.<br>의역, 오역, 직역이 있을 수 있음을 알려드립니다.<br>This post is a translation of this original article [<a href="https://leanpub.com/understandinges6/read#leanpub-auto-block-bindings" target="_blank" rel="external">https://leanpub.com/understandinges6/read#leanpub-auto-block-bindings</a>]</p>
</blockquote>
<h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul>
<li><a href="https://infoscis.github.io/2018/01/24/ecmascript-6-block-binding/">ECMAScript 6 Block Binding</a></li>
<li><a href="https://infoscis.github.io/2018/01/24/ecmascript-6-strings-and-regular-expressions/">ECMAScript 6 문자열과 정규 표현식</a></li>
<li><a href="https://infoscis.github.io/2018/01/24/ecmascript-6-functions/">ECMAScript 6 함수</a></li>
<li><a href="https://infoscis.github.io/2018/01/25/ecmascript-6-expanded-object-functionality/">ECMAScript 6 객체의 확장된 기능</a></li>
<li><a href="https://infoscis.github.io/2018/01/26/ecmascript-6-destructuring-for-easier-data-access/">ECMAScript 6 쉬운 데이터 액세스를 위한 Destructuring</a></li>
<li><a href="https://infoscis.github.io/2018/01/27/ecmascript-6-symbols-and-symbol-properties/">ECMAScript 6 Symbol과 Symbol 프로퍼티</a></li>
<li><a href="https://infoscis.github.io/2018/01/27/ecmascript-6-sets-and-maps/">ECMAScript 6 Set과 Map</a></li>
<li><a href="https://infoscis.github.io/2018/01/31/ecmascript-6-iterators-and-generators/">ECMAScript 6 Iterator와 Generator</a></li>
<li><a href="https://infoscis.github.io/2018/02/13/ecmascript-6-introducing-javascript-classes/">ECMAScript 6 JavaScript 클래스 소개</a></li>
<li><a href="https://infoscis.github.io/2018/02/13/ecmascript-6-improved-array-capabilities/">ECMAScript 6 Array 기능 향상</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-promises-and-asynchronous-programming/">ECMAScript 6 Promise와 비동기 프로그램밍</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-proxies-and-the-reflection-api/">ECMAScript 6 프록시와 리플렉션 API</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-encapsulating-code-with-modules/">ECMAScript 6 Module로 코드 캡슐화하기</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-appendix-a-smaller-changes/">ECMAScript 6 부록 A. 작은 변경 사항</a></li>
<li><a href="https://infoscis.github.io/2018/02/27/ecmascript-6-appendix-b-understanding-ecmascript-7/">ECMAScript 6 부록 B. ECMAScript 7(2016) 이해하기</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Block-Binding&quot;&gt;&lt;a href=&quot;#Block-Binding&quot; class=&quot;headerlink&quot; title=&quot;Block Binding&quot;&gt;&lt;/a&gt;Block Binding&lt;/h1&gt;&lt;p&gt;Javascript의 전통적인 식별자(Ident
    
    </summary>
    
      <category term="JavaScript" scheme="http://infoscis.github.io/categories/JavaScript/"/>
    
      <category term="ECMAScript 2015" scheme="http://infoscis.github.io/categories/JavaScript/ECMAScript-2015/"/>
    
    
      <category term="JavaScript" scheme="http://infoscis.github.io/tags/JavaScript/"/>
    
      <category term="ECMAScript 2015" scheme="http://infoscis.github.io/tags/ECMAScript-2015/"/>
    
  </entry>
  
  <entry>
    <title>Webpack Plugin 개발</title>
    <link href="http://infoscis.github.io/2018/01/24/develop-webpack-plugin/"/>
    <id>http://infoscis.github.io/2018/01/24/develop-webpack-plugin/</id>
    <published>2018-01-24T13:02:32.000Z</published>
    <updated>2018-02-13T15:11:27.900Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Webpack-Plugin-개발"><a href="#Webpack-Plugin-개발" class="headerlink" title="Webpack Plugin 개발"></a>Webpack Plugin 개발</h1><p>Plugin은 Webpack 엔진의 모든것을 개발자에게 공개합니다. 단계별 빌드 Callback을 사용하여 개발자는 Webpack 빌드 프로세스에 자신의 동작을 추가할 수 있습니다. Plugin 작성은 Loader를 빌드하는 것보다 조금더 진보된 것입니다. 왜냐하면 Webpack 하위 레벨 내부를 이해해야 할 필요가 있기 때문입니다.</p>
<h2 id="Plugin-만들기"><a href="#Plugin-만들기" class="headerlink" title="Plugin 만들기"></a>Plugin 만들기</h2><p>Webpack 용 Plugin은 다음과 같이 구성됩니다.</p>
<ul>
<li>이름이 부여된 JavaScript 함수.</li>
<li>프로토 타입에 <code>apply</code> 메서드를 정의.</li>
<li>Webpack의 Event Hook을 특정하고 Attach.</li>
<li>Webpack 내부 인스턴스 특정 데이터를 조작.</li>
<li>기능이 완료된 후 Webpack에서 Callback을 호출.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 이름이 부여된 JavaScript의 함수</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyExampleWebpackPlugin</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// prototype에 `apply` 메서드 정의</span></div><div class="line">MyExampleWebpackPlugin.prototype.apply = <span class="function"><span class="keyword">function</span>(<span class="params">compiler</span>) </span>&#123;</div><div class="line">  <span class="comment">// Webpack의 Event Hook을 지정하고 Attack</span></div><div class="line">  compiler.plugin(<span class="string">'webpacksEventHook'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">compilation <span class="regexp">/* Webpack 내부 인스턴스 특정 데이터 조작. */</span>, callback</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"This is an example plugin!!!"</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 기능이 완료된 후 Webpack에서 Callback을 호출.</span></div><div class="line">    callback();</div><div class="line">  &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>Plugin을 개발할 때 가장 중요한 두가지 자원 <code>compiler</code>와 <code>compilation</code> 객체가 있습니다. 이 두 객체의 역할을 이해하는 것은 Webpack 엔진을 확장하는 중요한 첫단계입니다.</p>
<ul>
<li><p><code>compiler</code> 객체는 완전히 구성된 Webpack 환경을 나타냅니다. 이 객체는 Webpack이 시작할 때 한번 빌드되며 Option, Loader 및 Plugin을 포함한 모든 작업 설정으로 구성됩니다. Webpack 환경에 Plugin을 적용할 때 Plugin이 <code>compiler</code>에 대한 참조를 받습니다. <code>compiler</code>를 사용하여 기본 Webpack 환경을 액세스할 수 있습니다.</p>
</li>
<li><p><code>compilation</code> 객체는 버전이 있는 Asset 하나의 빌드를 나타냅니다. Webpack 개발 미들웨어를 실행하는 동안 파일 변경이 감지될 때마다 새로운 <code>compilation</code>이 생성되어 새로운 컴파일된 Asset이 생성됩니다. <code>compilation</code>은 모듈 리소스, 컴파일된 Asset, 변경된 파일 감시<br>및 종속성의 현재 상태에 대한 정보를 나타냅니다. <code>compilation</code>은 또한 Plugin이 사용자 정의 작업을 수행하도록 선택할 수 있는 많은 Callback 포인트를 제공합니다.</p>
</li>
</ul>
<p>두 구성 요소는 모든 Webpack Plugin (특히 <code>compilation</code>)의 핵심 부분이므로 개발자는 다음 소스 파일을 알아두면 도움이됩니다.</p>
<ul>
<li><a href="https://github.com/webpack/webpack/blob/master/lib/Compiler.js" target="_blank" rel="external">Compiler Source</a></li>
<li><a href="https://github.com/webpack/webpack/blob/master/lib/Compilation.js" target="_blank" rel="external">Compilation Source</a></li>
</ul>
<h2 id="Plugin-기본-구조"><a href="#Plugin-기본-구조" class="headerlink" title="Plugin 기본 구조"></a>Plugin 기본 구조</h2><p>Plugin은 프로토타입에 <code>apply</code> 메서드가있는 인스턴스 객체입니다. 이 <code>apply</code> 메서드는 Plugin을 설치하는 동안 Webpack <code>compiler</code>에 의해 한번 호출됩니다. <code>apply</code> 메서드는 <code>compiler</code> Callback에 대한 액세스를 허용하는 기본 Webpack <code>compiler</code>에 대한 참조를 제공받습니다. 간단한 Plugin은 다음과 같이 구성됩니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">HelloWorldPlugin</span>(<span class="params">options</span>) </span>&#123;</div><div class="line">  <span class="comment">// Option으로 Plubin 인스턴스 설정...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">HelloWorldPlugin.prototype.apply = <span class="function"><span class="keyword">function</span>(<span class="params">compiler</span>) </span>&#123;</div><div class="line">  compiler.plugin(<span class="string">'done'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello World!'</span>);</div><div class="line">  &#125;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = HelloWorldPlugin;</div></pre></td></tr></table></figure>
<p>그런 다음 Plugin을 설치하려면 Webpack 설정파일의 <code>plugins</code> 배열에 인스턴스를 포함하면 됩니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> HelloWorldPlugin = <span class="built_in">require</span>(<span class="string">'hello-world'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> webpackConfig = &#123;</div><div class="line">  <span class="comment">// ... config settings here ...</span></div><div class="line">  plugins: [</div><div class="line">    <span class="keyword">new</span> HelloWorldPlugin(&#123;<span class="attr">options</span>: <span class="literal">true</span>&#125;)</div><div class="line">  ]</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="compilation-접근하기"><a href="#compilation-접근하기" class="headerlink" title="compilation 접근하기"></a>compilation 접근하기</h2><p><code>compiler</code> 객체를 사용하면 각각의 새로운 <code>compilation</code>에 대한 참조를 제공하는 Callback을 바인드할 수 있습니다. 이러한 <code>compilation</code>은 빌드 프로세스 내에서 수많은 단계를 Hook하기 위한 콜백을 제공합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">HelloCompilationPlugin</span>(<span class="params">options</span>) </span>&#123;&#125;</div><div class="line"></div><div class="line">HelloCompilationPlugin.prototype.apply = <span class="function"><span class="keyword">function</span>(<span class="params">compiler</span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">// compilation에 접근하기 위한 Callback 설정</span></div><div class="line">  compiler.plugin(<span class="string">"compilation"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">compilation</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 이제 compilation 단계들에 접근하기 위한 Callback 설정</span></div><div class="line">    compilation.plugin(<span class="string">"optimize"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">"Assets are being optimized."</span>);</div><div class="line">    &#125;);</div><div class="line">  &#125;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = HelloCompilationPlugin;</div></pre></td></tr></table></figure>
<p><code>compiler</code>,<code>compilation</code> 및 다른 중요한 객체에서 사용할 수있는 Callback에 대한 자세한 내용은 <a href="https://webpack.js.org/api/plugins/" target="_blank" rel="external">plugins</a>을 참조하십시오.</p>
<h2 id="비동기-compilation-Plugin"><a href="#비동기-compilation-Plugin" class="headerlink" title="비동기 compilation Plugin"></a>비동기 compilation Plugin</h2><p>일부 <code>compilation</code> Plugin 단계는 비동기이며, Plugin 실행이 끝나면 호출되어야하는 Callback 함수를 전달합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">HelloAsyncPlugin</span>(<span class="params">options</span>) </span>&#123;&#125;</div><div class="line"></div><div class="line">HelloAsyncPlugin.prototype.apply = <span class="function"><span class="keyword">function</span>(<span class="params">compiler</span>) </span>&#123;</div><div class="line">  compiler.plugin(<span class="string">"emit"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">compilation, callback</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// Do something async...</span></div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">"Done with async work..."</span>);</div><div class="line">      callback();</div><div class="line">    &#125;, <span class="number">1000</span>);</div><div class="line"></div><div class="line">  &#125;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = HelloAsyncPlugin;</div></pre></td></tr></table></figure>
<h2 id="예제"><a href="#예제" class="headerlink" title="예제"></a>예제</h2><p>일단 Webpack <code>compiler</code>와 개별 <code>compilation</code>에 접근하게 되면 엔진을 이용해할 수 있는 일이 많아집니다. 기존 파일을 다시 형식화하거나 파생 파일을 만들거나 완전히 새로운 Asset을 만들 수 있습니다.</p>
<p><code>filelist.md</code>라는 새로운 빌드 파일을 생성하는 간단한 예제 Plugin을 작성해 보겠습니다. 이 파일의 내용에는 빌드의 모든 Asset 파일이 나열됩니다. 이 Plugin은 아래와 같습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">FileListPlugin</span>(<span class="params">options</span>) </span>&#123;&#125;</div><div class="line"></div><div class="line">FileListPlugin.prototype.apply = <span class="function"><span class="keyword">function</span>(<span class="params">compiler</span>) </span>&#123;</div><div class="line">  compiler.plugin(<span class="string">'emit'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">compilation, callback</span>) </span>&#123;</div><div class="line">    <span class="comment">// Create a header string for the generated file:</span></div><div class="line">    <span class="keyword">var</span> filelist = <span class="string">'In this build:\n\n'</span>;</div><div class="line"></div><div class="line">    <span class="comment">// Loop through all compiled assets,</span></div><div class="line">    <span class="comment">// adding a new line item for each filename.</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> filename <span class="keyword">in</span> compilation.assets) &#123;</div><div class="line">      filelist += (<span class="string">'- '</span>+ filename +<span class="string">'\n'</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Insert this list into the webpack build as a new file asset:</span></div><div class="line">    compilation.assets[<span class="string">'filelist.md'</span>] = &#123;</div><div class="line">      <span class="attr">source</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> filelist;</div><div class="line">      &#125;,</div><div class="line">      <span class="attr">size</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> filelist.length;</div><div class="line">      &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    callback();</div><div class="line">  &#125;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = FileListPlugin;</div></pre></td></tr></table></figure>
<h2 id="Plugin의-다른-형태"><a href="#Plugin의-다른-형태" class="headerlink" title="Plugin의 다른 형태"></a>Plugin의 다른 형태</h2><p>Plugin은 등록된 이벤트에 따라 여러 종류로 분류할 수 있습니다. 모든 Event Hook은 레지스트리에 Plugin을 적용하는 방법을 결정합니다.</p>
<ul>
<li><p><strong>synchronous</strong> Tapable 인스턴스는 다음을 사용하여 Plugin을 적용합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">applyPlugins(name: string, <span class="attr">args</span>: any...)</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">applyPluginsBailResult(name: string, <span class="attr">args</span>: any...)</div></pre></td></tr></table></figure>
</li>
</ul>
<p>즉, 각 Plugin 콜백은 특정 <code>args</code>를 사용하여 차례로 호출됩니다. 이것은 Plugin의 가장 간단한 형식입니다. <code>&quot;compile&quot;</code>, <code>&quot;this-compilation&quot;</code>과 같은 많은 유용한 이벤트는 Plugin이 동기 실행할 것을 요구합니다.</p>
<ul>
<li><p><strong>waterfall</strong> Plugin을 사용하여 적용</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">applyPluginsWaterfall(name: string, <span class="attr">init</span>: any, <span class="attr">args</span>: any...)</div></pre></td></tr></table></figure>
</li>
</ul>
<p>여기서 각 Plugin은 이전 Plugin의 반환값에서 <code>args</code>를 사용하여 순차적으로 호출됩니다. Plugin은 실행 순서를 고려해야합니다. 실행된 이전 Plugin의 인수를 받아 들여야합니다. 첫 번째 Plugin의 값은 <code>init</code>입니다. 이 패턴은 <code>ModuleTemplate</code>, <code>ChunkTemplate</code>과 같은<code>webpack</code> 템플릿과 관련된 Tapable 인스턴스에서 사용됩니다.</p>
<ul>
<li><strong>asynchronous</strong> 모든 Plugin이 비동기적으로 적용될 때<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">applyPluginsAsync(name: string, <span class="attr">args</span>: any..., <span class="attr">callback</span>: (err?: <span class="built_in">Error</span>) -&gt; <span class="keyword">void</span>)</div></pre></td></tr></table></figure>
</li>
</ul>
<p>Plugin 핸들러 함수는 모든 <code>args</code>와 (<code>err ?: Error) -&gt; void</code> 시그니처를 가진 콜백 함수로 호출됩니다. 핸들러 함수는 등록된 순서로 호출되며 <code>callback</code>은 모든 핸들러가 호출된 후에 호출됩니다. 이것은 또한 <code>&quot;emit&quot;</code>, <code>&quot;run&quot;</code>과 같은 Event에 일반적으로 사용되는 패턴입니다.</p>
<ul>
<li><p><strong>async waterfall</strong> Plugin은 waterfall 방식으로 비동기로 적용됩니다</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">applyPluginsAsyncWaterfall(name: string, <span class="attr">init</span>: any, <span class="attr">callback</span>: (err: <span class="built_in">Error</span>, <span class="attr">result</span>: any) -&gt; <span class="keyword">void</span>)</div></pre></td></tr></table></figure>
</li>
</ul>
<p>Plugin 핸들러 함수는 현재 값과 <code>(err : Error, nextValue : any) -&gt; void</code> 시그니처가 있는 콜백 함수로 호출됩니다. <code>nextValue</code>가 호출되면 다음 핸들러의 현재 값이 됩니다. 첫 번째 핸들러의 현재 값은 <code>init</code>입니다. 모든 핸들러가 적용된 후 마지막 값으로 <code>callback</code>이 호출됩니다. 어떤 핸들러가 <code>err</code>에 값을 전달하면, 이 에러와 함께 <code>callback</code>이 호출되고 핸들러는 더 이상 호출되지 않습니다. 이 Plugin 패턴은 <code>&quot;before-resolve&quot;</code>및 <code>&quot;after-resolve&quot;</code>와 같은 Event에 필요합니다.</p>
<ul>
<li><p><strong>async series</strong> 비동기와 동일하지만 등록된 Plugin 중 하나라도 실패하면 Plugin이 더 이상 호출되지 않습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">applyPluginsAsyncSeries(name: string, <span class="attr">args</span>: any..., <span class="attr">callback</span>: (err: <span class="built_in">Error</span>, <span class="attr">result</span>: any) -&gt; <span class="keyword">void</span>)</div></pre></td></tr></table></figure>
</li>
<li><p><strong>parallel</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">applyPluginsParallel(name: string, <span class="attr">args</span>: any..., <span class="attr">callback</span>: (err?: <span class="built_in">Error</span>) -&gt; <span class="keyword">void</span>)</div></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">  applyPluginsParallelBailResult(name: string, args: any..., callback: (err: Error, result: any) -&gt; void)</div><div class="line">  ``</div><div class="line"></div><div class="line">## 유용한 Plugin 패턴</div><div class="line"></div><div class="line">Plugin은 Webpack 빌드 시스템 내에서 사용자 정의를 수행할 수 있는 무제한의 기회를 부여합니다. 이를 통해 사용자 정의 Asset을 만들거나, 고유한 빌드 수정을 수행하거나, 미들웨어를 사용하면서 Webpack 런타임을 향상시킬 수 있습니다. 다음은 Plugin 작성 중에 매우 유용하게 사용되는 Webpack의 일부 기능입니다.</div><div class="line"></div><div class="line">### Asset, Chunk, 모듈 및 종속성 탐색</div><div class="line"></div><div class="line">`compilation`이 완료된 후 `compilation` 내의 모든 구조를 탐색할 수 있습니다.</div><div class="line"></div><div class="line">```javascript</div><div class="line">function MyPlugin() &#123;&#125;</div><div class="line"></div><div class="line">MyPlugin.prototype.apply = function(compiler) &#123;</div><div class="line">  compiler.plugin('emit', function(compilation, callback) &#123;</div><div class="line">    </div><div class="line">    // 각 chunk를 탐색 (build output):</div><div class="line">    compilation.chunks.forEach(function(chunk) &#123;</div><div class="line">      // chunk 내의 각 모듈 탐색 (built inputs):</div><div class="line">      chunk.forEachModule(function(module) &#123;</div><div class="line">        // 모듈에 포함된 각 소스 파일 경로를 탐색합니다.:</div><div class="line">        module.fileDependencies.forEach(function(filepath) &#123;</div><div class="line">          // 이제 소스 구조에 대해 많은 것을 알게 되었습니다.</div><div class="line">        &#125;);</div><div class="line">      &#125;);</div><div class="line"></div><div class="line">      // chunk에 의해 생성된 각 asset 파일을 탐색합니다.</div><div class="line">      chunk.files.forEach(function(filename) &#123;</div><div class="line">        // chunk에 의해 생성된 각 파일의 asset 소스 가져 오기</div><div class="line">        var source = compilation.assets[filename].source();</div><div class="line">      &#125;);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    callback();</div><div class="line">  &#125;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">module.exports = MyPlugin;</div></pre></td></tr></table></figure>
</li>
<li><p><code>compilation.modules</code> : compilation의 모듈 배열 (Built 입력). 각 모듈은 소스 라이브러리에서 Raw 파일의 빌드를 관리합니다.</p>
</li>
<li><code>module.fileDependencies</code> : 모듈에 포함된 소스 파일 경로의 배열. 여기에는 소스 JavaScript 파일 자체 (예 : <code>index.js</code>) 및 필요한 모든 종속성 Asset 파일 (스타일 시트, 이미지 등)이 포함됩니다. 종속성 검토는 소스 파일이 모듈에 속하는지 확인하는데 유용합니다.</li>
<li><code>compilation.chunks</code> : 컴파일에서 chunk 배열 (빌드 결과). 각 Chunk는 최종 렌더링 Asset의 구성을 관리합니다.</li>
<li><code>chunk.modules</code> : Chunk에 포함되는 모듈의 배열. 확장에 따라 각 모듈의 종속성을 조사하여 청크에 공급된 Raw 소스 파일을 확인할 수 있습니다.</li>
<li><code>chunk.files</code> : Chunk에 의해 생성된 결과 파일 이름들의 배열. <code>compilation.assets</code> 테이블에서 이러한 Asset 소스에 액세스할 수 있습니다.</li>
</ul>
<h3 id="Watch-그래프-모니터링"><a href="#Watch-그래프-모니터링" class="headerlink" title="Watch 그래프 모니터링"></a>Watch 그래프 모니터링</h3><p>Webpack 미들웨어를 실행하는 동안 각 <code>compilation</code>에는 Watch 대상 파일인 <code>fileDependencies</code> 배열과 Watch된 파일 경로를 타임스탬프에 매핑하는 <code>fileTimestamps</code>가 포함됩니다. 이는 <code>compilation</code> 과정에서 변경된 파일을 탐지하는데 매우 유용합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPlugin</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.startTime = <span class="built_in">Date</span>.now();</div><div class="line">  <span class="keyword">this</span>.prevTimestamps = &#123;&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">MyPlugin.prototype.apply = <span class="function"><span class="keyword">function</span>(<span class="params">compiler</span>) </span>&#123;</div><div class="line">  compiler.plugin(<span class="string">'emit'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">compilation, callback</span>) </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">var</span> changedFiles = <span class="built_in">Object</span>.keys(compilation.fileTimestamps).filter(<span class="function"><span class="keyword">function</span>(<span class="params">watchfile</span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> (<span class="keyword">this</span>.prevTimestamps[watchfile] || <span class="keyword">this</span>.startTime) &lt; (compilation.fileTimestamps[watchfile] || <span class="literal">Infinity</span>);</div><div class="line">    &#125;.bind(<span class="keyword">this</span>));</div><div class="line">    </div><div class="line">    <span class="keyword">this</span>.prevTimestamps = compilation.fileTimestamps;</div><div class="line">    callback();</div><div class="line">  &#125;.bind(<span class="keyword">this</span>));</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = MyPlugin;</div></pre></td></tr></table></figure>
<p>새로운 파일 경로를 Watch 그래프에 제공하여 파일이 변경될 때 <code>compilation</code> 트리거를 수신할 수 있습니다. 유효한 파일 경로를 <code>compilation.fileDependencies</code> 배열에 넣어 Watch에 추가하면됩니다. 참고 : <code>fileDependencies</code> 배열은 각 <code>compilation</code>에서 다시 작성되므로 Plugin은 Watch 종속성을 각 <code>compilation</code>에 넣어 Watch를 계속 유지해야합니다.</p>
<h3 id="변경된-Chunk"><a href="#변경된-Chunk" class="headerlink" title="변경된 Chunk"></a>변경된 Chunk</h3><p>Watch 그래프와 마찬가지로 해시를 추적하여 <code>compilation</code>내에서 변경된 Chunk(또는 해당 모듈)를 모니터링하는 것도 가능합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPlugin</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.chunkVersions = &#123;&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">MyPlugin.prototype.apply = <span class="function"><span class="keyword">function</span>(<span class="params">compiler</span>) </span>&#123;</div><div class="line">  compiler.plugin(<span class="string">'emit'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">compilation, callback</span>) </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">var</span> changedChunks = compilation.chunks.filter(<span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</div><div class="line">      <span class="keyword">var</span> oldVersion = <span class="keyword">this</span>.chunkVersions[chunk.name];</div><div class="line">      <span class="keyword">this</span>.chunkVersions[chunk.name] = chunk.hash;</div><div class="line">      <span class="keyword">return</span> chunk.hash !== oldVersion;</div><div class="line">    &#125;.bind(<span class="keyword">this</span>));</div><div class="line">    </div><div class="line">    callback();</div><div class="line">  &#125;.bind(<span class="keyword">this</span>));</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = MyPlugin;</div></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>이 내용은 나중에 참고하기 위해 제가 공부하며 정리한 내용입니다.<br>의역, 오역, 직역이 있을 수 있음을 알려드립니다.<br>This post is a translation of this original article [<a href="https://webpack.js.org/contribute/writing-a-plugin/" target="_blank" rel="external">https://webpack.js.org/contribute/writing-a-plugin/</a>]<br>참고 : <a href="https://github.com/webpack/docs/wiki/How-to-write-a-plugin" target="_blank" rel="external">https://github.com/webpack/docs/wiki/How-to-write-a-plugin</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Webpack-Plugin-개발&quot;&gt;&lt;a href=&quot;#Webpack-Plugin-개발&quot; class=&quot;headerlink&quot; title=&quot;Webpack Plugin 개발&quot;&gt;&lt;/a&gt;Webpack Plugin 개발&lt;/h1&gt;&lt;p&gt;Plugin은 We
    
    </summary>
    
      <category term="Webpack" scheme="http://infoscis.github.io/categories/Webpack/"/>
    
    
      <category term="Webpack" scheme="http://infoscis.github.io/tags/Webpack/"/>
    
  </entry>
  
</feed>
